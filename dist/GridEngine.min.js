var GridEngine = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __exportStar = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module) => {
    return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);
  };

  // node_modules/phaser/dist/phaser.js
  var require_phaser = __commonJS((exports, module) => {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("Phaser", [], factory);
      else if (typeof exports === "object")
        exports["Phaser"] = factory();
      else
        root["Phaser"] = factory();
    })(window, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module2 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.l = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, {enumerable: true, get: getter});
          }
        };
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, {value: "Module"});
          }
          Object.defineProperty(exports2, "__esModule", {value: true});
        };
        __webpack_require__.t = function(value, mode) {
          if (mode & 1)
            value = __webpack_require__(value);
          if (mode & 8)
            return value;
          if (mode & 4 && typeof value === "object" && value && value.__esModule)
            return value;
          var ns = Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", {enumerable: true, value});
          if (mode & 2 && typeof value != "string")
            for (var key in value)
              __webpack_require__.d(ns, key, function(key2) {
                return value[key2];
              }.bind(null, key));
          return ns;
        };
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? function getDefault() {
            return module2["default"];
          } : function getModuleExports() {
            return module2;
          };
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 1497);
      }([
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          function hasGetterOrSetter(def) {
            return !!def.get && typeof def.get === "function" || !!def.set && typeof def.set === "function";
          }
          function getProperty(definition, k, isClassDescriptor) {
            var def = isClassDescriptor ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);
            if (!isClassDescriptor && def.value && typeof def.value === "object") {
              def = def.value;
            }
            if (def && hasGetterOrSetter(def)) {
              if (typeof def.enumerable === "undefined") {
                def.enumerable = true;
              }
              if (typeof def.configurable === "undefined") {
                def.configurable = true;
              }
              return def;
            } else {
              return false;
            }
          }
          function hasNonConfigurable(obj, k) {
            var prop = Object.getOwnPropertyDescriptor(obj, k);
            if (!prop) {
              return false;
            }
            if (prop.value && typeof prop.value === "object") {
              prop = prop.value;
            }
            if (prop.configurable === false) {
              return true;
            }
            return false;
          }
          function extend(ctor, definition, isClassDescriptor, extend2) {
            for (var k in definition) {
              if (!definition.hasOwnProperty(k)) {
                continue;
              }
              var def = getProperty(definition, k, isClassDescriptor);
              if (def !== false) {
                var parent = extend2 || ctor;
                if (hasNonConfigurable(parent.prototype, k)) {
                  if (Class.ignoreFinals) {
                    continue;
                  }
                  throw new Error("cannot override final property '" + k + "', set Class.ignoreFinals = true to skip");
                }
                Object.defineProperty(ctor.prototype, k, def);
              } else {
                ctor.prototype[k] = definition[k];
              }
            }
          }
          function mixin(myClass, mixins) {
            if (!mixins) {
              return;
            }
            if (!Array.isArray(mixins)) {
              mixins = [mixins];
            }
            for (var i = 0; i < mixins.length; i++) {
              extend(myClass, mixins[i].prototype || mixins[i]);
            }
          }
          function Class(definition) {
            if (!definition) {
              definition = {};
            }
            var initialize;
            var Extends;
            if (definition.initialize) {
              if (typeof definition.initialize !== "function") {
                throw new Error("initialize must be a function");
              }
              initialize = definition.initialize;
              delete definition.initialize;
            } else if (definition.Extends) {
              var base = definition.Extends;
              initialize = function() {
                base.apply(this, arguments);
              };
            } else {
              initialize = function() {
              };
            }
            if (definition.Extends) {
              initialize.prototype = Object.create(definition.Extends.prototype);
              initialize.prototype.constructor = initialize;
              Extends = definition.Extends;
              delete definition.Extends;
            } else {
              initialize.prototype.constructor = initialize;
            }
            var mixins = null;
            if (definition.Mixins) {
              mixins = definition.Mixins;
              delete definition.Mixins;
            }
            mixin(initialize, mixins);
            extend(initialize, definition, true, Extends);
            return initialize;
          }
          Class.extend = extend;
          Class.mixin = mixin;
          Class.ignoreFinals = false;
          module2.exports = Class;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var NOOP = function() {
          };
          module2.exports = NOOP;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetFastValue = function(source, key, defaultValue) {
            var t = typeof source;
            if (!source || t === "number" || t === "string") {
              return defaultValue;
            } else if (source.hasOwnProperty(key) && source[key] !== void 0) {
              return source[key];
            } else {
              return defaultValue;
            }
          };
          module2.exports = GetFastValue;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FuzzyEqual = __webpack_require__(123);
          var Vector29 = new Class({
            initialize: function Vector210(x, y) {
              this.x = 0;
              this.y = 0;
              if (typeof x === "object") {
                this.x = x.x || 0;
                this.y = x.y || 0;
              } else {
                if (y === void 0) {
                  y = x;
                }
                this.x = x || 0;
                this.y = y || 0;
              }
            },
            clone: function() {
              return new Vector29(this.x, this.y);
            },
            copy: function(src) {
              this.x = src.x || 0;
              this.y = src.y || 0;
              return this;
            },
            setFromObject: function(obj) {
              this.x = obj.x || 0;
              this.y = obj.y || 0;
              return this;
            },
            set: function(x, y) {
              if (y === void 0) {
                y = x;
              }
              this.x = x;
              this.y = y;
              return this;
            },
            setTo: function(x, y) {
              return this.set(x, y);
            },
            setToPolar: function(azimuth, radius) {
              if (radius == null) {
                radius = 1;
              }
              this.x = Math.cos(azimuth) * radius;
              this.y = Math.sin(azimuth) * radius;
              return this;
            },
            equals: function(v) {
              return this.x === v.x && this.y === v.y;
            },
            fuzzyEquals: function(v, epsilon) {
              return FuzzyEqual(this.x, v.x, epsilon) && FuzzyEqual(this.y, v.y, epsilon);
            },
            angle: function() {
              var angle = Math.atan2(this.y, this.x);
              if (angle < 0) {
                angle += 2 * Math.PI;
              }
              return angle;
            },
            setAngle: function(angle) {
              return this.setToPolar(angle, this.length());
            },
            add: function(src) {
              this.x += src.x;
              this.y += src.y;
              return this;
            },
            subtract: function(src) {
              this.x -= src.x;
              this.y -= src.y;
              return this;
            },
            multiply: function(src) {
              this.x *= src.x;
              this.y *= src.y;
              return this;
            },
            scale: function(value) {
              if (isFinite(value)) {
                this.x *= value;
                this.y *= value;
              } else {
                this.x = 0;
                this.y = 0;
              }
              return this;
            },
            divide: function(src) {
              this.x /= src.x;
              this.y /= src.y;
              return this;
            },
            negate: function() {
              this.x = -this.x;
              this.y = -this.y;
              return this;
            },
            distance: function(src) {
              var dx = src.x - this.x;
              var dy = src.y - this.y;
              return Math.sqrt(dx * dx + dy * dy);
            },
            distanceSq: function(src) {
              var dx = src.x - this.x;
              var dy = src.y - this.y;
              return dx * dx + dy * dy;
            },
            length: function() {
              var x = this.x;
              var y = this.y;
              return Math.sqrt(x * x + y * y);
            },
            setLength: function(length) {
              return this.normalize().scale(length);
            },
            lengthSq: function() {
              var x = this.x;
              var y = this.y;
              return x * x + y * y;
            },
            normalize: function() {
              var x = this.x;
              var y = this.y;
              var len = x * x + y * y;
              if (len > 0) {
                len = 1 / Math.sqrt(len);
                this.x = x * len;
                this.y = y * len;
              }
              return this;
            },
            normalizeRightHand: function() {
              var x = this.x;
              this.x = this.y * -1;
              this.y = x;
              return this;
            },
            normalizeLeftHand: function() {
              var x = this.x;
              this.x = this.y;
              this.y = x * -1;
              return this;
            },
            dot: function(src) {
              return this.x * src.x + this.y * src.y;
            },
            cross: function(src) {
              return this.x * src.y - this.y * src.x;
            },
            lerp: function(src, t) {
              if (t === void 0) {
                t = 0;
              }
              var ax = this.x;
              var ay = this.y;
              this.x = ax + t * (src.x - ax);
              this.y = ay + t * (src.y - ay);
              return this;
            },
            transformMat3: function(mat) {
              var x = this.x;
              var y = this.y;
              var m = mat.val;
              this.x = m[0] * x + m[3] * y + m[6];
              this.y = m[1] * x + m[4] * y + m[7];
              return this;
            },
            transformMat4: function(mat) {
              var x = this.x;
              var y = this.y;
              var m = mat.val;
              this.x = m[0] * x + m[4] * y + m[12];
              this.y = m[1] * x + m[5] * y + m[13];
              return this;
            },
            reset: function() {
              this.x = 0;
              this.y = 0;
              return this;
            },
            limit: function(max) {
              var len = this.length();
              if (len && len > max) {
                this.scale(max / len);
              }
              return this;
            },
            reflect: function(normal) {
              normal = normal.clone().normalize();
              return this.subtract(normal.scale(2 * this.dot(normal)));
            },
            mirror: function(axis) {
              return this.reflect(axis).negate();
            },
            rotate: function(delta) {
              var cos = Math.cos(delta);
              var sin = Math.sin(delta);
              return this.set(cos * this.x - sin * this.y, sin * this.x + cos * this.y);
            }
          });
          Vector29.ZERO = new Vector29();
          Vector29.RIGHT = new Vector29(1, 0);
          Vector29.LEFT = new Vector29(-1, 0);
          Vector29.UP = new Vector29(0, -1);
          Vector29.DOWN = new Vector29(0, 1);
          Vector29.ONE = new Vector29(1, 1);
          module2.exports = Vector29;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GEOM_CONST = __webpack_require__(55);
          var Point = new Class({
            initialize: function Point2(x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = x;
              }
              this.type = GEOM_CONST.POINT;
              this.x = x;
              this.y = y;
            },
            setTo: function(x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = x;
              }
              this.x = x;
              this.y = y;
              return this;
            }
          });
          module2.exports = Point;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(21);
          var GameObjectFactory = new Class({
            initialize: function GameObjectFactory2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.events = scene.sys.events;
              this.displayList;
              this.updateList;
              this.events.once(SceneEvents.BOOT, this.boot, this);
              this.events.on(SceneEvents.START, this.start, this);
            },
            boot: function() {
              this.displayList = this.systems.displayList;
              this.updateList = this.systems.updateList;
              this.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function() {
              this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            existing: function(child) {
              if (child.renderCanvas || child.renderWebGL) {
                this.displayList.add(child);
              }
              if (child.preUpdate) {
                this.updateList.add(child);
              }
              return child;
            },
            shutdown: function() {
              this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function() {
              this.shutdown();
              this.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
              this.events = null;
              this.displayList = null;
              this.updateList = null;
            }
          });
          GameObjectFactory.register = function(factoryType, factoryFunction) {
            if (!GameObjectFactory.prototype.hasOwnProperty(factoryType)) {
              GameObjectFactory.prototype[factoryType] = factoryFunction;
            }
          };
          GameObjectFactory.remove = function(factoryType) {
            if (GameObjectFactory.prototype.hasOwnProperty(factoryType)) {
              delete GameObjectFactory.prototype[factoryType];
            }
          };
          PluginCache.register("GameObjectFactory", GameObjectFactory, "add");
          module2.exports = GameObjectFactory;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetValue = function(source, key, defaultValue) {
            if (!source || typeof source === "number") {
              return defaultValue;
            } else if (source.hasOwnProperty(key)) {
              return source[key];
            } else if (key.indexOf(".") !== -1) {
              var keys = key.split(".");
              var parent = source;
              var value = defaultValue;
              for (var i = 0; i < keys.length; i++) {
                if (parent.hasOwnProperty(keys[i])) {
                  value = parent[keys[i]];
                  parent = parent[keys[i]];
                } else {
                  value = defaultValue;
                  break;
                }
              }
              return value;
            } else {
              return defaultValue;
            }
          };
          module2.exports = GetValue;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var IsPlainObject = function(obj) {
            if (typeof obj !== "object" || obj.nodeType || obj === obj.window) {
              return false;
            }
            try {
              if (obj.constructor && !{}.hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf")) {
                return false;
              }
            } catch (e) {
              return false;
            }
            return true;
          };
          module2.exports = IsPlainObject;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var types = {};
          var FileTypesManager = {
            install: function(loader) {
              for (var key in types) {
                loader[key] = types[key];
              }
            },
            register: function(key, factoryFunction) {
              types[key] = factoryFunction;
            },
            destroy: function() {
              types = {};
            }
          };
          module2.exports = FileTypesManager;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var has = Object.prototype.hasOwnProperty, prefix = "~";
          function Events() {
          }
          if (Object.create) {
            Events.prototype = Object.create(null);
            if (!new Events().__proto__)
              prefix = false;
          }
          function EE(fn, context, once) {
            this.fn = fn;
            this.context = context;
            this.once = once || false;
          }
          function addListener(emitter, event, fn, context, once) {
            if (typeof fn !== "function") {
              throw new TypeError("The listener must be a function");
            }
            var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
            if (!emitter._events[evt])
              emitter._events[evt] = listener, emitter._eventsCount++;
            else if (!emitter._events[evt].fn)
              emitter._events[evt].push(listener);
            else
              emitter._events[evt] = [emitter._events[evt], listener];
            return emitter;
          }
          function clearEvent(emitter, evt) {
            if (--emitter._eventsCount === 0)
              emitter._events = new Events();
            else
              delete emitter._events[evt];
          }
          function EventEmitter() {
            this._events = new Events();
            this._eventsCount = 0;
          }
          EventEmitter.prototype.eventNames = function eventNames() {
            var names = [], events, name;
            if (this._eventsCount === 0)
              return names;
            for (name in events = this._events) {
              if (has.call(events, name))
                names.push(prefix ? name.slice(1) : name);
            }
            if (Object.getOwnPropertySymbols) {
              return names.concat(Object.getOwnPropertySymbols(events));
            }
            return names;
          };
          EventEmitter.prototype.listeners = function listeners(event) {
            var evt = prefix ? prefix + event : event, handlers = this._events[evt];
            if (!handlers)
              return [];
            if (handlers.fn)
              return [handlers.fn];
            for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
              ee[i] = handlers[i].fn;
            }
            return ee;
          };
          EventEmitter.prototype.listenerCount = function listenerCount(event) {
            var evt = prefix ? prefix + event : event, listeners = this._events[evt];
            if (!listeners)
              return 0;
            if (listeners.fn)
              return 1;
            return listeners.length;
          };
          EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt])
              return false;
            var listeners = this._events[evt], len = arguments.length, args, i;
            if (listeners.fn) {
              if (listeners.once)
                this.removeListener(event, listeners.fn, void 0, true);
              switch (len) {
                case 1:
                  return listeners.fn.call(listeners.context), true;
                case 2:
                  return listeners.fn.call(listeners.context, a1), true;
                case 3:
                  return listeners.fn.call(listeners.context, a1, a2), true;
                case 4:
                  return listeners.fn.call(listeners.context, a1, a2, a3), true;
                case 5:
                  return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                case 6:
                  return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
              }
              for (i = 1, args = new Array(len - 1); i < len; i++) {
                args[i - 1] = arguments[i];
              }
              listeners.fn.apply(listeners.context, args);
            } else {
              var length = listeners.length, j;
              for (i = 0; i < length; i++) {
                if (listeners[i].once)
                  this.removeListener(event, listeners[i].fn, void 0, true);
                switch (len) {
                  case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;
                  case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;
                  case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;
                  case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;
                  default:
                    if (!args)
                      for (j = 1, args = new Array(len - 1); j < len; j++) {
                        args[j - 1] = arguments[j];
                      }
                    listeners[i].fn.apply(listeners[i].context, args);
                }
              }
            }
            return true;
          };
          EventEmitter.prototype.on = function on(event, fn, context) {
            return addListener(this, event, fn, context, false);
          };
          EventEmitter.prototype.once = function once(event, fn, context) {
            return addListener(this, event, fn, context, true);
          };
          EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt])
              return this;
            if (!fn) {
              clearEvent(this, evt);
              return this;
            }
            var listeners = this._events[evt];
            if (listeners.fn) {
              if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
                clearEvent(this, evt);
              }
            } else {
              for (var i = 0, events = [], length = listeners.length; i < length; i++) {
                if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                  events.push(listeners[i]);
                }
              }
              if (events.length)
                this._events[evt] = events.length === 1 ? events[0] : events;
              else
                clearEvent(this, evt);
            }
            return this;
          };
          EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
            var evt;
            if (event) {
              evt = prefix ? prefix + event : event;
              if (this._events[evt])
                clearEvent(this, evt);
            } else {
              this._events = new Events();
              this._eventsCount = 0;
            }
            return this;
          };
          EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
          EventEmitter.prototype.addListener = EventEmitter.prototype.on;
          EventEmitter.prefixed = prefix;
          EventEmitter.EventEmitter = EventEmitter;
          if (true) {
            module2.exports = EventEmitter;
          }
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Contains = __webpack_require__(56);
          var GetPoint = __webpack_require__(167);
          var GetPoints = __webpack_require__(300);
          var GEOM_CONST = __webpack_require__(55);
          var Line = __webpack_require__(45);
          var Random = __webpack_require__(170);
          var Rectangle = new Class({
            initialize: function Rectangle2(x, y, width, height) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 0;
              }
              if (height === void 0) {
                height = 0;
              }
              this.type = GEOM_CONST.RECTANGLE;
              this.x = x;
              this.y = y;
              this.width = width;
              this.height = height;
            },
            contains: function(x, y) {
              return Contains(this, x, y);
            },
            getPoint: function(position, output) {
              return GetPoint(this, position, output);
            },
            getPoints: function(quantity, stepRate, output) {
              return GetPoints(this, quantity, stepRate, output);
            },
            getRandomPoint: function(point) {
              return Random(this, point);
            },
            setTo: function(x, y, width, height) {
              this.x = x;
              this.y = y;
              this.width = width;
              this.height = height;
              return this;
            },
            setEmpty: function() {
              return this.setTo(0, 0, 0, 0);
            },
            setPosition: function(x, y) {
              if (y === void 0) {
                y = x;
              }
              this.x = x;
              this.y = y;
              return this;
            },
            setSize: function(width, height) {
              if (height === void 0) {
                height = width;
              }
              this.width = width;
              this.height = height;
              return this;
            },
            isEmpty: function() {
              return this.width <= 0 || this.height <= 0;
            },
            getLineA: function(line) {
              if (line === void 0) {
                line = new Line();
              }
              line.setTo(this.x, this.y, this.right, this.y);
              return line;
            },
            getLineB: function(line) {
              if (line === void 0) {
                line = new Line();
              }
              line.setTo(this.right, this.y, this.right, this.bottom);
              return line;
            },
            getLineC: function(line) {
              if (line === void 0) {
                line = new Line();
              }
              line.setTo(this.right, this.bottom, this.x, this.bottom);
              return line;
            },
            getLineD: function(line) {
              if (line === void 0) {
                line = new Line();
              }
              line.setTo(this.x, this.bottom, this.x, this.y);
              return line;
            },
            left: {
              get: function() {
                return this.x;
              },
              set: function(value) {
                if (value >= this.right) {
                  this.width = 0;
                } else {
                  this.width = this.right - value;
                }
                this.x = value;
              }
            },
            right: {
              get: function() {
                return this.x + this.width;
              },
              set: function(value) {
                if (value <= this.x) {
                  this.width = 0;
                } else {
                  this.width = value - this.x;
                }
              }
            },
            top: {
              get: function() {
                return this.y;
              },
              set: function(value) {
                if (value >= this.bottom) {
                  this.height = 0;
                } else {
                  this.height = this.bottom - value;
                }
                this.y = value;
              }
            },
            bottom: {
              get: function() {
                return this.y + this.height;
              },
              set: function(value) {
                if (value <= this.y) {
                  this.height = 0;
                } else {
                  this.height = value - this.y;
                }
              }
            },
            centerX: {
              get: function() {
                return this.x + this.width / 2;
              },
              set: function(value) {
                this.x = value - this.width / 2;
              }
            },
            centerY: {
              get: function() {
                return this.y + this.height / 2;
              },
              set: function(value) {
                this.y = value - this.height / 2;
              }
            }
          });
          module2.exports = Rectangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Alpha: __webpack_require__(605),
            AlphaSingle: __webpack_require__(297),
            BlendMode: __webpack_require__(298),
            ComputedSize: __webpack_require__(606),
            Crop: __webpack_require__(607),
            Depth: __webpack_require__(299),
            Flip: __webpack_require__(608),
            GetBounds: __webpack_require__(609),
            Mask: __webpack_require__(303),
            Origin: __webpack_require__(630),
            PathFollower: __webpack_require__(631),
            Pipeline: __webpack_require__(171),
            ScrollFactor: __webpack_require__(306),
            Size: __webpack_require__(632),
            Texture: __webpack_require__(633),
            TextureCrop: __webpack_require__(634),
            Tint: __webpack_require__(635),
            ToJSON: __webpack_require__(173),
            Transform: __webpack_require__(307),
            TransformMatrix: __webpack_require__(25),
            Visible: __webpack_require__(308)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Felipe Alfonso <@bitnenfer>
           * @author       Matthew Groves <@doormat>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          function GenerateSrc(maxIfs) {
            var src = "";
            for (var i = 0; i < maxIfs; ++i) {
              if (i > 0) {
                src += "\nelse ";
              }
              if (i < maxIfs - 1) {
                src += "if(test == " + i + ".0){}";
              }
            }
            return src;
          }
          module2.exports = {
            getTintFromFloats: function(r, g, b, a) {
              var ur = (r * 255 | 0) & 255;
              var ug = (g * 255 | 0) & 255;
              var ub = (b * 255 | 0) & 255;
              var ua = (a * 255 | 0) & 255;
              return (ua << 24 | ur << 16 | ug << 8 | ub) >>> 0;
            },
            getTintAppendFloatAlpha: function(rgb, a) {
              var ua = (a * 255 | 0) & 255;
              return (ua << 24 | rgb) >>> 0;
            },
            getTintAppendFloatAlphaAndSwap: function(rgb, a) {
              var ur = (rgb >> 16 | 0) & 255;
              var ug = (rgb >> 8 | 0) & 255;
              var ub = (rgb | 0) & 255;
              var ua = (a * 255 | 0) & 255;
              return (ua << 24 | ub << 16 | ug << 8 | ur) >>> 0;
            },
            getFloatsFromUintRGB: function(rgb) {
              var ur = (rgb >> 16 | 0) & 255;
              var ug = (rgb >> 8 | 0) & 255;
              var ub = (rgb | 0) & 255;
              return [ur / 255, ug / 255, ub / 255];
            },
            checkShaderMax: function(gl, maxTextures) {
              if (!maxTextures || maxTextures === -1) {
                maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
              }
              var shader = gl.createShader(gl.FRAGMENT_SHADER);
              var fragTemplate = [
                "precision mediump float;",
                "void main(void){",
                "float test = 0.1;",
                "%forloop%",
                "gl_FragColor = vec4(0.0);",
                "}"
              ].join("\n");
              while (true) {
                var fragmentSrc = fragTemplate.replace(/%forloop%/gi, GenerateSrc(maxTextures));
                gl.shaderSource(shader, fragmentSrc);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                  maxTextures = maxTextures / 2 | 0;
                } else {
                  break;
                }
              }
              return maxTextures;
            },
            parseFragmentShaderMaxTextures: function(fragmentShaderSource, maxTextures) {
              if (!fragmentShaderSource) {
                return "";
              }
              var src = "";
              for (var i = 0; i < maxTextures; i++) {
                if (i > 0) {
                  src += "\n	else ";
                }
                if (i < maxTextures - 1) {
                  src += "if (outTexId < " + i + ".5)";
                }
                src += "\n	{";
                src += "\n		texture = texture2D(uMainSampler[" + i + "], outTexCoord);";
                src += "\n	}";
              }
              fragmentShaderSource = fragmentShaderSource.replace(/%count%/gi, maxTextures.toString());
              return fragmentShaderSource.replace(/%forloop%/gi, src);
            }
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MATH = __webpack_require__(190);
          var GetValue = __webpack_require__(6);
          var GetAdvancedValue = function(source, key, defaultValue) {
            var value = GetValue(source, key, null);
            if (value === null) {
              return defaultValue;
            } else if (Array.isArray(value)) {
              return MATH.RND.pick(value);
            } else if (typeof value === "object") {
              if (value.hasOwnProperty("randInt")) {
                return MATH.RND.integerInRange(value.randInt[0], value.randInt[1]);
              } else if (value.hasOwnProperty("randFloat")) {
                return MATH.RND.realInRange(value.randFloat[0], value.randFloat[1]);
              }
            } else if (typeof value === "function") {
              return value(key);
            }
            return value;
          };
          module2.exports = GetAdvancedValue;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MATH_CONST = {
            PI2: Math.PI * 2,
            TAU: Math.PI * 0.5,
            EPSILON: 1e-6,
            DEG_TO_RAD: Math.PI / 180,
            RAD_TO_DEG: 180 / Math.PI,
            RND: null,
            MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,
            MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991
          };
          module2.exports = MATH_CONST;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var ComponentsToJSON = __webpack_require__(173);
          var DataManager = __webpack_require__(98);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(75);
          var GameObject = new Class({
            Extends: EventEmitter,
            initialize: function GameObject2(scene, type) {
              EventEmitter.call(this);
              this.scene = scene;
              this.displayList = null;
              this.type = type;
              this.state = 0;
              this.parentContainer = null;
              this.name = "";
              this.active = true;
              this.tabIndex = -1;
              this.data = null;
              this.renderFlags = 15;
              this.cameraFilter = 0;
              this.input = null;
              this.body = null;
              this.ignoreDestroy = false;
              this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);
              this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);
              scene.sys.queueDepthSort();
            },
            setActive: function(value) {
              this.active = value;
              return this;
            },
            setName: function(value) {
              this.name = value;
              return this;
            },
            setState: function(value) {
              this.state = value;
              return this;
            },
            setDataEnabled: function() {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              return this;
            },
            setData: function(key, value) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              this.data.set(key, value);
              return this;
            },
            incData: function(key, value) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              this.data.inc(key, value);
              return this;
            },
            toggleData: function(key) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              this.data.toggle(key);
              return this;
            },
            getData: function(key) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              return this.data.get(key);
            },
            setInteractive: function(hitArea, hitAreaCallback, dropZone) {
              this.scene.sys.input.enable(this, hitArea, hitAreaCallback, dropZone);
              return this;
            },
            disableInteractive: function() {
              if (this.input) {
                this.input.enabled = false;
              }
              return this;
            },
            removeInteractive: function() {
              this.scene.sys.input.clear(this);
              this.input = void 0;
              return this;
            },
            addedToScene: function() {
            },
            removedFromScene: function() {
            },
            update: function() {
            },
            toJSON: function() {
              return ComponentsToJSON(this);
            },
            willRender: function(camera) {
              return !(GameObject.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
            },
            getIndexList: function() {
              var child = this;
              var parent = this.parentContainer;
              var indexes = [];
              while (parent) {
                indexes.unshift(parent.getIndex(child));
                child = parent;
                if (!parent.parentContainer) {
                  break;
                } else {
                  parent = parent.parentContainer;
                }
              }
              if (this.displayList) {
                indexes.unshift(this.displayList.getIndex(child));
              } else {
                indexes.unshift(this.scene.sys.displayList.getIndex(child));
              }
              return indexes;
            },
            destroy: function() {
              if (!this.scene || this.ignoreDestroy) {
                return;
              }
              if (this.preDestroy) {
                this.preDestroy.call(this);
              }
              this.emit(Events.DESTROY, this);
              this.removeAllListeners();
              if (this.postPipelines) {
                this.resetPostPipeline(true);
              }
              if (this.displayList) {
                this.displayList.queueDepthSort();
                this.displayList.remove(this);
              }
              if (this.input) {
                this.scene.sys.input.clear(this);
                this.input = void 0;
              }
              if (this.data) {
                this.data.destroy();
                this.data = void 0;
              }
              if (this.body) {
                this.body.destroy();
                this.body = void 0;
              }
              this.active = false;
              this.visible = false;
              this.scene = void 0;
              this.displayList = void 0;
              this.parentContainer = void 0;
            }
          });
          GameObject.RENDER_MASK = 15;
          module2.exports = GameObject;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(21);
          var GameObjectCreator = new Class({
            initialize: function GameObjectCreator2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.events = scene.sys.events;
              this.displayList;
              this.updateList;
              this.events.once(SceneEvents.BOOT, this.boot, this);
              this.events.on(SceneEvents.START, this.start, this);
            },
            boot: function() {
              this.displayList = this.systems.displayList;
              this.updateList = this.systems.updateList;
              this.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function() {
              this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            shutdown: function() {
              this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function() {
              this.shutdown();
              this.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
              this.events = null;
              this.displayList = null;
              this.updateList = null;
            }
          });
          GameObjectCreator.register = function(factoryType, factoryFunction) {
            if (!GameObjectCreator.prototype.hasOwnProperty(factoryType)) {
              GameObjectCreator.prototype[factoryType] = factoryFunction;
            }
          };
          GameObjectCreator.remove = function(factoryType) {
            if (GameObjectCreator.prototype.hasOwnProperty(factoryType)) {
              delete GameObjectCreator.prototype[factoryType];
            }
          };
          PluginCache.register("GameObjectCreator", GameObjectCreator, "make");
          module2.exports = GameObjectCreator;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var IsPlainObject = __webpack_require__(7);
          var Extend = function() {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
            if (typeof target === "boolean") {
              deep = target;
              target = arguments[1] || {};
              i = 2;
            }
            if (length === i) {
              target = this;
              --i;
            }
            for (; i < length; i++) {
              if ((options = arguments[i]) != null) {
                for (name in options) {
                  src = target[name];
                  copy = options[name];
                  if (target === copy) {
                    continue;
                  }
                  if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                    if (copyIsArray) {
                      copyIsArray = false;
                      clone = src && Array.isArray(src) ? src : [];
                    } else {
                      clone = src && IsPlainObject(src) ? src : {};
                    }
                    target[name] = Extend(deep, clone, copy);
                  } else if (copy !== void 0) {
                    target[name] = copy;
                  }
                }
              }
            }
            return target;
          };
          module2.exports = Extend;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clamp = function(value, min, max) {
            return Math.max(min, Math.min(max, value));
          };
          module2.exports = Clamp;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TransformMatrix = __webpack_require__(25);
          var tempMatrix1 = new TransformMatrix();
          var tempMatrix2 = new TransformMatrix();
          var tempMatrix3 = new TransformMatrix();
          var result = {camera: tempMatrix1, sprite: tempMatrix2, calc: tempMatrix3};
          var GetCalcMatrix = function(src, camera, parentMatrix) {
            var camMatrix = tempMatrix1;
            var spriteMatrix = tempMatrix2;
            var calcMatrix = tempMatrix3;
            spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);
            camMatrix.copyFrom(camera.matrix);
            if (parentMatrix) {
              camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
              spriteMatrix.e = src.x;
              spriteMatrix.f = src.y;
            } else {
              spriteMatrix.e -= camera.scrollX * src.scrollFactorX;
              spriteMatrix.f -= camera.scrollY * src.scrollFactorY;
            }
            camMatrix.multiply(spriteMatrix, calcMatrix);
            return result;
          };
          module2.exports = GetCalcMatrix;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FILE_CONST = {
            LOADER_IDLE: 0,
            LOADER_LOADING: 1,
            LOADER_PROCESSING: 2,
            LOADER_COMPLETE: 3,
            LOADER_SHUTDOWN: 4,
            LOADER_DESTROYED: 5,
            FILE_PENDING: 10,
            FILE_LOADING: 11,
            FILE_LOADED: 12,
            FILE_FAILED: 13,
            FILE_PROCESSING: 14,
            FILE_ERRORED: 16,
            FILE_COMPLETE: 17,
            FILE_DESTROYED: 18,
            FILE_POPULATED: 19
          };
          module2.exports = FILE_CONST;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            ADDED_TO_SCENE: __webpack_require__(782),
            BOOT: __webpack_require__(783),
            CREATE: __webpack_require__(784),
            DESTROY: __webpack_require__(785),
            PAUSE: __webpack_require__(786),
            POST_UPDATE: __webpack_require__(787),
            PRE_UPDATE: __webpack_require__(788),
            READY: __webpack_require__(789),
            REMOVED_FROM_SCENE: __webpack_require__(790),
            RENDER: __webpack_require__(791),
            RESUME: __webpack_require__(792),
            SHUTDOWN: __webpack_require__(793),
            SLEEP: __webpack_require__(794),
            START: __webpack_require__(795),
            TRANSITION_COMPLETE: __webpack_require__(796),
            TRANSITION_INIT: __webpack_require__(797),
            TRANSITION_OUT: __webpack_require__(798),
            TRANSITION_START: __webpack_require__(799),
            TRANSITION_WAKE: __webpack_require__(800),
            UPDATE: __webpack_require__(801),
            WAKE: __webpack_require__(802)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            BLUR: __webpack_require__(610),
            BOOT: __webpack_require__(611),
            CONTEXT_LOST: __webpack_require__(612),
            CONTEXT_RESTORED: __webpack_require__(613),
            DESTROY: __webpack_require__(614),
            FOCUS: __webpack_require__(615),
            HIDDEN: __webpack_require__(616),
            PAUSE: __webpack_require__(617),
            POST_RENDER: __webpack_require__(618),
            POST_STEP: __webpack_require__(619),
            PRE_RENDER: __webpack_require__(620),
            PRE_STEP: __webpack_require__(621),
            READY: __webpack_require__(622),
            RESUME: __webpack_require__(623),
            STEP: __webpack_require__(624),
            VISIBLE: __webpack_require__(625)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var Events = __webpack_require__(91);
          var GetFastValue = __webpack_require__(2);
          var GetURL = __webpack_require__(153);
          var MergeXHRSettings = __webpack_require__(237);
          var XHRLoader = __webpack_require__(511);
          var XHRSettings = __webpack_require__(154);
          var File = new Class({
            initialize: function File2(loader, fileConfig) {
              this.loader = loader;
              this.cache = GetFastValue(fileConfig, "cache", false);
              this.type = GetFastValue(fileConfig, "type", false);
              this.key = GetFastValue(fileConfig, "key", false);
              var loadKey = this.key;
              if (loader.prefix && loader.prefix !== "") {
                this.key = loader.prefix + loadKey;
              }
              if (!this.type || !this.key) {
                throw new Error("Invalid Loader." + this.type + " key");
              }
              var url = GetFastValue(fileConfig, "url");
              if (url === void 0) {
                url = loader.path + loadKey + "." + GetFastValue(fileConfig, "extension", "");
              } else if (typeof url === "string" && !url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/)) {
                url = loader.path + url;
              }
              this.url = url;
              this.src = "";
              this.xhrSettings = XHRSettings(GetFastValue(fileConfig, "responseType", void 0));
              if (GetFastValue(fileConfig, "xhrSettings", false)) {
                this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, "xhrSettings", {}));
              }
              this.xhrLoader = null;
              this.state = typeof this.url === "function" ? CONST.FILE_POPULATED : CONST.FILE_PENDING;
              this.bytesTotal = 0;
              this.bytesLoaded = -1;
              this.percentComplete = -1;
              this.crossOrigin = void 0;
              this.data = void 0;
              this.config = GetFastValue(fileConfig, "config", {});
              this.multiFile;
              this.linkFile;
            },
            setLink: function(fileB) {
              this.linkFile = fileB;
              fileB.linkFile = this;
            },
            resetXHR: function() {
              if (this.xhrLoader) {
                this.xhrLoader.onload = void 0;
                this.xhrLoader.onerror = void 0;
                this.xhrLoader.onprogress = void 0;
              }
            },
            load: function() {
              if (this.state === CONST.FILE_POPULATED) {
                this.loader.nextFile(this, true);
              } else {
                this.state = CONST.FILE_LOADING;
                this.src = GetURL(this, this.loader.baseURL);
                if (this.src.indexOf("data:") === 0) {
                  console.warn("Local data URIs are not supported: " + this.key);
                } else {
                  this.xhrLoader = XHRLoader(this, this.loader.xhr);
                }
              }
            },
            onLoad: function(xhr, event) {
              var localFileOk = xhr.responseURL && xhr.responseURL.indexOf("file://") === 0 && event.target.status === 0;
              var success = !(event.target && event.target.status !== 200) || localFileOk;
              if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599) {
                success = false;
              }
              this.state = CONST.FILE_LOADED;
              this.resetXHR();
              this.loader.nextFile(this, success);
            },
            onError: function() {
              this.resetXHR();
              this.loader.nextFile(this, false);
            },
            onProgress: function(event) {
              if (event.lengthComputable) {
                this.bytesLoaded = event.loaded;
                this.bytesTotal = event.total;
                this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1);
                this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);
              }
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              this.onProcessComplete();
            },
            onProcessComplete: function() {
              this.state = CONST.FILE_COMPLETE;
              if (this.multiFile) {
                this.multiFile.onFileComplete(this);
              }
              this.loader.fileProcessComplete(this);
            },
            onProcessError: function() {
              this.state = CONST.FILE_ERRORED;
              if (this.multiFile) {
                this.multiFile.onFileFailed(this);
              }
              this.loader.fileProcessComplete(this);
            },
            hasCacheConflict: function() {
              return this.cache && this.cache.exists(this.key);
            },
            addToCache: function() {
              if (this.cache) {
                this.cache.add(this.key, this.data);
              }
              this.pendingDestroy();
            },
            pendingDestroy: function(data) {
              if (data === void 0) {
                data = this.data;
              }
              var key = this.key;
              var type = this.type;
              this.loader.emit(Events.FILE_COMPLETE, key, type, data);
              this.loader.emit(Events.FILE_KEY_COMPLETE + type + "-" + key, key, type, data);
              this.loader.flagForRemoval(this);
            },
            destroy: function() {
              this.loader = null;
              this.cache = null;
              this.xhrSettings = null;
              this.multiFile = null;
              this.linkFile = null;
              this.data = null;
            }
          });
          File.createObjectURL = function(image, blob, defaultType) {
            if (typeof URL === "function") {
              image.src = URL.createObjectURL(blob);
            } else {
              var reader = new FileReader();
              reader.onload = function() {
                image.removeAttribute("crossOrigin");
                image.src = "data:" + (blob.type || defaultType) + ";base64," + reader.result.split(",")[1];
              };
              reader.onerror = image.onerror;
              reader.readAsDataURL(blob);
            }
          };
          File.revokeObjectURL = function(image) {
            if (typeof URL === "function") {
              URL.revokeObjectURL(image.src);
            }
          };
          module2.exports = File;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var corePlugins = {};
          var customPlugins = {};
          var PluginCache = {};
          PluginCache.register = function(key, plugin, mapping, custom) {
            if (custom === void 0) {
              custom = false;
            }
            corePlugins[key] = {plugin, mapping, custom};
          };
          PluginCache.registerCustom = function(key, plugin, mapping, data) {
            customPlugins[key] = {plugin, mapping, data};
          };
          PluginCache.hasCore = function(key) {
            return corePlugins.hasOwnProperty(key);
          };
          PluginCache.hasCustom = function(key) {
            return customPlugins.hasOwnProperty(key);
          };
          PluginCache.getCore = function(key) {
            return corePlugins[key];
          };
          PluginCache.getCustom = function(key) {
            return customPlugins[key];
          };
          PluginCache.getCustomClass = function(key) {
            return customPlugins.hasOwnProperty(key) ? customPlugins[key].plugin : null;
          };
          PluginCache.remove = function(key) {
            if (corePlugins.hasOwnProperty(key)) {
              delete corePlugins[key];
            }
          };
          PluginCache.removeCustom = function(key) {
            if (customPlugins.hasOwnProperty(key)) {
              delete customPlugins[key];
            }
          };
          PluginCache.destroyCorePlugins = function() {
            for (var key in corePlugins) {
              if (corePlugins.hasOwnProperty(key)) {
                delete corePlugins[key];
              }
            }
          };
          PluginCache.destroyCustomPlugins = function() {
            for (var key in customPlugins) {
              if (customPlugins.hasOwnProperty(key)) {
                delete customPlugins[key];
              }
            }
          };
          module2.exports = PluginCache;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var MATH_CONST = __webpack_require__(14);
          var Vector29 = __webpack_require__(3);
          var TransformMatrix = new Class({
            initialize: function TransformMatrix2(a, b, c, d, tx, ty) {
              if (a === void 0) {
                a = 1;
              }
              if (b === void 0) {
                b = 0;
              }
              if (c === void 0) {
                c = 0;
              }
              if (d === void 0) {
                d = 1;
              }
              if (tx === void 0) {
                tx = 0;
              }
              if (ty === void 0) {
                ty = 0;
              }
              this.matrix = new Float32Array([a, b, c, d, tx, ty, 0, 0, 1]);
              this.decomposedMatrix = {
                translateX: 0,
                translateY: 0,
                scaleX: 1,
                scaleY: 1,
                rotation: 0
              };
            },
            a: {
              get: function() {
                return this.matrix[0];
              },
              set: function(value) {
                this.matrix[0] = value;
              }
            },
            b: {
              get: function() {
                return this.matrix[1];
              },
              set: function(value) {
                this.matrix[1] = value;
              }
            },
            c: {
              get: function() {
                return this.matrix[2];
              },
              set: function(value) {
                this.matrix[2] = value;
              }
            },
            d: {
              get: function() {
                return this.matrix[3];
              },
              set: function(value) {
                this.matrix[3] = value;
              }
            },
            e: {
              get: function() {
                return this.matrix[4];
              },
              set: function(value) {
                this.matrix[4] = value;
              }
            },
            f: {
              get: function() {
                return this.matrix[5];
              },
              set: function(value) {
                this.matrix[5] = value;
              }
            },
            tx: {
              get: function() {
                return this.matrix[4];
              },
              set: function(value) {
                this.matrix[4] = value;
              }
            },
            ty: {
              get: function() {
                return this.matrix[5];
              },
              set: function(value) {
                this.matrix[5] = value;
              }
            },
            rotation: {
              get: function() {
                return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1);
              }
            },
            rotationNormalized: {
              get: function() {
                var matrix = this.matrix;
                var a = matrix[0];
                var b = matrix[1];
                var c = matrix[2];
                var d = matrix[3];
                if (a || b) {
                  return b > 0 ? Math.acos(a / this.scaleX) : -Math.acos(a / this.scaleX);
                } else if (c || d) {
                  return MATH_CONST.TAU - (d > 0 ? Math.acos(-c / this.scaleY) : -Math.acos(c / this.scaleY));
                } else {
                  return 0;
                }
              }
            },
            scaleX: {
              get: function() {
                return Math.sqrt(this.a * this.a + this.b * this.b);
              }
            },
            scaleY: {
              get: function() {
                return Math.sqrt(this.c * this.c + this.d * this.d);
              }
            },
            loadIdentity: function() {
              var matrix = this.matrix;
              matrix[0] = 1;
              matrix[1] = 0;
              matrix[2] = 0;
              matrix[3] = 1;
              matrix[4] = 0;
              matrix[5] = 0;
              return this;
            },
            translate: function(x, y) {
              var matrix = this.matrix;
              matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];
              matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];
              return this;
            },
            scale: function(x, y) {
              var matrix = this.matrix;
              matrix[0] *= x;
              matrix[1] *= x;
              matrix[2] *= y;
              matrix[3] *= y;
              return this;
            },
            rotate: function(angle) {
              var sin = Math.sin(angle);
              var cos = Math.cos(angle);
              var matrix = this.matrix;
              var a = matrix[0];
              var b = matrix[1];
              var c = matrix[2];
              var d = matrix[3];
              matrix[0] = a * cos + c * sin;
              matrix[1] = b * cos + d * sin;
              matrix[2] = a * -sin + c * cos;
              matrix[3] = b * -sin + d * cos;
              return this;
            },
            multiply: function(rhs, out) {
              var matrix = this.matrix;
              var source = rhs.matrix;
              var localA = matrix[0];
              var localB = matrix[1];
              var localC = matrix[2];
              var localD = matrix[3];
              var localE = matrix[4];
              var localF = matrix[5];
              var sourceA = source[0];
              var sourceB = source[1];
              var sourceC = source[2];
              var sourceD = source[3];
              var sourceE = source[4];
              var sourceF = source[5];
              var destinationMatrix = out === void 0 ? this : out;
              destinationMatrix.a = sourceA * localA + sourceB * localC;
              destinationMatrix.b = sourceA * localB + sourceB * localD;
              destinationMatrix.c = sourceC * localA + sourceD * localC;
              destinationMatrix.d = sourceC * localB + sourceD * localD;
              destinationMatrix.e = sourceE * localA + sourceF * localC + localE;
              destinationMatrix.f = sourceE * localB + sourceF * localD + localF;
              return destinationMatrix;
            },
            multiplyWithOffset: function(src, offsetX, offsetY) {
              var matrix = this.matrix;
              var otherMatrix = src.matrix;
              var a0 = matrix[0];
              var b0 = matrix[1];
              var c0 = matrix[2];
              var d0 = matrix[3];
              var tx0 = matrix[4];
              var ty0 = matrix[5];
              var pse = offsetX * a0 + offsetY * c0 + tx0;
              var psf = offsetX * b0 + offsetY * d0 + ty0;
              var a1 = otherMatrix[0];
              var b1 = otherMatrix[1];
              var c1 = otherMatrix[2];
              var d1 = otherMatrix[3];
              var tx1 = otherMatrix[4];
              var ty1 = otherMatrix[5];
              matrix[0] = a1 * a0 + b1 * c0;
              matrix[1] = a1 * b0 + b1 * d0;
              matrix[2] = c1 * a0 + d1 * c0;
              matrix[3] = c1 * b0 + d1 * d0;
              matrix[4] = tx1 * a0 + ty1 * c0 + pse;
              matrix[5] = tx1 * b0 + ty1 * d0 + psf;
              return this;
            },
            transform: function(a, b, c, d, tx, ty) {
              var matrix = this.matrix;
              var a0 = matrix[0];
              var b0 = matrix[1];
              var c0 = matrix[2];
              var d0 = matrix[3];
              var tx0 = matrix[4];
              var ty0 = matrix[5];
              matrix[0] = a * a0 + b * c0;
              matrix[1] = a * b0 + b * d0;
              matrix[2] = c * a0 + d * c0;
              matrix[3] = c * b0 + d * d0;
              matrix[4] = tx * a0 + ty * c0 + tx0;
              matrix[5] = tx * b0 + ty * d0 + ty0;
              return this;
            },
            transformPoint: function(x, y, point) {
              if (point === void 0) {
                point = {x: 0, y: 0};
              }
              var matrix = this.matrix;
              var a = matrix[0];
              var b = matrix[1];
              var c = matrix[2];
              var d = matrix[3];
              var tx = matrix[4];
              var ty = matrix[5];
              point.x = x * a + y * c + tx;
              point.y = x * b + y * d + ty;
              return point;
            },
            invert: function() {
              var matrix = this.matrix;
              var a = matrix[0];
              var b = matrix[1];
              var c = matrix[2];
              var d = matrix[3];
              var tx = matrix[4];
              var ty = matrix[5];
              var n = a * d - b * c;
              matrix[0] = d / n;
              matrix[1] = -b / n;
              matrix[2] = -c / n;
              matrix[3] = a / n;
              matrix[4] = (c * ty - d * tx) / n;
              matrix[5] = -(a * ty - b * tx) / n;
              return this;
            },
            copyFrom: function(src) {
              var matrix = this.matrix;
              matrix[0] = src.a;
              matrix[1] = src.b;
              matrix[2] = src.c;
              matrix[3] = src.d;
              matrix[4] = src.e;
              matrix[5] = src.f;
              return this;
            },
            copyFromArray: function(src) {
              var matrix = this.matrix;
              matrix[0] = src[0];
              matrix[1] = src[1];
              matrix[2] = src[2];
              matrix[3] = src[3];
              matrix[4] = src[4];
              matrix[5] = src[5];
              return this;
            },
            copyToContext: function(ctx) {
              var matrix = this.matrix;
              ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
              return ctx;
            },
            setToContext: function(ctx) {
              var matrix = this.matrix;
              ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
              return ctx;
            },
            copyToArray: function(out) {
              var matrix = this.matrix;
              if (out === void 0) {
                out = [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]];
              } else {
                out[0] = matrix[0];
                out[1] = matrix[1];
                out[2] = matrix[2];
                out[3] = matrix[3];
                out[4] = matrix[4];
                out[5] = matrix[5];
              }
              return out;
            },
            setTransform: function(a, b, c, d, tx, ty) {
              var matrix = this.matrix;
              matrix[0] = a;
              matrix[1] = b;
              matrix[2] = c;
              matrix[3] = d;
              matrix[4] = tx;
              matrix[5] = ty;
              return this;
            },
            decomposeMatrix: function() {
              var decomposedMatrix = this.decomposedMatrix;
              var matrix = this.matrix;
              var a = matrix[0];
              var b = matrix[1];
              var c = matrix[2];
              var d = matrix[3];
              var determ = a * d - b * c;
              decomposedMatrix.translateX = matrix[4];
              decomposedMatrix.translateY = matrix[5];
              if (a || b) {
                var r = Math.sqrt(a * a + b * b);
                decomposedMatrix.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
                decomposedMatrix.scaleX = r;
                decomposedMatrix.scaleY = determ / r;
              } else if (c || d) {
                var s = Math.sqrt(c * c + d * d);
                decomposedMatrix.rotation = Math.PI * 0.5 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
                decomposedMatrix.scaleX = determ / s;
                decomposedMatrix.scaleY = s;
              } else {
                decomposedMatrix.rotation = 0;
                decomposedMatrix.scaleX = 0;
                decomposedMatrix.scaleY = 0;
              }
              return decomposedMatrix;
            },
            applyITRS: function(x, y, rotation, scaleX, scaleY) {
              var matrix = this.matrix;
              var radianSin = Math.sin(rotation);
              var radianCos = Math.cos(rotation);
              matrix[4] = x;
              matrix[5] = y;
              matrix[0] = radianCos * scaleX;
              matrix[1] = radianSin * scaleX;
              matrix[2] = -radianSin * scaleY;
              matrix[3] = radianCos * scaleY;
              return this;
            },
            applyInverse: function(x, y, output) {
              if (output === void 0) {
                output = new Vector29();
              }
              var matrix = this.matrix;
              var a = matrix[0];
              var b = matrix[1];
              var c = matrix[2];
              var d = matrix[3];
              var tx = matrix[4];
              var ty = matrix[5];
              var id = 1 / (a * d + c * -b);
              output.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;
              output.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;
              return output;
            },
            getX: function(x, y) {
              return x * this.a + y * this.c + this.e;
            },
            getY: function(x, y) {
              return x * this.b + y * this.d + this.f;
            },
            getXRound: function(x, y, round) {
              var v = this.getX(x, y);
              if (round) {
                v = Math.round(v);
              }
              return v;
            },
            getYRound: function(x, y, round) {
              var v = this.getY(x, y);
              if (round) {
                v = Math.round(v);
              }
              return v;
            },
            getCSSMatrix: function() {
              var m = this.matrix;
              return "matrix(" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + "," + m[4] + "," + m[5] + ")";
            },
            destroy: function() {
              this.matrix = null;
              this.decomposedMatrix = null;
            }
          });
          module2.exports = TransformMatrix;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetFastValue = __webpack_require__(2);
          var GetTilesWithin = function(tileX, tileY, width, height, filteringOptions, layer) {
            if (tileX === void 0) {
              tileX = 0;
            }
            if (tileY === void 0) {
              tileY = 0;
            }
            if (width === void 0) {
              width = layer.width;
            }
            if (height === void 0) {
              height = layer.height;
            }
            if (!filteringOptions) {
              filteringOptions = {};
            }
            var isNotEmpty = GetFastValue(filteringOptions, "isNotEmpty", false);
            var isColliding = GetFastValue(filteringOptions, "isColliding", false);
            var hasInterestingFace = GetFastValue(filteringOptions, "hasInterestingFace", false);
            if (tileX < 0) {
              width += tileX;
              tileX = 0;
            }
            if (tileY < 0) {
              height += tileY;
              tileY = 0;
            }
            if (tileX + width > layer.width) {
              width = Math.max(layer.width - tileX, 0);
            }
            if (tileY + height > layer.height) {
              height = Math.max(layer.height - tileY, 0);
            }
            var results = [];
            for (var ty = tileY; ty < tileY + height; ty++) {
              for (var tx = tileX; tx < tileX + width; tx++) {
                var tile = layer.data[ty][tx];
                if (tile !== null) {
                  if (isNotEmpty && tile.index === -1) {
                    continue;
                  }
                  if (isColliding && !tile.collides) {
                    continue;
                  }
                  if (hasInterestingFace && !tile.hasInterestingFace) {
                    continue;
                  }
                  results.push(tile);
                }
              }
            }
            return results;
          };
          module2.exports = GetTilesWithin;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = function(items, key, value, step, index, direction) {
            if (step === void 0) {
              step = 0;
            }
            if (index === void 0) {
              index = 0;
            }
            if (direction === void 0) {
              direction = 1;
            }
            var i;
            var t = 0;
            var end = items.length;
            if (direction === 1) {
              for (i = index; i < end; i++) {
                items[i][key] = value + t * step;
                t++;
              }
            } else {
              for (i = index; i >= 0; i--) {
                items[i][key] = value + t * step;
                t++;
              }
            }
            return items;
          };
          module2.exports = PropertyValueSet;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BlendModes = __webpack_require__(34);
          var GetAdvancedValue = __webpack_require__(13);
          var BuildGameObject = function(scene, gameObject, config2) {
            gameObject.x = GetAdvancedValue(config2, "x", 0);
            gameObject.y = GetAdvancedValue(config2, "y", 0);
            gameObject.depth = GetAdvancedValue(config2, "depth", 0);
            gameObject.flipX = GetAdvancedValue(config2, "flipX", false);
            gameObject.flipY = GetAdvancedValue(config2, "flipY", false);
            var scale = GetAdvancedValue(config2, "scale", null);
            if (typeof scale === "number") {
              gameObject.setScale(scale);
            } else if (scale !== null) {
              gameObject.scaleX = GetAdvancedValue(scale, "x", 1);
              gameObject.scaleY = GetAdvancedValue(scale, "y", 1);
            }
            var scrollFactor = GetAdvancedValue(config2, "scrollFactor", null);
            if (typeof scrollFactor === "number") {
              gameObject.setScrollFactor(scrollFactor);
            } else if (scrollFactor !== null) {
              gameObject.scrollFactorX = GetAdvancedValue(scrollFactor, "x", 1);
              gameObject.scrollFactorY = GetAdvancedValue(scrollFactor, "y", 1);
            }
            gameObject.rotation = GetAdvancedValue(config2, "rotation", 0);
            var angle = GetAdvancedValue(config2, "angle", null);
            if (angle !== null) {
              gameObject.angle = angle;
            }
            gameObject.alpha = GetAdvancedValue(config2, "alpha", 1);
            var origin = GetAdvancedValue(config2, "origin", null);
            if (typeof origin === "number") {
              gameObject.setOrigin(origin);
            } else if (origin !== null) {
              var ox = GetAdvancedValue(origin, "x", 0.5);
              var oy = GetAdvancedValue(origin, "y", 0.5);
              gameObject.setOrigin(ox, oy);
            }
            gameObject.blendMode = GetAdvancedValue(config2, "blendMode", BlendModes.NORMAL);
            gameObject.visible = GetAdvancedValue(config2, "visible", true);
            var add = GetAdvancedValue(config2, "add", true);
            if (add) {
              scene.sys.displayList.add(gameObject);
            }
            if (gameObject.preUpdate) {
              scene.sys.updateList.add(gameObject);
            }
            return gameObject;
          };
          module2.exports = BuildGameObject;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            ORTHOGONAL: 0,
            ISOMETRIC: 1,
            STAGGERED: 2,
            HEXAGONAL: 3
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCalcMatrix = __webpack_require__(19);
          var SetTransform = function(renderer, ctx, src, camera, parentMatrix) {
            var alpha = camera.alpha * src.alpha;
            if (alpha <= 0) {
              return false;
            }
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
            ctx.globalAlpha = alpha;
            ctx.save();
            calcMatrix.setToContext(ctx);
            ctx.imageSmoothingEnabled = !(!renderer.antialias || src.frame && src.frame.source.scaleMode);
            return true;
          };
          module2.exports = SetTransform;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(32);
          var Smoothing = __webpack_require__(189);
          var pool = [];
          var _disableContextSmoothing = false;
          var CanvasPool = function() {
            var create = function(parent, width, height, canvasType, selfParent) {
              if (width === void 0) {
                width = 1;
              }
              if (height === void 0) {
                height = 1;
              }
              if (canvasType === void 0) {
                canvasType = CONST.CANVAS;
              }
              if (selfParent === void 0) {
                selfParent = false;
              }
              var canvas;
              var container = first(canvasType);
              if (container === null) {
                container = {
                  parent,
                  canvas: document.createElement("canvas"),
                  type: canvasType
                };
                if (canvasType === CONST.CANVAS) {
                  pool.push(container);
                }
                canvas = container.canvas;
              } else {
                container.parent = parent;
                canvas = container.canvas;
              }
              if (selfParent) {
                container.parent = canvas;
              }
              canvas.width = width;
              canvas.height = height;
              if (_disableContextSmoothing && canvasType === CONST.CANVAS) {
                Smoothing.disable(canvas.getContext("2d"));
              }
              return canvas;
            };
            var create2D = function(parent, width, height) {
              return create(parent, width, height, CONST.CANVAS);
            };
            var createWebGL = function(parent, width, height) {
              return create(parent, width, height, CONST.WEBGL);
            };
            var first = function(canvasType) {
              if (canvasType === void 0) {
                canvasType = CONST.CANVAS;
              }
              if (canvasType === CONST.WEBGL) {
                return null;
              }
              for (var i = 0; i < pool.length; i++) {
                var container = pool[i];
                if (!container.parent && container.type === canvasType) {
                  return container;
                }
              }
              return null;
            };
            var remove = function(parent) {
              var isCanvas = parent instanceof HTMLCanvasElement;
              pool.forEach(function(container) {
                if (isCanvas && container.canvas === parent || !isCanvas && container.parent === parent) {
                  container.parent = null;
                  container.canvas.width = 1;
                  container.canvas.height = 1;
                }
              });
            };
            var total = function() {
              var c = 0;
              pool.forEach(function(container) {
                if (container.parent) {
                  c++;
                }
              });
              return c;
            };
            var free = function() {
              return pool.length - total();
            };
            var disableSmoothing = function() {
              _disableContextSmoothing = true;
            };
            var enableSmoothing = function() {
              _disableContextSmoothing = false;
            };
            return {
              create2D,
              create,
              createWebGL,
              disableSmoothing,
              enableSmoothing,
              first,
              free,
              pool,
              remove,
              total
            };
          };
          module2.exports = CanvasPool();
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = {
            VERSION: "3.52.0",
            BlendModes: __webpack_require__(34),
            ScaleModes: __webpack_require__(164),
            AUTO: 0,
            CANVAS: 1,
            WEBGL: 2,
            HEADLESS: 3,
            FOREVER: -1,
            NONE: 4,
            UP: 5,
            DOWN: 6,
            LEFT: 7,
            RIGHT: 8
          };
          module2.exports = CONST;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var Line = __webpack_require__(45);
          var PIPELINES_CONST = __webpack_require__(65);
          var Shape = new Class({
            Extends: GameObject,
            Mixins: [
              Components.AlphaSingle,
              Components.BlendMode,
              Components.Depth,
              Components.GetBounds,
              Components.Mask,
              Components.Origin,
              Components.Pipeline,
              Components.ScrollFactor,
              Components.Transform,
              Components.Visible
            ],
            initialize: function Shape2(scene, type, data) {
              if (type === void 0) {
                type = "Shape";
              }
              GameObject.call(this, scene, type);
              this.geom = data;
              this.pathData = [];
              this.pathIndexes = [];
              this.fillColor = 16777215;
              this.fillAlpha = 1;
              this.strokeColor = 16777215;
              this.strokeAlpha = 1;
              this.lineWidth = 1;
              this.isFilled = false;
              this.isStroked = false;
              this.closePath = true;
              this._tempLine = new Line();
              this.width = 0;
              this.height = 0;
              this.initPipeline(PIPELINES_CONST.GRAPHICS_PIPELINE);
            },
            setFillStyle: function(color, alpha) {
              if (alpha === void 0) {
                alpha = 1;
              }
              if (color === void 0) {
                this.isFilled = false;
              } else {
                this.fillColor = color;
                this.fillAlpha = alpha;
                this.isFilled = true;
              }
              return this;
            },
            setStrokeStyle: function(lineWidth, color, alpha) {
              if (alpha === void 0) {
                alpha = 1;
              }
              if (lineWidth === void 0) {
                this.isStroked = false;
              } else {
                this.lineWidth = lineWidth;
                this.strokeColor = color;
                this.strokeAlpha = alpha;
                this.isStroked = true;
              }
              return this;
            },
            setClosePath: function(value) {
              this.closePath = value;
              return this;
            },
            setSize: function(width, height) {
              this.width = width;
              this.height = height;
              return this;
            },
            preDestroy: function() {
              this.geom = null;
              this._tempLine = null;
              this.pathData = [];
              this.pathIndexes = [];
            },
            displayWidth: {
              get: function() {
                return this.scaleX * this.width;
              },
              set: function(value) {
                this.scaleX = value / this.width;
              }
            },
            displayHeight: {
              get: function() {
                return this.scaleY * this.height;
              },
              set: function(value) {
                this.scaleY = value / this.height;
              }
            }
          });
          module2.exports = Shape;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            SKIP_CHECK: -1,
            NORMAL: 0,
            ADD: 1,
            MULTIPLY: 2,
            SCREEN: 3,
            OVERLAY: 4,
            DARKEN: 5,
            LIGHTEN: 6,
            COLOR_DODGE: 7,
            COLOR_BURN: 8,
            HARD_LIGHT: 9,
            SOFT_LIGHT: 10,
            DIFFERENCE: 11,
            EXCLUSION: 12,
            HUE: 13,
            SATURATION: 14,
            COLOR: 15,
            LUMINOSITY: 16,
            ERASE: 17,
            SOURCE_IN: 18,
            SOURCE_OUT: 19,
            SOURCE_ATOP: 20,
            DESTINATION_OVER: 21,
            DESTINATION_IN: 22,
            DESTINATION_OUT: 23,
            DESTINATION_ATOP: 24,
            LIGHTER: 25,
            COPY: 26,
            XOR: 27
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(14);
          var DegToRad = function(degrees) {
            return degrees * CONST.DEG_TO_RAD;
          };
          module2.exports = DegToRad;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            DESTROY: __webpack_require__(719),
            FADE_IN_COMPLETE: __webpack_require__(720),
            FADE_IN_START: __webpack_require__(721),
            FADE_OUT_COMPLETE: __webpack_require__(722),
            FADE_OUT_START: __webpack_require__(723),
            FLASH_COMPLETE: __webpack_require__(724),
            FLASH_START: __webpack_require__(725),
            FOLLOW_UPDATE: __webpack_require__(726),
            PAN_COMPLETE: __webpack_require__(727),
            PAN_START: __webpack_require__(728),
            POST_RENDER: __webpack_require__(729),
            PRE_RENDER: __webpack_require__(730),
            ROTATE_COMPLETE: __webpack_require__(731),
            ROTATE_START: __webpack_require__(732),
            SHAKE_COMPLETE: __webpack_require__(733),
            SHAKE_START: __webpack_require__(734),
            ZOOM_COMPLETE: __webpack_require__(735),
            ZOOM_START: __webpack_require__(736)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetColor = __webpack_require__(100);
          var GetColor32 = __webpack_require__(322);
          var HSVToRGB = __webpack_require__(185);
          var RGBToHSV = __webpack_require__(323);
          var Color = new Class({
            initialize: function Color2(red, green, blue, alpha) {
              if (red === void 0) {
                red = 0;
              }
              if (green === void 0) {
                green = 0;
              }
              if (blue === void 0) {
                blue = 0;
              }
              if (alpha === void 0) {
                alpha = 255;
              }
              this.r = 0;
              this.g = 0;
              this.b = 0;
              this.a = 255;
              this._h = 0;
              this._s = 0;
              this._v = 0;
              this._locked = false;
              this.gl = [0, 0, 0, 1];
              this._color = 0;
              this._color32 = 0;
              this._rgba = "";
              this.setTo(red, green, blue, alpha);
            },
            transparent: function() {
              this._locked = true;
              this.red = 0;
              this.green = 0;
              this.blue = 0;
              this.alpha = 0;
              this._locked = false;
              return this.update(true);
            },
            setTo: function(red, green, blue, alpha, updateHSV) {
              if (alpha === void 0) {
                alpha = 255;
              }
              if (updateHSV === void 0) {
                updateHSV = true;
              }
              this._locked = true;
              this.red = red;
              this.green = green;
              this.blue = blue;
              this.alpha = alpha;
              this._locked = false;
              return this.update(updateHSV);
            },
            setGLTo: function(red, green, blue, alpha) {
              if (alpha === void 0) {
                alpha = 1;
              }
              this._locked = true;
              this.redGL = red;
              this.greenGL = green;
              this.blueGL = blue;
              this.alphaGL = alpha;
              this._locked = false;
              return this.update(true);
            },
            setFromRGB: function(color) {
              this._locked = true;
              this.red = color.r;
              this.green = color.g;
              this.blue = color.b;
              if (color.hasOwnProperty("a")) {
                this.alpha = color.a;
              }
              this._locked = false;
              return this.update(true);
            },
            setFromHSV: function(h, s, v) {
              return HSVToRGB(h, s, v, this);
            },
            update: function(updateHSV) {
              if (updateHSV === void 0) {
                updateHSV = false;
              }
              if (this._locked) {
                return this;
              }
              var r = this.r;
              var g = this.g;
              var b = this.b;
              var a = this.a;
              this._color = GetColor(r, g, b);
              this._color32 = GetColor32(r, g, b, a);
              this._rgba = "rgba(" + r + "," + g + "," + b + "," + a / 255 + ")";
              if (updateHSV) {
                RGBToHSV(r, g, b, this);
              }
              return this;
            },
            updateHSV: function() {
              var r = this.r;
              var g = this.g;
              var b = this.b;
              RGBToHSV(r, g, b, this);
              return this;
            },
            clone: function() {
              return new Color(this.r, this.g, this.b, this.a);
            },
            gray: function(shade) {
              return this.setTo(shade, shade, shade);
            },
            random: function(min, max) {
              if (min === void 0) {
                min = 0;
              }
              if (max === void 0) {
                max = 255;
              }
              var r = Math.floor(min + Math.random() * (max - min));
              var g = Math.floor(min + Math.random() * (max - min));
              var b = Math.floor(min + Math.random() * (max - min));
              return this.setTo(r, g, b);
            },
            randomGray: function(min, max) {
              if (min === void 0) {
                min = 0;
              }
              if (max === void 0) {
                max = 255;
              }
              var s = Math.floor(min + Math.random() * (max - min));
              return this.setTo(s, s, s);
            },
            saturate: function(amount) {
              this.s += amount / 100;
              return this;
            },
            desaturate: function(amount) {
              this.s -= amount / 100;
              return this;
            },
            lighten: function(amount) {
              this.v += amount / 100;
              return this;
            },
            darken: function(amount) {
              this.v -= amount / 100;
              return this;
            },
            brighten: function(amount) {
              var r = this.r;
              var g = this.g;
              var b = this.b;
              r = Math.max(0, Math.min(255, r - Math.round(255 * -(amount / 100))));
              g = Math.max(0, Math.min(255, g - Math.round(255 * -(amount / 100))));
              b = Math.max(0, Math.min(255, b - Math.round(255 * -(amount / 100))));
              return this.setTo(r, g, b);
            },
            color: {
              get: function() {
                return this._color;
              }
            },
            color32: {
              get: function() {
                return this._color32;
              }
            },
            rgba: {
              get: function() {
                return this._rgba;
              }
            },
            redGL: {
              get: function() {
                return this.gl[0];
              },
              set: function(value) {
                this.gl[0] = Math.min(Math.abs(value), 1);
                this.r = Math.floor(this.gl[0] * 255);
                this.update(true);
              }
            },
            greenGL: {
              get: function() {
                return this.gl[1];
              },
              set: function(value) {
                this.gl[1] = Math.min(Math.abs(value), 1);
                this.g = Math.floor(this.gl[1] * 255);
                this.update(true);
              }
            },
            blueGL: {
              get: function() {
                return this.gl[2];
              },
              set: function(value) {
                this.gl[2] = Math.min(Math.abs(value), 1);
                this.b = Math.floor(this.gl[2] * 255);
                this.update(true);
              }
            },
            alphaGL: {
              get: function() {
                return this.gl[3];
              },
              set: function(value) {
                this.gl[3] = Math.min(Math.abs(value), 1);
                this.a = Math.floor(this.gl[3] * 255);
                this.update();
              }
            },
            red: {
              get: function() {
                return this.r;
              },
              set: function(value) {
                value = Math.floor(Math.abs(value));
                this.r = Math.min(value, 255);
                this.gl[0] = value / 255;
                this.update(true);
              }
            },
            green: {
              get: function() {
                return this.g;
              },
              set: function(value) {
                value = Math.floor(Math.abs(value));
                this.g = Math.min(value, 255);
                this.gl[1] = value / 255;
                this.update(true);
              }
            },
            blue: {
              get: function() {
                return this.b;
              },
              set: function(value) {
                value = Math.floor(Math.abs(value));
                this.b = Math.min(value, 255);
                this.gl[2] = value / 255;
                this.update(true);
              }
            },
            alpha: {
              get: function() {
                return this.a;
              },
              set: function(value) {
                value = Math.floor(Math.abs(value));
                this.a = Math.min(value, 255);
                this.gl[3] = value / 255;
                this.update();
              }
            },
            h: {
              get: function() {
                return this._h;
              },
              set: function(value) {
                this._h = value;
                HSVToRGB(value, this._s, this._v, this);
              }
            },
            s: {
              get: function() {
                return this._s;
              },
              set: function(value) {
                this._s = value;
                HSVToRGB(this._h, value, this._v, this);
              }
            },
            v: {
              get: function() {
                return this._v;
              },
              set: function(value) {
                this._v = value;
                HSVToRGB(this._h, this._s, value, this);
              }
            }
          });
          module2.exports = Color;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Vector3 = new Class({
            initialize: function Vector32(x, y, z) {
              this.x = 0;
              this.y = 0;
              this.z = 0;
              if (typeof x === "object") {
                this.x = x.x || 0;
                this.y = x.y || 0;
                this.z = x.z || 0;
              } else {
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
              }
            },
            up: function() {
              this.x = 0;
              this.y = 1;
              this.z = 0;
              return this;
            },
            min: function(v) {
              this.x = Math.min(this.x, v.x);
              this.y = Math.min(this.y, v.y);
              this.z = Math.min(this.z, v.z);
              return this;
            },
            max: function(v) {
              this.x = Math.max(this.x, v.x);
              this.y = Math.max(this.y, v.y);
              this.z = Math.max(this.z, v.z);
              return this;
            },
            clone: function() {
              return new Vector3(this.x, this.y, this.z);
            },
            addVectors: function(a, b) {
              this.x = a.x + b.x;
              this.y = a.y + b.y;
              this.z = a.z + b.z;
              return this;
            },
            crossVectors: function(a, b) {
              var ax = a.x;
              var ay = a.y;
              var az = a.z;
              var bx = b.x;
              var by = b.y;
              var bz = b.z;
              this.x = ay * bz - az * by;
              this.y = az * bx - ax * bz;
              this.z = ax * by - ay * bx;
              return this;
            },
            equals: function(v) {
              return this.x === v.x && this.y === v.y && this.z === v.z;
            },
            copy: function(src) {
              this.x = src.x;
              this.y = src.y;
              this.z = src.z || 0;
              return this;
            },
            set: function(x, y, z) {
              if (typeof x === "object") {
                this.x = x.x || 0;
                this.y = x.y || 0;
                this.z = x.z || 0;
              } else {
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
              }
              return this;
            },
            setFromMatrixPosition: function(m) {
              return this.fromArray(m.val, 12);
            },
            setFromMatrixColumn: function(mat4, index) {
              return this.fromArray(mat4.val, index * 4);
            },
            fromArray: function(array, offset) {
              if (offset === void 0) {
                offset = 0;
              }
              this.x = array[offset];
              this.y = array[offset + 1];
              this.z = array[offset + 2];
              return this;
            },
            add: function(v) {
              this.x += v.x;
              this.y += v.y;
              this.z += v.z || 0;
              return this;
            },
            addScalar: function(s) {
              this.x += s;
              this.y += s;
              this.z += s;
              return this;
            },
            addScale: function(v, scale) {
              this.x += v.x * scale;
              this.y += v.y * scale;
              this.z += v.z * scale || 0;
              return this;
            },
            subtract: function(v) {
              this.x -= v.x;
              this.y -= v.y;
              this.z -= v.z || 0;
              return this;
            },
            multiply: function(v) {
              this.x *= v.x;
              this.y *= v.y;
              this.z *= v.z || 1;
              return this;
            },
            scale: function(scale) {
              if (isFinite(scale)) {
                this.x *= scale;
                this.y *= scale;
                this.z *= scale;
              } else {
                this.x = 0;
                this.y = 0;
                this.z = 0;
              }
              return this;
            },
            divide: function(v) {
              this.x /= v.x;
              this.y /= v.y;
              this.z /= v.z || 1;
              return this;
            },
            negate: function() {
              this.x = -this.x;
              this.y = -this.y;
              this.z = -this.z;
              return this;
            },
            distance: function(v) {
              var dx = v.x - this.x;
              var dy = v.y - this.y;
              var dz = v.z - this.z || 0;
              return Math.sqrt(dx * dx + dy * dy + dz * dz);
            },
            distanceSq: function(v) {
              var dx = v.x - this.x;
              var dy = v.y - this.y;
              var dz = v.z - this.z || 0;
              return dx * dx + dy * dy + dz * dz;
            },
            length: function() {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              return Math.sqrt(x * x + y * y + z * z);
            },
            lengthSq: function() {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              return x * x + y * y + z * z;
            },
            normalize: function() {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var len = x * x + y * y + z * z;
              if (len > 0) {
                len = 1 / Math.sqrt(len);
                this.x = x * len;
                this.y = y * len;
                this.z = z * len;
              }
              return this;
            },
            dot: function(v) {
              return this.x * v.x + this.y * v.y + this.z * v.z;
            },
            cross: function(v) {
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var bx = v.x;
              var by = v.y;
              var bz = v.z;
              this.x = ay * bz - az * by;
              this.y = az * bx - ax * bz;
              this.z = ax * by - ay * bx;
              return this;
            },
            lerp: function(v, t) {
              if (t === void 0) {
                t = 0;
              }
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              this.x = ax + t * (v.x - ax);
              this.y = ay + t * (v.y - ay);
              this.z = az + t * (v.z - az);
              return this;
            },
            applyMatrix3: function(mat3) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var m = mat3.val;
              this.x = m[0] * x + m[3] * y + m[6] * z;
              this.y = m[1] * x + m[4] * y + m[7] * z;
              this.z = m[2] * x + m[5] * y + m[8] * z;
              return this;
            },
            applyMatrix4: function(mat4) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var m = mat4.val;
              var w = 1 / (m[3] * x + m[7] * y + m[11] * z + m[15]);
              this.x = (m[0] * x + m[4] * y + m[8] * z + m[12]) * w;
              this.y = (m[1] * x + m[5] * y + m[9] * z + m[13]) * w;
              this.z = (m[2] * x + m[6] * y + m[10] * z + m[14]) * w;
              return this;
            },
            transformMat3: function(mat) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var m = mat.val;
              this.x = x * m[0] + y * m[3] + z * m[6];
              this.y = x * m[1] + y * m[4] + z * m[7];
              this.z = x * m[2] + y * m[5] + z * m[8];
              return this;
            },
            transformMat4: function(mat) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var m = mat.val;
              this.x = m[0] * x + m[4] * y + m[8] * z + m[12];
              this.y = m[1] * x + m[5] * y + m[9] * z + m[13];
              this.z = m[2] * x + m[6] * y + m[10] * z + m[14];
              return this;
            },
            transformCoordinates: function(mat) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var m = mat.val;
              var tx = x * m[0] + y * m[4] + z * m[8] + m[12];
              var ty = x * m[1] + y * m[5] + z * m[9] + m[13];
              var tz = x * m[2] + y * m[6] + z * m[10] + m[14];
              var tw = x * m[3] + y * m[7] + z * m[11] + m[15];
              this.x = tx / tw;
              this.y = ty / tw;
              this.z = tz / tw;
              return this;
            },
            transformQuat: function(q) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var qx = q.x;
              var qy = q.y;
              var qz = q.z;
              var qw = q.w;
              var ix = qw * x + qy * z - qz * y;
              var iy = qw * y + qz * x - qx * z;
              var iz = qw * z + qx * y - qy * x;
              var iw = -qx * x - qy * y - qz * z;
              this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
              this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
              this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
              return this;
            },
            project: function(mat) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var m = mat.val;
              var a00 = m[0];
              var a01 = m[1];
              var a02 = m[2];
              var a03 = m[3];
              var a10 = m[4];
              var a11 = m[5];
              var a12 = m[6];
              var a13 = m[7];
              var a20 = m[8];
              var a21 = m[9];
              var a22 = m[10];
              var a23 = m[11];
              var a30 = m[12];
              var a31 = m[13];
              var a32 = m[14];
              var a33 = m[15];
              var lw = 1 / (x * a03 + y * a13 + z * a23 + a33);
              this.x = (x * a00 + y * a10 + z * a20 + a30) * lw;
              this.y = (x * a01 + y * a11 + z * a21 + a31) * lw;
              this.z = (x * a02 + y * a12 + z * a22 + a32) * lw;
              return this;
            },
            projectViewMatrix: function(viewMatrix, projectionMatrix) {
              return this.applyMatrix4(viewMatrix).applyMatrix4(projectionMatrix);
            },
            unprojectViewMatrix: function(projectionMatrix, worldMatrix) {
              return this.applyMatrix4(projectionMatrix).applyMatrix4(worldMatrix);
            },
            unproject: function(viewport, invProjectionView) {
              var viewX = viewport.x;
              var viewY = viewport.y;
              var viewWidth = viewport.z;
              var viewHeight = viewport.w;
              var x = this.x - viewX;
              var y = viewHeight - this.y - 1 - viewY;
              var z = this.z;
              this.x = 2 * x / viewWidth - 1;
              this.y = 2 * y / viewHeight - 1;
              this.z = 2 * z - 1;
              return this.project(invProjectionView);
            },
            reset: function() {
              this.x = 0;
              this.y = 0;
              this.z = 0;
              return this;
            }
          });
          Vector3.ZERO = new Vector3();
          Vector3.RIGHT = new Vector3(1, 0, 0);
          Vector3.LEFT = new Vector3(-1, 0, 0);
          Vector3.UP = new Vector3(0, -1, 0);
          Vector3.DOWN = new Vector3(0, 1, 0);
          Vector3.FORWARD = new Vector3(0, 0, 1);
          Vector3.BACK = new Vector3(0, 0, -1);
          Vector3.ONE = new Vector3(1, 1, 1);
          module2.exports = Vector3;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            CSV: 0,
            TILED_JSON: 1,
            ARRAY_2D: 2,
            WELTMEISTER: 3
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetBottom = function(gameObject) {
            return gameObject.y + gameObject.height - gameObject.height * gameObject.originY;
          };
          module2.exports = GetBottom;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetLeft = function(gameObject) {
            return gameObject.x - gameObject.width * gameObject.originX;
          };
          module2.exports = GetLeft;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetRight = function(gameObject) {
            return gameObject.x + gameObject.width - gameObject.width * gameObject.originX;
          };
          module2.exports = GetRight;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTop = function(gameObject) {
            return gameObject.y - gameObject.height * gameObject.originY;
          };
          module2.exports = GetTop;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueInc = function(items, key, value, step, index, direction) {
            if (step === void 0) {
              step = 0;
            }
            if (index === void 0) {
              index = 0;
            }
            if (direction === void 0) {
              direction = 1;
            }
            var i;
            var t = 0;
            var end = items.length;
            if (direction === 1) {
              for (i = index; i < end; i++) {
                items[i][key] += value + t * step;
                t++;
              }
            } else {
              for (i = index; i >= 0; i--) {
                items[i][key] += value + t * step;
                t++;
              }
            }
            return items;
          };
          module2.exports = PropertyValueInc;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetPoint = __webpack_require__(301);
          var GetPoints = __webpack_require__(168);
          var GEOM_CONST = __webpack_require__(55);
          var Random = __webpack_require__(169);
          var Vector29 = __webpack_require__(3);
          var Line = new Class({
            initialize: function Line2(x1, y1, x2, y2) {
              if (x1 === void 0) {
                x1 = 0;
              }
              if (y1 === void 0) {
                y1 = 0;
              }
              if (x2 === void 0) {
                x2 = 0;
              }
              if (y2 === void 0) {
                y2 = 0;
              }
              this.type = GEOM_CONST.LINE;
              this.x1 = x1;
              this.y1 = y1;
              this.x2 = x2;
              this.y2 = y2;
            },
            getPoint: function(position, output) {
              return GetPoint(this, position, output);
            },
            getPoints: function(quantity, stepRate, output) {
              return GetPoints(this, quantity, stepRate, output);
            },
            getRandomPoint: function(point) {
              return Random(this, point);
            },
            setTo: function(x1, y1, x2, y2) {
              if (x1 === void 0) {
                x1 = 0;
              }
              if (y1 === void 0) {
                y1 = 0;
              }
              if (x2 === void 0) {
                x2 = 0;
              }
              if (y2 === void 0) {
                y2 = 0;
              }
              this.x1 = x1;
              this.y1 = y1;
              this.x2 = x2;
              this.y2 = y2;
              return this;
            },
            getPointA: function(vec2) {
              if (vec2 === void 0) {
                vec2 = new Vector29();
              }
              vec2.set(this.x1, this.y1);
              return vec2;
            },
            getPointB: function(vec2) {
              if (vec2 === void 0) {
                vec2 = new Vector29();
              }
              vec2.set(this.x2, this.y2);
              return vec2;
            },
            left: {
              get: function() {
                return Math.min(this.x1, this.x2);
              },
              set: function(value) {
                if (this.x1 <= this.x2) {
                  this.x1 = value;
                } else {
                  this.x2 = value;
                }
              }
            },
            right: {
              get: function() {
                return Math.max(this.x1, this.x2);
              },
              set: function(value) {
                if (this.x1 > this.x2) {
                  this.x1 = value;
                } else {
                  this.x2 = value;
                }
              }
            },
            top: {
              get: function() {
                return Math.min(this.y1, this.y2);
              },
              set: function(value) {
                if (this.y1 <= this.y2) {
                  this.y1 = value;
                } else {
                  this.y2 = value;
                }
              }
            },
            bottom: {
              get: function() {
                return Math.max(this.y1, this.y2);
              },
              set: function(value) {
                if (this.y1 > this.y2) {
                  this.y1 = value;
                } else {
                  this.y2 = value;
                }
              }
            }
          });
          module2.exports = Line;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FillStyleCanvas = function(ctx, src, altColor, altAlpha) {
            var fillColor = altColor ? altColor : src.fillColor;
            var fillAlpha = altAlpha ? altAlpha : src.fillAlpha;
            var red = (fillColor & 16711680) >>> 16;
            var green = (fillColor & 65280) >>> 8;
            var blue = fillColor & 255;
            ctx.fillStyle = "rgba(" + red + "," + green + "," + blue + "," + fillAlpha + ")";
          };
          module2.exports = FillStyleCanvas;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var MultiFile = new Class({
            initialize: function MultiFile2(loader, type, key, files) {
              var finalFiles = [];
              files.forEach(function(file) {
                if (file) {
                  finalFiles.push(file);
                }
              });
              this.loader = loader;
              this.type = type;
              this.key = key;
              this.multiKeyIndex = loader.multiKeyIndex++;
              this.files = finalFiles;
              this.complete = false;
              this.pending = finalFiles.length;
              this.failed = 0;
              this.config = {};
              this.baseURL = loader.baseURL;
              this.path = loader.path;
              this.prefix = loader.prefix;
              for (var i = 0; i < finalFiles.length; i++) {
                finalFiles[i].multiFile = this;
              }
            },
            isReadyToProcess: function() {
              return this.pending === 0 && this.failed === 0 && !this.complete;
            },
            addToMultiFile: function(file) {
              this.files.push(file);
              file.multiFile = this;
              this.pending++;
              this.complete = false;
              return this;
            },
            onFileComplete: function(file) {
              var index = this.files.indexOf(file);
              if (index !== -1) {
                this.pending--;
              }
            },
            onFileFailed: function(file) {
              var index = this.files.indexOf(file);
              if (index !== -1) {
                this.failed++;
              }
            }
          });
          module2.exports = MultiFile;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DistanceBetween = function(x1, y1, x2, y2) {
            var dx = x1 - x2;
            var dy = y1 - y2;
            return Math.sqrt(dx * dx + dy * dy);
          };
          module2.exports = DistanceBetween;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            BOOT: __webpack_require__(918),
            DESTROY: __webpack_require__(919),
            DRAG_END: __webpack_require__(920),
            DRAG_ENTER: __webpack_require__(921),
            DRAG: __webpack_require__(922),
            DRAG_LEAVE: __webpack_require__(923),
            DRAG_OVER: __webpack_require__(924),
            DRAG_START: __webpack_require__(925),
            DROP: __webpack_require__(926),
            GAME_OUT: __webpack_require__(927),
            GAME_OVER: __webpack_require__(928),
            GAMEOBJECT_DOWN: __webpack_require__(929),
            GAMEOBJECT_DRAG_END: __webpack_require__(930),
            GAMEOBJECT_DRAG_ENTER: __webpack_require__(931),
            GAMEOBJECT_DRAG: __webpack_require__(932),
            GAMEOBJECT_DRAG_LEAVE: __webpack_require__(933),
            GAMEOBJECT_DRAG_OVER: __webpack_require__(934),
            GAMEOBJECT_DRAG_START: __webpack_require__(935),
            GAMEOBJECT_DROP: __webpack_require__(936),
            GAMEOBJECT_MOVE: __webpack_require__(937),
            GAMEOBJECT_OUT: __webpack_require__(938),
            GAMEOBJECT_OVER: __webpack_require__(939),
            GAMEOBJECT_POINTER_DOWN: __webpack_require__(940),
            GAMEOBJECT_POINTER_MOVE: __webpack_require__(941),
            GAMEOBJECT_POINTER_OUT: __webpack_require__(942),
            GAMEOBJECT_POINTER_OVER: __webpack_require__(943),
            GAMEOBJECT_POINTER_UP: __webpack_require__(944),
            GAMEOBJECT_POINTER_WHEEL: __webpack_require__(945),
            GAMEOBJECT_UP: __webpack_require__(946),
            GAMEOBJECT_WHEEL: __webpack_require__(947),
            MANAGER_BOOT: __webpack_require__(948),
            MANAGER_PROCESS: __webpack_require__(949),
            MANAGER_UPDATE: __webpack_require__(950),
            POINTER_DOWN: __webpack_require__(951),
            POINTER_DOWN_OUTSIDE: __webpack_require__(952),
            POINTER_MOVE: __webpack_require__(953),
            POINTER_OUT: __webpack_require__(954),
            POINTER_OVER: __webpack_require__(955),
            POINTER_UP: __webpack_require__(956),
            POINTER_UP_OUTSIDE: __webpack_require__(957),
            POINTER_WHEEL: __webpack_require__(958),
            POINTERLOCK_CHANGE: __webpack_require__(959),
            PRE_UPDATE: __webpack_require__(960),
            SHUTDOWN: __webpack_require__(961),
            START: __webpack_require__(962),
            UPDATE: __webpack_require__(963)
          };
        },
        function(module2, exports2) {
          var Common = {};
          module2.exports = Common;
          (function() {
            Common._nextId = 0;
            Common._seed = 0;
            Common._nowStartTime = +new Date();
            Common.extend = function(obj, deep) {
              var argsStart, args, deepClone;
              if (typeof deep === "boolean") {
                argsStart = 2;
                deepClone = deep;
              } else {
                argsStart = 1;
                deepClone = true;
              }
              for (var i = argsStart; i < arguments.length; i++) {
                var source = arguments[i];
                if (source) {
                  for (var prop in source) {
                    if (deepClone && source[prop] && source[prop].constructor === Object) {
                      if (!obj[prop] || obj[prop].constructor === Object) {
                        obj[prop] = obj[prop] || {};
                        Common.extend(obj[prop], deepClone, source[prop]);
                      } else {
                        obj[prop] = source[prop];
                      }
                    } else {
                      obj[prop] = source[prop];
                    }
                  }
                }
              }
              return obj;
            };
            Common.clone = function(obj, deep) {
              return Common.extend({}, deep, obj);
            };
            Common.keys = function(obj) {
              if (Object.keys)
                return Object.keys(obj);
              var keys = [];
              for (var key in obj)
                keys.push(key);
              return keys;
            };
            Common.values = function(obj) {
              var values = [];
              if (Object.keys) {
                var keys = Object.keys(obj);
                for (var i = 0; i < keys.length; i++) {
                  values.push(obj[keys[i]]);
                }
                return values;
              }
              for (var key in obj)
                values.push(obj[key]);
              return values;
            };
            Common.get = function(obj, path, begin, end) {
              path = path.split(".").slice(begin, end);
              for (var i = 0; i < path.length; i += 1) {
                obj = obj[path[i]];
              }
              return obj;
            };
            Common.set = function(obj, path, val, begin, end) {
              var parts = path.split(".").slice(begin, end);
              Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;
              return val;
            };
            Common.shuffle = function(array) {
              for (var i = array.length - 1; i > 0; i--) {
                var j = Math.floor(Common.random() * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
              }
              return array;
            };
            Common.choose = function(choices) {
              return choices[Math.floor(Common.random() * choices.length)];
            };
            Common.isElement = function(obj) {
              if (typeof HTMLElement !== "undefined") {
                return obj instanceof HTMLElement;
              }
              return !!(obj && obj.nodeType && obj.nodeName);
            };
            Common.isArray = function(obj) {
              return Object.prototype.toString.call(obj) === "[object Array]";
            };
            Common.isFunction = function(obj) {
              return typeof obj === "function";
            };
            Common.isPlainObject = function(obj) {
              return typeof obj === "object" && obj.constructor === Object;
            };
            Common.isString = function(obj) {
              return Object.prototype.toString.call(obj) === "[object String]";
            };
            Common.clamp = function(value, min, max) {
              if (value < min)
                return min;
              if (value > max)
                return max;
              return value;
            };
            Common.sign = function(value) {
              return value < 0 ? -1 : 1;
            };
            Common.now = function() {
              if (typeof window !== "undefined" && window.performance) {
                if (window.performance.now) {
                  return window.performance.now();
                } else if (window.performance.webkitNow) {
                  return window.performance.webkitNow();
                }
              }
              return new Date() - Common._nowStartTime;
            };
            Common.random = function(min, max) {
              min = typeof min !== "undefined" ? min : 0;
              max = typeof max !== "undefined" ? max : 1;
              return min + _seededRandom() * (max - min);
            };
            var _seededRandom = function() {
              Common._seed = (Common._seed * 9301 + 49297) % 233280;
              return Common._seed / 233280;
            };
            Common.colorToNumber = function(colorString) {
              colorString = colorString.replace("#", "");
              if (colorString.length == 3) {
                colorString = colorString.charAt(0) + colorString.charAt(0) + colorString.charAt(1) + colorString.charAt(1) + colorString.charAt(2) + colorString.charAt(2);
              }
              return parseInt(colorString, 16);
            };
            Common.logLevel = 1;
            Common.log = function() {
              if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
                console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
              }
            };
            Common.info = function() {
              if (console && Common.logLevel > 0 && Common.logLevel <= 2) {
                console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
              }
            };
            Common.warn = function() {
              if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
                console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
              }
            };
            Common.nextId = function() {
              return Common._nextId++;
            };
            Common.indexOf = function(haystack, needle) {
              if (haystack.indexOf)
                return haystack.indexOf(needle);
              for (var i = 0; i < haystack.length; i++) {
                if (haystack[i] === needle)
                  return i;
              }
              return -1;
            };
            Common.map = function(list, func) {
              if (list.map) {
                return list.map(func);
              }
              var mapped = [];
              for (var i = 0; i < list.length; i += 1) {
                mapped.push(func(list[i]));
              }
              return mapped;
            };
            Common.topologicalSort = function(graph) {
              var result = [], visited = [], temp = [];
              for (var node in graph) {
                if (!visited[node] && !temp[node]) {
                  Common._topologicalSort(node, visited, temp, graph, result);
                }
              }
              return result;
            };
            Common._topologicalSort = function(node, visited, temp, graph, result) {
              var neighbors = graph[node] || [];
              temp[node] = true;
              for (var i = 0; i < neighbors.length; i += 1) {
                var neighbor = neighbors[i];
                if (temp[neighbor]) {
                  continue;
                }
                if (!visited[neighbor]) {
                  Common._topologicalSort(neighbor, visited, temp, graph, result);
                }
              }
              temp[node] = false;
              visited[node] = true;
              result.push(node);
            };
            Common.chain = function() {
              var funcs = [];
              for (var i = 0; i < arguments.length; i += 1) {
                var func = arguments[i];
                if (func._chained) {
                  funcs.push.apply(funcs, func._chained);
                } else {
                  funcs.push(func);
                }
              }
              var chain = function() {
                var lastResult, args = new Array(arguments.length);
                for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
                  args[i2] = arguments[i2];
                }
                for (i2 = 0; i2 < funcs.length; i2 += 1) {
                  var result = funcs[i2].apply(lastResult, args);
                  if (typeof result !== "undefined") {
                    lastResult = result;
                  }
                }
                return lastResult;
              };
              chain._chained = funcs;
              return chain;
            };
            Common.chainPathBefore = function(base, path, func) {
              return Common.set(base, path, Common.chain(func, Common.get(base, path)));
            };
            Common.chainPathAfter = function(base, path, func) {
              return Common.set(base, path, Common.chain(Common.get(base, path), func));
            };
          })();
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetTop = function(gameObject, value) {
            gameObject.y = value + gameObject.height * gameObject.originY;
            return gameObject;
          };
          module2.exports = SetTop;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetLeft = function(gameObject, value) {
            gameObject.x = value + gameObject.width * gameObject.originX;
            return gameObject;
          };
          module2.exports = SetLeft;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetRight = function(gameObject, value) {
            gameObject.x = value - gameObject.width + gameObject.width * gameObject.originX;
            return gameObject;
          };
          module2.exports = SetRight;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetBottom = function(gameObject, value) {
            gameObject.y = value - gameObject.height + gameObject.height * gameObject.originY;
            return gameObject;
          };
          module2.exports = SetBottom;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GEOM_CONST = {
            CIRCLE: 0,
            ELLIPSE: 1,
            LINE: 2,
            POINT: 3,
            POLYGON: 4,
            RECTANGLE: 5,
            TRIANGLE: 6
          };
          module2.exports = GEOM_CONST;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Contains = function(rect, x, y) {
            if (rect.width <= 0 || rect.height <= 0) {
              return false;
            }
            return rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y;
          };
          module2.exports = Contains;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var DeepCopy = __webpack_require__(172);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(368);
          var GetFastValue = __webpack_require__(2);
          var Matrix4 = __webpack_require__(67);
          var RendererEvents = __webpack_require__(88);
          var RenderTarget = __webpack_require__(139);
          var Utils = __webpack_require__(12);
          var WebGLShader = __webpack_require__(369);
          var WebGLPipeline = new Class({
            Extends: EventEmitter,
            initialize: function WebGLPipeline2(config2) {
              EventEmitter.call(this);
              var game = config2.game;
              var renderer = game.renderer;
              var gl = renderer.gl;
              this.name = GetFastValue(config2, "name", "WebGLPipeline");
              this.game = game;
              this.renderer = renderer;
              this.manager;
              this.gl = gl;
              this.view = game.canvas;
              this.width = 0;
              this.height = 0;
              this.vertexCount = 0;
              this.vertexCapacity = 0;
              this.vertexData;
              this.vertexBuffer;
              this.topology = GetFastValue(config2, "topology", gl.TRIANGLES);
              this.bytes;
              this.vertexViewF32;
              this.vertexViewU32;
              this.active = true;
              this.currentUnit = 0;
              this.forceZero = GetFastValue(config2, "forceZero", false);
              this.hasBooted = false;
              this.isPostFX = false;
              this.renderTargets = [];
              this.currentRenderTarget;
              this.shaders = [];
              this.currentShader;
              this.projectionMatrix;
              this.projectionWidth = 0;
              this.projectionHeight = 0;
              this.config = config2;
            },
            boot: function() {
              var i;
              var gl = this.gl;
              var config2 = this.config;
              var renderer = this.renderer;
              if (!this.isPostFX) {
                this.projectionMatrix = new Matrix4().identity();
              }
              var renderTargets = this.renderTargets;
              var targets = GetFastValue(config2, "renderTarget", false);
              if (typeof targets === "boolean" && targets) {
                targets = 1;
              }
              var width = renderer.width;
              var height = renderer.height;
              if (typeof targets === "number") {
                for (i = 0; i < targets; i++) {
                  renderTargets.push(new RenderTarget(renderer, width, height, 1, 0, true));
                }
              } else if (Array.isArray(targets)) {
                for (i = 0; i < targets.length; i++) {
                  var scale = GetFastValue(targets[i], "scale", 1);
                  var minFilter = GetFastValue(targets[i], "minFilter", 0);
                  var autoClear = GetFastValue(targets[i], "autoClear", 1);
                  renderTargets.push(new RenderTarget(renderer, width, height, scale, minFilter, autoClear));
                }
              }
              if (renderTargets.length) {
                this.currentRenderTarget = renderTargets[0];
              }
              this.setShadersFromConfig(config2);
              var shaders = this.shaders;
              var vertexSize = 0;
              for (i = 0; i < shaders.length; i++) {
                if (shaders[i].vertexSize > vertexSize) {
                  vertexSize = shaders[i].vertexSize;
                }
              }
              var batchSize = GetFastValue(config2, "batchSize", renderer.config.batchSize);
              this.vertexCapacity = batchSize * 6;
              var data = new ArrayBuffer(this.vertexCapacity * vertexSize);
              this.vertexData = data;
              this.bytes = new Uint8Array(data);
              this.vertexViewF32 = new Float32Array(data);
              this.vertexViewU32 = new Uint32Array(data);
              var configVerts = GetFastValue(config2, "vertices", null);
              if (configVerts) {
                this.vertexViewF32.set(configVerts);
                this.vertexBuffer = renderer.createVertexBuffer(data, gl.STATIC_DRAW);
              } else {
                this.vertexBuffer = renderer.createVertexBuffer(data.byteLength, gl.DYNAMIC_DRAW);
              }
              this.setVertexBuffer();
              for (i = shaders.length - 1; i >= 0; i--) {
                shaders[i].rebind();
              }
              this.hasBooted = true;
              renderer.on(RendererEvents.RESIZE, this.resize, this);
              renderer.on(RendererEvents.PRE_RENDER, this.onPreRender, this);
              renderer.on(RendererEvents.RENDER, this.onRender, this);
              renderer.on(RendererEvents.POST_RENDER, this.onPostRender, this);
              this.emit(Events.BOOT, this);
              this.onBoot();
            },
            onBoot: function() {
            },
            onResize: function() {
            },
            setShader: function(shader, setAttributes) {
              var renderer = this.renderer;
              if (shader !== this.currentShader || renderer.currentProgram !== this.currentShader.program) {
                this.flush();
                renderer.resetTextures();
                var wasBound = this.setVertexBuffer();
                if (wasBound && !setAttributes) {
                  setAttributes = true;
                }
                shader.bind(setAttributes, false);
                this.currentShader = shader;
              }
              return this;
            },
            getShaderByName: function(name) {
              var shaders = this.shaders;
              for (var i = 0; i < shaders.length; i++) {
                if (shaders[i].name === name) {
                  return shaders[i];
                }
              }
            },
            setShadersFromConfig: function(config2) {
              var i;
              var shaders = this.shaders;
              var renderer = this.renderer;
              for (i = 0; i < shaders.length; i++) {
                shaders[i].destroy();
              }
              var vName = "vertShader";
              var fName = "fragShader";
              var aName = "attributes";
              var defaultVertShader = GetFastValue(config2, vName, null);
              var defaultFragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(config2, fName, null), renderer.maxTextures);
              var defaultAttribs = GetFastValue(config2, aName, null);
              var configShaders = GetFastValue(config2, "shaders", []);
              var len = configShaders.length;
              if (len === 0) {
                if (defaultVertShader && defaultFragShader) {
                  this.shaders = [new WebGLShader(this, "default", defaultVertShader, defaultFragShader, DeepCopy(defaultAttribs))];
                }
              } else {
                var newShaders = [];
                for (i = 0; i < len; i++) {
                  var shaderEntry = configShaders[i];
                  var name = GetFastValue(shaderEntry, "name", "default");
                  var vertShader = GetFastValue(shaderEntry, vName, defaultVertShader);
                  var fragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(shaderEntry, fName, defaultFragShader), renderer.maxTextures);
                  var attributes = GetFastValue(shaderEntry, aName, defaultAttribs);
                  if (vertShader && fragShader) {
                    newShaders.push(new WebGLShader(this, name, vertShader, fragShader, DeepCopy(attributes)));
                  }
                }
                this.shaders = newShaders;
              }
              if (this.shaders.length === 0) {
                console.warn("Pipeline: " + this.name + " - Invalid shader config");
              } else {
                this.currentShader = this.shaders[0];
              }
              return this;
            },
            setGameObject: function(gameObject, frame) {
              if (frame === void 0) {
                frame = gameObject.frame;
              }
              this.currentUnit = this.renderer.setTextureSource(frame.source);
              return this.currentUnit;
            },
            shouldFlush: function(amount) {
              if (amount === void 0) {
                amount = 0;
              }
              return this.vertexCount + amount > this.vertexCapacity;
            },
            resize: function(width, height) {
              if (width !== this.width || height !== this.height) {
                this.flush();
              }
              this.width = width;
              this.height = height;
              var targets = this.renderTargets;
              for (var i = 0; i < targets.length; i++) {
                targets[i].resize(width, height);
              }
              this.setProjectionMatrix(width, height);
              this.emit(Events.RESIZE, width, height, this);
              this.onResize(width, height);
              return this;
            },
            setProjectionMatrix: function(width, height) {
              var projectionMatrix = this.projectionMatrix;
              if (!projectionMatrix) {
                return this;
              }
              this.projectionWidth = width;
              this.projectionHeight = height;
              projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);
              var shaders = this.shaders;
              var name = "uProjectionMatrix";
              for (var i = 0; i < shaders.length; i++) {
                var shader = shaders[i];
                if (shader.hasUniform(name)) {
                  shader.resetUniform(name);
                  shader.setMatrix4fv(name, false, projectionMatrix.val, shader);
                }
              }
              return this;
            },
            updateProjectionMatrix: function() {
              if (this.projectionMatrix) {
                var globalWidth = this.renderer.projectionWidth;
                var globalHeight = this.renderer.projectionHeight;
                if (this.projectionWidth !== globalWidth || this.projectionHeight !== globalHeight) {
                  this.setProjectionMatrix(globalWidth, globalHeight);
                }
              }
            },
            bind: function(currentShader) {
              if (currentShader === void 0) {
                currentShader = this.currentShader;
              }
              var wasBound = this.setVertexBuffer();
              currentShader.bind(wasBound);
              this.currentShader = currentShader;
              this.emit(Events.BIND, this, currentShader);
              this.onActive(currentShader);
              return this;
            },
            rebind: function() {
              this.setVertexBuffer();
              var shaders = this.shaders;
              for (var i = shaders.length - 1; i >= 0; i--) {
                this.currentShader = shaders[i].rebind();
              }
              this.emit(Events.REBIND, this.currentShader);
              this.onActive(this.currentShader);
              this.onRebind();
              return this;
            },
            setVertexBuffer: function() {
              var gl = this.gl;
              var buffer = this.vertexBuffer;
              if (gl.getParameter(gl.ARRAY_BUFFER_BINDING) !== buffer) {
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                return true;
              }
              return false;
            },
            preBatch: function(gameObject) {
              if (this.currentRenderTarget) {
                this.currentRenderTarget.bind();
              }
              this.onPreBatch(gameObject);
              return this;
            },
            postBatch: function(gameObject) {
              this.onDraw(this.currentRenderTarget);
              this.onPostBatch(gameObject);
              return this;
            },
            onDraw: function() {
            },
            unbind: function() {
              if (this.currentRenderTarget) {
                this.currentRenderTarget.unbind();
              }
            },
            flush: function(isPostFlush) {
              if (isPostFlush === void 0) {
                isPostFlush = false;
              }
              if (this.vertexCount > 0) {
                this.emit(Events.BEFORE_FLUSH, this, isPostFlush);
                this.onBeforeFlush(isPostFlush);
                var gl = this.gl;
                var vertexCount = this.vertexCount;
                var vertexSize = this.currentShader.vertexSize;
                if (this.active) {
                  this.setVertexBuffer();
                  if (vertexCount === this.vertexCapacity) {
                    gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.DYNAMIC_DRAW);
                  } else {
                    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));
                  }
                  gl.drawArrays(this.topology, 0, vertexCount);
                }
                this.vertexCount = 0;
                this.emit(Events.AFTER_FLUSH, this, isPostFlush);
                this.onAfterFlush(isPostFlush);
              }
              return this;
            },
            onActive: function() {
            },
            onBind: function() {
            },
            onRebind: function() {
            },
            onBatch: function() {
            },
            onPreBatch: function() {
            },
            onPostBatch: function() {
            },
            onPreRender: function() {
            },
            onRender: function() {
            },
            onPostRender: function() {
            },
            onBeforeFlush: function() {
            },
            onAfterFlush: function() {
            },
            batchVert: function(x, y, u, v, unit, tintEffect, tint) {
              var vertexViewF32 = this.vertexViewF32;
              var vertexViewU32 = this.vertexViewU32;
              var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
              vertexViewF32[++vertexOffset] = x;
              vertexViewF32[++vertexOffset] = y;
              vertexViewF32[++vertexOffset] = u;
              vertexViewF32[++vertexOffset] = v;
              vertexViewF32[++vertexOffset] = unit;
              vertexViewF32[++vertexOffset] = tintEffect;
              vertexViewU32[++vertexOffset] = tint;
              this.vertexCount++;
            },
            batchQuad: function(gameObject, x0, y0, x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, unit) {
              if (unit === void 0) {
                unit = this.currentUnit;
              }
              var hasFlushed = false;
              if (this.shouldFlush(6)) {
                this.flush();
                hasFlushed = true;
                unit = this.setTexture2D(texture);
              }
              this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);
              this.batchVert(x1, y1, u0, v1, unit, tintEffect, tintBL);
              this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBR);
              this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);
              this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBR);
              this.batchVert(x3, y3, u1, v0, unit, tintEffect, tintTR);
              this.onBatch(gameObject);
              return hasFlushed;
            },
            batchTri: function(gameObject, x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintEffect, texture, unit) {
              if (unit === void 0) {
                unit = this.currentUnit;
              }
              var hasFlushed = false;
              if (this.shouldFlush(3)) {
                this.flush();
                hasFlushed = true;
                unit = this.setTexture2D(texture);
              }
              this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);
              this.batchVert(x1, y1, u0, v1, unit, tintEffect, tintTR);
              this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBL);
              this.onBatch(gameObject);
              return hasFlushed;
            },
            drawFillRect: function(x, y, width, height, color, alpha, texture, flipUV) {
              if (texture === void 0) {
                texture = this.renderer.whiteTexture.glTexture;
              }
              if (flipUV === void 0) {
                flipUV = true;
              }
              x = Math.floor(x);
              y = Math.floor(y);
              var xw = Math.floor(x + width);
              var yh = Math.floor(y + height);
              var unit = this.setTexture2D(texture);
              var tint = Utils.getTintAppendFloatAlphaAndSwap(color, alpha);
              var u0 = 0;
              var v0 = 0;
              var u1 = 1;
              var v1 = 1;
              if (flipUV) {
                v0 = 1;
                v1 = 0;
              }
              this.batchQuad(null, x, y, x, yh, xw, yh, xw, y, u0, v0, u1, v1, tint, tint, tint, tint, 0, texture, unit);
            },
            setTexture2D: function(texture) {
              if (texture === void 0) {
                texture = this.renderer.whiteTexture.glTexture;
              }
              this.currentUnit = this.renderer.setTexture2D(texture);
              return this.currentUnit;
            },
            bindTexture: function(texture, unit) {
              if (unit === void 0) {
                unit = 0;
              }
              var gl = this.gl;
              gl.activeTexture(gl.TEXTURE0 + unit);
              gl.bindTexture(gl.TEXTURE_2D, texture);
              return this;
            },
            bindRenderTarget: function(target, unit) {
              return this.bindTexture(target.texture, unit);
            },
            setTime: function(uniform) {
              this.set1f(uniform, this.game.loop.getDuration());
              return this;
            },
            set1f: function(name, x, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set1f(name, x);
              return this;
            },
            set2f: function(name, x, y, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set2f(name, x, y);
              return this;
            },
            set3f: function(name, x, y, z, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set3f(name, x, y, z);
              return this;
            },
            set4f: function(name, x, y, z, w, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set4f(name, x, y, z, w);
              return this;
            },
            set1fv: function(name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set1fv(name, arr);
              return this;
            },
            set2fv: function(name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set2fv(name, arr);
              return this;
            },
            set3fv: function(name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set3fv(name, arr);
              return this;
            },
            set4fv: function(name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set4fv(name, arr);
              return this;
            },
            set1iv: function(name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set1iv(name, arr);
              return this;
            },
            set2iv: function(name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set2iv(name, arr);
              return this;
            },
            set3iv: function(name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set3iv(name, arr);
              return this;
            },
            set4iv: function(name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set4iv(name, arr);
              return this;
            },
            set1i: function(name, x, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set1i(name, x);
              return this;
            },
            set2i: function(name, x, y, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set2i(name, x, y);
              return this;
            },
            set3i: function(name, x, y, z, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set3i(name, x, y, z);
              return this;
            },
            set4i: function(name, x, y, z, w, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set4i(name, x, y, z, w);
              return this;
            },
            setMatrix2fv: function(name, transpose, matrix, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.setMatrix2fv(name, transpose, matrix);
              return this;
            },
            setMatrix3fv: function(name, transpose, matrix, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.setMatrix3fv(name, transpose, matrix);
              return this;
            },
            setMatrix4fv: function(name, transpose, matrix, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.setMatrix4fv(name, transpose, matrix);
              return this;
            },
            destroy: function() {
              this.emit(Events.DESTROY, this);
              var i;
              var shaders = this.shaders;
              for (i = 0; i < shaders.length; i++) {
                shaders[i].destroy();
              }
              var targets = this.renderTargets;
              for (i = 0; i < targets.length; i++) {
                targets[i].destroy();
              }
              this.gl.deleteBuffer(this.vertexBuffer);
              var renderer = this.renderer;
              renderer.off(RendererEvents.RESIZE, this.resize, this);
              renderer.off(RendererEvents.PRE_RENDER, this.onPreRender, this);
              renderer.off(RendererEvents.RENDER, this.onRender, this);
              renderer.off(RendererEvents.POST_RENDER, this.onPostRender, this);
              this.removeAllListeners();
              this.game = null;
              this.renderer = null;
              this.manager = null;
              this.gl = null;
              this.view = null;
              this.shaders = null;
              this.renderTargets = null;
              this.bytes = null;
              this.vertexViewF32 = null;
              this.vertexViewU32 = null;
              this.vertexData = null;
              this.vertexBuffer = null;
              this.currentShader = null;
              this.currentRenderTarget = null;
              return this;
            }
          });
          module2.exports = WebGLPipeline;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var LineStyleCanvas = function(ctx, src, altColor, altAlpha) {
            var strokeColor = altColor ? altColor : src.strokeColor;
            var strokeAlpha = altAlpha ? altAlpha : src.strokeAlpha;
            var red = (strokeColor & 16711680) >>> 16;
            var green = (strokeColor & 65280) >>> 8;
            var blue = strokeColor & 255;
            ctx.strokeStyle = "rgba(" + red + "," + green + "," + blue + "," + strokeAlpha + ")";
            ctx.lineWidth = src.lineWidth;
          };
          module2.exports = LineStyleCanvas;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var GetValue = __webpack_require__(6);
          var IsPlainObject = __webpack_require__(7);
          var JSONFile = new Class({
            Extends: File,
            initialize: function JSONFile2(loader, key, url, xhrSettings, dataKey) {
              var extension = "json";
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
                dataKey = GetFastValue(config2, "dataKey", dataKey);
              }
              var fileConfig = {
                type: "json",
                cache: loader.cacheManager.json,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings,
                config: dataKey
              };
              File.call(this, loader, fileConfig);
              if (IsPlainObject(url)) {
                if (dataKey) {
                  this.data = GetValue(url, dataKey);
                } else {
                  this.data = url;
                }
                this.state = CONST.FILE_POPULATED;
              }
            },
            onProcess: function() {
              if (this.state !== CONST.FILE_POPULATED) {
                this.state = CONST.FILE_PROCESSING;
                var json = JSON.parse(this.xhrLoader.responseText);
                var key = this.config;
                if (typeof key === "string") {
                  this.data = GetValue(json, key, json);
                } else {
                  this.data = json;
                }
              }
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("json", function(key, url, dataKey, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new JSONFile(this, key[i]));
              }
            } else {
              this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));
            }
            return this;
          });
          module2.exports = JSONFile;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = {
            DYNAMIC_BODY: 0,
            STATIC_BODY: 1,
            GROUP: 2,
            TILEMAPLAYER: 3,
            FACING_NONE: 10,
            FACING_UP: 11,
            FACING_DOWN: 12,
            FACING_LEFT: 13,
            FACING_RIGHT: 14
          };
          module2.exports = CONST;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTileAt = __webpack_require__(156);
          var GetTilesWithin = __webpack_require__(26);
          var CalculateFacesWithin = function(tileX, tileY, width, height, layer) {
            var above = null;
            var below = null;
            var left = null;
            var right = null;
            var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
            for (var i = 0; i < tiles.length; i++) {
              var tile = tiles[i];
              if (tile) {
                if (tile.collides) {
                  above = GetTileAt(tile.x, tile.y - 1, true, layer);
                  below = GetTileAt(tile.x, tile.y + 1, true, layer);
                  left = GetTileAt(tile.x - 1, tile.y, true, layer);
                  right = GetTileAt(tile.x + 1, tile.y, true, layer);
                  tile.faceTop = above && above.collides ? false : true;
                  tile.faceBottom = below && below.collides ? false : true;
                  tile.faceLeft = left && left.collides ? false : true;
                  tile.faceRight = right && right.collides ? false : true;
                } else {
                  tile.resetFaces();
                }
              }
            }
          };
          module2.exports = CalculateFacesWithin;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Contains = __webpack_require__(63);
          var GetPoint = __webpack_require__(294);
          var GetPoints = __webpack_require__(295);
          var GEOM_CONST = __webpack_require__(55);
          var Random = __webpack_require__(166);
          var Circle = new Class({
            initialize: function Circle2(x, y, radius) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (radius === void 0) {
                radius = 0;
              }
              this.type = GEOM_CONST.CIRCLE;
              this.x = x;
              this.y = y;
              this._radius = radius;
              this._diameter = radius * 2;
            },
            contains: function(x, y) {
              return Contains(this, x, y);
            },
            getPoint: function(position, point) {
              return GetPoint(this, position, point);
            },
            getPoints: function(quantity, stepRate, output) {
              return GetPoints(this, quantity, stepRate, output);
            },
            getRandomPoint: function(point) {
              return Random(this, point);
            },
            setTo: function(x, y, radius) {
              this.x = x;
              this.y = y;
              this._radius = radius;
              this._diameter = radius * 2;
              return this;
            },
            setEmpty: function() {
              this._radius = 0;
              this._diameter = 0;
              return this;
            },
            setPosition: function(x, y) {
              if (y === void 0) {
                y = x;
              }
              this.x = x;
              this.y = y;
              return this;
            },
            isEmpty: function() {
              return this._radius <= 0;
            },
            radius: {
              get: function() {
                return this._radius;
              },
              set: function(value) {
                this._radius = value;
                this._diameter = value * 2;
              }
            },
            diameter: {
              get: function() {
                return this._diameter;
              },
              set: function(value) {
                this._diameter = value;
                this._radius = value * 0.5;
              }
            },
            left: {
              get: function() {
                return this.x - this._radius;
              },
              set: function(value) {
                this.x = value + this._radius;
              }
            },
            right: {
              get: function() {
                return this.x + this._radius;
              },
              set: function(value) {
                this.x = value - this._radius;
              }
            },
            top: {
              get: function() {
                return this.y - this._radius;
              },
              set: function(value) {
                this.y = value + this._radius;
              }
            },
            bottom: {
              get: function() {
                return this.y + this._radius;
              },
              set: function(value) {
                this.y = value - this._radius;
              }
            }
          });
          module2.exports = Circle;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Contains = function(circle, x, y) {
            if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom) {
              var dx = (circle.x - x) * (circle.x - x);
              var dy = (circle.y - y) * (circle.y - y);
              return dx + dy <= circle.radius * circle.radius;
            } else {
              return false;
            }
          };
          module2.exports = Contains;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Length = function(line) {
            return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
          };
          module2.exports = Length;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PIPELINE_CONST = {
            BITMAPMASK_PIPELINE: "BitmapMaskPipeline",
            LIGHT_PIPELINE: "Light2D",
            POINTLIGHT_PIPELINE: "PointLightPipeline",
            SINGLE_PIPELINE: "SinglePipeline",
            MULTI_PIPELINE: "MultiPipeline",
            ROPE_PIPELINE: "RopePipeline",
            GRAPHICS_PIPELINE: "GraphicsPipeline",
            POSTFX_PIPELINE: "PostFXPipeline",
            UTILITY_PIPELINE: "UtilityPipeline"
          };
          module2.exports = PIPELINE_CONST;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Wrap = function(value, min, max) {
            var range = max - min;
            return min + ((value - min) % range + range) % range;
          };
          module2.exports = Wrap;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Vector3 = __webpack_require__(38);
          var EPSILON = 1e-6;
          var Matrix4 = new Class({
            initialize: function Matrix42(m) {
              this.val = new Float32Array(16);
              if (m) {
                this.copy(m);
              } else {
                this.identity();
              }
            },
            clone: function() {
              return new Matrix4(this);
            },
            set: function(src) {
              return this.copy(src);
            },
            setValues: function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
              var out = this.val;
              out[0] = m00;
              out[1] = m01;
              out[2] = m02;
              out[3] = m03;
              out[4] = m10;
              out[5] = m11;
              out[6] = m12;
              out[7] = m13;
              out[8] = m20;
              out[9] = m21;
              out[10] = m22;
              out[11] = m23;
              out[12] = m30;
              out[13] = m31;
              out[14] = m32;
              out[15] = m33;
              return this;
            },
            copy: function(src) {
              var a = src.val;
              return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
            },
            fromArray: function(a) {
              return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
            },
            zero: function() {
              return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            },
            transform: function(position, scale, rotation) {
              var rotMatrix = _tempMat1.fromQuat(rotation);
              var rm = rotMatrix.val;
              var sx = scale.x;
              var sy = scale.y;
              var sz = scale.z;
              return this.setValues(rm[0] * sx, rm[1] * sx, rm[2] * sx, 0, rm[4] * sy, rm[5] * sy, rm[6] * sy, 0, rm[8] * sz, rm[9] * sz, rm[10] * sz, 0, position.x, position.y, position.z, 1);
            },
            xyz: function(x, y, z) {
              this.identity();
              var out = this.val;
              out[12] = x;
              out[13] = y;
              out[14] = z;
              return this;
            },
            scaling: function(x, y, z) {
              this.zero();
              var out = this.val;
              out[0] = x;
              out[5] = y;
              out[10] = z;
              out[15] = 1;
              return this;
            },
            identity: function() {
              return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            },
            transpose: function() {
              var a = this.val;
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a12 = a[6];
              var a13 = a[7];
              var a23 = a[11];
              a[1] = a[4];
              a[2] = a[8];
              a[3] = a[12];
              a[4] = a01;
              a[6] = a[9];
              a[7] = a[13];
              a[8] = a02;
              a[9] = a12;
              a[11] = a[14];
              a[12] = a03;
              a[13] = a13;
              a[14] = a23;
              return this;
            },
            getInverse: function(m) {
              this.copy(m);
              return this.invert();
            },
            invert: function() {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              var a30 = a[12];
              var a31 = a[13];
              var a32 = a[14];
              var a33 = a[15];
              var b00 = a00 * a11 - a01 * a10;
              var b01 = a00 * a12 - a02 * a10;
              var b02 = a00 * a13 - a03 * a10;
              var b03 = a01 * a12 - a02 * a11;
              var b04 = a01 * a13 - a03 * a11;
              var b05 = a02 * a13 - a03 * a12;
              var b06 = a20 * a31 - a21 * a30;
              var b07 = a20 * a32 - a22 * a30;
              var b08 = a20 * a33 - a23 * a30;
              var b09 = a21 * a32 - a22 * a31;
              var b10 = a21 * a33 - a23 * a31;
              var b11 = a22 * a33 - a23 * a32;
              var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
              if (!det) {
                return this;
              }
              det = 1 / det;
              return this.setValues((a11 * b11 - a12 * b10 + a13 * b09) * det, (a02 * b10 - a01 * b11 - a03 * b09) * det, (a31 * b05 - a32 * b04 + a33 * b03) * det, (a22 * b04 - a21 * b05 - a23 * b03) * det, (a12 * b08 - a10 * b11 - a13 * b07) * det, (a00 * b11 - a02 * b08 + a03 * b07) * det, (a32 * b02 - a30 * b05 - a33 * b01) * det, (a20 * b05 - a22 * b02 + a23 * b01) * det, (a10 * b10 - a11 * b08 + a13 * b06) * det, (a01 * b08 - a00 * b10 - a03 * b06) * det, (a30 * b04 - a31 * b02 + a33 * b00) * det, (a21 * b02 - a20 * b04 - a23 * b00) * det, (a11 * b07 - a10 * b09 - a12 * b06) * det, (a00 * b09 - a01 * b07 + a02 * b06) * det, (a31 * b01 - a30 * b03 - a32 * b00) * det, (a20 * b03 - a21 * b01 + a22 * b00) * det);
            },
            adjoint: function() {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              var a30 = a[12];
              var a31 = a[13];
              var a32 = a[14];
              var a33 = a[15];
              return this.setValues(a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22), -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22)), a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12), -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12)), -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22)), a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22), -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12)), a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12), a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21), -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21)), a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11), -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11)), -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21)), a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21), -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11)), a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
            },
            determinant: function() {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              var a30 = a[12];
              var a31 = a[13];
              var a32 = a[14];
              var a33 = a[15];
              var b00 = a00 * a11 - a01 * a10;
              var b01 = a00 * a12 - a02 * a10;
              var b02 = a00 * a13 - a03 * a10;
              var b03 = a01 * a12 - a02 * a11;
              var b04 = a01 * a13 - a03 * a11;
              var b05 = a02 * a13 - a03 * a12;
              var b06 = a20 * a31 - a21 * a30;
              var b07 = a20 * a32 - a22 * a30;
              var b08 = a20 * a33 - a23 * a30;
              var b09 = a21 * a32 - a22 * a31;
              var b10 = a21 * a33 - a23 * a31;
              var b11 = a22 * a33 - a23 * a32;
              return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            },
            multiply: function(src) {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              var a30 = a[12];
              var a31 = a[13];
              var a32 = a[14];
              var a33 = a[15];
              var b = src.val;
              var b0 = b[0];
              var b1 = b[1];
              var b2 = b[2];
              var b3 = b[3];
              a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
              a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
              a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
              a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
              b0 = b[4];
              b1 = b[5];
              b2 = b[6];
              b3 = b[7];
              a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
              a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
              a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
              a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
              b0 = b[8];
              b1 = b[9];
              b2 = b[10];
              b3 = b[11];
              a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
              a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
              a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
              a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
              b0 = b[12];
              b1 = b[13];
              b2 = b[14];
              b3 = b[15];
              a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
              a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
              a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
              a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
              return this;
            },
            multiplyLocal: function(src) {
              var a = this.val;
              var b = src.val;
              return this.setValues(a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12], a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13], a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14], a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15], a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12], a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13], a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14], a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15], a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12], a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13], a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14], a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15], a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12], a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13], a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14], a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]);
            },
            premultiply: function(m) {
              return this.multiplyMatrices(m, this);
            },
            multiplyMatrices: function(a, b) {
              var am = a.val;
              var bm = b.val;
              var a11 = am[0];
              var a12 = am[4];
              var a13 = am[8];
              var a14 = am[12];
              var a21 = am[1];
              var a22 = am[5];
              var a23 = am[9];
              var a24 = am[13];
              var a31 = am[2];
              var a32 = am[6];
              var a33 = am[10];
              var a34 = am[14];
              var a41 = am[3];
              var a42 = am[7];
              var a43 = am[11];
              var a44 = am[15];
              var b11 = bm[0];
              var b12 = bm[4];
              var b13 = bm[8];
              var b14 = bm[12];
              var b21 = bm[1];
              var b22 = bm[5];
              var b23 = bm[9];
              var b24 = bm[13];
              var b31 = bm[2];
              var b32 = bm[6];
              var b33 = bm[10];
              var b34 = bm[14];
              var b41 = bm[3];
              var b42 = bm[7];
              var b43 = bm[11];
              var b44 = bm[15];
              return this.setValues(a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41, a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41, a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41, a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41, a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42, a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42, a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42, a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42, a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43, a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43, a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43, a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43, a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44, a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44, a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44, a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44);
            },
            translate: function(v) {
              return this.translateXYZ(v.x, v.y, v.z);
            },
            translateXYZ: function(x, y, z) {
              var a = this.val;
              a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
              a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
              a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
              a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
              return this;
            },
            scale: function(v) {
              return this.scaleXYZ(v.x, v.y, v.z);
            },
            scaleXYZ: function(x, y, z) {
              var a = this.val;
              a[0] = a[0] * x;
              a[1] = a[1] * x;
              a[2] = a[2] * x;
              a[3] = a[3] * x;
              a[4] = a[4] * y;
              a[5] = a[5] * y;
              a[6] = a[6] * y;
              a[7] = a[7] * y;
              a[8] = a[8] * z;
              a[9] = a[9] * z;
              a[10] = a[10] * z;
              a[11] = a[11] * z;
              return this;
            },
            makeRotationAxis: function(axis, angle) {
              var c = Math.cos(angle);
              var s = Math.sin(angle);
              var t = 1 - c;
              var x = axis.x;
              var y = axis.y;
              var z = axis.z;
              var tx = t * x;
              var ty = t * y;
              return this.setValues(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
            },
            rotate: function(rad, axis) {
              var a = this.val;
              var x = axis.x;
              var y = axis.y;
              var z = axis.z;
              var len = Math.sqrt(x * x + y * y + z * z);
              if (Math.abs(len) < EPSILON) {
                return this;
              }
              len = 1 / len;
              x *= len;
              y *= len;
              z *= len;
              var s = Math.sin(rad);
              var c = Math.cos(rad);
              var t = 1 - c;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              var a30 = a[12];
              var a31 = a[13];
              var a32 = a[14];
              var a33 = a[15];
              var b00 = x * x * t + c;
              var b01 = y * x * t + z * s;
              var b02 = z * x * t - y * s;
              var b10 = x * y * t - z * s;
              var b11 = y * y * t + c;
              var b12 = z * y * t + x * s;
              var b20 = x * z * t + y * s;
              var b21 = y * z * t - x * s;
              var b22 = z * z * t + c;
              return this.setValues(a00 * b00 + a10 * b01 + a20 * b02, a01 * b00 + a11 * b01 + a21 * b02, a02 * b00 + a12 * b01 + a22 * b02, a03 * b00 + a13 * b01 + a23 * b02, a00 * b10 + a10 * b11 + a20 * b12, a01 * b10 + a11 * b11 + a21 * b12, a02 * b10 + a12 * b11 + a22 * b12, a03 * b10 + a13 * b11 + a23 * b12, a00 * b20 + a10 * b21 + a20 * b22, a01 * b20 + a11 * b21 + a21 * b22, a02 * b20 + a12 * b21 + a22 * b22, a03 * b20 + a13 * b21 + a23 * b22, a30, a31, a32, a33);
            },
            rotateX: function(rad) {
              var a = this.val;
              var s = Math.sin(rad);
              var c = Math.cos(rad);
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              a[4] = a10 * c + a20 * s;
              a[5] = a11 * c + a21 * s;
              a[6] = a12 * c + a22 * s;
              a[7] = a13 * c + a23 * s;
              a[8] = a20 * c - a10 * s;
              a[9] = a21 * c - a11 * s;
              a[10] = a22 * c - a12 * s;
              a[11] = a23 * c - a13 * s;
              return this;
            },
            rotateY: function(rad) {
              var a = this.val;
              var s = Math.sin(rad);
              var c = Math.cos(rad);
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              a[0] = a00 * c - a20 * s;
              a[1] = a01 * c - a21 * s;
              a[2] = a02 * c - a22 * s;
              a[3] = a03 * c - a23 * s;
              a[8] = a00 * s + a20 * c;
              a[9] = a01 * s + a21 * c;
              a[10] = a02 * s + a22 * c;
              a[11] = a03 * s + a23 * c;
              return this;
            },
            rotateZ: function(rad) {
              var a = this.val;
              var s = Math.sin(rad);
              var c = Math.cos(rad);
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              a[0] = a00 * c + a10 * s;
              a[1] = a01 * c + a11 * s;
              a[2] = a02 * c + a12 * s;
              a[3] = a03 * c + a13 * s;
              a[4] = a10 * c - a00 * s;
              a[5] = a11 * c - a01 * s;
              a[6] = a12 * c - a02 * s;
              a[7] = a13 * c - a03 * s;
              return this;
            },
            fromRotationTranslation: function(q, v) {
              var x = q.x;
              var y = q.y;
              var z = q.z;
              var w = q.w;
              var x2 = x + x;
              var y2 = y + y;
              var z2 = z + z;
              var xx = x * x2;
              var xy = x * y2;
              var xz = x * z2;
              var yy = y * y2;
              var yz = y * z2;
              var zz = z * z2;
              var wx = w * x2;
              var wy = w * y2;
              var wz = w * z2;
              return this.setValues(1 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1 - (xx + yy), 0, v.x, v.y, v.z, 1);
            },
            fromQuat: function(q) {
              var x = q.x;
              var y = q.y;
              var z = q.z;
              var w = q.w;
              var x2 = x + x;
              var y2 = y + y;
              var z2 = z + z;
              var xx = x * x2;
              var xy = x * y2;
              var xz = x * z2;
              var yy = y * y2;
              var yz = y * z2;
              var zz = z * z2;
              var wx = w * x2;
              var wy = w * y2;
              var wz = w * z2;
              return this.setValues(1 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1 - (xx + yy), 0, 0, 0, 0, 1);
            },
            frustum: function(left, right, bottom, top, near, far) {
              var rl = 1 / (right - left);
              var tb = 1 / (top - bottom);
              var nf = 1 / (near - far);
              return this.setValues(near * 2 * rl, 0, 0, 0, 0, near * 2 * tb, 0, 0, (right + left) * rl, (top + bottom) * tb, (far + near) * nf, -1, 0, 0, far * near * 2 * nf, 0);
            },
            perspective: function(fovy, aspect, near, far) {
              var f = 1 / Math.tan(fovy / 2);
              var nf = 1 / (near - far);
              return this.setValues(f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (far + near) * nf, -1, 0, 0, 2 * far * near * nf, 0);
            },
            perspectiveLH: function(width, height, near, far) {
              return this.setValues(2 * near / width, 0, 0, 0, 0, 2 * near / height, 0, 0, 0, 0, -far / (near - far), 1, 0, 0, near * far / (near - far), 0);
            },
            ortho: function(left, right, bottom, top, near, far) {
              var lr = left - right;
              var bt = bottom - top;
              var nf = near - far;
              lr = lr === 0 ? lr : 1 / lr;
              bt = bt === 0 ? bt : 1 / bt;
              nf = nf === 0 ? nf : 1 / nf;
              return this.setValues(-2 * lr, 0, 0, 0, 0, -2 * bt, 0, 0, 0, 0, 2 * nf, 0, (left + right) * lr, (top + bottom) * bt, (far + near) * nf, 1);
            },
            lookAtRH: function(eye, target, up) {
              var m = this.val;
              _z.subVectors(eye, target);
              if (_z.getLengthSquared() === 0) {
                _z.z = 1;
              }
              _z.normalize();
              _x.crossVectors(up, _z);
              if (_x.getLengthSquared() === 0) {
                if (Math.abs(up.z) === 1) {
                  _z.x += 1e-4;
                } else {
                  _z.z += 1e-4;
                }
                _z.normalize();
                _x.crossVectors(up, _z);
              }
              _x.normalize();
              _y.crossVectors(_z, _x);
              m[0] = _x.x;
              m[1] = _x.y;
              m[2] = _x.z;
              m[4] = _y.x;
              m[5] = _y.y;
              m[6] = _y.z;
              m[8] = _z.x;
              m[9] = _z.y;
              m[10] = _z.z;
              return this;
            },
            lookAt: function(eye, center, up) {
              var eyex = eye.x;
              var eyey = eye.y;
              var eyez = eye.z;
              var upx = up.x;
              var upy = up.y;
              var upz = up.z;
              var centerx = center.x;
              var centery = center.y;
              var centerz = center.z;
              if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
                return this.identity();
              }
              var z0 = eyex - centerx;
              var z1 = eyey - centery;
              var z2 = eyez - centerz;
              var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
              z0 *= len;
              z1 *= len;
              z2 *= len;
              var x0 = upy * z2 - upz * z1;
              var x1 = upz * z0 - upx * z2;
              var x2 = upx * z1 - upy * z0;
              len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
              if (!len) {
                x0 = 0;
                x1 = 0;
                x2 = 0;
              } else {
                len = 1 / len;
                x0 *= len;
                x1 *= len;
                x2 *= len;
              }
              var y0 = z1 * x2 - z2 * x1;
              var y1 = z2 * x0 - z0 * x2;
              var y2 = z0 * x1 - z1 * x0;
              len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
              if (!len) {
                y0 = 0;
                y1 = 0;
                y2 = 0;
              } else {
                len = 1 / len;
                y0 *= len;
                y1 *= len;
                y2 *= len;
              }
              return this.setValues(x0, y0, z0, 0, x1, y1, z1, 0, x2, y2, z2, 0, -(x0 * eyex + x1 * eyey + x2 * eyez), -(y0 * eyex + y1 * eyey + y2 * eyez), -(z0 * eyex + z1 * eyey + z2 * eyez), 1);
            },
            yawPitchRoll: function(yaw, pitch, roll) {
              this.zero();
              _tempMat1.zero();
              _tempMat2.zero();
              var m0 = this.val;
              var m1 = _tempMat1.val;
              var m2 = _tempMat2.val;
              var s = Math.sin(roll);
              var c = Math.cos(roll);
              m0[10] = 1;
              m0[15] = 1;
              m0[0] = c;
              m0[1] = s;
              m0[4] = -s;
              m0[5] = c;
              s = Math.sin(pitch);
              c = Math.cos(pitch);
              m1[0] = 1;
              m1[15] = 1;
              m1[5] = c;
              m1[10] = c;
              m1[9] = -s;
              m1[6] = s;
              s = Math.sin(yaw);
              c = Math.cos(yaw);
              m2[5] = 1;
              m2[15] = 1;
              m2[0] = c;
              m2[2] = -s;
              m2[8] = s;
              m2[10] = c;
              this.multiplyLocal(_tempMat1);
              this.multiplyLocal(_tempMat2);
              return this;
            },
            setWorldMatrix: function(rotation, position, scale, viewMatrix, projectionMatrix) {
              this.yawPitchRoll(rotation.y, rotation.x, rotation.z);
              _tempMat1.scaling(scale.x, scale.y, scale.z);
              _tempMat2.xyz(position.x, position.y, position.z);
              this.multiplyLocal(_tempMat1);
              this.multiplyLocal(_tempMat2);
              if (viewMatrix) {
                this.multiplyLocal(viewMatrix);
              }
              if (projectionMatrix) {
                this.multiplyLocal(projectionMatrix);
              }
              return this;
            },
            multiplyToMat4: function(src, out) {
              var a = this.val;
              var b = src.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              var a30 = a[12];
              var a31 = a[13];
              var a32 = a[14];
              var a33 = a[15];
              var b00 = b[0];
              var b01 = b[1];
              var b02 = b[2];
              var b03 = b[3];
              var b10 = b[4];
              var b11 = b[5];
              var b12 = b[6];
              var b13 = b[7];
              var b20 = b[8];
              var b21 = b[9];
              var b22 = b[10];
              var b23 = b[11];
              var b30 = b[12];
              var b31 = b[13];
              var b32 = b[14];
              var b33 = b[15];
              return out.setValues(b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30, b01 * a01 + b01 * a11 + b02 * a21 + b03 * a31, b02 * a02 + b01 * a12 + b02 * a22 + b03 * a32, b03 * a03 + b01 * a13 + b02 * a23 + b03 * a33, b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30, b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31, b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32, b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33, b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30, b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31, b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32, b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33, b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30, b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31, b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32, b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33);
            },
            fromRotationXYTranslation: function(rotation, position, translateFirst) {
              var x = position.x;
              var y = position.y;
              var z = position.z;
              var sx = Math.sin(rotation.x);
              var cx = Math.cos(rotation.x);
              var sy = Math.sin(rotation.y);
              var cy = Math.cos(rotation.y);
              var a30 = x;
              var a31 = y;
              var a32 = z;
              var b21 = -sx;
              var c01 = 0 - b21 * sy;
              var c02 = 0 - cx * sy;
              var c21 = b21 * cy;
              var c22 = cx * cy;
              if (!translateFirst) {
                a30 = cy * x + sy * z;
                a31 = c01 * x + cx * y + c21 * z;
                a32 = c02 * x + sx * y + c22 * z;
              }
              return this.setValues(cy, c01, c02, 0, 0, cx, sx, 0, sy, c21, c22, 0, a30, a31, a32, 1);
            },
            getMaxScaleOnAxis: function() {
              var m = this.val;
              var scaleXSq = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];
              var scaleYSq = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];
              var scaleZSq = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];
              return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
            }
          });
          var _tempMat1 = new Matrix4();
          var _tempMat2 = new Matrix4();
          var _x = new Vector3();
          var _y = new Vector3();
          var _z = new Vector3();
          module2.exports = Matrix4;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          function earcut(data, holeIndices, dim) {
            dim = dim || 2;
            var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
            if (!outerNode || outerNode.next === outerNode.prev)
              return triangles;
            var minX, minY, maxX, maxY, x, y, invSize;
            if (hasHoles)
              outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
            if (data.length > 80 * dim) {
              minX = maxX = data[0];
              minY = maxY = data[1];
              for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX)
                  minX = x;
                if (y < minY)
                  minY = y;
                if (x > maxX)
                  maxX = x;
                if (y > maxY)
                  maxY = y;
              }
              invSize = Math.max(maxX - minX, maxY - minY);
              invSize = invSize !== 0 ? 1 / invSize : 0;
            }
            earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
            return triangles;
          }
          function linkedList(data, start, end, dim, clockwise) {
            var i, last;
            if (clockwise === signedArea(data, start, end, dim) > 0) {
              for (i = start; i < end; i += dim)
                last = insertNode(i, data[i], data[i + 1], last);
            } else {
              for (i = end - dim; i >= start; i -= dim)
                last = insertNode(i, data[i], data[i + 1], last);
            }
            if (last && equals(last, last.next)) {
              removeNode(last);
              last = last.next;
            }
            return last;
          }
          function filterPoints(start, end) {
            if (!start)
              return start;
            if (!end)
              end = start;
            var p = start, again;
            do {
              again = false;
              if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next)
                  break;
                again = true;
              } else {
                p = p.next;
              }
            } while (again || p !== end);
            return end;
          }
          function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
            if (!ear)
              return;
            if (!pass && invSize)
              indexCurve(ear, minX, minY, invSize);
            var stop = ear, prev, next;
            while (ear.prev !== ear.next) {
              prev = ear.prev;
              next = ear.next;
              if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
                removeNode(ear);
                ear = next.next;
                stop = next.next;
                continue;
              }
              ear = next;
              if (ear === stop) {
                if (!pass) {
                  earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                } else if (pass === 1) {
                  ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                  earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                } else if (pass === 2) {
                  splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }
                break;
              }
            }
          }
          function isEar(ear) {
            var a = ear.prev, b = ear, c = ear.next;
            if (area(a, b, c) >= 0)
              return false;
            var p = ear.next.next;
            while (p !== ear.prev) {
              if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
                return false;
              p = p.next;
            }
            return true;
          }
          function isEarHashed(ear, minX, minY, invSize) {
            var a = ear.prev, b = ear, c = ear.next;
            if (area(a, b, c) >= 0)
              return false;
            var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
            var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
            var p = ear.prevZ, n = ear.nextZ;
            while (p && p.z >= minZ && n && n.z <= maxZ) {
              if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
                return false;
              p = p.prevZ;
              if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
                return false;
              n = n.nextZ;
            }
            while (p && p.z >= minZ) {
              if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
                return false;
              p = p.prevZ;
            }
            while (n && n.z <= maxZ) {
              if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
                return false;
              n = n.nextZ;
            }
            return true;
          }
          function cureLocalIntersections(start, triangles, dim) {
            var p = start;
            do {
              var a = p.prev, b = p.next.next;
              if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);
                removeNode(p);
                removeNode(p.next);
                p = start = b;
              }
              p = p.next;
            } while (p !== start);
            return filterPoints(p);
          }
          function splitEarcut(start, triangles, dim, minX, minY, invSize) {
            var a = start;
            do {
              var b = a.next.next;
              while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                  var c = splitPolygon(a, b);
                  a = filterPoints(a, a.next);
                  c = filterPoints(c, c.next);
                  earcutLinked(a, triangles, dim, minX, minY, invSize);
                  earcutLinked(c, triangles, dim, minX, minY, invSize);
                  return;
                }
                b = b.next;
              }
              a = a.next;
            } while (a !== start);
          }
          function eliminateHoles(data, holeIndices, outerNode, dim) {
            var queue = [], i, len, start, end, list;
            for (i = 0, len = holeIndices.length; i < len; i++) {
              start = holeIndices[i] * dim;
              end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
              list = linkedList(data, start, end, dim, false);
              if (list === list.next)
                list.steiner = true;
              queue.push(getLeftmost(list));
            }
            queue.sort(compareX);
            for (i = 0; i < queue.length; i++) {
              eliminateHole(queue[i], outerNode);
              outerNode = filterPoints(outerNode, outerNode.next);
            }
            return outerNode;
          }
          function compareX(a, b) {
            return a.x - b.x;
          }
          function eliminateHole(hole, outerNode) {
            outerNode = findHoleBridge(hole, outerNode);
            if (outerNode) {
              var b = splitPolygon(outerNode, hole);
              filterPoints(outerNode, outerNode.next);
              filterPoints(b, b.next);
            }
          }
          function findHoleBridge(hole, outerNode) {
            var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
            do {
              if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                  qx = x;
                  if (x === hx) {
                    if (hy === p.y)
                      return p;
                    if (hy === p.next.y)
                      return p.next;
                  }
                  m = p.x < p.next.x ? p : p.next;
                }
              }
              p = p.next;
            } while (p !== outerNode);
            if (!m)
              return null;
            if (hx === qx)
              return m;
            var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
            p = m;
            do {
              if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x);
                if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                  m = p;
                  tanMin = tan;
                }
              }
              p = p.next;
            } while (p !== stop);
            return m;
          }
          function sectorContainsSector(m, p) {
            return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
          }
          function indexCurve(start, minX, minY, invSize) {
            var p = start;
            do {
              if (p.z === null)
                p.z = zOrder(p.x, p.y, minX, minY, invSize);
              p.prevZ = p.prev;
              p.nextZ = p.next;
              p = p.next;
            } while (p !== start);
            p.prevZ.nextZ = null;
            p.prevZ = null;
            sortLinked(p);
          }
          function sortLinked(list) {
            var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
            do {
              p = list;
              list = null;
              tail = null;
              numMerges = 0;
              while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                  pSize++;
                  q = q.nextZ;
                  if (!q)
                    break;
                }
                qSize = inSize;
                while (pSize > 0 || qSize > 0 && q) {
                  if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                  } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                  }
                  if (tail)
                    tail.nextZ = e;
                  else
                    list = e;
                  e.prevZ = tail;
                  tail = e;
                }
                p = q;
              }
              tail.nextZ = null;
              inSize *= 2;
            } while (numMerges > 1);
            return list;
          }
          function zOrder(x, y, minX, minY, invSize) {
            x = 32767 * (x - minX) * invSize;
            y = 32767 * (y - minY) * invSize;
            x = (x | x << 8) & 16711935;
            x = (x | x << 4) & 252645135;
            x = (x | x << 2) & 858993459;
            x = (x | x << 1) & 1431655765;
            y = (y | y << 8) & 16711935;
            y = (y | y << 4) & 252645135;
            y = (y | y << 2) & 858993459;
            y = (y | y << 1) & 1431655765;
            return x | y << 1;
          }
          function getLeftmost(start) {
            var p = start, leftmost = start;
            do {
              if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
                leftmost = p;
              p = p.next;
            } while (p !== start);
            return leftmost;
          }
          function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
          }
          function isValidDiagonal(a, b) {
            return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
          }
          function area(p, q, r) {
            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
          }
          function equals(p1, p2) {
            return p1.x === p2.x && p1.y === p2.y;
          }
          function intersects(p1, q1, p2, q2) {
            var o1 = sign(area(p1, q1, p2));
            var o2 = sign(area(p1, q1, q2));
            var o3 = sign(area(p2, q2, p1));
            var o4 = sign(area(p2, q2, q1));
            if (o1 !== o2 && o3 !== o4)
              return true;
            if (o1 === 0 && onSegment(p1, p2, q1))
              return true;
            if (o2 === 0 && onSegment(p1, q2, q1))
              return true;
            if (o3 === 0 && onSegment(p2, p1, q2))
              return true;
            if (o4 === 0 && onSegment(p2, q1, q2))
              return true;
            return false;
          }
          function onSegment(p, q, r) {
            return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
          }
          function sign(num) {
            return num > 0 ? 1 : num < 0 ? -1 : 0;
          }
          function intersectsPolygon(a, b) {
            var p = a;
            do {
              if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
                return true;
              p = p.next;
            } while (p !== a);
            return false;
          }
          function locallyInside(a, b) {
            return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
          }
          function middleInside(a, b) {
            var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
            do {
              if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
                inside = !inside;
              p = p.next;
            } while (p !== a);
            return inside;
          }
          function splitPolygon(a, b) {
            var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
            a.next = b;
            b.prev = a;
            a2.next = an;
            an.prev = a2;
            b2.next = a2;
            a2.prev = b2;
            bp.next = b2;
            b2.prev = bp;
            return b2;
          }
          function insertNode(i, x, y, last) {
            var p = new Node(i, x, y);
            if (!last) {
              p.prev = p;
              p.next = p;
            } else {
              p.next = last.next;
              p.prev = last;
              last.next.prev = p;
              last.next = p;
            }
            return p;
          }
          function removeNode(p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            if (p.prevZ)
              p.prevZ.nextZ = p.nextZ;
            if (p.nextZ)
              p.nextZ.prevZ = p.prevZ;
          }
          function Node(i, x, y) {
            this.i = i;
            this.x = x;
            this.y = y;
            this.prev = null;
            this.next = null;
            this.z = null;
            this.prevZ = null;
            this.nextZ = null;
            this.steiner = false;
          }
          earcut.deviation = function(data, holeIndices, dim, triangles) {
            var hasHoles = holeIndices && holeIndices.length;
            var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
            var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
            if (hasHoles) {
              for (var i = 0, len = holeIndices.length; i < len; i++) {
                var start = holeIndices[i] * dim;
                var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                polygonArea -= Math.abs(signedArea(data, start, end, dim));
              }
            }
            var trianglesArea = 0;
            for (i = 0; i < triangles.length; i += 3) {
              var a = triangles[i] * dim;
              var b = triangles[i + 1] * dim;
              var c = triangles[i + 2] * dim;
              trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
            }
            return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
          };
          function signedArea(data, start, end, dim) {
            var sum = 0;
            for (var i = start, j = end - dim; i < end; i += dim) {
              sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
              j = i;
            }
            return sum;
          }
          earcut.flatten = function(data) {
            var dim = data[0][0].length, result = {vertices: [], holes: [], dimensions: dim}, holeIndex = 0;
            for (var i = 0; i < data.length; i++) {
              for (var j = 0; j < data[i].length; j++) {
                for (var d = 0; d < dim; d++)
                  result.vertices.push(data[i][j][d]);
              }
              if (i > 0) {
                holeIndex += data[i - 1].length;
                result.holes.push(holeIndex);
              }
            }
            return result;
          };
          module2.exports = earcut;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            COMPLETE: __webpack_require__(983),
            DECODED: __webpack_require__(984),
            DECODED_ALL: __webpack_require__(985),
            DESTROY: __webpack_require__(986),
            DETUNE: __webpack_require__(987),
            GLOBAL_DETUNE: __webpack_require__(988),
            GLOBAL_MUTE: __webpack_require__(989),
            GLOBAL_RATE: __webpack_require__(990),
            GLOBAL_VOLUME: __webpack_require__(991),
            LOOP: __webpack_require__(992),
            LOOPED: __webpack_require__(993),
            MUTE: __webpack_require__(994),
            PAN: __webpack_require__(995),
            PAUSE_ALL: __webpack_require__(996),
            PAUSE: __webpack_require__(997),
            PLAY: __webpack_require__(998),
            RATE: __webpack_require__(999),
            RESUME_ALL: __webpack_require__(1e3),
            RESUME: __webpack_require__(1001),
            SEEK: __webpack_require__(1002),
            STOP_ALL: __webpack_require__(1003),
            STOP: __webpack_require__(1004),
            UNLOCKED: __webpack_require__(1005),
            VOLUME: __webpack_require__(1006)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var ImageFile = new Class({
            Extends: File,
            initialize: function ImageFile2(loader, key, url, xhrSettings, frameConfig) {
              var extension = "png";
              var normalMapURL;
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                normalMapURL = GetFastValue(config2, "normalMap");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
                frameConfig = GetFastValue(config2, "frameConfig");
              }
              if (Array.isArray(url)) {
                normalMapURL = url[1];
                url = url[0];
              }
              var fileConfig = {
                type: "image",
                cache: loader.textureManager,
                extension,
                responseType: "blob",
                key,
                url,
                xhrSettings,
                config: frameConfig
              };
              File.call(this, loader, fileConfig);
              if (normalMapURL) {
                var normalMap = new ImageFile2(loader, this.key, normalMapURL, xhrSettings, frameConfig);
                normalMap.type = "normalMap";
                this.setLink(normalMap);
                loader.addFile(normalMap);
              }
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              this.data = new Image();
              this.data.crossOrigin = this.crossOrigin;
              var _this = this;
              this.data.onload = function() {
                File.revokeObjectURL(_this.data);
                _this.onProcessComplete();
              };
              this.data.onerror = function() {
                File.revokeObjectURL(_this.data);
                _this.onProcessError();
              };
              File.createObjectURL(this.data, this.xhrLoader.response, "image/png");
            },
            addToCache: function() {
              var texture;
              var linkFile = this.linkFile;
              if (linkFile && linkFile.state === CONST.FILE_COMPLETE) {
                if (this.type === "image") {
                  texture = this.cache.addImage(this.key, this.data, linkFile.data);
                } else {
                  texture = this.cache.addImage(linkFile.key, linkFile.data, this.data);
                }
                this.pendingDestroy(texture);
                linkFile.pendingDestroy(texture);
              } else if (!linkFile) {
                texture = this.cache.addImage(this.key, this.data);
                this.pendingDestroy(texture);
              }
            }
          });
          FileTypesManager.register("image", function(key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new ImageFile(this, key[i]));
              }
            } else {
              this.addFile(new ImageFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = ImageFile;
        },
        function(module2, exports2, __webpack_require__) {
          var Body = {};
          module2.exports = Body;
          var Vertices = __webpack_require__(94);
          var Vector = __webpack_require__(116);
          var Sleeping = __webpack_require__(267);
          var Common = __webpack_require__(50);
          var Bounds = __webpack_require__(117);
          var Axes = __webpack_require__(585);
          (function() {
            Body._inertiaScale = 4;
            Body._nextCollidingGroupId = 1;
            Body._nextNonCollidingGroupId = -1;
            Body._nextCategory = 1;
            Body.create = function(options) {
              var defaults = {
                id: Common.nextId(),
                type: "body",
                label: "Body",
                parts: [],
                plugin: {},
                angle: 0,
                vertices: null,
                position: {x: 0, y: 0},
                force: {x: 0, y: 0},
                torque: 0,
                positionImpulse: {x: 0, y: 0},
                previousPositionImpulse: {x: 0, y: 0},
                constraintImpulse: {x: 0, y: 0, angle: 0},
                totalContacts: 0,
                speed: 0,
                angularSpeed: 0,
                velocity: {x: 0, y: 0},
                angularVelocity: 0,
                isSensor: false,
                isStatic: false,
                isSleeping: false,
                motion: 0,
                sleepThreshold: 60,
                density: 1e-3,
                restitution: 0,
                friction: 0.1,
                frictionStatic: 0.5,
                frictionAir: 0.01,
                collisionFilter: {
                  category: 1,
                  mask: 4294967295,
                  group: 0
                },
                slop: 0.05,
                timeScale: 1,
                events: null,
                bounds: null,
                chamfer: null,
                circleRadius: 0,
                positionPrev: null,
                anglePrev: 0,
                parent: null,
                axes: null,
                area: 0,
                mass: 0,
                inverseMass: 0,
                inertia: 0,
                inverseInertia: 0,
                _original: null,
                render: {
                  visible: true,
                  opacity: 1,
                  sprite: {
                    xOffset: 0,
                    yOffset: 0
                  },
                  fillColor: null,
                  fillOpacity: null,
                  lineColor: null,
                  lineOpacity: null,
                  lineThickness: null
                },
                gameObject: null,
                scale: {x: 1, y: 1},
                centerOfMass: {x: 0, y: 0},
                centerOffset: {x: 0, y: 0},
                gravityScale: {x: 1, y: 1},
                ignoreGravity: false,
                ignorePointer: false,
                onCollideCallback: null,
                onCollideEndCallback: null,
                onCollideActiveCallback: null,
                onCollideWith: {}
              };
              if (!options.hasOwnProperty("position") && options.hasOwnProperty("vertices")) {
                options.position = Vertices.centre(options.vertices);
              } else if (!options.hasOwnProperty("vertices")) {
                defaults.vertices = Vertices.fromPath("L 0 0 L 40 0 L 40 40 L 0 40");
              }
              var body = Common.extend(defaults, options);
              _initProperties(body, options);
              body.setOnCollideWith = function(body2, callback) {
                if (callback) {
                  this.onCollideWith[body2.id] = callback;
                } else {
                  delete this.onCollideWith[body2.id];
                }
                return this;
              };
              return body;
            };
            Body.nextGroup = function(isNonColliding) {
              if (isNonColliding)
                return Body._nextNonCollidingGroupId--;
              return Body._nextCollidingGroupId++;
            };
            Body.nextCategory = function() {
              Body._nextCategory = Body._nextCategory << 1;
              return Body._nextCategory;
            };
            var _initProperties = function(body, options) {
              options = options || {};
              Body.set(body, {
                bounds: body.bounds || Bounds.create(body.vertices),
                positionPrev: body.positionPrev || Vector.clone(body.position),
                anglePrev: body.anglePrev || body.angle,
                vertices: body.vertices,
                parts: body.parts || [body],
                isStatic: body.isStatic,
                isSleeping: body.isSleeping,
                parent: body.parent || body
              });
              var bounds = body.bounds;
              Vertices.rotate(body.vertices, body.angle, body.position);
              Axes.rotate(body.axes, body.angle);
              Bounds.update(bounds, body.vertices, body.velocity);
              Body.set(body, {
                axes: options.axes || body.axes,
                area: options.area || body.area,
                mass: options.mass || body.mass,
                inertia: options.inertia || body.inertia
              });
              if (body.parts.length === 1) {
                var centerOfMass = body.centerOfMass;
                var centerOffset = body.centerOffset;
                var bodyWidth = bounds.max.x - bounds.min.x;
                var bodyHeight = bounds.max.y - bounds.min.y;
                centerOfMass.x = -(bounds.min.x - body.position.x) / bodyWidth;
                centerOfMass.y = -(bounds.min.y - body.position.y) / bodyHeight;
                centerOffset.x = bodyWidth * centerOfMass.x;
                centerOffset.y = bodyHeight * centerOfMass.y;
              }
            };
            Body.set = function(body, settings, value) {
              var property;
              if (typeof settings === "string") {
                property = settings;
                settings = {};
                settings[property] = value;
              }
              for (property in settings) {
                if (!Object.prototype.hasOwnProperty.call(settings, property))
                  continue;
                value = settings[property];
                switch (property) {
                  case "isStatic":
                    Body.setStatic(body, value);
                    break;
                  case "isSleeping":
                    Sleeping.set(body, value);
                    break;
                  case "mass":
                    Body.setMass(body, value);
                    break;
                  case "density":
                    Body.setDensity(body, value);
                    break;
                  case "inertia":
                    Body.setInertia(body, value);
                    break;
                  case "vertices":
                    Body.setVertices(body, value);
                    break;
                  case "position":
                    Body.setPosition(body, value);
                    break;
                  case "angle":
                    Body.setAngle(body, value);
                    break;
                  case "velocity":
                    Body.setVelocity(body, value);
                    break;
                  case "angularVelocity":
                    Body.setAngularVelocity(body, value);
                    break;
                  case "parts":
                    Body.setParts(body, value);
                    break;
                  case "centre":
                    Body.setCentre(body, value);
                    break;
                  default:
                    body[property] = value;
                }
              }
            };
            Body.setStatic = function(body, isStatic) {
              for (var i = 0; i < body.parts.length; i++) {
                var part = body.parts[i];
                part.isStatic = isStatic;
                if (isStatic) {
                  part._original = {
                    restitution: part.restitution,
                    friction: part.friction,
                    mass: part.mass,
                    inertia: part.inertia,
                    density: part.density,
                    inverseMass: part.inverseMass,
                    inverseInertia: part.inverseInertia
                  };
                  part.restitution = 0;
                  part.friction = 1;
                  part.mass = part.inertia = part.density = Infinity;
                  part.inverseMass = part.inverseInertia = 0;
                  part.positionPrev.x = part.position.x;
                  part.positionPrev.y = part.position.y;
                  part.anglePrev = part.angle;
                  part.angularVelocity = 0;
                  part.speed = 0;
                  part.angularSpeed = 0;
                  part.motion = 0;
                } else if (part._original) {
                  part.restitution = part._original.restitution;
                  part.friction = part._original.friction;
                  part.mass = part._original.mass;
                  part.inertia = part._original.inertia;
                  part.density = part._original.density;
                  part.inverseMass = part._original.inverseMass;
                  part.inverseInertia = part._original.inverseInertia;
                  part._original = null;
                }
              }
            };
            Body.setMass = function(body, mass) {
              var moment = body.inertia / (body.mass / 6);
              body.inertia = moment * (mass / 6);
              body.inverseInertia = 1 / body.inertia;
              body.mass = mass;
              body.inverseMass = 1 / body.mass;
              body.density = body.mass / body.area;
            };
            Body.setDensity = function(body, density) {
              Body.setMass(body, density * body.area);
              body.density = density;
            };
            Body.setInertia = function(body, inertia) {
              body.inertia = inertia;
              body.inverseInertia = 1 / body.inertia;
            };
            Body.setVertices = function(body, vertices) {
              if (vertices[0].body === body) {
                body.vertices = vertices;
              } else {
                body.vertices = Vertices.create(vertices, body);
              }
              body.axes = Axes.fromVertices(body.vertices);
              body.area = Vertices.area(body.vertices);
              Body.setMass(body, body.density * body.area);
              var centre = Vertices.centre(body.vertices);
              Vertices.translate(body.vertices, centre, -1);
              Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));
              Vertices.translate(body.vertices, body.position);
              Bounds.update(body.bounds, body.vertices, body.velocity);
            };
            Body.setParts = function(body, parts, autoHull) {
              var i;
              parts = parts.slice(0);
              body.parts.length = 0;
              body.parts.push(body);
              body.parent = body;
              for (i = 0; i < parts.length; i++) {
                var part = parts[i];
                if (part !== body) {
                  part.parent = body;
                  body.parts.push(part);
                }
              }
              if (body.parts.length === 1)
                return;
              autoHull = typeof autoHull !== "undefined" ? autoHull : true;
              if (autoHull) {
                var vertices = [];
                for (i = 0; i < parts.length; i++) {
                  vertices = vertices.concat(parts[i].vertices);
                }
                Vertices.clockwiseSort(vertices);
                var hull = Vertices.hull(vertices), hullCentre = Vertices.centre(hull);
                Body.setVertices(body, hull);
                Vertices.translate(body.vertices, hullCentre);
              }
              var total = Body._totalProperties(body);
              var cx = total.centre.x;
              var cy = total.centre.y;
              var bounds = body.bounds;
              var centerOfMass = body.centerOfMass;
              var centerOffset = body.centerOffset;
              Bounds.update(bounds, body.vertices, body.velocity);
              centerOfMass.x = -(bounds.min.x - cx) / (bounds.max.x - bounds.min.x);
              centerOfMass.y = -(bounds.min.y - cy) / (bounds.max.y - bounds.min.y);
              centerOffset.x = cx;
              centerOffset.y = cy;
              body.area = total.area;
              body.parent = body;
              body.position.x = cx;
              body.position.y = cy;
              body.positionPrev.x = cx;
              body.positionPrev.y = cy;
              Body.setMass(body, total.mass);
              Body.setInertia(body, total.inertia);
              Body.setPosition(body, total.centre);
            };
            Body.setCentre = function(body, centre, relative) {
              if (!relative) {
                body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);
                body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);
                body.position.x = centre.x;
                body.position.y = centre.y;
              } else {
                body.positionPrev.x += centre.x;
                body.positionPrev.y += centre.y;
                body.position.x += centre.x;
                body.position.y += centre.y;
              }
            };
            Body.setPosition = function(body, position) {
              var delta = Vector.sub(position, body.position);
              body.positionPrev.x += delta.x;
              body.positionPrev.y += delta.y;
              for (var i = 0; i < body.parts.length; i++) {
                var part = body.parts[i];
                part.position.x += delta.x;
                part.position.y += delta.y;
                Vertices.translate(part.vertices, delta);
                Bounds.update(part.bounds, part.vertices, body.velocity);
              }
            };
            Body.setAngle = function(body, angle) {
              var delta = angle - body.angle;
              body.anglePrev += delta;
              for (var i = 0; i < body.parts.length; i++) {
                var part = body.parts[i];
                part.angle += delta;
                Vertices.rotate(part.vertices, delta, body.position);
                Axes.rotate(part.axes, delta);
                Bounds.update(part.bounds, part.vertices, body.velocity);
                if (i > 0) {
                  Vector.rotateAbout(part.position, delta, body.position, part.position);
                }
              }
            };
            Body.setVelocity = function(body, velocity) {
              body.positionPrev.x = body.position.x - velocity.x;
              body.positionPrev.y = body.position.y - velocity.y;
              body.velocity.x = velocity.x;
              body.velocity.y = velocity.y;
              body.speed = Vector.magnitude(body.velocity);
            };
            Body.setAngularVelocity = function(body, velocity) {
              body.anglePrev = body.angle - velocity;
              body.angularVelocity = velocity;
              body.angularSpeed = Math.abs(body.angularVelocity);
            };
            Body.translate = function(body, translation) {
              Body.setPosition(body, Vector.add(body.position, translation));
            };
            Body.rotate = function(body, rotation, point) {
              if (!point) {
                Body.setAngle(body, body.angle + rotation);
              } else {
                var cos = Math.cos(rotation), sin = Math.sin(rotation), dx = body.position.x - point.x, dy = body.position.y - point.y;
                Body.setPosition(body, {
                  x: point.x + (dx * cos - dy * sin),
                  y: point.y + (dx * sin + dy * cos)
                });
                Body.setAngle(body, body.angle + rotation);
              }
            };
            Body.scale = function(body, scaleX, scaleY, point) {
              var totalArea = 0, totalInertia = 0;
              point = point || body.position;
              for (var i = 0; i < body.parts.length; i++) {
                var part = body.parts[i];
                part.scale.x = scaleX;
                part.scale.y = scaleY;
                Vertices.scale(part.vertices, scaleX, scaleY, point);
                part.axes = Axes.fromVertices(part.vertices);
                part.area = Vertices.area(part.vertices);
                Body.setMass(part, body.density * part.area);
                Vertices.translate(part.vertices, {x: -part.position.x, y: -part.position.y});
                Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));
                Vertices.translate(part.vertices, {x: part.position.x, y: part.position.y});
                if (i > 0) {
                  totalArea += part.area;
                  totalInertia += part.inertia;
                }
                part.position.x = point.x + (part.position.x - point.x) * scaleX;
                part.position.y = point.y + (part.position.y - point.y) * scaleY;
                Bounds.update(part.bounds, part.vertices, body.velocity);
              }
              if (body.parts.length > 1) {
                body.area = totalArea;
                if (!body.isStatic) {
                  Body.setMass(body, body.density * totalArea);
                  Body.setInertia(body, totalInertia);
                }
              }
              if (body.circleRadius) {
                if (scaleX === scaleY) {
                  body.circleRadius *= scaleX;
                } else {
                  body.circleRadius = null;
                }
              }
            };
            Body.update = function(body, deltaTime, timeScale, correction) {
              var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);
              var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale, velocityPrevX = body.position.x - body.positionPrev.x, velocityPrevY = body.position.y - body.positionPrev.y;
              body.velocity.x = velocityPrevX * frictionAir * correction + body.force.x / body.mass * deltaTimeSquared;
              body.velocity.y = velocityPrevY * frictionAir * correction + body.force.y / body.mass * deltaTimeSquared;
              body.positionPrev.x = body.position.x;
              body.positionPrev.y = body.position.y;
              body.position.x += body.velocity.x;
              body.position.y += body.velocity.y;
              body.angularVelocity = (body.angle - body.anglePrev) * frictionAir * correction + body.torque / body.inertia * deltaTimeSquared;
              body.anglePrev = body.angle;
              body.angle += body.angularVelocity;
              body.speed = Vector.magnitude(body.velocity);
              body.angularSpeed = Math.abs(body.angularVelocity);
              for (var i = 0; i < body.parts.length; i++) {
                var part = body.parts[i];
                Vertices.translate(part.vertices, body.velocity);
                if (i > 0) {
                  part.position.x += body.velocity.x;
                  part.position.y += body.velocity.y;
                }
                if (body.angularVelocity !== 0) {
                  Vertices.rotate(part.vertices, body.angularVelocity, body.position);
                  Axes.rotate(part.axes, body.angularVelocity);
                  if (i > 0) {
                    Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);
                  }
                }
                Bounds.update(part.bounds, part.vertices, body.velocity);
              }
            };
            Body.applyForce = function(body, position, force) {
              body.force.x += force.x;
              body.force.y += force.y;
              var offset = {x: position.x - body.position.x, y: position.y - body.position.y};
              body.torque += offset.x * force.y - offset.y * force.x;
            };
            Body._totalProperties = function(body) {
              var properties = {
                mass: 0,
                area: 0,
                inertia: 0,
                centre: {x: 0, y: 0}
              };
              for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {
                var part = body.parts[i], mass = part.mass !== Infinity ? part.mass : 1;
                properties.mass += mass;
                properties.area += part.area;
                properties.inertia += part.inertia;
                properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));
              }
              properties.centre = Vector.div(properties.centre, properties.mass);
              return properties;
            };
          })();
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetTileCollision = function(tile, collides) {
            if (collides) {
              tile.setCollision(true, true, true, true, false);
            } else {
              tile.resetCollision(false);
            }
          };
          module2.exports = SetTileCollision;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AnimationState = __webpack_require__(162);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var SpriteRender = __webpack_require__(1059);
          var Sprite = new Class({
            Extends: GameObject,
            Mixins: [
              Components.Alpha,
              Components.BlendMode,
              Components.Depth,
              Components.Flip,
              Components.GetBounds,
              Components.Mask,
              Components.Origin,
              Components.Pipeline,
              Components.ScrollFactor,
              Components.Size,
              Components.TextureCrop,
              Components.Tint,
              Components.Transform,
              Components.Visible,
              SpriteRender
            ],
            initialize: function Sprite2(scene, x, y, texture, frame) {
              GameObject.call(this, scene, "Sprite");
              this._crop = this.resetCropObject();
              this.anims = new AnimationState(this);
              this.setTexture(texture, frame);
              this.setPosition(x, y);
              this.setSizeToFrame();
              this.setOriginFromFrame();
              this.initPipeline();
            },
            addedToScene: function() {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function() {
              this.scene.sys.updateList.remove(this);
            },
            preUpdate: function(time, delta) {
              this.anims.update(time, delta);
            },
            play: function(key, ignoreIfPlaying) {
              return this.anims.play(key, ignoreIfPlaying);
            },
            playReverse: function(key, ignoreIfPlaying) {
              return this.anims.playReverse(key, ignoreIfPlaying);
            },
            playAfterDelay: function(key, delay) {
              return this.anims.playAfterDelay(key, delay);
            },
            playAfterRepeat: function(key, repeatCount) {
              return this.anims.playAfterRepeat(key, repeatCount);
            },
            chain: function(key) {
              return this.anims.chain(key);
            },
            stop: function() {
              return this.anims.stop();
            },
            stopAfterDelay: function(delay) {
              return this.anims.stopAfterDelay(delay);
            },
            stopAfterRepeat: function(repeatCount) {
              return this.anims.stopAfterRepeat(repeatCount);
            },
            stopOnFrame: function(frame) {
              return this.anims.stopOnFrame(frame);
            },
            toJSON: function() {
              return Components.ToJSON(this);
            },
            preDestroy: function() {
              this.anims.destroy();
              this.anims = void 0;
            }
          });
          module2.exports = Sprite;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SpliceOne = function(array, index) {
            if (index >= array.length) {
              return;
            }
            var len = array.length - 1;
            var item = array[index];
            for (var i = index; i < len; i++) {
              array[i] = array[i + 1];
            }
            array.length = len;
            return item;
          };
          module2.exports = SpliceOne;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            ADDED_TO_SCENE: __webpack_require__(641),
            DESTROY: __webpack_require__(642),
            REMOVED_FROM_SCENE: __webpack_require__(643),
            VIDEO_COMPLETE: __webpack_require__(644),
            VIDEO_CREATED: __webpack_require__(645),
            VIDEO_ERROR: __webpack_require__(646),
            VIDEO_LOOP: __webpack_require__(647),
            VIDEO_PLAY: __webpack_require__(648),
            VIDEO_SEEKED: __webpack_require__(649),
            VIDEO_SEEKING: __webpack_require__(650),
            VIDEO_STOP: __webpack_require__(651),
            VIDEO_TIMEOUT: __webpack_require__(652),
            VIDEO_UNLOCKED: __webpack_require__(653)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SnapFloor = function(value, gap, start, divide) {
            if (start === void 0) {
              start = 0;
            }
            if (gap === 0) {
              return value;
            }
            value -= start;
            value = gap * Math.floor(value / gap);
            return divide ? (start + value) / gap : start + value;
          };
          module2.exports = SnapFloor;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clone = function(obj) {
            var clone = {};
            for (var key in obj) {
              if (Array.isArray(obj[key])) {
                clone[key] = obj[key].slice(0);
              } else {
                clone[key] = obj[key];
              }
            }
            return clone;
          };
          module2.exports = Clone;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SafeRange = function(array, startIndex, endIndex, throwError) {
            var len = array.length;
            if (startIndex < 0 || startIndex > len || startIndex >= endIndex || endIndex > len || startIndex + endIndex > len) {
              if (throwError) {
                throw new Error("Range Error: Values outside acceptable range");
              }
              return false;
            } else {
              return true;
            }
          };
          module2.exports = SafeRange;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Angry Bytes (and contributors)
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          function Compare(a, b) {
            return String(a).localeCompare(b);
          }
          function Process(array, compare) {
            var len = array.length;
            if (len <= 1) {
              return array;
            }
            var buffer = new Array(len);
            for (var chk = 1; chk < len; chk *= 2) {
              RunPass(array, compare, chk, buffer);
              var tmp = array;
              array = buffer;
              buffer = tmp;
            }
            return array;
          }
          function RunPass(arr, comp, chk, result) {
            var len = arr.length;
            var i = 0;
            var dbl = chk * 2;
            var l, r, e;
            var li, ri;
            for (l = 0; l < len; l += dbl) {
              r = l + chk;
              e = r + chk;
              if (r > len) {
                r = len;
              }
              if (e > len) {
                e = len;
              }
              li = l;
              ri = r;
              while (true) {
                if (li < r && ri < e) {
                  if (comp(arr[li], arr[ri]) <= 0) {
                    result[i++] = arr[li++];
                  } else {
                    result[i++] = arr[ri++];
                  }
                } else if (li < r) {
                  result[i++] = arr[li++];
                } else if (ri < e) {
                  result[i++] = arr[ri++];
                } else {
                  break;
                }
              }
            }
          }
          var StableSort = function(array, compare) {
            if (compare === void 0) {
              compare = Compare;
            }
            var result = Process(array, compare);
            if (result !== array) {
              RunPass(result, null, array.length, array);
            }
            return array;
          };
          module2.exports = StableSort;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var EaseMap = __webpack_require__(132);
          var UppercaseFirst = __webpack_require__(202);
          var GetEaseFunction = function(ease, easeParams) {
            var easeFunction = EaseMap.Power0;
            if (typeof ease === "string") {
              if (EaseMap.hasOwnProperty(ease)) {
                easeFunction = EaseMap[ease];
              } else {
                var direction = "";
                if (ease.indexOf(".")) {
                  direction = ease.substr(ease.indexOf(".") + 1);
                  if (direction.toLowerCase() === "in") {
                    direction = "easeIn";
                  } else if (direction.toLowerCase() === "out") {
                    direction = "easeOut";
                  } else if (direction.toLowerCase() === "inout") {
                    direction = "easeInOut";
                  }
                }
                ease = UppercaseFirst(ease.substr(0, ease.indexOf(".") + 1) + direction);
                if (EaseMap.hasOwnProperty(ease)) {
                  easeFunction = EaseMap[ease];
                }
              }
            } else if (typeof ease === "function") {
              easeFunction = ease;
            } else if (Array.isArray(ease) && ease.length === 4) {
            }
            if (!easeParams) {
              return easeFunction;
            }
            var cloneParams = easeParams.slice(0);
            cloneParams.unshift(0);
            return function(v) {
              cloneParams[0] = v;
              return easeFunction.apply(this, cloneParams);
            };
          };
          module2.exports = GetEaseFunction;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Utils = __webpack_require__(12);
          var StrokePathWebGL = function(pipeline, src, alpha, dx, dy) {
            var strokeTint = pipeline.strokeTint;
            var strokeTintColor = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
            strokeTint.TL = strokeTintColor;
            strokeTint.TR = strokeTintColor;
            strokeTint.BL = strokeTintColor;
            strokeTint.BR = strokeTintColor;
            var path = src.pathData;
            var pathLength = path.length - 1;
            var lineWidth = src.lineWidth;
            var halfLineWidth = lineWidth / 2;
            var px1 = path[0] - dx;
            var py1 = path[1] - dy;
            if (!src.closePath) {
              pathLength -= 2;
            }
            for (var i = 2; i < pathLength; i += 2) {
              var px2 = path[i] - dx;
              var py2 = path[i + 1] - dy;
              pipeline.batchLine(px1, py1, px2, py2, halfLineWidth, halfLineWidth, lineWidth, i - 2, src.closePath ? i === pathLength - 1 : false);
              px1 = px2;
              py1 = py2;
            }
          };
          module2.exports = StrokePathWebGL;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Contains = __webpack_require__(112);
          var GetPoint = __webpack_require__(470);
          var GetPoints = __webpack_require__(471);
          var GEOM_CONST = __webpack_require__(55);
          var Line = __webpack_require__(45);
          var Random = __webpack_require__(178);
          var Triangle = new Class({
            initialize: function Triangle2(x1, y1, x2, y2, x3, y3) {
              if (x1 === void 0) {
                x1 = 0;
              }
              if (y1 === void 0) {
                y1 = 0;
              }
              if (x2 === void 0) {
                x2 = 0;
              }
              if (y2 === void 0) {
                y2 = 0;
              }
              if (x3 === void 0) {
                x3 = 0;
              }
              if (y3 === void 0) {
                y3 = 0;
              }
              this.type = GEOM_CONST.TRIANGLE;
              this.x1 = x1;
              this.y1 = y1;
              this.x2 = x2;
              this.y2 = y2;
              this.x3 = x3;
              this.y3 = y3;
            },
            contains: function(x, y) {
              return Contains(this, x, y);
            },
            getPoint: function(position, output) {
              return GetPoint(this, position, output);
            },
            getPoints: function(quantity, stepRate, output) {
              return GetPoints(this, quantity, stepRate, output);
            },
            getRandomPoint: function(point) {
              return Random(this, point);
            },
            setTo: function(x1, y1, x2, y2, x3, y3) {
              if (x1 === void 0) {
                x1 = 0;
              }
              if (y1 === void 0) {
                y1 = 0;
              }
              if (x2 === void 0) {
                x2 = 0;
              }
              if (y2 === void 0) {
                y2 = 0;
              }
              if (x3 === void 0) {
                x3 = 0;
              }
              if (y3 === void 0) {
                y3 = 0;
              }
              this.x1 = x1;
              this.y1 = y1;
              this.x2 = x2;
              this.y2 = y2;
              this.x3 = x3;
              this.y3 = y3;
              return this;
            },
            getLineA: function(line) {
              if (line === void 0) {
                line = new Line();
              }
              line.setTo(this.x1, this.y1, this.x2, this.y2);
              return line;
            },
            getLineB: function(line) {
              if (line === void 0) {
                line = new Line();
              }
              line.setTo(this.x2, this.y2, this.x3, this.y3);
              return line;
            },
            getLineC: function(line) {
              if (line === void 0) {
                line = new Line();
              }
              line.setTo(this.x3, this.y3, this.x1, this.y1);
              return line;
            },
            left: {
              get: function() {
                return Math.min(this.x1, this.x2, this.x3);
              },
              set: function(value) {
                var diff = 0;
                if (this.x1 <= this.x2 && this.x1 <= this.x3) {
                  diff = this.x1 - value;
                } else if (this.x2 <= this.x1 && this.x2 <= this.x3) {
                  diff = this.x2 - value;
                } else {
                  diff = this.x3 - value;
                }
                this.x1 -= diff;
                this.x2 -= diff;
                this.x3 -= diff;
              }
            },
            right: {
              get: function() {
                return Math.max(this.x1, this.x2, this.x3);
              },
              set: function(value) {
                var diff = 0;
                if (this.x1 >= this.x2 && this.x1 >= this.x3) {
                  diff = this.x1 - value;
                } else if (this.x2 >= this.x1 && this.x2 >= this.x3) {
                  diff = this.x2 - value;
                } else {
                  diff = this.x3 - value;
                }
                this.x1 -= diff;
                this.x2 -= diff;
                this.x3 -= diff;
              }
            },
            top: {
              get: function() {
                return Math.min(this.y1, this.y2, this.y3);
              },
              set: function(value) {
                var diff = 0;
                if (this.y1 <= this.y2 && this.y1 <= this.y3) {
                  diff = this.y1 - value;
                } else if (this.y2 <= this.y1 && this.y2 <= this.y3) {
                  diff = this.y2 - value;
                } else {
                  diff = this.y3 - value;
                }
                this.y1 -= diff;
                this.y2 -= diff;
                this.y3 -= diff;
              }
            },
            bottom: {
              get: function() {
                return Math.max(this.y1, this.y2, this.y3);
              },
              set: function(value) {
                var diff = 0;
                if (this.y1 >= this.y2 && this.y1 >= this.y3) {
                  diff = this.y1 - value;
                } else if (this.y2 >= this.y1 && this.y2 >= this.y3) {
                  diff = this.y2 - value;
                } else {
                  diff = this.y3 - value;
                }
                this.y1 -= diff;
                this.y2 -= diff;
                this.y3 -= diff;
              }
            }
          });
          module2.exports = Triangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(29);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var Rectangle = __webpack_require__(496);
          var Tile = new Class({
            Mixins: [
              Components.Alpha,
              Components.Flip,
              Components.Visible
            ],
            initialize: function Tile2(layer, index, x, y, width, height, baseWidth, baseHeight) {
              this.layer = layer;
              this.index = index;
              this.x = x;
              this.y = y;
              this.width = width;
              this.height = height;
              this.right;
              this.bottom;
              this.baseWidth = baseWidth !== void 0 ? baseWidth : width;
              this.baseHeight = baseHeight !== void 0 ? baseHeight : height;
              this.pixelX = 0;
              this.pixelY = 0;
              this.updatePixelXY();
              this.properties = {};
              this.rotation = 0;
              this.collideLeft = false;
              this.collideRight = false;
              this.collideUp = false;
              this.collideDown = false;
              this.faceLeft = false;
              this.faceRight = false;
              this.faceTop = false;
              this.faceBottom = false;
              this.collisionCallback = void 0;
              this.collisionCallbackContext = this;
              this.tint = 16777215;
              this.physics = {};
            },
            containsPoint: function(x, y) {
              return !(x < this.pixelX || y < this.pixelY || x > this.right || y > this.bottom);
            },
            copy: function(tile) {
              this.index = tile.index;
              this.alpha = tile.alpha;
              this.properties = tile.properties;
              this.visible = tile.visible;
              this.setFlip(tile.flipX, tile.flipY);
              this.tint = tile.tint;
              this.rotation = tile.rotation;
              this.collideUp = tile.collideUp;
              this.collideDown = tile.collideDown;
              this.collideLeft = tile.collideLeft;
              this.collideRight = tile.collideRight;
              this.collisionCallback = tile.collisionCallback;
              this.collisionCallbackContext = tile.collisionCallbackContext;
              return this;
            },
            getCollisionGroup: function() {
              return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null;
            },
            getTileData: function() {
              return this.tileset ? this.tileset.getTileData(this.index) : null;
            },
            getLeft: function(camera) {
              var tilemapLayer = this.tilemapLayer;
              return tilemapLayer ? tilemapLayer.tileToWorldX(this.x, camera) : this.x * this.baseWidth;
            },
            getRight: function(camera) {
              var tilemapLayer = this.tilemapLayer;
              return tilemapLayer ? this.getLeft(camera) + this.width * tilemapLayer.scaleX : this.getLeft(camera) + this.width;
            },
            getTop: function(camera) {
              var tilemapLayer = this.tilemapLayer;
              return tilemapLayer ? tilemapLayer.tileToWorldY(this.y, camera) - (this.height - this.baseHeight) * tilemapLayer.scaleY : this.y * this.baseHeight - (this.height - this.baseHeight);
            },
            getBottom: function(camera) {
              var tilemapLayer = this.tilemapLayer;
              return tilemapLayer ? this.getTop(camera) + this.height * tilemapLayer.scaleY : this.getTop(camera) + this.height;
            },
            getBounds: function(camera, output) {
              if (output === void 0) {
                output = new Rectangle();
              }
              output.x = this.getLeft();
              output.y = this.getTop();
              output.width = this.getRight() - output.x;
              output.height = this.getBottom() - output.y;
              return output;
            },
            getCenterX: function(camera) {
              return (this.getLeft(camera) + this.getRight(camera)) / 2;
            },
            getCenterY: function(camera) {
              return (this.getTop(camera) + this.getBottom(camera)) / 2;
            },
            intersects: function(x, y, right, bottom) {
              return !(right <= this.pixelX || bottom <= this.pixelY || x >= this.right || y >= this.bottom);
            },
            isInteresting: function(collides, faces) {
              if (collides && faces) {
                return this.canCollide || this.hasInterestingFace;
              } else if (collides) {
                return this.collides;
              } else if (faces) {
                return this.hasInterestingFace;
              }
              return false;
            },
            resetCollision: function(recalculateFaces) {
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              this.collideLeft = false;
              this.collideRight = false;
              this.collideUp = false;
              this.collideDown = false;
              this.faceTop = false;
              this.faceBottom = false;
              this.faceLeft = false;
              this.faceRight = false;
              if (recalculateFaces) {
                var tilemapLayer = this.tilemapLayer;
                if (tilemapLayer) {
                  this.tilemapLayer.calculateFacesAt(this.x, this.y);
                }
              }
              return this;
            },
            resetFaces: function() {
              this.faceTop = false;
              this.faceBottom = false;
              this.faceLeft = false;
              this.faceRight = false;
              return this;
            },
            setCollision: function(left, right, up, down, recalculateFaces) {
              if (right === void 0) {
                right = left;
              }
              if (up === void 0) {
                up = left;
              }
              if (down === void 0) {
                down = left;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              this.collideLeft = left;
              this.collideRight = right;
              this.collideUp = up;
              this.collideDown = down;
              this.faceLeft = left;
              this.faceRight = right;
              this.faceTop = up;
              this.faceBottom = down;
              if (recalculateFaces) {
                var tilemapLayer = this.tilemapLayer;
                if (tilemapLayer) {
                  this.tilemapLayer.calculateFacesAt(this.x, this.y);
                }
              }
              return this;
            },
            setCollisionCallback: function(callback, context) {
              if (callback === null) {
                this.collisionCallback = void 0;
                this.collisionCallbackContext = void 0;
              } else {
                this.collisionCallback = callback;
                this.collisionCallbackContext = context;
              }
              return this;
            },
            setSize: function(tileWidth, tileHeight, baseWidth, baseHeight) {
              if (tileWidth !== void 0) {
                this.width = tileWidth;
              }
              if (tileHeight !== void 0) {
                this.height = tileHeight;
              }
              if (baseWidth !== void 0) {
                this.baseWidth = baseWidth;
              }
              if (baseHeight !== void 0) {
                this.baseHeight = baseHeight;
              }
              this.updatePixelXY();
              return this;
            },
            updatePixelXY: function() {
              var orientation = this.layer.orientation;
              if (orientation === CONST.ORTHOGONAL) {
                this.pixelX = this.x * this.baseWidth;
                this.pixelY = this.y * this.baseHeight;
              } else if (orientation === CONST.ISOMETRIC) {
                this.pixelX = (this.x - this.y) * this.baseWidth * 0.5;
                this.pixelY = (this.x + this.y) * this.baseHeight * 0.5;
              } else if (orientation === CONST.STAGGERED) {
                this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);
                this.pixelY = this.y * (this.baseHeight / 2);
              } else if (orientation === CONST.HEXAGONAL) {
                var len = this.layer.hexSideLength;
                var rowHeight = (this.baseHeight - len) / 2 + len;
                this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);
                this.pixelY = this.y * rowHeight;
              }
              this.right = this.pixelX + this.baseWidth;
              this.bottom = this.pixelY + this.baseHeight;
              return this;
            },
            destroy: function() {
              this.collisionCallback = void 0;
              this.collisionCallbackContext = void 0;
              this.properties = void 0;
            },
            canCollide: {
              get: function() {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback !== void 0;
              }
            },
            collides: {
              get: function() {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
              }
            },
            hasInterestingFace: {
              get: function() {
                return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight;
              }
            },
            tileset: {
              get: function() {
                var tilemapLayer = this.layer.tilemapLayer;
                if (tilemapLayer) {
                  var tileset = tilemapLayer.gidMap[this.index];
                  if (tileset) {
                    return tileset;
                  }
                }
                return null;
              }
            },
            tilemapLayer: {
              get: function() {
                return this.layer.tilemapLayer;
              }
            },
            tilemap: {
              get: function() {
                var tilemapLayer = this.tilemapLayer;
                return tilemapLayer ? tilemapLayer.tilemap : null;
              }
            }
          });
          module2.exports = Tile;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCenterX = function(gameObject) {
            return gameObject.x - gameObject.width * gameObject.originX + gameObject.width * 0.5;
          };
          module2.exports = GetCenterX;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetCenterX = function(gameObject, x) {
            var offsetX = gameObject.width * gameObject.originX;
            gameObject.x = x + offsetX - gameObject.width * 0.5;
            return gameObject;
          };
          module2.exports = SetCenterX;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCenterY = function(gameObject) {
            return gameObject.y - gameObject.height * gameObject.originY + gameObject.height * 0.5;
          };
          module2.exports = GetCenterY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetCenterY = function(gameObject, y) {
            var offsetY = gameObject.height * gameObject.originY;
            gameObject.y = y + offsetY - gameObject.height * 0.5;
            return gameObject;
          };
          module2.exports = SetCenterY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            POST_RENDER: __webpack_require__(626),
            PRE_RENDER: __webpack_require__(627),
            RENDER: __webpack_require__(628),
            RESIZE: __webpack_require__(629)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SpliceOne = __webpack_require__(74);
          var Remove = function(array, item, callback, context) {
            if (context === void 0) {
              context = array;
            }
            var index;
            if (!Array.isArray(item)) {
              index = array.indexOf(item);
              if (index !== -1) {
                SpliceOne(array, index);
                if (callback) {
                  callback.call(context, item);
                }
                return item;
              } else {
                return null;
              }
            }
            var itemLength = item.length - 1;
            var removed = [];
            while (itemLength >= 0) {
              var entry = item[itemLength];
              index = array.indexOf(entry);
              if (index !== -1) {
                SpliceOne(array, index);
                removed.push(entry);
                if (callback) {
                  callback.call(context, entry);
                }
              }
              itemLength--;
            }
            return removed;
          };
          module2.exports = Remove;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FromPoints = __webpack_require__(196);
          var Rectangle = __webpack_require__(10);
          var Vector29 = __webpack_require__(3);
          var Curve = new Class({
            initialize: function Curve2(type) {
              this.type = type;
              this.defaultDivisions = 5;
              this.arcLengthDivisions = 100;
              this.cacheArcLengths = [];
              this.needsUpdate = true;
              this.active = true;
              this._tmpVec2A = new Vector29();
              this._tmpVec2B = new Vector29();
            },
            draw: function(graphics, pointsTotal) {
              if (pointsTotal === void 0) {
                pointsTotal = 32;
              }
              return graphics.strokePoints(this.getPoints(pointsTotal));
            },
            getBounds: function(out, accuracy) {
              if (!out) {
                out = new Rectangle();
              }
              if (accuracy === void 0) {
                accuracy = 16;
              }
              var len = this.getLength();
              if (accuracy > len) {
                accuracy = len / 2;
              }
              var spaced = Math.max(1, Math.round(len / accuracy));
              return FromPoints(this.getSpacedPoints(spaced), out);
            },
            getDistancePoints: function(distance) {
              var len = this.getLength();
              var spaced = Math.max(1, len / distance);
              return this.getSpacedPoints(spaced);
            },
            getEndPoint: function(out) {
              if (out === void 0) {
                out = new Vector29();
              }
              return this.getPointAt(1, out);
            },
            getLength: function() {
              var lengths = this.getLengths();
              return lengths[lengths.length - 1];
            },
            getLengths: function(divisions) {
              if (divisions === void 0) {
                divisions = this.arcLengthDivisions;
              }
              if (this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
                return this.cacheArcLengths;
              }
              this.needsUpdate = false;
              var cache = [];
              var current;
              var last = this.getPoint(0, this._tmpVec2A);
              var sum = 0;
              cache.push(0);
              for (var p = 1; p <= divisions; p++) {
                current = this.getPoint(p / divisions, this._tmpVec2B);
                sum += current.distance(last);
                cache.push(sum);
                last.copy(current);
              }
              this.cacheArcLengths = cache;
              return cache;
            },
            getPointAt: function(u, out) {
              var t = this.getUtoTmapping(u);
              return this.getPoint(t, out);
            },
            getPoints: function(divisions, stepRate, out) {
              if (out === void 0) {
                out = [];
              }
              if (!divisions) {
                if (!stepRate) {
                  divisions = this.defaultDivisions;
                } else {
                  divisions = this.getLength() / stepRate;
                }
              }
              for (var d = 0; d <= divisions; d++) {
                out.push(this.getPoint(d / divisions));
              }
              return out;
            },
            getRandomPoint: function(out) {
              if (out === void 0) {
                out = new Vector29();
              }
              return this.getPoint(Math.random(), out);
            },
            getSpacedPoints: function(divisions, stepRate, out) {
              if (out === void 0) {
                out = [];
              }
              if (!divisions) {
                if (!stepRate) {
                  divisions = this.defaultDivisions;
                } else {
                  divisions = this.getLength() / stepRate;
                }
              }
              for (var d = 0; d <= divisions; d++) {
                var t = this.getUtoTmapping(d / divisions, null, divisions);
                out.push(this.getPoint(t));
              }
              return out;
            },
            getStartPoint: function(out) {
              if (out === void 0) {
                out = new Vector29();
              }
              return this.getPointAt(0, out);
            },
            getTangent: function(t, out) {
              if (out === void 0) {
                out = new Vector29();
              }
              var delta = 1e-4;
              var t1 = t - delta;
              var t2 = t + delta;
              if (t1 < 0) {
                t1 = 0;
              }
              if (t2 > 1) {
                t2 = 1;
              }
              this.getPoint(t1, this._tmpVec2A);
              this.getPoint(t2, out);
              return out.subtract(this._tmpVec2A).normalize();
            },
            getTangentAt: function(u, out) {
              var t = this.getUtoTmapping(u);
              return this.getTangent(t, out);
            },
            getTFromDistance: function(distance, divisions) {
              if (distance <= 0) {
                return 0;
              }
              return this.getUtoTmapping(0, distance, divisions);
            },
            getUtoTmapping: function(u, distance, divisions) {
              var arcLengths = this.getLengths(divisions);
              var i = 0;
              var il = arcLengths.length;
              var targetArcLength;
              if (distance) {
                targetArcLength = Math.min(distance, arcLengths[il - 1]);
              } else {
                targetArcLength = u * arcLengths[il - 1];
              }
              var low = 0;
              var high = il - 1;
              var comparison;
              while (low <= high) {
                i = Math.floor(low + (high - low) / 2);
                comparison = arcLengths[i] - targetArcLength;
                if (comparison < 0) {
                  low = i + 1;
                } else if (comparison > 0) {
                  high = i - 1;
                } else {
                  high = i;
                  break;
                }
              }
              i = high;
              if (arcLengths[i] === targetArcLength) {
                return i / (il - 1);
              }
              var lengthBefore = arcLengths[i];
              var lengthAfter = arcLengths[i + 1];
              var segmentLength = lengthAfter - lengthBefore;
              var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
              return (i + segmentFraction) / (il - 1);
            },
            updateArcLengths: function() {
              this.needsUpdate = true;
              this.getLengths();
            }
          });
          module2.exports = Curve;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            ADD: __webpack_require__(964),
            COMPLETE: __webpack_require__(965),
            FILE_COMPLETE: __webpack_require__(966),
            FILE_KEY_COMPLETE: __webpack_require__(967),
            FILE_LOAD_ERROR: __webpack_require__(968),
            FILE_LOAD: __webpack_require__(969),
            FILE_PROGRESS: __webpack_require__(970),
            POST_PROCESS: __webpack_require__(971),
            PROGRESS: __webpack_require__(972),
            START: __webpack_require__(973)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var LineToLine = function(line1, line2, out) {
            if (out === void 0) {
              out = new Point();
            }
            var x1 = line1.x1;
            var y1 = line1.y1;
            var x2 = line1.x2;
            var y2 = line1.y2;
            var x3 = line2.x1;
            var y3 = line2.y1;
            var x4 = line2.x2;
            var y4 = line2.y2;
            var numA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
            var numB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
            var deNom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (deNom === 0) {
              return false;
            }
            var uA = numA / deNom;
            var uB = numB / deNom;
            if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
              out.x = x1 + uA * (x2 - x1);
              out.y = y1 + uA * (y2 - y1);
              return true;
            }
            return false;
          };
          module2.exports = LineToLine;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Angle = function(line) {
            return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
          };
          module2.exports = Angle;
        },
        function(module2, exports2, __webpack_require__) {
          var Vertices = {};
          module2.exports = Vertices;
          var Vector = __webpack_require__(116);
          var Common = __webpack_require__(50);
          (function() {
            Vertices.create = function(points, body) {
              var vertices = [];
              for (var i = 0; i < points.length; i++) {
                var point = points[i], vertex = {
                  x: point.x,
                  y: point.y,
                  index: i,
                  body,
                  isInternal: false,
                  contact: null,
                  offset: null
                };
                vertex.contact = {
                  vertex,
                  normalImpulse: 0,
                  tangentImpulse: 0
                };
                vertices.push(vertex);
              }
              return vertices;
            };
            Vertices.fromPath = function(path, body) {
              var pathPattern = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, points = [];
              path.replace(pathPattern, function(match, x, y) {
                points.push({x: parseFloat(x), y: parseFloat(y)});
              });
              return Vertices.create(points, body);
            };
            Vertices.centre = function(vertices) {
              var area = Vertices.area(vertices, true), centre = {x: 0, y: 0}, cross, temp, j;
              for (var i = 0; i < vertices.length; i++) {
                j = (i + 1) % vertices.length;
                cross = Vector.cross(vertices[i], vertices[j]);
                temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);
                centre = Vector.add(centre, temp);
              }
              return Vector.div(centre, 6 * area);
            };
            Vertices.mean = function(vertices) {
              var average = {x: 0, y: 0};
              for (var i = 0; i < vertices.length; i++) {
                average.x += vertices[i].x;
                average.y += vertices[i].y;
              }
              return Vector.div(average, vertices.length);
            };
            Vertices.area = function(vertices, signed) {
              var area = 0, j = vertices.length - 1;
              for (var i = 0; i < vertices.length; i++) {
                area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);
                j = i;
              }
              if (signed)
                return area / 2;
              return Math.abs(area) / 2;
            };
            Vertices.inertia = function(vertices, mass) {
              var numerator = 0, denominator = 0, v = vertices, cross, j;
              for (var n = 0; n < v.length; n++) {
                j = (n + 1) % v.length;
                cross = Math.abs(Vector.cross(v[j], v[n]));
                numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));
                denominator += cross;
              }
              return mass / 6 * (numerator / denominator);
            };
            Vertices.translate = function(vertices, vector, scalar) {
              var i;
              if (scalar) {
                for (i = 0; i < vertices.length; i++) {
                  vertices[i].x += vector.x * scalar;
                  vertices[i].y += vector.y * scalar;
                }
              } else {
                for (i = 0; i < vertices.length; i++) {
                  vertices[i].x += vector.x;
                  vertices[i].y += vector.y;
                }
              }
              return vertices;
            };
            Vertices.rotate = function(vertices, angle, point) {
              if (angle === 0)
                return;
              var cos = Math.cos(angle), sin = Math.sin(angle);
              for (var i = 0; i < vertices.length; i++) {
                var vertice = vertices[i], dx = vertice.x - point.x, dy = vertice.y - point.y;
                vertice.x = point.x + (dx * cos - dy * sin);
                vertice.y = point.y + (dx * sin + dy * cos);
              }
              return vertices;
            };
            Vertices.contains = function(vertices, point) {
              for (var i = 0; i < vertices.length; i++) {
                var vertice = vertices[i], nextVertice = vertices[(i + 1) % vertices.length];
                if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {
                  return false;
                }
              }
              return true;
            };
            Vertices.scale = function(vertices, scaleX, scaleY, point) {
              if (scaleX === 1 && scaleY === 1)
                return vertices;
              point = point || Vertices.centre(vertices);
              var vertex, delta;
              for (var i = 0; i < vertices.length; i++) {
                vertex = vertices[i];
                delta = Vector.sub(vertex, point);
                vertices[i].x = point.x + delta.x * scaleX;
                vertices[i].y = point.y + delta.y * scaleY;
              }
              return vertices;
            };
            Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {
              if (typeof radius === "number") {
                radius = [radius];
              } else {
                radius = radius || [8];
              }
              quality = typeof quality !== "undefined" ? quality : -1;
              qualityMin = qualityMin || 2;
              qualityMax = qualityMax || 14;
              var newVertices = [];
              for (var i = 0; i < vertices.length; i++) {
                var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1], vertex = vertices[i], nextVertex = vertices[(i + 1) % vertices.length], currentRadius = radius[i < radius.length ? i : radius.length - 1];
                if (currentRadius === 0) {
                  newVertices.push(vertex);
                  continue;
                }
                var prevNormal = Vector.normalise({
                  x: vertex.y - prevVertex.y,
                  y: prevVertex.x - vertex.x
                });
                var nextNormal = Vector.normalise({
                  x: nextVertex.y - vertex.y,
                  y: vertex.x - nextVertex.x
                });
                var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)), radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius), midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)), scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));
                var precision = quality;
                if (quality === -1) {
                  precision = Math.pow(currentRadius, 0.32) * 1.75;
                }
                precision = Common.clamp(precision, qualityMin, qualityMax);
                if (precision % 2 === 1)
                  precision += 1;
                var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)), theta = alpha / precision;
                for (var j = 0; j < precision; j++) {
                  newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));
                }
              }
              return newVertices;
            };
            Vertices.clockwiseSort = function(vertices) {
              var centre = Vertices.mean(vertices);
              vertices.sort(function(vertexA, vertexB) {
                return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);
              });
              return vertices;
            };
            Vertices.isConvex = function(vertices) {
              var flag = 0, n = vertices.length, i, j, k, z;
              if (n < 3)
                return null;
              for (i = 0; i < n; i++) {
                j = (i + 1) % n;
                k = (i + 2) % n;
                z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);
                z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);
                if (z < 0) {
                  flag |= 1;
                } else if (z > 0) {
                  flag |= 2;
                }
                if (flag === 3) {
                  return false;
                }
              }
              if (flag !== 0) {
                return true;
              } else {
                return null;
              }
            };
            Vertices.hull = function(vertices) {
              var upper = [], lower = [], vertex, i;
              vertices = vertices.slice(0);
              vertices.sort(function(vertexA, vertexB) {
                var dx = vertexA.x - vertexB.x;
                return dx !== 0 ? dx : vertexA.y - vertexB.y;
              });
              for (i = 0; i < vertices.length; i += 1) {
                vertex = vertices[i];
                while (lower.length >= 2 && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {
                  lower.pop();
                }
                lower.push(vertex);
              }
              for (i = vertices.length - 1; i >= 0; i -= 1) {
                vertex = vertices[i];
                while (upper.length >= 2 && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {
                  upper.pop();
                }
                upper.push(vertex);
              }
              upper.pop();
              lower.pop();
              return upper.concat(lower);
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clamp = __webpack_require__(18);
          var FromPercent = function(percent, min, max) {
            percent = Clamp(percent, 0, 1);
            return (max - min) * percent;
          };
          module2.exports = FromPercent;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetBoolean = function(source, key, defaultValue) {
            if (!source) {
              return defaultValue;
            } else if (source.hasOwnProperty(key)) {
              return source[key];
            } else {
              return defaultValue;
            }
          };
          module2.exports = GetBoolean;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TWEEN_CONST = {
            CREATED: 0,
            INIT: 1,
            DELAY: 2,
            OFFSET_DELAY: 3,
            PENDING_RENDER: 4,
            PLAYING_FORWARD: 5,
            PLAYING_BACKWARD: 6,
            HOLD_DELAY: 7,
            REPEAT_DELAY: 8,
            COMPLETE: 9,
            PENDING_ADD: 20,
            PAUSED: 21,
            LOOP_DELAY: 22,
            ACTIVE: 23,
            COMPLETE_DELAY: 24,
            PENDING_REMOVE: 25,
            REMOVED: 26
          };
          module2.exports = TWEEN_CONST;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(309);
          var DataManager = new Class({
            initialize: function DataManager2(parent, eventEmitter) {
              this.parent = parent;
              this.events = eventEmitter;
              if (!eventEmitter) {
                this.events = parent.events ? parent.events : parent;
              }
              this.list = {};
              this.values = {};
              this._frozen = false;
              if (!parent.hasOwnProperty("sys") && this.events) {
                this.events.once(Events.DESTROY, this.destroy, this);
              }
            },
            get: function(key) {
              var list = this.list;
              if (Array.isArray(key)) {
                var output = [];
                for (var i = 0; i < key.length; i++) {
                  output.push(list[key[i]]);
                }
                return output;
              } else {
                return list[key];
              }
            },
            getAll: function() {
              var results = {};
              for (var key in this.list) {
                if (this.list.hasOwnProperty(key)) {
                  results[key] = this.list[key];
                }
              }
              return results;
            },
            query: function(search) {
              var results = {};
              for (var key in this.list) {
                if (this.list.hasOwnProperty(key) && key.match(search)) {
                  results[key] = this.list[key];
                }
              }
              return results;
            },
            set: function(key, data) {
              if (this._frozen) {
                return this;
              }
              if (typeof key === "string") {
                return this.setValue(key, data);
              } else {
                for (var entry in key) {
                  this.setValue(entry, key[entry]);
                }
              }
              return this;
            },
            inc: function(key, data) {
              if (this._frozen) {
                return this;
              }
              if (data === void 0) {
                data = 1;
              }
              var value = this.get(key);
              if (value === void 0) {
                value = 0;
              }
              this.set(key, value + data);
              return this;
            },
            toggle: function(key) {
              if (this._frozen) {
                return this;
              }
              this.set(key, !this.get(key));
              return this;
            },
            setValue: function(key, data) {
              if (this._frozen) {
                return this;
              }
              if (this.has(key)) {
                this.values[key] = data;
              } else {
                var _this = this;
                var list = this.list;
                var events = this.events;
                var parent = this.parent;
                Object.defineProperty(this.values, key, {
                  enumerable: true,
                  configurable: true,
                  get: function() {
                    return list[key];
                  },
                  set: function(value) {
                    if (!_this._frozen) {
                      var previousValue = list[key];
                      list[key] = value;
                      events.emit(Events.CHANGE_DATA, parent, key, value, previousValue);
                      events.emit(Events.CHANGE_DATA_KEY + key, parent, value, previousValue);
                    }
                  }
                });
                list[key] = data;
                events.emit(Events.SET_DATA, parent, key, data);
              }
              return this;
            },
            each: function(callback, context) {
              var args = [this.parent, null, void 0];
              for (var i = 1; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (var key in this.list) {
                args[1] = key;
                args[2] = this.list[key];
                callback.apply(context, args);
              }
              return this;
            },
            merge: function(data, overwrite) {
              if (overwrite === void 0) {
                overwrite = true;
              }
              for (var key in data) {
                if (data.hasOwnProperty(key) && (overwrite || !overwrite && !this.has(key))) {
                  this.setValue(key, data[key]);
                }
              }
              return this;
            },
            remove: function(key) {
              if (this._frozen) {
                return this;
              }
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.removeValue(key[i]);
                }
              } else {
                return this.removeValue(key);
              }
              return this;
            },
            removeValue: function(key) {
              if (this.has(key)) {
                var data = this.list[key];
                delete this.list[key];
                delete this.values[key];
                this.events.emit(Events.REMOVE_DATA, this.parent, key, data);
              }
              return this;
            },
            pop: function(key) {
              var data = void 0;
              if (!this._frozen && this.has(key)) {
                data = this.list[key];
                delete this.list[key];
                delete this.values[key];
                this.events.emit(Events.REMOVE_DATA, this.parent, key, data);
              }
              return data;
            },
            has: function(key) {
              return this.list.hasOwnProperty(key);
            },
            setFreeze: function(value) {
              this._frozen = value;
              return this;
            },
            reset: function() {
              for (var key in this.list) {
                delete this.list[key];
                delete this.values[key];
              }
              this._frozen = false;
              return this;
            },
            destroy: function() {
              this.reset();
              this.events.off(Events.CHANGE_DATA);
              this.events.off(Events.SET_DATA);
              this.events.off(Events.REMOVE_DATA);
              this.parent = null;
            },
            freeze: {
              get: function() {
                return this._frozen;
              },
              set: function(value) {
                this._frozen = value ? true : false;
              }
            },
            count: {
              get: function() {
                var i = 0;
                for (var key in this.list) {
                  if (this.list[key] !== void 0) {
                    i++;
                  }
                }
                return i;
              }
            }
          });
          module2.exports = DataManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Map2 = new Class({
            initialize: function Map3(elements) {
              this.entries = {};
              this.size = 0;
              if (Array.isArray(elements)) {
                for (var i = 0; i < elements.length; i++) {
                  this.set(elements[i][0], elements[i][1]);
                }
              }
            },
            set: function(key, value) {
              if (!this.has(key)) {
                this.size++;
              }
              this.entries[key] = value;
              return this;
            },
            get: function(key) {
              if (this.has(key)) {
                return this.entries[key];
              }
            },
            getArray: function() {
              var output = [];
              var entries = this.entries;
              for (var key in entries) {
                output.push(entries[key]);
              }
              return output;
            },
            has: function(key) {
              return this.entries.hasOwnProperty(key);
            },
            delete: function(key) {
              if (this.has(key)) {
                delete this.entries[key];
                this.size--;
              }
              return this;
            },
            clear: function() {
              Object.keys(this.entries).forEach(function(prop) {
                delete this.entries[prop];
              }, this);
              this.size = 0;
              return this;
            },
            keys: function() {
              return Object.keys(this.entries);
            },
            values: function() {
              var output = [];
              var entries = this.entries;
              for (var key in entries) {
                output.push(entries[key]);
              }
              return output;
            },
            dump: function() {
              var entries = this.entries;
              console.group("Map");
              for (var key in entries) {
                console.log(key, entries[key]);
              }
              console.groupEnd();
            },
            each: function(callback) {
              var entries = this.entries;
              for (var key in entries) {
                if (callback(key, entries[key]) === false) {
                  break;
                }
              }
              return this;
            },
            contains: function(value) {
              var entries = this.entries;
              for (var key in entries) {
                if (entries[key] === value) {
                  return true;
                }
              }
              return false;
            },
            merge: function(map, override) {
              if (override === void 0) {
                override = false;
              }
              var local = this.entries;
              var source = map.entries;
              for (var key in source) {
                if (local.hasOwnProperty(key) && override) {
                  local[key] = source[key];
                } else {
                  this.set(key, source[key]);
                }
              }
              return this;
            }
          });
          module2.exports = Map2;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetColor = function(red, green, blue) {
            return red << 16 | green << 8 | blue;
          };
          module2.exports = GetColor;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            ENTER_FULLSCREEN: __webpack_require__(776),
            FULLSCREEN_FAILED: __webpack_require__(777),
            FULLSCREEN_UNSUPPORTED: __webpack_require__(778),
            LEAVE_FULLSCREEN: __webpack_require__(779),
            ORIENTATION_CHANGE: __webpack_require__(780),
            RESIZE: __webpack_require__(781)
          };
        },
        function(module2, exports2, __webpack_require__) {
          (function(process) {
            /**
            * @author       Richard Davey <rich@photonstorm.com>
            * @copyright    2020 Photon Storm Ltd.
            * @license      {@link https://opensource.org/licenses/MIT|MIT License}
            */
            var OS = {
              android: false,
              chromeOS: false,
              cordova: false,
              crosswalk: false,
              desktop: false,
              ejecta: false,
              electron: false,
              iOS: false,
              iOSVersion: 0,
              iPad: false,
              iPhone: false,
              kindle: false,
              linux: false,
              macOS: false,
              node: false,
              nodeWebkit: false,
              pixelRatio: 1,
              webApp: false,
              windows: false,
              windowsPhone: false
            };
            function init() {
              var ua = navigator.userAgent;
              if (/Windows/.test(ua)) {
                OS.windows = true;
              } else if (/Mac OS/.test(ua) && !/like Mac OS/.test(ua)) {
                if (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) {
                  OS.iOS = true;
                  OS.iPad = true;
                  navigator.appVersion.match(/Version\/(\d+)/);
                  OS.iOSVersion = parseInt(RegExp.$1, 10);
                } else {
                  OS.macOS = true;
                }
              } else if (/Android/.test(ua)) {
                OS.android = true;
              } else if (/Linux/.test(ua)) {
                OS.linux = true;
              } else if (/iP[ao]d|iPhone/i.test(ua)) {
                OS.iOS = true;
                navigator.appVersion.match(/OS (\d+)/);
                OS.iOSVersion = parseInt(RegExp.$1, 10);
                OS.iPhone = ua.toLowerCase().indexOf("iphone") !== -1;
                OS.iPad = ua.toLowerCase().indexOf("ipad") !== -1;
              } else if (/Kindle/.test(ua) || /\bKF[A-Z][A-Z]+/.test(ua) || /Silk.*Mobile Safari/.test(ua)) {
                OS.kindle = true;
              } else if (/CrOS/.test(ua)) {
                OS.chromeOS = true;
              }
              if (/Windows Phone/i.test(ua) || /IEMobile/i.test(ua)) {
                OS.android = false;
                OS.iOS = false;
                OS.macOS = false;
                OS.windows = true;
                OS.windowsPhone = true;
              }
              var silk = /Silk/.test(ua);
              if (OS.windows || OS.macOS || OS.linux && !silk || OS.chromeOS) {
                OS.desktop = true;
              }
              if (OS.windowsPhone || /Windows NT/i.test(ua) && /Touch/i.test(ua)) {
                OS.desktop = false;
              }
              if (navigator.standalone) {
                OS.webApp = true;
              }
              if (window.cordova !== void 0) {
                OS.cordova = true;
              }
              if (typeof process !== "undefined" && process.versions && process.versions.node) {
                OS.node = true;
              }
              if (OS.node && typeof process.versions === "object") {
                OS.nodeWebkit = !!process.versions["node-webkit"];
                OS.electron = !!process.versions.electron;
              }
              if (window.ejecta !== void 0) {
                OS.ejecta = true;
              }
              if (/Crosswalk/.test(ua)) {
                OS.crosswalk = true;
              }
              OS.pixelRatio = window["devicePixelRatio"] || 1;
              return OS;
            }
            module2.exports = init();
          }).call(this, __webpack_require__(804));
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            ADD: __webpack_require__(857),
            ERROR: __webpack_require__(858),
            LOAD: __webpack_require__(859),
            READY: __webpack_require__(860),
            REMOVE: __webpack_require__(861)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var WEBGL_CONST = {
            BYTE: {enum: 5120, size: 1},
            UNSIGNED_BYTE: {enum: 5121, size: 1},
            SHORT: {enum: 5122, size: 2},
            UNSIGNED_SHORT: {enum: 5123, size: 2},
            INT: {enum: 5124, size: 4},
            UNSIGNED_INT: {enum: 5125, size: 4},
            FLOAT: {enum: 5126, size: 4}
          };
          module2.exports = WEBGL_CONST;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Felipe Alfonso <@bitnenfer>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var ShaderSourceFS = __webpack_require__(874);
          var ShaderSourceVS = __webpack_require__(875);
          var TransformMatrix = __webpack_require__(25);
          var Utils = __webpack_require__(12);
          var WEBGL_CONST = __webpack_require__(104);
          var WebGLPipeline = __webpack_require__(57);
          var MultiPipeline = new Class({
            Extends: WebGLPipeline,
            initialize: function MultiPipeline2(config2) {
              var renderer = config2.game.renderer;
              var fragmentShaderSource = GetFastValue(config2, "fragShader", ShaderSourceFS);
              config2.fragShader = Utils.parseFragmentShaderMaxTextures(fragmentShaderSource, renderer.maxTextures);
              config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS);
              config2.attributes = GetFastValue(config2, "attributes", [
                {
                  name: "inPosition",
                  size: 2
                },
                {
                  name: "inTexCoord",
                  size: 2
                },
                {
                  name: "inTexId"
                },
                {
                  name: "inTintEffect"
                },
                {
                  name: "inTint",
                  size: 4,
                  type: WEBGL_CONST.UNSIGNED_BYTE,
                  normalized: true
                }
              ]);
              WebGLPipeline.call(this, config2);
              this._tempMatrix1 = new TransformMatrix();
              this._tempMatrix2 = new TransformMatrix();
              this._tempMatrix3 = new TransformMatrix();
            },
            boot: function() {
              WebGLPipeline.prototype.boot.call(this);
              this.currentShader.set1iv("uMainSampler", this.renderer.textureIndexes);
            },
            batchSprite: function(gameObject, camera, parentTransformMatrix) {
              this.manager.set(this, gameObject);
              var camMatrix = this._tempMatrix1;
              var spriteMatrix = this._tempMatrix2;
              var calcMatrix = this._tempMatrix3;
              var frame = gameObject.frame;
              var texture = frame.glTexture;
              var u0 = frame.u0;
              var v0 = frame.v0;
              var u1 = frame.u1;
              var v1 = frame.v1;
              var frameX = frame.x;
              var frameY = frame.y;
              var frameWidth = frame.cutWidth;
              var frameHeight = frame.cutHeight;
              var customPivot = frame.customPivot;
              var displayOriginX = gameObject.displayOriginX;
              var displayOriginY = gameObject.displayOriginY;
              var x = -displayOriginX + frameX;
              var y = -displayOriginY + frameY;
              if (gameObject.isCropped) {
                var crop = gameObject._crop;
                if (crop.flipX !== gameObject.flipX || crop.flipY !== gameObject.flipY) {
                  frame.updateCropUVs(crop, gameObject.flipX, gameObject.flipY);
                }
                u0 = crop.u0;
                v0 = crop.v0;
                u1 = crop.u1;
                v1 = crop.v1;
                frameWidth = crop.width;
                frameHeight = crop.height;
                frameX = crop.x;
                frameY = crop.y;
                x = -displayOriginX + frameX;
                y = -displayOriginY + frameY;
              }
              var flipX = 1;
              var flipY = 1;
              if (gameObject.flipX) {
                if (!customPivot) {
                  x += -frame.realWidth + displayOriginX * 2;
                }
                flipX = -1;
              }
              if (gameObject.flipY || frame.source.isGLTexture && !texture.flipY) {
                if (!customPivot) {
                  y += -frame.realHeight + displayOriginY * 2;
                }
                flipY = -1;
              }
              spriteMatrix.applyITRS(gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX * flipX, gameObject.scaleY * flipY);
              camMatrix.copyFrom(camera.matrix);
              if (parentTransformMatrix) {
                camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * gameObject.scrollFactorX, -camera.scrollY * gameObject.scrollFactorY);
                spriteMatrix.e = gameObject.x;
                spriteMatrix.f = gameObject.y;
              } else {
                spriteMatrix.e -= camera.scrollX * gameObject.scrollFactorX;
                spriteMatrix.f -= camera.scrollY * gameObject.scrollFactorY;
              }
              camMatrix.multiply(spriteMatrix, calcMatrix);
              var xw = x + frameWidth;
              var yh = y + frameHeight;
              var roundPixels = camera.roundPixels;
              var tx0 = calcMatrix.getXRound(x, y, roundPixels);
              var ty0 = calcMatrix.getYRound(x, y, roundPixels);
              var tx1 = calcMatrix.getXRound(x, yh, roundPixels);
              var ty1 = calcMatrix.getYRound(x, yh, roundPixels);
              var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);
              var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);
              var tx3 = calcMatrix.getXRound(xw, y, roundPixels);
              var ty3 = calcMatrix.getYRound(xw, y, roundPixels);
              var getTint = Utils.getTintAppendFloatAlpha;
              var cameraAlpha = camera.alpha;
              var tintTL = getTint(gameObject.tintTopLeft, cameraAlpha * gameObject._alphaTL);
              var tintTR = getTint(gameObject.tintTopRight, cameraAlpha * gameObject._alphaTR);
              var tintBL = getTint(gameObject.tintBottomLeft, cameraAlpha * gameObject._alphaBL);
              var tintBR = getTint(gameObject.tintBottomRight, cameraAlpha * gameObject._alphaBR);
              if (this.shouldFlush(6)) {
                this.flush();
              }
              var unit = this.setGameObject(gameObject, frame);
              this.manager.preBatch(gameObject);
              this.batchQuad(gameObject, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, gameObject.tintFill, texture, unit);
              this.manager.postBatch(gameObject);
            },
            batchTexture: function(gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit) {
              this.manager.set(this, gameObject);
              var camMatrix = this._tempMatrix1;
              var spriteMatrix = this._tempMatrix2;
              var calcMatrix = this._tempMatrix3;
              var u0 = frameX / textureWidth + uOffset;
              var v0 = frameY / textureHeight + vOffset;
              var u1 = (frameX + frameWidth) / textureWidth + uOffset;
              var v1 = (frameY + frameHeight) / textureHeight + vOffset;
              var width = srcWidth;
              var height = srcHeight;
              var x = -displayOriginX;
              var y = -displayOriginY;
              if (gameObject.isCropped) {
                var crop = gameObject._crop;
                var cropWidth = crop.width;
                var cropHeight = crop.height;
                width = cropWidth;
                height = cropHeight;
                srcWidth = cropWidth;
                srcHeight = cropHeight;
                frameX = crop.x;
                frameY = crop.y;
                var ox = frameX;
                var oy = frameY;
                if (flipX) {
                  ox = frameWidth - crop.x - cropWidth;
                }
                if (flipY) {
                  oy = frameHeight - crop.y - cropHeight;
                }
                u0 = ox / textureWidth + uOffset;
                v0 = oy / textureHeight + vOffset;
                u1 = (ox + cropWidth) / textureWidth + uOffset;
                v1 = (oy + cropHeight) / textureHeight + vOffset;
                x = -displayOriginX + frameX;
                y = -displayOriginY + frameY;
              }
              flipY = flipY ^ (!skipFlip && texture.isRenderTexture ? 1 : 0);
              if (flipX) {
                width *= -1;
                x += srcWidth;
              }
              if (flipY) {
                height *= -1;
                y += srcHeight;
              }
              var xw = x + width;
              var yh = y + height;
              spriteMatrix.applyITRS(srcX, srcY, rotation, scaleX, scaleY);
              camMatrix.copyFrom(camera.matrix);
              if (parentTransformMatrix) {
                camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
                spriteMatrix.e = srcX;
                spriteMatrix.f = srcY;
              } else {
                spriteMatrix.e -= camera.scrollX * scrollFactorX;
                spriteMatrix.f -= camera.scrollY * scrollFactorY;
              }
              camMatrix.multiply(spriteMatrix, calcMatrix);
              var roundPixels = camera.roundPixels;
              var tx0 = calcMatrix.getXRound(x, y, roundPixels);
              var ty0 = calcMatrix.getYRound(x, y, roundPixels);
              var tx1 = calcMatrix.getXRound(x, yh, roundPixels);
              var ty1 = calcMatrix.getYRound(x, yh, roundPixels);
              var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);
              var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);
              var tx3 = calcMatrix.getXRound(xw, y, roundPixels);
              var ty3 = calcMatrix.getYRound(xw, y, roundPixels);
              if (textureUnit === void 0) {
                textureUnit = this.renderer.setTexture2D(texture);
              }
              if (gameObject) {
                this.manager.preBatch(gameObject);
              }
              this.batchQuad(gameObject, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
              if (gameObject) {
                this.manager.postBatch(gameObject);
              }
            },
            batchTextureFrame: function(frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix) {
              this.manager.set(this);
              var spriteMatrix = this._tempMatrix1.copyFrom(transformMatrix);
              var calcMatrix = this._tempMatrix2;
              var xw = x + frame.width;
              var yh = y + frame.height;
              if (parentTransformMatrix) {
                spriteMatrix.multiply(parentTransformMatrix, calcMatrix);
              } else {
                calcMatrix = spriteMatrix;
              }
              var tx0 = calcMatrix.getX(x, y);
              var ty0 = calcMatrix.getY(x, y);
              var tx1 = calcMatrix.getX(x, yh);
              var ty1 = calcMatrix.getY(x, yh);
              var tx2 = calcMatrix.getX(xw, yh);
              var ty2 = calcMatrix.getY(xw, yh);
              var tx3 = calcMatrix.getX(xw, y);
              var ty3 = calcMatrix.getY(xw, y);
              var unit = this.renderer.setTextureSource(frame.source);
              tint = Utils.getTintAppendFloatAlpha(tint, alpha);
              this.batchQuad(null, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, 0, frame.glTexture, unit);
            }
          });
          module2.exports = MultiPipeline;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Clamp = __webpack_require__(18);
          var Extend = __webpack_require__(17);
          var Frame = new Class({
            initialize: function Frame2(texture, name, sourceIndex, x, y, width, height) {
              this.texture = texture;
              this.name = name;
              this.source = texture.source[sourceIndex];
              this.sourceIndex = sourceIndex;
              this.glTexture = this.source.glTexture;
              this.cutX;
              this.cutY;
              this.cutWidth;
              this.cutHeight;
              this.x = 0;
              this.y = 0;
              this.width;
              this.height;
              this.halfWidth;
              this.halfHeight;
              this.centerX;
              this.centerY;
              this.pivotX = 0;
              this.pivotY = 0;
              this.customPivot = false;
              this.rotated = false;
              this.autoRound = -1;
              this.customData = {};
              this.u0 = 0;
              this.v0 = 0;
              this.u1 = 0;
              this.v1 = 0;
              this.data = {
                cut: {
                  x: 0,
                  y: 0,
                  w: 0,
                  h: 0,
                  r: 0,
                  b: 0
                },
                trim: false,
                sourceSize: {
                  w: 0,
                  h: 0
                },
                spriteSourceSize: {
                  x: 0,
                  y: 0,
                  w: 0,
                  h: 0,
                  r: 0,
                  b: 0
                },
                radius: 0,
                drawImage: {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                }
              };
              this.setSize(width, height, x, y);
            },
            setSize: function(width, height, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              this.cutX = x;
              this.cutY = y;
              this.cutWidth = width;
              this.cutHeight = height;
              this.width = width;
              this.height = height;
              this.halfWidth = Math.floor(width * 0.5);
              this.halfHeight = Math.floor(height * 0.5);
              this.centerX = Math.floor(width / 2);
              this.centerY = Math.floor(height / 2);
              var data = this.data;
              var cut = data.cut;
              cut.x = x;
              cut.y = y;
              cut.w = width;
              cut.h = height;
              cut.r = x + width;
              cut.b = y + height;
              data.sourceSize.w = width;
              data.sourceSize.h = height;
              data.spriteSourceSize.w = width;
              data.spriteSourceSize.h = height;
              data.radius = 0.5 * Math.sqrt(width * width + height * height);
              var drawImage = data.drawImage;
              drawImage.x = x;
              drawImage.y = y;
              drawImage.width = width;
              drawImage.height = height;
              return this.updateUVs();
            },
            setTrim: function(actualWidth, actualHeight, destX, destY, destWidth, destHeight) {
              var data = this.data;
              var ss = data.spriteSourceSize;
              data.trim = true;
              data.sourceSize.w = actualWidth;
              data.sourceSize.h = actualHeight;
              ss.x = destX;
              ss.y = destY;
              ss.w = destWidth;
              ss.h = destHeight;
              ss.r = destX + destWidth;
              ss.b = destY + destHeight;
              this.x = destX;
              this.y = destY;
              this.width = destWidth;
              this.height = destHeight;
              this.halfWidth = destWidth * 0.5;
              this.halfHeight = destHeight * 0.5;
              this.centerX = Math.floor(destWidth / 2);
              this.centerY = Math.floor(destHeight / 2);
              return this.updateUVs();
            },
            setCropUVs: function(crop, x, y, width, height, flipX, flipY) {
              var cx = this.cutX;
              var cy = this.cutY;
              var cw = this.cutWidth;
              var ch = this.cutHeight;
              var rw = this.realWidth;
              var rh = this.realHeight;
              x = Clamp(x, 0, rw);
              y = Clamp(y, 0, rh);
              width = Clamp(width, 0, rw - x);
              height = Clamp(height, 0, rh - y);
              var ox = cx + x;
              var oy = cy + y;
              var ow = width;
              var oh = height;
              var data = this.data;
              if (data.trim) {
                var ss = data.spriteSourceSize;
                width = Clamp(width, 0, cw - x);
                height = Clamp(height, 0, ch - y);
                var cropRight = x + width;
                var cropBottom = y + height;
                var intersects = !(ss.r < x || ss.b < y || ss.x > cropRight || ss.y > cropBottom);
                if (intersects) {
                  var ix = Math.max(ss.x, x);
                  var iy = Math.max(ss.y, y);
                  var iw = Math.min(ss.r, cropRight) - ix;
                  var ih = Math.min(ss.b, cropBottom) - iy;
                  ow = iw;
                  oh = ih;
                  if (flipX) {
                    ox = cx + (cw - (ix - ss.x) - iw);
                  } else {
                    ox = cx + (ix - ss.x);
                  }
                  if (flipY) {
                    oy = cy + (ch - (iy - ss.y) - ih);
                  } else {
                    oy = cy + (iy - ss.y);
                  }
                  x = ix;
                  y = iy;
                  width = iw;
                  height = ih;
                } else {
                  ox = 0;
                  oy = 0;
                  ow = 0;
                  oh = 0;
                }
              } else {
                if (flipX) {
                  ox = cx + (cw - x - width);
                }
                if (flipY) {
                  oy = cy + (ch - y - height);
                }
              }
              var tw = this.source.width;
              var th = this.source.height;
              crop.u0 = Math.max(0, ox / tw);
              crop.v0 = Math.max(0, oy / th);
              crop.u1 = Math.min(1, (ox + ow) / tw);
              crop.v1 = Math.min(1, (oy + oh) / th);
              crop.x = x;
              crop.y = y;
              crop.cx = ox;
              crop.cy = oy;
              crop.cw = ow;
              crop.ch = oh;
              crop.width = width;
              crop.height = height;
              crop.flipX = flipX;
              crop.flipY = flipY;
              return crop;
            },
            updateCropUVs: function(crop, flipX, flipY) {
              return this.setCropUVs(crop, crop.x, crop.y, crop.width, crop.height, flipX, flipY);
            },
            setUVs: function(width, height, u0, v0, u1, v1) {
              var cd = this.data.drawImage;
              cd.width = width;
              cd.height = height;
              this.u0 = u0;
              this.v0 = v0;
              this.u1 = u1;
              this.v1 = v1;
              return this;
            },
            updateUVs: function() {
              var cx = this.cutX;
              var cy = this.cutY;
              var cw = this.cutWidth;
              var ch = this.cutHeight;
              var cd = this.data.drawImage;
              cd.width = cw;
              cd.height = ch;
              var tw = this.source.width;
              var th = this.source.height;
              this.u0 = cx / tw;
              this.v0 = cy / th;
              this.u1 = (cx + cw) / tw;
              this.v1 = (cy + ch) / th;
              return this;
            },
            updateUVsInverted: function() {
              var tw = this.source.width;
              var th = this.source.height;
              this.u0 = (this.cutX + this.cutHeight) / tw;
              this.v0 = this.cutY / th;
              this.u1 = this.cutX / tw;
              this.v1 = (this.cutY + this.cutWidth) / th;
              return this;
            },
            clone: function() {
              var clone = new Frame(this.texture, this.name, this.sourceIndex);
              clone.cutX = this.cutX;
              clone.cutY = this.cutY;
              clone.cutWidth = this.cutWidth;
              clone.cutHeight = this.cutHeight;
              clone.x = this.x;
              clone.y = this.y;
              clone.width = this.width;
              clone.height = this.height;
              clone.halfWidth = this.halfWidth;
              clone.halfHeight = this.halfHeight;
              clone.centerX = this.centerX;
              clone.centerY = this.centerY;
              clone.rotated = this.rotated;
              clone.data = Extend(true, clone.data, this.data);
              clone.updateUVs();
              return clone;
            },
            destroy: function() {
              this.source = null;
              this.texture = null;
              this.glTexture = null;
              this.customData = null;
              this.data = null;
            },
            realWidth: {
              get: function() {
                return this.data.sourceSize.w;
              }
            },
            realHeight: {
              get: function() {
                return this.data.sourceSize.h;
              }
            },
            radius: {
              get: function() {
                return this.data.radius;
              }
            },
            trimmed: {
              get: function() {
                return this.data.trim;
              }
            },
            canvasData: {
              get: function() {
                return this.data.drawImage;
              }
            }
          });
          module2.exports = Frame;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ArrayUtils = __webpack_require__(205);
          var Class = __webpack_require__(0);
          var NOOP = __webpack_require__(1);
          var StableSort = __webpack_require__(79);
          var List = new Class({
            initialize: function List2(parent) {
              this.parent = parent;
              this.list = [];
              this.position = 0;
              this.addCallback = NOOP;
              this.removeCallback = NOOP;
              this._sortKey = "";
            },
            add: function(child, skipCallback) {
              if (skipCallback) {
                return ArrayUtils.Add(this.list, child);
              } else {
                return ArrayUtils.Add(this.list, child, 0, this.addCallback, this);
              }
            },
            addAt: function(child, index, skipCallback) {
              if (skipCallback) {
                return ArrayUtils.AddAt(this.list, child, index);
              } else {
                return ArrayUtils.AddAt(this.list, child, index, 0, this.addCallback, this);
              }
            },
            getAt: function(index) {
              return this.list[index];
            },
            getIndex: function(child) {
              return this.list.indexOf(child);
            },
            sort: function(property, handler) {
              if (!property) {
                return this;
              }
              if (handler === void 0) {
                handler = function(childA, childB) {
                  return childA[property] - childB[property];
                };
              }
              StableSort(this.list, handler);
              return this;
            },
            getByName: function(name) {
              return ArrayUtils.GetFirst(this.list, "name", name);
            },
            getRandom: function(startIndex, length) {
              return ArrayUtils.GetRandom(this.list, startIndex, length);
            },
            getFirst: function(property, value, startIndex, endIndex) {
              return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
            },
            getAll: function(property, value, startIndex, endIndex) {
              return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
            },
            count: function(property, value) {
              return ArrayUtils.CountAllMatching(this.list, property, value);
            },
            swap: function(child1, child2) {
              ArrayUtils.Swap(this.list, child1, child2);
            },
            moveTo: function(child, index) {
              return ArrayUtils.MoveTo(this.list, child, index);
            },
            remove: function(child, skipCallback) {
              if (skipCallback) {
                return ArrayUtils.Remove(this.list, child);
              } else {
                return ArrayUtils.Remove(this.list, child, this.removeCallback, this);
              }
            },
            removeAt: function(index, skipCallback) {
              if (skipCallback) {
                return ArrayUtils.RemoveAt(this.list, index);
              } else {
                return ArrayUtils.RemoveAt(this.list, index, this.removeCallback, this);
              }
            },
            removeBetween: function(startIndex, endIndex, skipCallback) {
              if (skipCallback) {
                return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex);
              } else {
                return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeCallback, this);
              }
            },
            removeAll: function(skipCallback) {
              var i = this.list.length;
              while (i--) {
                this.remove(this.list[i], skipCallback);
              }
              return this;
            },
            bringToTop: function(child) {
              return ArrayUtils.BringToTop(this.list, child);
            },
            sendToBack: function(child) {
              return ArrayUtils.SendToBack(this.list, child);
            },
            moveUp: function(child) {
              ArrayUtils.MoveUp(this.list, child);
              return child;
            },
            moveDown: function(child) {
              ArrayUtils.MoveDown(this.list, child);
              return child;
            },
            reverse: function() {
              this.list.reverse();
              return this;
            },
            shuffle: function() {
              ArrayUtils.Shuffle(this.list);
              return this;
            },
            replace: function(oldChild, newChild) {
              return ArrayUtils.Replace(this.list, oldChild, newChild);
            },
            exists: function(child) {
              return this.list.indexOf(child) > -1;
            },
            setAll: function(property, value, startIndex, endIndex) {
              ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);
              return this;
            },
            each: function(callback, context) {
              var args = [null];
              for (var i = 2; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (i = 0; i < this.list.length; i++) {
                args[0] = this.list[i];
                callback.apply(context, args);
              }
            },
            shutdown: function() {
              this.removeAll();
              this.list = [];
            },
            destroy: function() {
              this.removeAll();
              this.parent = null;
              this.addCallback = null;
              this.removeCallback = null;
            },
            length: {
              get: function() {
                return this.list.length;
              }
            },
            first: {
              get: function() {
                this.position = 0;
                if (this.list.length > 0) {
                  return this.list[0];
                } else {
                  return null;
                }
              }
            },
            last: {
              get: function() {
                if (this.list.length > 0) {
                  this.position = this.list.length - 1;
                  return this.list[this.position];
                } else {
                  return null;
                }
              }
            },
            next: {
              get: function() {
                if (this.position < this.list.length) {
                  this.position++;
                  return this.list[this.position];
                } else {
                  return null;
                }
              }
            },
            previous: {
              get: function() {
                if (this.position > 0) {
                  this.position--;
                  return this.list[this.position];
                } else {
                  return null;
                }
              }
            }
          });
          module2.exports = List;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Contains = __webpack_require__(109);
          var GetPoint = __webpack_require__(439);
          var GetPoints = __webpack_require__(440);
          var GEOM_CONST = __webpack_require__(55);
          var Random = __webpack_require__(177);
          var Ellipse = new Class({
            initialize: function Ellipse2(x, y, width, height) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 0;
              }
              if (height === void 0) {
                height = 0;
              }
              this.type = GEOM_CONST.ELLIPSE;
              this.x = x;
              this.y = y;
              this.width = width;
              this.height = height;
            },
            contains: function(x, y) {
              return Contains(this, x, y);
            },
            getPoint: function(position, point) {
              return GetPoint(this, position, point);
            },
            getPoints: function(quantity, stepRate, output) {
              return GetPoints(this, quantity, stepRate, output);
            },
            getRandomPoint: function(point) {
              return Random(this, point);
            },
            setTo: function(x, y, width, height) {
              this.x = x;
              this.y = y;
              this.width = width;
              this.height = height;
              return this;
            },
            setEmpty: function() {
              this.width = 0;
              this.height = 0;
              return this;
            },
            setPosition: function(x, y) {
              if (y === void 0) {
                y = x;
              }
              this.x = x;
              this.y = y;
              return this;
            },
            setSize: function(width, height) {
              if (height === void 0) {
                height = width;
              }
              this.width = width;
              this.height = height;
              return this;
            },
            isEmpty: function() {
              return this.width <= 0 || this.height <= 0;
            },
            getMinorRadius: function() {
              return Math.min(this.width, this.height) / 2;
            },
            getMajorRadius: function() {
              return Math.max(this.width, this.height) / 2;
            },
            left: {
              get: function() {
                return this.x - this.width / 2;
              },
              set: function(value) {
                this.x = value + this.width / 2;
              }
            },
            right: {
              get: function() {
                return this.x + this.width / 2;
              },
              set: function(value) {
                this.x = value - this.width / 2;
              }
            },
            top: {
              get: function() {
                return this.y - this.height / 2;
              },
              set: function(value) {
                this.y = value + this.height / 2;
              }
            },
            bottom: {
              get: function() {
                return this.y + this.height / 2;
              },
              set: function(value) {
                this.y = value - this.height / 2;
              }
            }
          });
          module2.exports = Ellipse;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Contains = function(ellipse, x, y) {
            if (ellipse.width <= 0 || ellipse.height <= 0) {
              return false;
            }
            var normx = (x - ellipse.x) / ellipse.width;
            var normy = (y - ellipse.y) / ellipse.height;
            normx *= normx;
            normy *= normy;
            return normx + normy < 0.25;
          };
          module2.exports = Contains;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Actions = __webpack_require__(269);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(75);
          var EventEmitter = __webpack_require__(9);
          var GetAll = __webpack_require__(204);
          var GetFastValue = __webpack_require__(2);
          var GetValue = __webpack_require__(6);
          var IsPlainObject = __webpack_require__(7);
          var Range = __webpack_require__(431);
          var Set2 = __webpack_require__(148);
          var Sprite = __webpack_require__(73);
          var Group = new Class({
            Extends: EventEmitter,
            initialize: function Group2(scene, children, config2) {
              EventEmitter.call(this);
              if (config2) {
                if (children && !Array.isArray(children)) {
                  children = [children];
                }
              } else if (Array.isArray(children)) {
                if (IsPlainObject(children[0])) {
                  config2 = children;
                  children = null;
                }
              } else if (IsPlainObject(children)) {
                config2 = children;
                children = null;
              }
              this.scene = scene;
              this.children = new Set2();
              this.isParent = true;
              this.type = "Group";
              this.classType = GetFastValue(config2, "classType", Sprite);
              this.name = GetFastValue(config2, "name", "");
              this.active = GetFastValue(config2, "active", true);
              this.maxSize = GetFastValue(config2, "maxSize", -1);
              this.defaultKey = GetFastValue(config2, "defaultKey", null);
              this.defaultFrame = GetFastValue(config2, "defaultFrame", null);
              this.runChildUpdate = GetFastValue(config2, "runChildUpdate", false);
              this.createCallback = GetFastValue(config2, "createCallback", null);
              this.removeCallback = GetFastValue(config2, "removeCallback", null);
              this.createMultipleCallback = GetFastValue(config2, "createMultipleCallback", null);
              this.internalCreateCallback = GetFastValue(config2, "internalCreateCallback", null);
              this.internalRemoveCallback = GetFastValue(config2, "internalRemoveCallback", null);
              if (children) {
                this.addMultiple(children);
              }
              if (config2) {
                this.createMultiple(config2);
              }
            },
            addedToScene: function() {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function() {
              this.scene.sys.updateList.remove(this);
            },
            create: function(x, y, key, frame, visible, active) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (key === void 0) {
                key = this.defaultKey;
              }
              if (frame === void 0) {
                frame = this.defaultFrame;
              }
              if (visible === void 0) {
                visible = true;
              }
              if (active === void 0) {
                active = true;
              }
              if (this.isFull()) {
                return null;
              }
              var child = new this.classType(this.scene, x, y, key, frame);
              this.scene.sys.displayList.add(child);
              if (child.preUpdate) {
                this.scene.sys.updateList.add(child);
              }
              child.visible = visible;
              child.setActive(active);
              this.add(child);
              return child;
            },
            createMultiple: function(config2) {
              if (this.isFull()) {
                return [];
              }
              if (!Array.isArray(config2)) {
                config2 = [config2];
              }
              var output = [];
              if (config2[0].key) {
                for (var i = 0; i < config2.length; i++) {
                  var entries = this.createFromConfig(config2[i]);
                  output = output.concat(entries);
                }
              }
              return output;
            },
            createFromConfig: function(options) {
              if (this.isFull()) {
                return [];
              }
              this.classType = GetFastValue(options, "classType", this.classType);
              var key = GetFastValue(options, "key", void 0);
              var frame = GetFastValue(options, "frame", null);
              var visible = GetFastValue(options, "visible", true);
              var active = GetFastValue(options, "active", true);
              var entries = [];
              if (key === void 0) {
                return entries;
              } else {
                if (!Array.isArray(key)) {
                  key = [key];
                }
                if (!Array.isArray(frame)) {
                  frame = [frame];
                }
              }
              var repeat = GetFastValue(options, "repeat", 0);
              var randomKey = GetFastValue(options, "randomKey", false);
              var randomFrame = GetFastValue(options, "randomFrame", false);
              var yoyo = GetFastValue(options, "yoyo", false);
              var quantity = GetFastValue(options, "quantity", false);
              var frameQuantity = GetFastValue(options, "frameQuantity", 1);
              var max = GetFastValue(options, "max", 0);
              var range = Range(key, frame, {
                max,
                qty: quantity ? quantity : frameQuantity,
                random: randomKey,
                randomB: randomFrame,
                repeat,
                yoyo
              });
              if (options.createCallback) {
                this.createCallback = options.createCallback;
              }
              if (options.removeCallback) {
                this.removeCallback = options.removeCallback;
              }
              for (var c = 0; c < range.length; c++) {
                var created = this.create(0, 0, range[c].a, range[c].b, visible, active);
                if (!created) {
                  break;
                }
                entries.push(created);
              }
              var x = GetValue(options, "setXY.x", 0);
              var y = GetValue(options, "setXY.y", 0);
              var stepX = GetValue(options, "setXY.stepX", 0);
              var stepY = GetValue(options, "setXY.stepY", 0);
              Actions.SetXY(entries, x, y, stepX, stepY);
              var rotation = GetValue(options, "setRotation.value", 0);
              var stepRotation = GetValue(options, "setRotation.step", 0);
              Actions.SetRotation(entries, rotation, stepRotation);
              var scaleX = GetValue(options, "setScale.x", 1);
              var scaleY = GetValue(options, "setScale.y", scaleX);
              var stepScaleX = GetValue(options, "setScale.stepX", 0);
              var stepScaleY = GetValue(options, "setScale.stepY", 0);
              Actions.SetScale(entries, scaleX, scaleY, stepScaleX, stepScaleY);
              var originX = GetValue(options, "setOrigin.x", 0.5);
              var originY = GetValue(options, "setOrigin.y", originX);
              var stepOriginX = GetValue(options, "setOrigin.stepX", 0);
              var stepOriginY = GetValue(options, "setOrigin.stepY", 0);
              Actions.SetOrigin(entries, originX, originY, stepOriginX, stepOriginY);
              var alpha = GetValue(options, "setAlpha.value", 1);
              var stepAlpha = GetValue(options, "setAlpha.step", 0);
              Actions.SetAlpha(entries, alpha, stepAlpha);
              var depth = GetValue(options, "setDepth.value", 0);
              var stepDepth = GetValue(options, "setDepth.step", 0);
              Actions.SetDepth(entries, depth, stepDepth);
              var scrollFactorX = GetValue(options, "setScrollFactor.x", 1);
              var scrollFactorY = GetValue(options, "setScrollFactor.y", scrollFactorX);
              var stepScrollFactorX = GetValue(options, "setScrollFactor.stepX", 0);
              var stepScrollFactorY = GetValue(options, "setScrollFactor.stepY", 0);
              Actions.SetScrollFactor(entries, scrollFactorX, scrollFactorY, stepScrollFactorX, stepScrollFactorY);
              var hitArea = GetFastValue(options, "hitArea", null);
              var hitAreaCallback = GetFastValue(options, "hitAreaCallback", null);
              if (hitArea) {
                Actions.SetHitArea(entries, hitArea, hitAreaCallback);
              }
              var grid = GetFastValue(options, "gridAlign", false);
              if (grid) {
                Actions.GridAlign(entries, grid);
              }
              if (this.createMultipleCallback) {
                this.createMultipleCallback.call(this, entries);
              }
              return entries;
            },
            preUpdate: function(time, delta) {
              if (!this.runChildUpdate || this.children.size === 0) {
                return;
              }
              var temp = this.children.entries.slice();
              for (var i = 0; i < temp.length; i++) {
                var item = temp[i];
                if (item.active) {
                  item.update(time, delta);
                }
              }
            },
            add: function(child, addToScene) {
              if (addToScene === void 0) {
                addToScene = false;
              }
              if (this.isFull()) {
                return this;
              }
              this.children.set(child);
              if (this.internalCreateCallback) {
                this.internalCreateCallback.call(this, child);
              }
              if (this.createCallback) {
                this.createCallback.call(this, child);
              }
              if (addToScene) {
                this.scene.sys.displayList.add(child);
                if (child.preUpdate) {
                  this.scene.sys.updateList.add(child);
                }
              }
              child.on(Events.DESTROY, this.remove, this);
              return this;
            },
            addMultiple: function(children, addToScene) {
              if (addToScene === void 0) {
                addToScene = false;
              }
              if (Array.isArray(children)) {
                for (var i = 0; i < children.length; i++) {
                  this.add(children[i], addToScene);
                }
              }
              return this;
            },
            remove: function(child, removeFromScene, destroyChild) {
              if (removeFromScene === void 0) {
                removeFromScene = false;
              }
              if (destroyChild === void 0) {
                destroyChild = false;
              }
              if (!this.children.contains(child)) {
                return this;
              }
              this.children.delete(child);
              if (this.internalRemoveCallback) {
                this.internalRemoveCallback.call(this, child);
              }
              if (this.removeCallback) {
                this.removeCallback.call(this, child);
              }
              child.off(Events.DESTROY, this.remove, this);
              if (destroyChild) {
                child.destroy();
              } else if (removeFromScene) {
                child.scene.sys.displayList.remove(child);
                if (child.preUpdate) {
                  child.scene.sys.updateList.remove(child);
                }
              }
              return this;
            },
            clear: function(removeFromScene, destroyChild) {
              if (removeFromScene === void 0) {
                removeFromScene = false;
              }
              if (destroyChild === void 0) {
                destroyChild = false;
              }
              var children = this.children;
              for (var i = 0; i < children.size; i++) {
                var gameObject = children.entries[i];
                gameObject.off(Events.DESTROY, this.remove, this);
                if (destroyChild) {
                  gameObject.destroy();
                } else if (removeFromScene) {
                  gameObject.scene.sys.displayList.remove(gameObject);
                  if (gameObject.preUpdate) {
                    gameObject.scene.sys.updateList.remove(gameObject);
                  }
                }
              }
              this.children.clear();
              return this;
            },
            contains: function(child) {
              return this.children.contains(child);
            },
            getChildren: function() {
              return this.children.entries;
            },
            getLength: function() {
              return this.children.size;
            },
            getMatching: function(property, value, startIndex, endIndex) {
              return GetAll(this.children.entries, property, value, startIndex, endIndex);
            },
            getFirst: function(state, createIfNull, x, y, key, frame, visible) {
              return this.getHandler(true, 1, state, createIfNull, x, y, key, frame, visible);
            },
            getFirstNth: function(nth, state, createIfNull, x, y, key, frame, visible) {
              return this.getHandler(true, nth, state, createIfNull, x, y, key, frame, visible);
            },
            getLast: function(state, createIfNull, x, y, key, frame, visible) {
              return this.getHandler(false, 1, state, createIfNull, x, y, key, frame, visible);
            },
            getLastNth: function(nth, state, createIfNull, x, y, key, frame, visible) {
              return this.getHandler(false, nth, state, createIfNull, x, y, key, frame, visible);
            },
            getHandler: function(forwards, nth, state, createIfNull, x, y, key, frame, visible) {
              if (state === void 0) {
                state = false;
              }
              if (createIfNull === void 0) {
                createIfNull = false;
              }
              var gameObject;
              var i;
              var total = 0;
              var children = this.children.entries;
              if (forwards) {
                for (i = 0; i < children.length; i++) {
                  gameObject = children[i];
                  if (gameObject.active === state) {
                    total++;
                    if (total === nth) {
                      break;
                    }
                  } else {
                    gameObject = null;
                  }
                }
              } else {
                for (i = children.length - 1; i >= 0; i--) {
                  gameObject = children[i];
                  if (gameObject.active === state) {
                    total++;
                    if (total === nth) {
                      break;
                    }
                  } else {
                    gameObject = null;
                  }
                }
              }
              if (gameObject) {
                if (typeof x === "number") {
                  gameObject.x = x;
                }
                if (typeof y === "number") {
                  gameObject.y = y;
                }
                return gameObject;
              }
              if (createIfNull) {
                return this.create(x, y, key, frame, visible);
              } else {
                return null;
              }
            },
            get: function(x, y, key, frame, visible) {
              return this.getFirst(false, true, x, y, key, frame, visible);
            },
            getFirstAlive: function(createIfNull, x, y, key, frame, visible) {
              return this.getFirst(true, createIfNull, x, y, key, frame, visible);
            },
            getFirstDead: function(createIfNull, x, y, key, frame, visible) {
              return this.getFirst(false, createIfNull, x, y, key, frame, visible);
            },
            playAnimation: function(key, startFrame) {
              Actions.PlayAnimation(this.children.entries, key, startFrame);
              return this;
            },
            isFull: function() {
              if (this.maxSize === -1) {
                return false;
              } else {
                return this.children.size >= this.maxSize;
              }
            },
            countActive: function(value) {
              if (value === void 0) {
                value = true;
              }
              var total = 0;
              for (var i = 0; i < this.children.size; i++) {
                if (this.children.entries[i].active === value) {
                  total++;
                }
              }
              return total;
            },
            getTotalUsed: function() {
              return this.countActive();
            },
            getTotalFree: function() {
              var used = this.getTotalUsed();
              var capacity = this.maxSize === -1 ? 999999999999 : this.maxSize;
              return capacity - used;
            },
            setActive: function(value) {
              this.active = value;
              return this;
            },
            setName: function(value) {
              this.name = value;
              return this;
            },
            propertyValueSet: function(key, value, step, index, direction) {
              Actions.PropertyValueSet(this.children.entries, key, value, step, index, direction);
              return this;
            },
            propertyValueInc: function(key, value, step, index, direction) {
              Actions.PropertyValueInc(this.children.entries, key, value, step, index, direction);
              return this;
            },
            setX: function(value, step) {
              Actions.SetX(this.children.entries, value, step);
              return this;
            },
            setY: function(value, step) {
              Actions.SetY(this.children.entries, value, step);
              return this;
            },
            setXY: function(x, y, stepX, stepY) {
              Actions.SetXY(this.children.entries, x, y, stepX, stepY);
              return this;
            },
            incX: function(value, step) {
              Actions.IncX(this.children.entries, value, step);
              return this;
            },
            incY: function(value, step) {
              Actions.IncY(this.children.entries, value, step);
              return this;
            },
            incXY: function(x, y, stepX, stepY) {
              Actions.IncXY(this.children.entries, x, y, stepX, stepY);
              return this;
            },
            shiftPosition: function(x, y, direction) {
              Actions.ShiftPosition(this.children.entries, x, y, direction);
              return this;
            },
            angle: function(value, step) {
              Actions.Angle(this.children.entries, value, step);
              return this;
            },
            rotate: function(value, step) {
              Actions.Rotate(this.children.entries, value, step);
              return this;
            },
            rotateAround: function(point, angle) {
              Actions.RotateAround(this.children.entries, point, angle);
              return this;
            },
            rotateAroundDistance: function(point, angle, distance) {
              Actions.RotateAroundDistance(this.children.entries, point, angle, distance);
              return this;
            },
            setAlpha: function(value, step) {
              Actions.SetAlpha(this.children.entries, value, step);
              return this;
            },
            setTint: function(topLeft, topRight, bottomLeft, bottomRight) {
              Actions.SetTint(this.children.entries, topLeft, topRight, bottomLeft, bottomRight);
              return this;
            },
            setOrigin: function(originX, originY, stepX, stepY) {
              Actions.SetOrigin(this.children.entries, originX, originY, stepX, stepY);
              return this;
            },
            scaleX: function(value, step) {
              Actions.ScaleX(this.children.entries, value, step);
              return this;
            },
            scaleY: function(value, step) {
              Actions.ScaleY(this.children.entries, value, step);
              return this;
            },
            scaleXY: function(scaleX, scaleY, stepX, stepY) {
              Actions.ScaleXY(this.children.entries, scaleX, scaleY, stepX, stepY);
              return this;
            },
            setDepth: function(value, step) {
              Actions.SetDepth(this.children.entries, value, step);
              return this;
            },
            setBlendMode: function(value) {
              Actions.SetBlendMode(this.children.entries, value);
              return this;
            },
            setHitArea: function(hitArea, hitAreaCallback) {
              Actions.SetHitArea(this.children.entries, hitArea, hitAreaCallback);
              return this;
            },
            shuffle: function() {
              Actions.Shuffle(this.children.entries);
              return this;
            },
            kill: function(gameObject) {
              if (this.children.contains(gameObject)) {
                gameObject.setActive(false);
              }
            },
            killAndHide: function(gameObject) {
              if (this.children.contains(gameObject)) {
                gameObject.setActive(false);
                gameObject.setVisible(false);
              }
            },
            setVisible: function(value, index, direction) {
              Actions.SetVisible(this.children.entries, value, index, direction);
              return this;
            },
            toggleVisible: function() {
              Actions.ToggleVisible(this.children.entries);
              return this;
            },
            destroy: function(destroyChildren) {
              if (destroyChildren === void 0) {
                destroyChildren = false;
              }
              if (!this.scene || this.ignoreDestroy) {
                return;
              }
              this.clear(false, destroyChildren);
              this.scene = void 0;
              this.children = void 0;
            }
          });
          module2.exports = Group;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Utils = __webpack_require__(12);
          var FillPathWebGL = function(pipeline, calcMatrix, src, alpha, dx, dy) {
            var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
            var path = src.pathData;
            var pathIndexes = src.pathIndexes;
            for (var i = 0; i < pathIndexes.length; i += 3) {
              var p0 = pathIndexes[i] * 2;
              var p1 = pathIndexes[i + 1] * 2;
              var p2 = pathIndexes[i + 2] * 2;
              var x0 = path[p0 + 0] - dx;
              var y0 = path[p0 + 1] - dy;
              var x1 = path[p1 + 0] - dx;
              var y1 = path[p1 + 1] - dy;
              var x2 = path[p2 + 0] - dx;
              var y2 = path[p2 + 1] - dy;
              var tx0 = calcMatrix.getX(x0, y0);
              var ty0 = calcMatrix.getY(x0, y0);
              var tx1 = calcMatrix.getX(x1, y1);
              var ty1 = calcMatrix.getY(x1, y1);
              var tx2 = calcMatrix.getX(x2, y2);
              var ty2 = calcMatrix.getY(x2, y2);
              pipeline.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, fillTintColor, fillTintColor, fillTintColor);
            }
          };
          module2.exports = FillPathWebGL;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Contains = function(triangle, x, y) {
            var v0x = triangle.x3 - triangle.x1;
            var v0y = triangle.y3 - triangle.y1;
            var v1x = triangle.x2 - triangle.x1;
            var v1y = triangle.y2 - triangle.y1;
            var v2x = x - triangle.x1;
            var v2y = y - triangle.y1;
            var dot00 = v0x * v0x + v0y * v0y;
            var dot01 = v0x * v1x + v0y * v1y;
            var dot02 = v0x * v2x + v0y * v2y;
            var dot11 = v1x * v1x + v1y * v1y;
            var dot12 = v1x * v2x + v1y * v2y;
            var b = dot00 * dot11 - dot01 * dot01;
            var inv = b === 0 ? 0 : 1 / b;
            var u = (dot11 * dot02 - dot01 * dot12) * inv;
            var v = (dot00 * dot12 - dot01 * dot02) * inv;
            return u >= 0 && v >= 0 && u + v < 1;
          };
          module2.exports = Contains;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Rectangle = __webpack_require__(10);
          var RectangleToRectangle = __webpack_require__(114);
          var Vector29 = __webpack_require__(3);
          function GetLength(x1, y1, x2, y2) {
            var x = x1 - x2;
            var y = y1 - y2;
            var magnitude = x * x + y * y;
            return Math.sqrt(magnitude);
          }
          var Face = new Class({
            initialize: function Face2(vertex1, vertex2, vertex3) {
              this.vertex1 = vertex1;
              this.vertex2 = vertex2;
              this.vertex3 = vertex3;
              this.bounds = new Rectangle();
              this._inCenter = new Vector29();
            },
            getInCenter: function(local) {
              if (local === void 0) {
                local = true;
              }
              var v1 = this.vertex1;
              var v2 = this.vertex2;
              var v3 = this.vertex3;
              var v1x;
              var v1y;
              var v2x;
              var v2y;
              var v3x;
              var v3y;
              if (local) {
                v1x = v1.x;
                v1y = v1.y;
                v2x = v2.x;
                v2y = v2.y;
                v3x = v3.x;
                v3y = v3.y;
              } else {
                v1x = v1.vx;
                v1y = v1.vy;
                v2x = v2.vx;
                v2y = v2.vy;
                v3x = v3.vx;
                v3y = v3.vy;
              }
              var d1 = GetLength(v3x, v3y, v2x, v2y);
              var d2 = GetLength(v1x, v1y, v3x, v3y);
              var d3 = GetLength(v2x, v2y, v1x, v1y);
              var p = d1 + d2 + d3;
              return this._inCenter.set((v1x * d1 + v2x * d2 + v3x * d3) / p, (v1y * d1 + v2y * d2 + v3y * d3) / p);
            },
            contains: function(x, y, calcMatrix) {
              var vertex1 = this.vertex1;
              var vertex2 = this.vertex2;
              var vertex3 = this.vertex3;
              var v1x = vertex1.vx;
              var v1y = vertex1.vy;
              var v2x = vertex2.vx;
              var v2y = vertex2.vy;
              var v3x = vertex3.vx;
              var v3y = vertex3.vy;
              if (calcMatrix) {
                var a = calcMatrix.a;
                var b = calcMatrix.b;
                var c = calcMatrix.c;
                var d = calcMatrix.d;
                var e = calcMatrix.e;
                var f = calcMatrix.f;
                v1x = vertex1.vx * a + vertex1.vy * c + e;
                v1y = vertex1.vx * b + vertex1.vy * d + f;
                v2x = vertex2.vx * a + vertex2.vy * c + e;
                v2y = vertex2.vx * b + vertex2.vy * d + f;
                v3x = vertex3.vx * a + vertex3.vy * c + e;
                v3y = vertex3.vx * b + vertex3.vy * d + f;
              }
              var t0x = v3x - v1x;
              var t0y = v3y - v1y;
              var t1x = v2x - v1x;
              var t1y = v2y - v1y;
              var t2x = x - v1x;
              var t2y = y - v1y;
              var dot00 = t0x * t0x + t0y * t0y;
              var dot01 = t0x * t1x + t0y * t1y;
              var dot02 = t0x * t2x + t0y * t2y;
              var dot11 = t1x * t1x + t1y * t1y;
              var dot12 = t1x * t2x + t1y * t2y;
              var bc = dot00 * dot11 - dot01 * dot01;
              var inv = bc === 0 ? 0 : 1 / bc;
              var u = (dot11 * dot02 - dot01 * dot12) * inv;
              var v = (dot00 * dot12 - dot01 * dot02) * inv;
              return u >= 0 && v >= 0 && u + v < 1;
            },
            isCounterClockwise: function(z) {
              var v1 = this.vertex1;
              var v2 = this.vertex2;
              var v3 = this.vertex3;
              var d = (v2.vx - v1.vx) * (v3.vy - v1.vy) - (v2.vy - v1.vy) * (v3.vx - v1.vx);
              return z <= 0 ? d >= 0 : d < 0;
            },
            load: function(F32, U32, offset, textureUnit, tintEffect) {
              offset = this.vertex1.load(F32, U32, offset, textureUnit, tintEffect);
              offset = this.vertex2.load(F32, U32, offset, textureUnit, tintEffect);
              offset = this.vertex3.load(F32, U32, offset, textureUnit, tintEffect);
              return offset;
            },
            transformCoordinatesLocal: function(transformMatrix, width, height, cameraZ) {
              this.vertex1.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
              this.vertex2.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
              this.vertex3.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
              return this;
            },
            updateBounds: function() {
              var v1 = this.vertex1;
              var v2 = this.vertex2;
              var v3 = this.vertex3;
              var bounds = this.bounds;
              bounds.x = Math.min(v1.vx, v2.vx, v3.vx);
              bounds.y = Math.min(v1.vy, v2.vy, v3.vy);
              bounds.width = Math.max(v1.vx, v2.vx, v3.vx) - bounds.x;
              bounds.height = Math.max(v1.vy, v2.vy, v3.vy) - bounds.y;
              return this;
            },
            isInView: function(camera, hideCCW, z, alpha, a, b, c, d, e, f, roundPixels) {
              var v1 = this.vertex1.update(a, b, c, d, e, f, roundPixels, alpha);
              var v2 = this.vertex2.update(a, b, c, d, e, f, roundPixels, alpha);
              var v3 = this.vertex3.update(a, b, c, d, e, f, roundPixels, alpha);
              if (v1.ta <= 0 && v2.ta <= 0 && v3.ta <= 0) {
                return false;
              }
              if (hideCCW && !this.isCounterClockwise(z)) {
                return false;
              }
              var bounds = this.bounds;
              bounds.x = Math.min(v1.tx, v2.tx, v3.tx);
              bounds.y = Math.min(v1.ty, v2.ty, v3.ty);
              bounds.width = Math.max(v1.tx, v2.tx, v3.tx) - bounds.x;
              bounds.height = Math.max(v1.ty, v2.ty, v3.ty) - bounds.y;
              return RectangleToRectangle(bounds, camera.worldView);
            },
            translate: function(x, y) {
              if (y === void 0) {
                y = 0;
              }
              var v1 = this.vertex1;
              var v2 = this.vertex2;
              var v3 = this.vertex3;
              v1.x += x;
              v1.y += y;
              v2.x += x;
              v2.y += y;
              v3.x += x;
              v3.y += y;
              return this;
            },
            x: {
              get: function() {
                return this.getInCenter().x;
              },
              set: function(value) {
                var current = this.getInCenter();
                this.translate(value - current.x, 0);
              }
            },
            y: {
              get: function() {
                return this.getInCenter().y;
              },
              set: function(value) {
                var current = this.getInCenter();
                this.translate(0, value - current.y);
              }
            },
            alpha: {
              get: function() {
                var v1 = this.vertex1;
                var v2 = this.vertex2;
                var v3 = this.vertex3;
                return (v1.alpha + v2.alpha + v3.alpha) / 3;
              },
              set: function(value) {
                this.vertex1.alpha = value;
                this.vertex2.alpha = value;
                this.vertex3.alpha = value;
              }
            },
            depth: {
              get: function() {
                var v1 = this.vertex1;
                var v2 = this.vertex2;
                var v3 = this.vertex3;
                return (v1.vz + v2.vz + v3.vz) / 3;
              }
            },
            destroy: function() {
              this.vertex1 = null;
              this.vertex2 = null;
              this.vertex3 = null;
            }
          });
          module2.exports = Face;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RectangleToRectangle = function(rectA, rectB) {
            if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0) {
              return false;
            }
            return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
          };
          module2.exports = RectangleToRectangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Utils = __webpack_require__(12);
          var Vector3 = __webpack_require__(38);
          var Vertex = new Class({
            Extends: Vector3,
            initialize: function Vertex2(x, y, z, u, v, color, alpha, nx, ny, nz) {
              if (color === void 0) {
                color = 16777215;
              }
              if (alpha === void 0) {
                alpha = 1;
              }
              if (nx === void 0) {
                nx = 0;
              }
              if (ny === void 0) {
                ny = 0;
              }
              if (nz === void 0) {
                nz = 0;
              }
              Vector3.call(this, x, y, z);
              this.vx = 0;
              this.vy = 0;
              this.vz = 0;
              this.nx = nx;
              this.ny = ny;
              this.nz = nz;
              this.u = u;
              this.v = v;
              this.color = color;
              this.alpha = alpha;
              this.tx = 0;
              this.ty = 0;
              this.ta = 0;
            },
            setUVs: function(u, v) {
              this.u = u;
              this.v = v;
              return this;
            },
            transformCoordinatesLocal: function(transformMatrix, width, height, cameraZ) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var m = transformMatrix.val;
              var tx = x * m[0] + y * m[4] + z * m[8] + m[12];
              var ty = x * m[1] + y * m[5] + z * m[9] + m[13];
              var tz = x * m[2] + y * m[6] + z * m[10] + m[14];
              var tw = x * m[3] + y * m[7] + z * m[11] + m[15];
              this.vx = tx / tw * width;
              this.vy = -(ty / tw) * height;
              if (cameraZ <= 0) {
                this.vz = tz / tw;
              } else {
                this.vz = -(tz / tw);
              }
            },
            update: function(a, b, c, d, e, f, roundPixels, alpha) {
              var tx = this.vx * a + this.vy * c + e;
              var ty = this.vx * b + this.vy * d + f;
              if (roundPixels) {
                tx = Math.round(tx);
                ty = Math.round(ty);
              }
              this.tx = tx;
              this.ty = ty;
              this.ta = this.alpha * alpha;
              return this;
            },
            load: function(F32, U32, offset, textureUnit, tintEffect) {
              F32[++offset] = this.tx;
              F32[++offset] = this.ty;
              F32[++offset] = this.u;
              F32[++offset] = this.v;
              F32[++offset] = textureUnit;
              F32[++offset] = tintEffect;
              U32[++offset] = Utils.getTintAppendFloatAlpha(this.color, this.ta);
              return offset;
            }
          });
          module2.exports = Vertex;
        },
        function(module2, exports2) {
          var Vector = {};
          module2.exports = Vector;
          (function() {
            Vector.create = function(x, y) {
              return {x: x || 0, y: y || 0};
            };
            Vector.clone = function(vector) {
              return {x: vector.x, y: vector.y};
            };
            Vector.magnitude = function(vector) {
              return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
            };
            Vector.magnitudeSquared = function(vector) {
              return vector.x * vector.x + vector.y * vector.y;
            };
            Vector.rotate = function(vector, angle, output) {
              var cos = Math.cos(angle), sin = Math.sin(angle);
              if (!output)
                output = {};
              var x = vector.x * cos - vector.y * sin;
              output.y = vector.x * sin + vector.y * cos;
              output.x = x;
              return output;
            };
            Vector.rotateAbout = function(vector, angle, point, output) {
              var cos = Math.cos(angle), sin = Math.sin(angle);
              if (!output)
                output = {};
              var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);
              output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);
              output.x = x;
              return output;
            };
            Vector.normalise = function(vector) {
              var magnitude = Vector.magnitude(vector);
              if (magnitude === 0)
                return {x: 0, y: 0};
              return {x: vector.x / magnitude, y: vector.y / magnitude};
            };
            Vector.dot = function(vectorA, vectorB) {
              return vectorA.x * vectorB.x + vectorA.y * vectorB.y;
            };
            Vector.cross = function(vectorA, vectorB) {
              return vectorA.x * vectorB.y - vectorA.y * vectorB.x;
            };
            Vector.cross3 = function(vectorA, vectorB, vectorC) {
              return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);
            };
            Vector.add = function(vectorA, vectorB, output) {
              if (!output)
                output = {};
              output.x = vectorA.x + vectorB.x;
              output.y = vectorA.y + vectorB.y;
              return output;
            };
            Vector.sub = function(vectorA, vectorB, output) {
              if (!output)
                output = {};
              output.x = vectorA.x - vectorB.x;
              output.y = vectorA.y - vectorB.y;
              return output;
            };
            Vector.mult = function(vector, scalar) {
              return {x: vector.x * scalar, y: vector.y * scalar};
            };
            Vector.div = function(vector, scalar) {
              return {x: vector.x / scalar, y: vector.y / scalar};
            };
            Vector.perp = function(vector, negate) {
              negate = negate === true ? -1 : 1;
              return {x: negate * -vector.y, y: negate * vector.x};
            };
            Vector.neg = function(vector) {
              return {x: -vector.x, y: -vector.y};
            };
            Vector.angle = function(vectorA, vectorB) {
              return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);
            };
            Vector._temp = [
              Vector.create(),
              Vector.create(),
              Vector.create(),
              Vector.create(),
              Vector.create(),
              Vector.create()
            ];
          })();
        },
        function(module2, exports2) {
          var Bounds = {};
          module2.exports = Bounds;
          (function() {
            Bounds.create = function(vertices) {
              var bounds = {
                min: {x: 0, y: 0},
                max: {x: 0, y: 0}
              };
              if (vertices)
                Bounds.update(bounds, vertices);
              return bounds;
            };
            Bounds.update = function(bounds, vertices, velocity) {
              bounds.min.x = Infinity;
              bounds.max.x = -Infinity;
              bounds.min.y = Infinity;
              bounds.max.y = -Infinity;
              for (var i = 0; i < vertices.length; i++) {
                var vertex = vertices[i];
                if (vertex.x > bounds.max.x)
                  bounds.max.x = vertex.x;
                if (vertex.x < bounds.min.x)
                  bounds.min.x = vertex.x;
                if (vertex.y > bounds.max.y)
                  bounds.max.y = vertex.y;
                if (vertex.y < bounds.min.y)
                  bounds.min.y = vertex.y;
              }
              if (velocity) {
                if (velocity.x > 0) {
                  bounds.max.x += velocity.x;
                } else {
                  bounds.min.x += velocity.x;
                }
                if (velocity.y > 0) {
                  bounds.max.y += velocity.y;
                } else {
                  bounds.min.y += velocity.y;
                }
              }
            };
            Bounds.contains = function(bounds, point) {
              return point.x >= bounds.min.x && point.x <= bounds.max.x && point.y >= bounds.min.y && point.y <= bounds.max.y;
            };
            Bounds.overlaps = function(boundsA, boundsB) {
              return boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y;
            };
            Bounds.translate = function(bounds, vector) {
              bounds.min.x += vector.x;
              bounds.max.x += vector.x;
              bounds.min.y += vector.y;
              bounds.max.y += vector.y;
            };
            Bounds.shift = function(bounds, position) {
              var deltaX = bounds.max.x - bounds.min.x, deltaY = bounds.max.y - bounds.min.y;
              bounds.min.x = position.x;
              bounds.max.x = position.x + deltaX;
              bounds.min.y = position.y;
              bounds.max.y = position.y + deltaY;
            };
          })();
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var IsInLayerBounds = function(tileX, tileY, layer) {
            return tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height;
          };
          module2.exports = IsInLayerBounds;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(29);
          var GetFastValue = __webpack_require__(2);
          var LayerData = new Class({
            initialize: function LayerData2(config2) {
              if (config2 === void 0) {
                config2 = {};
              }
              this.name = GetFastValue(config2, "name", "layer");
              this.x = GetFastValue(config2, "x", 0);
              this.y = GetFastValue(config2, "y", 0);
              this.width = GetFastValue(config2, "width", 0);
              this.height = GetFastValue(config2, "height", 0);
              this.tileWidth = GetFastValue(config2, "tileWidth", 0);
              this.tileHeight = GetFastValue(config2, "tileHeight", 0);
              this.baseTileWidth = GetFastValue(config2, "baseTileWidth", this.tileWidth);
              this.baseTileHeight = GetFastValue(config2, "baseTileHeight", this.tileHeight);
              this.orientation = GetFastValue(config2, "orientation", CONST.ORTHOGONAL);
              this.widthInPixels = GetFastValue(config2, "widthInPixels", this.width * this.baseTileWidth);
              this.heightInPixels = GetFastValue(config2, "heightInPixels", this.height * this.baseTileHeight);
              this.alpha = GetFastValue(config2, "alpha", 1);
              this.visible = GetFastValue(config2, "visible", true);
              this.properties = GetFastValue(config2, "properties", []);
              this.indexes = GetFastValue(config2, "indexes", []);
              this.collideIndexes = GetFastValue(config2, "collideIndexes", []);
              this.callbacks = GetFastValue(config2, "callbacks", []);
              this.bodies = GetFastValue(config2, "bodies", []);
              this.data = GetFastValue(config2, "data", []);
              this.tilemapLayer = GetFastValue(config2, "tilemapLayer", null);
              this.hexSideLength = GetFastValue(config2, "hexSideLength", 0);
            }
          });
          module2.exports = LayerData;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(29);
          var GetFastValue = __webpack_require__(2);
          var MapData = new Class({
            initialize: function MapData2(config2) {
              if (config2 === void 0) {
                config2 = {};
              }
              this.name = GetFastValue(config2, "name", "map");
              this.width = GetFastValue(config2, "width", 0);
              this.height = GetFastValue(config2, "height", 0);
              this.infinite = GetFastValue(config2, "infinite", false);
              this.tileWidth = GetFastValue(config2, "tileWidth", 0);
              this.tileHeight = GetFastValue(config2, "tileHeight", 0);
              this.widthInPixels = GetFastValue(config2, "widthInPixels", this.width * this.tileWidth);
              this.heightInPixels = GetFastValue(config2, "heightInPixels", this.height * this.tileHeight);
              this.format = GetFastValue(config2, "format", null);
              this.orientation = GetFastValue(config2, "orientation", CONST.ORTHOGONAL);
              this.renderOrder = GetFastValue(config2, "renderOrder", "right-down");
              this.version = GetFastValue(config2, "version", "1");
              this.properties = GetFastValue(config2, "properties", {});
              this.layers = GetFastValue(config2, "layers", []);
              this.images = GetFastValue(config2, "images", []);
              this.objects = GetFastValue(config2, "objects", {});
              this.collision = GetFastValue(config2, "collision", {});
              this.tilesets = GetFastValue(config2, "tilesets", []);
              this.imageCollections = GetFastValue(config2, "imageCollections", []);
              this.tiles = GetFastValue(config2, "tiles", []);
              this.hexSideLength = GetFastValue(config2, "hexSideLength", 0);
            }
          });
          module2.exports = MapData;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Tileset = new Class({
            initialize: function Tileset2(name, firstgid, tileWidth, tileHeight, tileMargin, tileSpacing, tileProperties, tileData) {
              if (tileWidth === void 0 || tileWidth <= 0) {
                tileWidth = 32;
              }
              if (tileHeight === void 0 || tileHeight <= 0) {
                tileHeight = 32;
              }
              if (tileMargin === void 0) {
                tileMargin = 0;
              }
              if (tileSpacing === void 0) {
                tileSpacing = 0;
              }
              if (tileProperties === void 0) {
                tileProperties = {};
              }
              if (tileData === void 0) {
                tileData = {};
              }
              this.name = name;
              this.firstgid = firstgid;
              this.tileWidth = tileWidth;
              this.tileHeight = tileHeight;
              this.tileMargin = tileMargin;
              this.tileSpacing = tileSpacing;
              this.tileProperties = tileProperties;
              this.tileData = tileData;
              this.image = null;
              this.glTexture = null;
              this.rows = 0;
              this.columns = 0;
              this.total = 0;
              this.texCoordinates = [];
            },
            getTileProperties: function(tileIndex) {
              if (!this.containsTileIndex(tileIndex)) {
                return null;
              }
              return this.tileProperties[tileIndex - this.firstgid];
            },
            getTileData: function(tileIndex) {
              if (!this.containsTileIndex(tileIndex)) {
                return null;
              }
              return this.tileData[tileIndex - this.firstgid];
            },
            getTileCollisionGroup: function(tileIndex) {
              var data = this.getTileData(tileIndex);
              return data && data.objectgroup ? data.objectgroup : null;
            },
            containsTileIndex: function(tileIndex) {
              return tileIndex >= this.firstgid && tileIndex < this.firstgid + this.total;
            },
            getTileTextureCoordinates: function(tileIndex) {
              if (!this.containsTileIndex(tileIndex)) {
                return null;
              }
              return this.texCoordinates[tileIndex - this.firstgid];
            },
            setImage: function(texture) {
              this.image = texture;
              this.glTexture = texture.get().source.glTexture;
              this.updateTileData(this.image.source[0].width, this.image.source[0].height);
              return this;
            },
            setTileSize: function(tileWidth, tileHeight) {
              if (tileWidth !== void 0) {
                this.tileWidth = tileWidth;
              }
              if (tileHeight !== void 0) {
                this.tileHeight = tileHeight;
              }
              if (this.image) {
                this.updateTileData(this.image.source[0].width, this.image.source[0].height);
              }
              return this;
            },
            setSpacing: function(margin, spacing) {
              if (margin !== void 0) {
                this.tileMargin = margin;
              }
              if (spacing !== void 0) {
                this.tileSpacing = spacing;
              }
              if (this.image) {
                this.updateTileData(this.image.source[0].width, this.image.source[0].height);
              }
              return this;
            },
            updateTileData: function(imageWidth, imageHeight) {
              var rowCount = (imageHeight - this.tileMargin * 2 + this.tileSpacing) / (this.tileHeight + this.tileSpacing);
              var colCount = (imageWidth - this.tileMargin * 2 + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
              if (rowCount % 1 !== 0 || colCount % 1 !== 0) {
                console.warn("Image tile area not tile size multiple in: " + this.name);
              }
              rowCount = Math.floor(rowCount);
              colCount = Math.floor(colCount);
              this.rows = rowCount;
              this.columns = colCount;
              this.total = rowCount * colCount;
              this.texCoordinates.length = 0;
              var tx = this.tileMargin;
              var ty = this.tileMargin;
              for (var y = 0; y < this.rows; y++) {
                for (var x = 0; x < this.columns; x++) {
                  this.texCoordinates.push({x: tx, y: ty});
                  tx += this.tileWidth + this.tileSpacing;
                }
                tx = this.tileMargin;
                ty += this.tileHeight + this.tileSpacing;
              }
              return this;
            }
          });
          module2.exports = Tileset;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ALIGN_CONST = {
            TOP_LEFT: 0,
            TOP_CENTER: 1,
            TOP_RIGHT: 2,
            LEFT_TOP: 3,
            LEFT_CENTER: 4,
            LEFT_BOTTOM: 5,
            CENTER: 6,
            RIGHT_TOP: 7,
            RIGHT_CENTER: 8,
            RIGHT_BOTTOM: 9,
            BOTTOM_LEFT: 10,
            BOTTOM_CENTER: 11,
            BOTTOM_RIGHT: 12
          };
          module2.exports = ALIGN_CONST;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Equal = function(a, b, epsilon) {
            if (epsilon === void 0) {
              epsilon = 1e-4;
            }
            return Math.abs(a - b) < epsilon;
          };
          module2.exports = Equal;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var ImageRender = __webpack_require__(1062);
          var Image2 = new Class({
            Extends: GameObject,
            Mixins: [
              Components.Alpha,
              Components.BlendMode,
              Components.Depth,
              Components.Flip,
              Components.GetBounds,
              Components.Mask,
              Components.Origin,
              Components.Pipeline,
              Components.ScrollFactor,
              Components.Size,
              Components.TextureCrop,
              Components.Tint,
              Components.Transform,
              Components.Visible,
              ImageRender
            ],
            initialize: function Image3(scene, x, y, texture, frame) {
              GameObject.call(this, scene, "Image");
              this._crop = this.resetCropObject();
              this.setTexture(texture, frame);
              this.setPosition(x, y);
              this.setSizeToFrame();
              this.setOriginFromFrame();
              this.initPipeline();
            }
          });
          module2.exports = Image2;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var HasValue = function(source, key) {
            return source.hasOwnProperty(key);
          };
          module2.exports = HasValue;
        },
        function(module2, exports2, __webpack_require__) {
          var Bodies = {};
          module2.exports = Bodies;
          var Vertices = __webpack_require__(94);
          var Common = __webpack_require__(50);
          var Body = __webpack_require__(71);
          var Bounds = __webpack_require__(117);
          var Vector = __webpack_require__(116);
          var decomp = __webpack_require__(1487);
          (function() {
            Bodies.rectangle = function(x, y, width, height, options) {
              options = options || {};
              var rectangle = {
                label: "Rectangle Body",
                position: {x, y},
                vertices: Vertices.fromPath("L 0 0 L " + width + " 0 L " + width + " " + height + " L 0 " + height)
              };
              if (options.chamfer) {
                var chamfer = options.chamfer;
                rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                delete options.chamfer;
              }
              return Body.create(Common.extend({}, rectangle, options));
            };
            Bodies.trapezoid = function(x, y, width, height, slope, options) {
              options = options || {};
              slope *= 0.5;
              var roof = (1 - slope * 2) * width;
              var x1 = width * slope, x2 = x1 + roof, x3 = x2 + x1, verticesPath;
              if (slope < 0.5) {
                verticesPath = "L 0 0 L " + x1 + " " + -height + " L " + x2 + " " + -height + " L " + x3 + " 0";
              } else {
                verticesPath = "L 0 0 L " + x2 + " " + -height + " L " + x3 + " 0";
              }
              var trapezoid = {
                label: "Trapezoid Body",
                position: {x, y},
                vertices: Vertices.fromPath(verticesPath)
              };
              if (options.chamfer) {
                var chamfer = options.chamfer;
                trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                delete options.chamfer;
              }
              return Body.create(Common.extend({}, trapezoid, options));
            };
            Bodies.circle = function(x, y, radius, options, maxSides) {
              options = options || {};
              var circle = {
                label: "Circle Body",
                circleRadius: radius
              };
              maxSides = maxSides || 25;
              var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));
              if (sides % 2 === 1)
                sides += 1;
              return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));
            };
            Bodies.polygon = function(x, y, sides, radius, options) {
              options = options || {};
              if (sides < 3)
                return Bodies.circle(x, y, radius, options);
              var theta = 2 * Math.PI / sides, path = "", offset = theta * 0.5;
              for (var i = 0; i < sides; i += 1) {
                var angle = offset + i * theta, xx = Math.cos(angle) * radius, yy = Math.sin(angle) * radius;
                path += "L " + xx.toFixed(3) + " " + yy.toFixed(3) + " ";
              }
              var polygon = {
                label: "Polygon Body",
                position: {x, y},
                vertices: Vertices.fromPath(path)
              };
              if (options.chamfer) {
                var chamfer = options.chamfer;
                polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                delete options.chamfer;
              }
              return Body.create(Common.extend({}, polygon, options));
            };
            Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
              var body, parts, isConvex, vertices, i, j, k, v, z;
              options = options || {};
              parts = [];
              flagInternal = typeof flagInternal !== "undefined" ? flagInternal : false;
              removeCollinear = typeof removeCollinear !== "undefined" ? removeCollinear : 0.01;
              minimumArea = typeof minimumArea !== "undefined" ? minimumArea : 10;
              if (!decomp) {
                Common.warn("Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.");
              }
              if (!Common.isArray(vertexSets[0])) {
                vertexSets = [vertexSets];
              }
              for (v = 0; v < vertexSets.length; v += 1) {
                vertices = vertexSets[v];
                isConvex = Vertices.isConvex(vertices);
                if (isConvex || !decomp) {
                  if (isConvex) {
                    vertices = Vertices.clockwiseSort(vertices);
                  } else {
                    vertices = Vertices.hull(vertices);
                  }
                  parts.push({
                    position: {x, y},
                    vertices
                  });
                } else {
                  var concave = vertices.map(function(vertex) {
                    return [vertex.x, vertex.y];
                  });
                  decomp.makeCCW(concave);
                  if (removeCollinear !== false)
                    decomp.removeCollinearPoints(concave, removeCollinear);
                  var decomposed = decomp.quickDecomp(concave);
                  for (i = 0; i < decomposed.length; i++) {
                    var chunk = decomposed[i];
                    var chunkVertices = chunk.map(function(vertices2) {
                      return {
                        x: vertices2[0],
                        y: vertices2[1]
                      };
                    });
                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)
                      continue;
                    parts.push({
                      position: Vertices.centre(chunkVertices),
                      vertices: chunkVertices
                    });
                  }
                }
              }
              for (i = 0; i < parts.length; i++) {
                parts[i] = Body.create(Common.extend(parts[i], options));
              }
              if (flagInternal) {
                Bodies.flagCoincidentParts(parts, 5);
              }
              if (parts.length > 1) {
                body = Body.create(Common.extend({parts: parts.slice(0)}, options));
                Body.setPosition(body, {x, y});
                return body;
              } else {
                return parts[0];
              }
            };
            Bodies.flagCoincidentParts = function(parts, maxDistance) {
              if (maxDistance === void 0) {
                maxDistance = 5;
              }
              for (var i = 0; i < parts.length; i++) {
                var partA = parts[i];
                for (var j = i + 1; j < parts.length; j++) {
                  var partB = parts[j];
                  if (Bounds.overlaps(partA.bounds, partB.bounds)) {
                    var pav = partA.vertices;
                    var pbv = partB.vertices;
                    for (var k = 0; k < partA.vertices.length; k++) {
                      for (var z = 0; z < partB.vertices.length; z++) {
                        var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z]));
                        var db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));
                        if (da < maxDistance && db < maxDistance) {
                          pav[k].isInternal = true;
                          pbv[z].isInternal = true;
                        }
                      }
                    }
                  }
                }
              }
              return parts;
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BlendModes = __webpack_require__(34);
          var Circle = __webpack_require__(62);
          var CircleContains = __webpack_require__(63);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var Rectangle = __webpack_require__(10);
          var RectangleContains = __webpack_require__(56);
          var Zone = new Class({
            Extends: GameObject,
            Mixins: [
              Components.Depth,
              Components.GetBounds,
              Components.Origin,
              Components.Transform,
              Components.ScrollFactor,
              Components.Visible
            ],
            initialize: function Zone2(scene, x, y, width, height) {
              if (width === void 0) {
                width = 1;
              }
              if (height === void 0) {
                height = width;
              }
              GameObject.call(this, scene, "Zone");
              this.setPosition(x, y);
              this.width = width;
              this.height = height;
              this.blendMode = BlendModes.NORMAL;
              this.updateDisplayOrigin();
            },
            displayWidth: {
              get: function() {
                return this.scaleX * this.width;
              },
              set: function(value) {
                this.scaleX = value / this.width;
              }
            },
            displayHeight: {
              get: function() {
                return this.scaleY * this.height;
              },
              set: function(value) {
                this.scaleY = value / this.height;
              }
            },
            setSize: function(width, height, resizeInput) {
              if (resizeInput === void 0) {
                resizeInput = true;
              }
              this.width = width;
              this.height = height;
              this.updateDisplayOrigin();
              var input = this.input;
              if (resizeInput && input && !input.customHitArea) {
                input.hitArea.width = width;
                input.hitArea.height = height;
              }
              return this;
            },
            setDisplaySize: function(width, height) {
              this.displayWidth = width;
              this.displayHeight = height;
              return this;
            },
            setCircleDropZone: function(radius) {
              return this.setDropZone(new Circle(0, 0, radius), CircleContains);
            },
            setRectangleDropZone: function(width, height) {
              return this.setDropZone(new Rectangle(0, 0, width, height), RectangleContains);
            },
            setDropZone: function(hitArea, hitAreaCallback) {
              if (hitArea === void 0) {
                this.setRectangleDropZone(this.width, this.height);
              } else if (!this.input) {
                this.setInteractive(hitArea, hitAreaCallback, true);
              }
              return this;
            },
            setAlpha: function() {
            },
            setBlendMode: function() {
            },
            renderCanvas: function() {
            },
            renderWebGL: function() {
            }
          });
          module2.exports = Zone;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Perimeter = function(rect) {
            return 2 * (rect.width + rect.height);
          };
          module2.exports = Perimeter;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Shuffle = function(array) {
            for (var i = array.length - 1; i > 0; i--) {
              var j = Math.floor(Math.random() * (i + 1));
              var temp = array[i];
              array[i] = array[j];
              array[j] = temp;
            }
            return array;
          };
          module2.exports = Shuffle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            ADD_ANIMATION: __webpack_require__(700),
            ANIMATION_COMPLETE: __webpack_require__(701),
            ANIMATION_COMPLETE_KEY: __webpack_require__(702),
            ANIMATION_REPEAT: __webpack_require__(703),
            ANIMATION_RESTART: __webpack_require__(704),
            ANIMATION_START: __webpack_require__(705),
            ANIMATION_STOP: __webpack_require__(706),
            ANIMATION_UPDATE: __webpack_require__(707),
            PAUSE_ALL: __webpack_require__(708),
            REMOVE_ANIMATION: __webpack_require__(709),
            RESUME_ALL: __webpack_require__(710)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var DegToRad = __webpack_require__(35);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(36);
          var Rectangle = __webpack_require__(10);
          var TransformMatrix = __webpack_require__(25);
          var ValueToColor = __webpack_require__(184);
          var Vector29 = __webpack_require__(3);
          var BaseCamera = new Class({
            Extends: EventEmitter,
            Mixins: [
              Components.Alpha,
              Components.Visible
            ],
            initialize: function BaseCamera2(x, y, width, height) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 0;
              }
              if (height === void 0) {
                height = 0;
              }
              EventEmitter.call(this);
              this.scene;
              this.sceneManager;
              this.scaleManager;
              this.cameraManager;
              this.id = 0;
              this.name = "";
              this.roundPixels = false;
              this.useBounds = false;
              this.worldView = new Rectangle();
              this.dirty = true;
              this._x = x;
              this._y = y;
              this._width = width;
              this._height = height;
              this._bounds = new Rectangle();
              this._scrollX = 0;
              this._scrollY = 0;
              this._zoomX = 1;
              this._zoomY = 1;
              this._rotation = 0;
              this.matrix = new TransformMatrix();
              this.transparent = true;
              this.backgroundColor = ValueToColor("rgba(0,0,0,0)");
              this.disableCull = false;
              this.culledObjects = [];
              this.midPoint = new Vector29(width / 2, height / 2);
              this.originX = 0.5;
              this.originY = 0.5;
              this._customViewport = false;
              this.mask = null;
              this._maskCamera = null;
              this.renderList = [];
            },
            addToRenderList: function(child) {
              this.renderList.push(child);
            },
            setOrigin: function(x, y) {
              if (x === void 0) {
                x = 0.5;
              }
              if (y === void 0) {
                y = x;
              }
              this.originX = x;
              this.originY = y;
              return this;
            },
            getScroll: function(x, y, out) {
              if (out === void 0) {
                out = new Vector29();
              }
              var originX = this.width * 0.5;
              var originY = this.height * 0.5;
              out.x = x - originX;
              out.y = y - originY;
              if (this.useBounds) {
                out.x = this.clampX(out.x);
                out.y = this.clampY(out.y);
              }
              return out;
            },
            centerOnX: function(x) {
              var originX = this.width * 0.5;
              this.midPoint.x = x;
              this.scrollX = x - originX;
              if (this.useBounds) {
                this.scrollX = this.clampX(this.scrollX);
              }
              return this;
            },
            centerOnY: function(y) {
              var originY = this.height * 0.5;
              this.midPoint.y = y;
              this.scrollY = y - originY;
              if (this.useBounds) {
                this.scrollY = this.clampY(this.scrollY);
              }
              return this;
            },
            centerOn: function(x, y) {
              this.centerOnX(x);
              this.centerOnY(y);
              return this;
            },
            centerToBounds: function() {
              if (this.useBounds) {
                var bounds = this._bounds;
                var originX = this.width * 0.5;
                var originY = this.height * 0.5;
                this.midPoint.set(bounds.centerX, bounds.centerY);
                this.scrollX = bounds.centerX - originX;
                this.scrollY = bounds.centerY - originY;
              }
              return this;
            },
            centerToSize: function() {
              this.scrollX = this.width * 0.5;
              this.scrollY = this.height * 0.5;
              return this;
            },
            cull: function(renderableObjects) {
              if (this.disableCull) {
                return renderableObjects;
              }
              var cameraMatrix = this.matrix.matrix;
              var mva = cameraMatrix[0];
              var mvb = cameraMatrix[1];
              var mvc = cameraMatrix[2];
              var mvd = cameraMatrix[3];
              var determinant = mva * mvd - mvb * mvc;
              if (!determinant) {
                return renderableObjects;
              }
              var mve = cameraMatrix[4];
              var mvf = cameraMatrix[5];
              var scrollX = this.scrollX;
              var scrollY = this.scrollY;
              var cameraW = this.width;
              var cameraH = this.height;
              var cullTop = this.y;
              var cullBottom = cullTop + cameraH;
              var cullLeft = this.x;
              var cullRight = cullLeft + cameraW;
              var culledObjects = this.culledObjects;
              var length = renderableObjects.length;
              determinant = 1 / determinant;
              culledObjects.length = 0;
              for (var index = 0; index < length; ++index) {
                var object = renderableObjects[index];
                if (!object.hasOwnProperty("width") || object.parentContainer) {
                  culledObjects.push(object);
                  continue;
                }
                var objectW = object.width;
                var objectH = object.height;
                var objectX = object.x - scrollX * object.scrollFactorX - objectW * object.originX;
                var objectY = object.y - scrollY * object.scrollFactorY - objectH * object.originY;
                var tx = objectX * mva + objectY * mvc + mve;
                var ty = objectX * mvb + objectY * mvd + mvf;
                var tw = (objectX + objectW) * mva + (objectY + objectH) * mvc + mve;
                var th = (objectX + objectW) * mvb + (objectY + objectH) * mvd + mvf;
                if (tw > cullLeft && tx < cullRight && (th > cullTop && ty < cullBottom)) {
                  culledObjects.push(object);
                }
              }
              return culledObjects;
            },
            getWorldPoint: function(x, y, output) {
              if (output === void 0) {
                output = new Vector29();
              }
              var cameraMatrix = this.matrix.matrix;
              var mva = cameraMatrix[0];
              var mvb = cameraMatrix[1];
              var mvc = cameraMatrix[2];
              var mvd = cameraMatrix[3];
              var mve = cameraMatrix[4];
              var mvf = cameraMatrix[5];
              var determinant = mva * mvd - mvb * mvc;
              if (!determinant) {
                output.x = x;
                output.y = y;
                return output;
              }
              determinant = 1 / determinant;
              var ima = mvd * determinant;
              var imb = -mvb * determinant;
              var imc = -mvc * determinant;
              var imd = mva * determinant;
              var ime = (mvc * mvf - mvd * mve) * determinant;
              var imf = (mvb * mve - mva * mvf) * determinant;
              var c = Math.cos(this.rotation);
              var s = Math.sin(this.rotation);
              var zoomX = this.zoomX;
              var zoomY = this.zoomY;
              var scrollX = this.scrollX;
              var scrollY = this.scrollY;
              var sx = x + (scrollX * c - scrollY * s) * zoomX;
              var sy = y + (scrollX * s + scrollY * c) * zoomY;
              output.x = sx * ima + sy * imc + ime;
              output.y = sx * imb + sy * imd + imf;
              return output;
            },
            ignore: function(entries) {
              var id = this.id;
              if (!Array.isArray(entries)) {
                entries = [entries];
              }
              for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];
                if (Array.isArray(entry)) {
                  this.ignore(entry);
                } else if (entry.isParent) {
                  this.ignore(entry.getChildren());
                } else {
                  entry.cameraFilter |= id;
                }
              }
              return this;
            },
            preRender: function() {
              this.renderList.length = 0;
              var width = this.width;
              var height = this.height;
              var halfWidth = width * 0.5;
              var halfHeight = height * 0.5;
              var zoomX = this.zoomX;
              var zoomY = this.zoomY;
              var matrix = this.matrix;
              var originX = width * this.originX;
              var originY = height * this.originY;
              var sx = this.scrollX;
              var sy = this.scrollY;
              if (this.useBounds) {
                sx = this.clampX(sx);
                sy = this.clampY(sy);
              }
              if (this.roundPixels) {
                originX = Math.round(originX);
                originY = Math.round(originY);
              }
              this.scrollX = sx;
              this.scrollY = sy;
              var midX = sx + halfWidth;
              var midY = sy + halfHeight;
              this.midPoint.set(midX, midY);
              var displayWidth = width / zoomX;
              var displayHeight = height / zoomY;
              this.worldView.setTo(midX - displayWidth / 2, midY - displayHeight / 2, displayWidth, displayHeight);
              matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoomX, zoomY);
              matrix.translate(-originX, -originY);
            },
            clampX: function(x) {
              var bounds = this._bounds;
              var dw = this.displayWidth;
              var bx = bounds.x + (dw - this.width) / 2;
              var bw = Math.max(bx, bx + bounds.width - dw);
              if (x < bx) {
                x = bx;
              } else if (x > bw) {
                x = bw;
              }
              return x;
            },
            clampY: function(y) {
              var bounds = this._bounds;
              var dh = this.displayHeight;
              var by = bounds.y + (dh - this.height) / 2;
              var bh = Math.max(by, by + bounds.height - dh);
              if (y < by) {
                y = by;
              } else if (y > bh) {
                y = bh;
              }
              return y;
            },
            removeBounds: function() {
              this.useBounds = false;
              this.dirty = true;
              this._bounds.setEmpty();
              return this;
            },
            setAngle: function(value) {
              if (value === void 0) {
                value = 0;
              }
              this.rotation = DegToRad(value);
              return this;
            },
            setBackgroundColor: function(color) {
              if (color === void 0) {
                color = "rgba(0,0,0,0)";
              }
              this.backgroundColor = ValueToColor(color);
              this.transparent = this.backgroundColor.alpha === 0;
              return this;
            },
            setBounds: function(x, y, width, height, centerOn) {
              if (centerOn === void 0) {
                centerOn = false;
              }
              this._bounds.setTo(x, y, width, height);
              this.dirty = true;
              this.useBounds = true;
              if (centerOn) {
                this.centerToBounds();
              } else {
                this.scrollX = this.clampX(this.scrollX);
                this.scrollY = this.clampY(this.scrollY);
              }
              return this;
            },
            getBounds: function(out) {
              if (out === void 0) {
                out = new Rectangle();
              }
              var source = this._bounds;
              out.setTo(source.x, source.y, source.width, source.height);
              return out;
            },
            setName: function(value) {
              if (value === void 0) {
                value = "";
              }
              this.name = value;
              return this;
            },
            setPosition: function(x, y) {
              if (y === void 0) {
                y = x;
              }
              this.x = x;
              this.y = y;
              return this;
            },
            setRotation: function(value) {
              if (value === void 0) {
                value = 0;
              }
              this.rotation = value;
              return this;
            },
            setRoundPixels: function(value) {
              this.roundPixels = value;
              return this;
            },
            setScene: function(scene) {
              if (this.scene && this._customViewport) {
                this.sceneManager.customViewports--;
              }
              this.scene = scene;
              var sys = scene.sys;
              this.sceneManager = sys.game.scene;
              this.scaleManager = sys.scale;
              this.cameraManager = sys.cameras;
              this.updateSystem();
              return this;
            },
            setScroll: function(x, y) {
              if (y === void 0) {
                y = x;
              }
              this.scrollX = x;
              this.scrollY = y;
              return this;
            },
            setSize: function(width, height) {
              if (height === void 0) {
                height = width;
              }
              this.width = width;
              this.height = height;
              return this;
            },
            setViewport: function(x, y, width, height) {
              this.x = x;
              this.y = y;
              this.width = width;
              this.height = height;
              return this;
            },
            setZoom: function(x, y) {
              if (x === void 0) {
                x = 1;
              }
              if (y === void 0) {
                y = x;
              }
              if (x === 0) {
                x = 1e-3;
              }
              if (y === 0) {
                y = 1e-3;
              }
              this.zoomX = x;
              this.zoomY = y;
              return this;
            },
            setMask: function(mask, fixedPosition) {
              if (fixedPosition === void 0) {
                fixedPosition = true;
              }
              this.mask = mask;
              this._maskCamera = fixedPosition ? this.cameraManager.default : this;
              return this;
            },
            clearMask: function(destroyMask) {
              if (destroyMask === void 0) {
                destroyMask = false;
              }
              if (destroyMask && this.mask) {
                this.mask.destroy();
              }
              this.mask = null;
              return this;
            },
            toJSON: function() {
              var output = {
                name: this.name,
                x: this.x,
                y: this.y,
                width: this.width,
                height: this.height,
                zoom: this.zoom,
                rotation: this.rotation,
                roundPixels: this.roundPixels,
                scrollX: this.scrollX,
                scrollY: this.scrollY,
                backgroundColor: this.backgroundColor.rgba
              };
              if (this.useBounds) {
                output["bounds"] = {
                  x: this._bounds.x,
                  y: this._bounds.y,
                  width: this._bounds.width,
                  height: this._bounds.height
                };
              }
              return output;
            },
            update: function() {
            },
            updateSystem: function() {
              if (!this.scaleManager) {
                return;
              }
              var custom = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height;
              var sceneManager = this.sceneManager;
              if (custom && !this._customViewport) {
                sceneManager.customViewports++;
              } else if (!custom && this._customViewport) {
                sceneManager.customViewports--;
              }
              this.dirty = true;
              this._customViewport = custom;
            },
            destroy: function() {
              this.emit(Events.DESTROY, this);
              this.removeAllListeners();
              this.matrix.destroy();
              this.culledObjects = [];
              if (this._customViewport) {
                this.sceneManager.customViewports--;
              }
              this.renderList = [];
              this._bounds = null;
              this.scene = null;
              this.scaleManager = null;
              this.sceneManager = null;
              this.cameraManager = null;
            },
            x: {
              get: function() {
                return this._x;
              },
              set: function(value) {
                this._x = value;
                this.updateSystem();
              }
            },
            y: {
              get: function() {
                return this._y;
              },
              set: function(value) {
                this._y = value;
                this.updateSystem();
              }
            },
            width: {
              get: function() {
                return this._width;
              },
              set: function(value) {
                this._width = value;
                this.updateSystem();
              }
            },
            height: {
              get: function() {
                return this._height;
              },
              set: function(value) {
                this._height = value;
                this.updateSystem();
              }
            },
            scrollX: {
              get: function() {
                return this._scrollX;
              },
              set: function(value) {
                this._scrollX = value;
                this.dirty = true;
              }
            },
            scrollY: {
              get: function() {
                return this._scrollY;
              },
              set: function(value) {
                this._scrollY = value;
                this.dirty = true;
              }
            },
            zoom: {
              get: function() {
                return (this._zoomX + this._zoomY) / 2;
              },
              set: function(value) {
                this._zoomX = value;
                this._zoomY = value;
                this.dirty = true;
              }
            },
            zoomX: {
              get: function() {
                return this._zoomX;
              },
              set: function(value) {
                this._zoomX = value;
                this.dirty = true;
              }
            },
            zoomY: {
              get: function() {
                return this._zoomY;
              },
              set: function(value) {
                this._zoomY = value;
                this.dirty = true;
              }
            },
            rotation: {
              get: function() {
                return this._rotation;
              },
              set: function(value) {
                this._rotation = value;
                this.dirty = true;
              }
            },
            centerX: {
              get: function() {
                return this.x + 0.5 * this.width;
              }
            },
            centerY: {
              get: function() {
                return this.y + 0.5 * this.height;
              }
            },
            displayWidth: {
              get: function() {
                return this.width / this.zoomX;
              }
            },
            displayHeight: {
              get: function() {
                return this.height / this.zoomY;
              }
            }
          });
          module2.exports = BaseCamera;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Back = __webpack_require__(328);
          var Bounce = __webpack_require__(329);
          var Circular = __webpack_require__(330);
          var Cubic = __webpack_require__(331);
          var Elastic = __webpack_require__(332);
          var Expo = __webpack_require__(333);
          var Linear = __webpack_require__(334);
          var Quadratic = __webpack_require__(335);
          var Quartic = __webpack_require__(336);
          var Quintic = __webpack_require__(337);
          var Sine = __webpack_require__(338);
          var Stepped = __webpack_require__(339);
          module2.exports = {
            Power0: Linear,
            Power1: Quadratic.Out,
            Power2: Cubic.Out,
            Power3: Quartic.Out,
            Power4: Quintic.Out,
            Linear,
            Quad: Quadratic.Out,
            Cubic: Cubic.Out,
            Quart: Quartic.Out,
            Quint: Quintic.Out,
            Sine: Sine.Out,
            Expo: Expo.Out,
            Circ: Circular.Out,
            Elastic: Elastic.Out,
            Back: Back.Out,
            Bounce: Bounce.Out,
            Stepped,
            "Quad.easeIn": Quadratic.In,
            "Cubic.easeIn": Cubic.In,
            "Quart.easeIn": Quartic.In,
            "Quint.easeIn": Quintic.In,
            "Sine.easeIn": Sine.In,
            "Expo.easeIn": Expo.In,
            "Circ.easeIn": Circular.In,
            "Elastic.easeIn": Elastic.In,
            "Back.easeIn": Back.In,
            "Bounce.easeIn": Bounce.In,
            "Quad.easeOut": Quadratic.Out,
            "Cubic.easeOut": Cubic.Out,
            "Quart.easeOut": Quartic.Out,
            "Quint.easeOut": Quintic.Out,
            "Sine.easeOut": Sine.Out,
            "Expo.easeOut": Expo.Out,
            "Circ.easeOut": Circular.Out,
            "Elastic.easeOut": Elastic.Out,
            "Back.easeOut": Back.Out,
            "Bounce.easeOut": Bounce.Out,
            "Quad.easeInOut": Quadratic.InOut,
            "Cubic.easeInOut": Cubic.InOut,
            "Quart.easeInOut": Quartic.InOut,
            "Quint.easeInOut": Quintic.InOut,
            "Sine.easeInOut": Sine.InOut,
            "Expo.easeInOut": Expo.InOut,
            "Circ.easeInOut": Circular.InOut,
            "Elastic.easeInOut": Elastic.InOut,
            "Back.easeInOut": Back.InOut,
            "Bounce.easeInOut": Bounce.InOut
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Linear = function(p0, p1, t) {
            return (p1 - p0) * t + p0;
          };
          module2.exports = Linear;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var OS = __webpack_require__(102);
          var Browser = {
            chrome: false,
            chromeVersion: 0,
            edge: false,
            firefox: false,
            firefoxVersion: 0,
            ie: false,
            ieVersion: 0,
            mobileSafari: false,
            opera: false,
            safari: false,
            safariVersion: 0,
            silk: false,
            trident: false,
            tridentVersion: 0
          };
          function init() {
            var ua = navigator.userAgent;
            if (/Edge\/\d+/.test(ua)) {
              Browser.edge = true;
            } else if (/Chrome\/(\d+)/.test(ua) && !OS.windowsPhone) {
              Browser.chrome = true;
              Browser.chromeVersion = parseInt(RegExp.$1, 10);
            } else if (/Firefox\D+(\d+)/.test(ua)) {
              Browser.firefox = true;
              Browser.firefoxVersion = parseInt(RegExp.$1, 10);
            } else if (/AppleWebKit/.test(ua) && OS.iOS) {
              Browser.mobileSafari = true;
            } else if (/MSIE (\d+\.\d+);/.test(ua)) {
              Browser.ie = true;
              Browser.ieVersion = parseInt(RegExp.$1, 10);
            } else if (/Opera/.test(ua)) {
              Browser.opera = true;
            } else if (/Safari/.test(ua) && !OS.windowsPhone) {
              Browser.safari = true;
            } else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(ua)) {
              Browser.ie = true;
              Browser.trident = true;
              Browser.tridentVersion = parseInt(RegExp.$1, 10);
              Browser.ieVersion = parseInt(RegExp.$3, 10);
            }
            if (/Silk/.test(ua)) {
              Browser.silk = true;
            }
            return Browser;
          }
          module2.exports = init();
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FloatBetween = function(min, max) {
            return Math.random() * (max - min) + min;
          };
          module2.exports = FloatBetween;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var IsSizePowerOfTwo = function(width, height) {
            return width > 0 && (width & width - 1) === 0 && height > 0 && (height & height - 1) === 0;
          };
          module2.exports = IsSizePowerOfTwo;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SnapCeil = function(value, gap, start, divide) {
            if (start === void 0) {
              start = 0;
            }
            if (gap === 0) {
              return value;
            }
            value -= start;
            value = gap * Math.ceil(value / gap);
            return divide ? (start + value) / gap : start + value;
          };
          module2.exports = SnapCeil;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Vector4 = new Class({
            initialize: function Vector42(x, y, z, w) {
              this.x = 0;
              this.y = 0;
              this.z = 0;
              this.w = 0;
              if (typeof x === "object") {
                this.x = x.x || 0;
                this.y = x.y || 0;
                this.z = x.z || 0;
                this.w = x.w || 0;
              } else {
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
                this.w = w || 0;
              }
            },
            clone: function() {
              return new Vector4(this.x, this.y, this.z, this.w);
            },
            copy: function(src) {
              this.x = src.x;
              this.y = src.y;
              this.z = src.z || 0;
              this.w = src.w || 0;
              return this;
            },
            equals: function(v) {
              return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
            },
            set: function(x, y, z, w) {
              if (typeof x === "object") {
                this.x = x.x || 0;
                this.y = x.y || 0;
                this.z = x.z || 0;
                this.w = x.w || 0;
              } else {
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
                this.w = w || 0;
              }
              return this;
            },
            add: function(v) {
              this.x += v.x;
              this.y += v.y;
              this.z += v.z || 0;
              this.w += v.w || 0;
              return this;
            },
            subtract: function(v) {
              this.x -= v.x;
              this.y -= v.y;
              this.z -= v.z || 0;
              this.w -= v.w || 0;
              return this;
            },
            scale: function(scale) {
              this.x *= scale;
              this.y *= scale;
              this.z *= scale;
              this.w *= scale;
              return this;
            },
            length: function() {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var w = this.w;
              return Math.sqrt(x * x + y * y + z * z + w * w);
            },
            lengthSq: function() {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var w = this.w;
              return x * x + y * y + z * z + w * w;
            },
            normalize: function() {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var w = this.w;
              var len = x * x + y * y + z * z + w * w;
              if (len > 0) {
                len = 1 / Math.sqrt(len);
                this.x = x * len;
                this.y = y * len;
                this.z = z * len;
                this.w = w * len;
              }
              return this;
            },
            dot: function(v) {
              return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
            },
            lerp: function(v, t) {
              if (t === void 0) {
                t = 0;
              }
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var aw = this.w;
              this.x = ax + t * (v.x - ax);
              this.y = ay + t * (v.y - ay);
              this.z = az + t * (v.z - az);
              this.w = aw + t * (v.w - aw);
              return this;
            },
            multiply: function(v) {
              this.x *= v.x;
              this.y *= v.y;
              this.z *= v.z || 1;
              this.w *= v.w || 1;
              return this;
            },
            divide: function(v) {
              this.x /= v.x;
              this.y /= v.y;
              this.z /= v.z || 1;
              this.w /= v.w || 1;
              return this;
            },
            distance: function(v) {
              var dx = v.x - this.x;
              var dy = v.y - this.y;
              var dz = v.z - this.z || 0;
              var dw = v.w - this.w || 0;
              return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
            },
            distanceSq: function(v) {
              var dx = v.x - this.x;
              var dy = v.y - this.y;
              var dz = v.z - this.z || 0;
              var dw = v.w - this.w || 0;
              return dx * dx + dy * dy + dz * dz + dw * dw;
            },
            negate: function() {
              this.x = -this.x;
              this.y = -this.y;
              this.z = -this.z;
              this.w = -this.w;
              return this;
            },
            transformMat4: function(mat) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var w = this.w;
              var m = mat.val;
              this.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
              this.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
              this.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
              this.w = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
              return this;
            },
            transformQuat: function(q) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var qx = q.x;
              var qy = q.y;
              var qz = q.z;
              var qw = q.w;
              var ix = qw * x + qy * z - qz * y;
              var iy = qw * y + qz * x - qx * z;
              var iz = qw * z + qx * y - qy * x;
              var iw = -qx * x - qy * y - qz * z;
              this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
              this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
              this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
              return this;
            },
            reset: function() {
              this.x = 0;
              this.y = 0;
              this.z = 0;
              this.w = 0;
              return this;
            }
          });
          Vector4.prototype.sub = Vector4.prototype.subtract;
          Vector4.prototype.mul = Vector4.prototype.multiply;
          Vector4.prototype.div = Vector4.prototype.divide;
          Vector4.prototype.dist = Vector4.prototype.distance;
          Vector4.prototype.distSq = Vector4.prototype.distanceSq;
          Vector4.prototype.len = Vector4.prototype.length;
          Vector4.prototype.lenSq = Vector4.prototype.lengthSq;
          module2.exports = Vector4;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(88);
          var RenderTarget = new Class({
            initialize: function RenderTarget2(renderer, width, height, scale, minFilter, autoClear, autoResize) {
              if (scale === void 0) {
                scale = 1;
              }
              if (minFilter === void 0) {
                minFilter = 0;
              }
              if (autoClear === void 0) {
                autoClear = true;
              }
              if (autoResize === void 0) {
                autoResize = false;
              }
              this.renderer = renderer;
              this.framebuffer = null;
              this.texture = null;
              this.width = 0;
              this.height = 0;
              this.scale = scale;
              this.minFilter = minFilter;
              this.autoClear = autoClear;
              this.autoResize = false;
              this.resize(width, height);
              if (autoResize) {
                this.setAutoResize(true);
              }
            },
            setAutoResize: function(autoResize) {
              if (autoResize && !this.autoResize) {
                this.renderer.on(Events.RESIZE, this.resize, this);
                this.autoResize = true;
              } else if (!autoResize && this.autoResize) {
                this.renderer.off(Events.RESIZE, this.resize, this);
                this.autoResize = false;
              }
              return this;
            },
            resize: function(width, height) {
              var scaledWidth = width * this.scale;
              var scaledHeight = height * this.scale;
              if (scaledWidth !== this.width || scaledHeight !== this.height) {
                var renderer = this.renderer;
                renderer.deleteFramebuffer(this.framebuffer);
                renderer.deleteTexture(this.texture);
                width *= this.scale;
                height *= this.scale;
                this.texture = renderer.createTextureFromSource(null, width, height, this.minFilter);
                this.framebuffer = renderer.createFramebuffer(width, height, this.texture, false);
                this.width = width;
                this.height = height;
              }
              return this;
            },
            bind: function(adjustViewport, width, height) {
              if (adjustViewport === void 0) {
                adjustViewport = false;
              }
              if (adjustViewport) {
                this.renderer.flush();
              }
              if (width && height) {
                this.resize(width, height);
              }
              this.renderer.pushFramebuffer(this.framebuffer, false, false, false);
              if (adjustViewport) {
                this.adjustViewport();
              }
              if (this.autoClear) {
                var gl = this.renderer.gl;
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
            },
            adjustViewport: function() {
              var gl = this.renderer.gl;
              gl.viewport(0, 0, this.width, this.height);
              gl.disable(gl.SCISSOR_TEST);
            },
            clear: function() {
              var renderer = this.renderer;
              var gl = renderer.gl;
              renderer.pushFramebuffer(this.framebuffer);
              gl.disable(gl.SCISSOR_TEST);
              gl.clearColor(0, 0, 0, 0);
              gl.clear(gl.COLOR_BUFFER_BIT);
              renderer.popFramebuffer();
              renderer.resetScissor();
            },
            unbind: function(flush) {
              if (flush === void 0) {
                flush = false;
              }
              var renderer = this.renderer;
              if (flush) {
                renderer.flush();
              }
              return renderer.popFramebuffer();
            },
            destroy: function() {
              var renderer = this.renderer;
              renderer.deleteFramebuffer(this.framebuffer);
              renderer.deleteTexture(this.texture);
              renderer.off(Events.RESIZE, this.resize, this);
              this.renderer = null;
              this.framebuffer = null;
              this.texture = null;
            }
          });
          module2.exports = RenderTarget;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AddToDOM = function(element, parent) {
            var target;
            if (parent) {
              if (typeof parent === "string") {
                target = document.getElementById(parent);
              } else if (typeof parent === "object" && parent.nodeType === 1) {
                target = parent;
              }
            } else if (element.parentElement || parent === null) {
              return element;
            }
            if (!target) {
              target = document.body;
            }
            target.appendChild(element);
            return element;
          };
          module2.exports = AddToDOM;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var KeyCodes = {
            BACKSPACE: 8,
            TAB: 9,
            ENTER: 13,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            PAUSE: 19,
            CAPS_LOCK: 20,
            ESC: 27,
            SPACE: 32,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            END: 35,
            HOME: 36,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            PRINT_SCREEN: 42,
            INSERT: 45,
            DELETE: 46,
            ZERO: 48,
            ONE: 49,
            TWO: 50,
            THREE: 51,
            FOUR: 52,
            FIVE: 53,
            SIX: 54,
            SEVEN: 55,
            EIGHT: 56,
            NINE: 57,
            NUMPAD_ZERO: 96,
            NUMPAD_ONE: 97,
            NUMPAD_TWO: 98,
            NUMPAD_THREE: 99,
            NUMPAD_FOUR: 100,
            NUMPAD_FIVE: 101,
            NUMPAD_SIX: 102,
            NUMPAD_SEVEN: 103,
            NUMPAD_EIGHT: 104,
            NUMPAD_NINE: 105,
            NUMPAD_ADD: 107,
            NUMPAD_SUBTRACT: 109,
            A: 65,
            B: 66,
            C: 67,
            D: 68,
            E: 69,
            F: 70,
            G: 71,
            H: 72,
            I: 73,
            J: 74,
            K: 75,
            L: 76,
            M: 77,
            N: 78,
            O: 79,
            P: 80,
            Q: 81,
            R: 82,
            S: 83,
            T: 84,
            U: 85,
            V: 86,
            W: 87,
            X: 88,
            Y: 89,
            Z: 90,
            F1: 112,
            F2: 113,
            F3: 114,
            F4: 115,
            F5: 116,
            F6: 117,
            F7: 118,
            F8: 119,
            F9: 120,
            F10: 121,
            F11: 122,
            F12: 123,
            SEMICOLON: 186,
            PLUS: 187,
            COMMA: 188,
            MINUS: 189,
            PERIOD: 190,
            FORWARD_SLASH: 191,
            BACK_SLASH: 220,
            QUOTES: 222,
            BACKTICK: 192,
            OPEN_BRACKET: 219,
            CLOSED_BRACKET: 221,
            SEMICOLON_FIREFOX: 59,
            COLON: 58,
            COMMA_FIREFOX_WINDOWS: 60,
            COMMA_FIREFOX: 62,
            BRACKET_RIGHT_FIREFOX: 174,
            BRACKET_LEFT_FIREFOX: 175
          };
          module2.exports = KeyCodes;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = {
            PENDING: 0,
            INIT: 1,
            START: 2,
            LOADING: 3,
            CREATING: 4,
            RUNNING: 5,
            PAUSED: 6,
            SLEEPING: 7,
            SHUTDOWN: 8,
            DESTROYED: 9
          };
          module2.exports = CONST;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clone = __webpack_require__(77);
          var Merge = function(obj1, obj2) {
            var clone = Clone(obj1);
            for (var key in obj2) {
              if (!clone.hasOwnProperty(key)) {
                clone[key] = obj2[key];
              }
            }
            return clone;
          };
          module2.exports = Merge;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Clone = __webpack_require__(77);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(69);
          var GameEvents = __webpack_require__(22);
          var NOOP = __webpack_require__(1);
          var GetAll = __webpack_require__(204);
          var GetFirst = __webpack_require__(422);
          var BaseSoundManager = new Class({
            Extends: EventEmitter,
            initialize: function BaseSoundManager2(game) {
              EventEmitter.call(this);
              this.game = game;
              this.jsonCache = game.cache.json;
              this.sounds = [];
              this.mute = false;
              this.volume = 1;
              this.pauseOnBlur = true;
              this._rate = 1;
              this._detune = 0;
              this.locked = this.locked || false;
              this.unlocked = false;
              game.events.on(GameEvents.BLUR, this.onGameBlur, this);
              game.events.on(GameEvents.FOCUS, this.onGameFocus, this);
              game.events.on(GameEvents.PRE_STEP, this.update, this);
              game.events.once(GameEvents.DESTROY, this.destroy, this);
            },
            add: NOOP,
            addAudioSprite: function(key, config2) {
              if (config2 === void 0) {
                config2 = {};
              }
              var sound = this.add(key, config2);
              sound.spritemap = this.jsonCache.get(key).spritemap;
              for (var markerName in sound.spritemap) {
                if (!sound.spritemap.hasOwnProperty(markerName)) {
                  continue;
                }
                var markerConfig = Clone(config2);
                var marker = sound.spritemap[markerName];
                markerConfig.loop = marker.hasOwnProperty("loop") ? marker.loop : false;
                sound.addMarker({
                  name: markerName,
                  start: marker.start,
                  duration: marker.end - marker.start,
                  config: markerConfig
                });
              }
              return sound;
            },
            get: function(key) {
              return GetFirst(this.sounds, "key", key);
            },
            getAll: function(key) {
              return GetAll(this.sounds, "key", key);
            },
            play: function(key, extra) {
              var sound = this.add(key);
              sound.once(Events.COMPLETE, sound.destroy, sound);
              if (extra) {
                if (extra.name) {
                  sound.addMarker(extra);
                  return sound.play(extra.name);
                } else {
                  return sound.play(extra);
                }
              } else {
                return sound.play();
              }
            },
            playAudioSprite: function(key, spriteName, config2) {
              var sound = this.addAudioSprite(key);
              sound.once(Events.COMPLETE, sound.destroy, sound);
              return sound.play(spriteName, config2);
            },
            remove: function(sound) {
              var index = this.sounds.indexOf(sound);
              if (index !== -1) {
                sound.destroy();
                this.sounds.splice(index, 1);
                return true;
              }
              return false;
            },
            removeAll: function() {
              this.sounds.forEach(function(sound) {
                sound.destroy();
              });
              this.sounds.length = 0;
            },
            removeByKey: function(key) {
              var removed = 0;
              for (var i = this.sounds.length - 1; i >= 0; i--) {
                var sound = this.sounds[i];
                if (sound.key === key) {
                  sound.destroy();
                  this.sounds.splice(i, 1);
                  removed++;
                }
              }
              return removed;
            },
            pauseAll: function() {
              this.forEachActiveSound(function(sound) {
                sound.pause();
              });
              this.emit(Events.PAUSE_ALL, this);
            },
            resumeAll: function() {
              this.forEachActiveSound(function(sound) {
                sound.resume();
              });
              this.emit(Events.RESUME_ALL, this);
            },
            stopAll: function() {
              this.forEachActiveSound(function(sound) {
                sound.stop();
              });
              this.emit(Events.STOP_ALL, this);
            },
            stopByKey: function(key) {
              var stopped = 0;
              this.getAll(key).forEach(function(sound) {
                if (sound.stop()) {
                  stopped++;
                }
              });
              return stopped;
            },
            unlock: NOOP,
            onBlur: NOOP,
            onFocus: NOOP,
            onGameBlur: function() {
              if (this.pauseOnBlur) {
                this.onBlur();
              }
            },
            onGameFocus: function() {
              if (this.pauseOnBlur) {
                this.onFocus();
              }
            },
            update: function(time, delta) {
              if (this.unlocked) {
                this.unlocked = false;
                this.locked = false;
                this.emit(Events.UNLOCKED, this);
              }
              for (var i = this.sounds.length - 1; i >= 0; i--) {
                if (this.sounds[i].pendingRemove) {
                  this.sounds.splice(i, 1);
                }
              }
              this.sounds.forEach(function(sound) {
                sound.update(time, delta);
              });
            },
            destroy: function() {
              this.game.events.off(GameEvents.BLUR, this.onGameBlur, this);
              this.game.events.off(GameEvents.FOCUS, this.onGameFocus, this);
              this.game.events.off(GameEvents.PRE_STEP, this.update, this);
              this.removeAllListeners();
              this.removeAll();
              this.sounds.length = 0;
              this.sounds = null;
              this.game = null;
            },
            forEachActiveSound: function(callback, scope) {
              var _this = this;
              this.sounds.forEach(function(sound, index) {
                if (sound && !sound.pendingRemove) {
                  callback.call(scope || _this, sound, index, _this.sounds);
                }
              });
            },
            setRate: function(value) {
              this.rate = value;
              return this;
            },
            rate: {
              get: function() {
                return this._rate;
              },
              set: function(value) {
                this._rate = value;
                this.forEachActiveSound(function(sound) {
                  sound.calculateRate();
                });
                this.emit(Events.GLOBAL_RATE, this, value);
              }
            },
            setDetune: function(value) {
              this.detune = value;
              return this;
            },
            detune: {
              get: function() {
                return this._detune;
              },
              set: function(value) {
                this._detune = value;
                this.forEachActiveSound(function(sound) {
                  sound.calculateRate();
                });
                this.emit(Events.GLOBAL_DETUNE, this, value);
              }
            }
          });
          module2.exports = BaseSoundManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(69);
          var Extend = __webpack_require__(17);
          var NOOP = __webpack_require__(1);
          var BaseSound = new Class({
            Extends: EventEmitter,
            initialize: function BaseSound2(manager, key, config2) {
              EventEmitter.call(this);
              this.manager = manager;
              this.key = key;
              this.isPlaying = false;
              this.isPaused = false;
              this.totalRate = 1;
              this.duration = this.duration || 0;
              this.totalDuration = this.totalDuration || 0;
              this.config = {
                mute: false,
                volume: 1,
                rate: 1,
                detune: 0,
                seek: 0,
                loop: false,
                delay: 0,
                pan: 0
              };
              this.currentConfig = this.config;
              this.config = Extend(this.config, config2);
              this.markers = {};
              this.currentMarker = null;
              this.pendingRemove = false;
            },
            addMarker: function(marker) {
              if (!marker || !marker.name || typeof marker.name !== "string") {
                return false;
              }
              if (this.markers[marker.name]) {
                console.error("addMarker " + marker.name + " already exists in Sound");
                return false;
              }
              marker = Extend(true, {
                name: "",
                start: 0,
                duration: this.totalDuration - (marker.start || 0),
                config: {
                  mute: false,
                  volume: 1,
                  rate: 1,
                  detune: 0,
                  seek: 0,
                  loop: false,
                  delay: 0,
                  pan: 0
                }
              }, marker);
              this.markers[marker.name] = marker;
              return true;
            },
            updateMarker: function(marker) {
              if (!marker || !marker.name || typeof marker.name !== "string") {
                return false;
              }
              if (!this.markers[marker.name]) {
                console.warn("Audio Marker: " + marker.name + " missing in Sound: " + this.key);
                return false;
              }
              this.markers[marker.name] = Extend(true, this.markers[marker.name], marker);
              return true;
            },
            removeMarker: function(markerName) {
              var marker = this.markers[markerName];
              if (!marker) {
                return null;
              }
              this.markers[markerName] = null;
              return marker;
            },
            play: function(markerName, config2) {
              if (markerName === void 0) {
                markerName = "";
              }
              if (typeof markerName === "object") {
                config2 = markerName;
                markerName = "";
              }
              if (typeof markerName !== "string") {
                return false;
              }
              if (!markerName) {
                this.currentMarker = null;
                this.currentConfig = this.config;
                this.duration = this.totalDuration;
              } else {
                if (!this.markers[markerName]) {
                  console.warn("Marker: " + markerName + " missing in Sound: " + this.key);
                  return false;
                }
                this.currentMarker = this.markers[markerName];
                this.currentConfig = this.currentMarker.config;
                this.duration = this.currentMarker.duration;
              }
              this.resetConfig();
              this.currentConfig = Extend(this.currentConfig, config2);
              this.isPlaying = true;
              this.isPaused = false;
              return true;
            },
            pause: function() {
              if (this.isPaused || !this.isPlaying) {
                return false;
              }
              this.isPlaying = false;
              this.isPaused = true;
              return true;
            },
            resume: function() {
              if (!this.isPaused || this.isPlaying) {
                return false;
              }
              this.isPlaying = true;
              this.isPaused = false;
              return true;
            },
            stop: function() {
              if (!this.isPaused && !this.isPlaying) {
                return false;
              }
              this.isPlaying = false;
              this.isPaused = false;
              this.resetConfig();
              return true;
            },
            applyConfig: function() {
              this.mute = this.currentConfig.mute;
              this.volume = this.currentConfig.volume;
              this.rate = this.currentConfig.rate;
              this.detune = this.currentConfig.detune;
              this.loop = this.currentConfig.loop;
              this.pan = this.currentConfig.pan;
            },
            resetConfig: function() {
              this.currentConfig.seek = 0;
              this.currentConfig.delay = 0;
            },
            update: NOOP,
            calculateRate: function() {
              var cent = 1.0005777895065548;
              var totalDetune = this.currentConfig.detune + this.manager.detune;
              var detuneRate = Math.pow(cent, totalDetune);
              this.totalRate = this.currentConfig.rate * this.manager.rate * detuneRate;
            },
            destroy: function() {
              if (this.pendingRemove) {
                return;
              }
              this.emit(Events.DESTROY, this);
              this.pendingRemove = true;
              this.manager = null;
              this.key = "";
              this.removeAllListeners();
              this.isPlaying = false;
              this.isPaused = false;
              this.config = null;
              this.currentConfig = null;
              this.markers = null;
              this.currentMarker = null;
            }
          });
          module2.exports = BaseSound;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CheckMatrix = __webpack_require__(206);
          var TransposeMatrix = __webpack_require__(429);
          var RotateMatrix = function(matrix, direction) {
            if (direction === void 0) {
              direction = 90;
            }
            if (!CheckMatrix(matrix)) {
              return null;
            }
            if (typeof direction !== "string") {
              direction = (direction % 360 + 360) % 360;
            }
            if (direction === 90 || direction === -270 || direction === "rotateLeft") {
              matrix = TransposeMatrix(matrix);
              matrix.reverse();
            } else if (direction === -90 || direction === 270 || direction === "rotateRight") {
              matrix.reverse();
              matrix = TransposeMatrix(matrix);
            } else if (Math.abs(direction) === 180 || direction === "rotate180") {
              for (var i = 0; i < matrix.length; i++) {
                matrix[i].reverse();
              }
              matrix.reverse();
            }
            return matrix;
          };
          module2.exports = RotateMatrix;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Clamp = __webpack_require__(18);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var GetBitmapTextSize = __webpack_require__(1037);
          var ParseFromAtlas = __webpack_require__(1038);
          var ParseXMLBitmapFont = __webpack_require__(209);
          var Rectangle = __webpack_require__(10);
          var Render = __webpack_require__(1039);
          var BitmapText = new Class({
            Extends: GameObject,
            Mixins: [
              Components.Alpha,
              Components.BlendMode,
              Components.Depth,
              Components.Mask,
              Components.Origin,
              Components.Pipeline,
              Components.ScrollFactor,
              Components.Texture,
              Components.Tint,
              Components.Transform,
              Components.Visible,
              Render
            ],
            initialize: function BitmapText2(scene, x, y, font, text, size, align) {
              if (text === void 0) {
                text = "";
              }
              if (align === void 0) {
                align = 0;
              }
              GameObject.call(this, scene, "BitmapText");
              this.font = font;
              var entry = this.scene.sys.cache.bitmapFont.get(font);
              if (!entry) {
                console.warn("Invalid BitmapText key: " + font);
              }
              this.fontData = entry.data;
              this._text = "";
              this._fontSize = size || this.fontData.size;
              this._letterSpacing = 0;
              this._align = align;
              this._bounds = GetBitmapTextSize();
              this._dirty = true;
              this._maxWidth = 0;
              this.wordWrapCharCode = 32;
              this.charColors = [];
              this.dropShadowX = 0;
              this.dropShadowY = 0;
              this.dropShadowColor = 0;
              this.dropShadowAlpha = 0.5;
              this.setTexture(entry.texture, entry.frame);
              this.setPosition(x, y);
              this.setOrigin(0, 0);
              this.initPipeline();
              this.setText(text);
            },
            setLeftAlign: function() {
              this._align = BitmapText.ALIGN_LEFT;
              this._dirty = true;
              return this;
            },
            setCenterAlign: function() {
              this._align = BitmapText.ALIGN_CENTER;
              this._dirty = true;
              return this;
            },
            setRightAlign: function() {
              this._align = BitmapText.ALIGN_RIGHT;
              this._dirty = true;
              return this;
            },
            setFontSize: function(size) {
              this._fontSize = size;
              this._dirty = true;
              return this;
            },
            setLetterSpacing: function(spacing) {
              if (spacing === void 0) {
                spacing = 0;
              }
              this._letterSpacing = spacing;
              this._dirty = true;
              return this;
            },
            setText: function(value) {
              if (!value && value !== 0) {
                value = "";
              }
              if (Array.isArray(value)) {
                value = value.join("\n");
              }
              if (value !== this.text) {
                this._text = value.toString();
                this._dirty = true;
                this.updateDisplayOrigin();
              }
              return this;
            },
            setDropShadow: function(x, y, color, alpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (color === void 0) {
                color = 0;
              }
              if (alpha === void 0) {
                alpha = 0.5;
              }
              this.dropShadowX = x;
              this.dropShadowY = y;
              this.dropShadowColor = color;
              this.dropShadowAlpha = alpha;
              return this;
            },
            setCharacterTint: function(start, length, tintFill, topLeft, topRight, bottomLeft, bottomRight) {
              if (start === void 0) {
                start = 0;
              }
              if (length === void 0) {
                length = 1;
              }
              if (tintFill === void 0) {
                tintFill = false;
              }
              if (topLeft === void 0) {
                topLeft = -1;
              }
              if (topRight === void 0) {
                topRight = topLeft;
                bottomLeft = topLeft;
                bottomRight = topLeft;
              }
              var len = this.text.length;
              if (length === -1) {
                length = len;
              }
              if (start < 0) {
                start = len + start;
              }
              start = Clamp(start, 0, len - 1);
              var end = Clamp(start + length, start, len);
              var charColors = this.charColors;
              for (var i = start; i < end; i++) {
                var color = charColors[i];
                if (topLeft === -1) {
                  charColors[i] = null;
                } else {
                  var tintEffect = tintFill ? 1 : 0;
                  if (color) {
                    color.tintEffect = tintEffect;
                    color.tintTL = topLeft;
                    color.tintTR = topRight;
                    color.tintBL = bottomLeft;
                    color.tintBR = bottomRight;
                  } else {
                    charColors[i] = {
                      tintEffect,
                      tintTL: topLeft,
                      tintTR: topRight,
                      tintBL: bottomLeft,
                      tintBR: bottomRight
                    };
                  }
                }
              }
              return this;
            },
            setWordTint: function(word, count, tintFill, topLeft, topRight, bottomLeft, bottomRight) {
              if (count === void 0) {
                count = 1;
              }
              var bounds = this.getTextBounds();
              var words = bounds.words;
              var wordIsNumber = typeof word === "number";
              var total = 0;
              for (var i = 0; i < words.length; i++) {
                var lineword = words[i];
                if (wordIsNumber && i === word || !wordIsNumber && lineword.word === word) {
                  this.setCharacterTint(lineword.i, lineword.word.length, tintFill, topLeft, topRight, bottomLeft, bottomRight);
                  total++;
                  if (total === count) {
                    return this;
                  }
                }
              }
              return this;
            },
            getTextBounds: function(round) {
              var bounds = this._bounds;
              if (this._dirty || round || this.scaleX !== bounds.scaleX || this.scaleY !== bounds.scaleY) {
                GetBitmapTextSize(this, round, true, bounds);
                this._dirty = false;
              }
              return bounds;
            },
            getCharacterAt: function(x, y, camera) {
              var point = this.getLocalPoint(x, y, null, camera);
              var bounds = this.getTextBounds();
              var chars = bounds.characters;
              var tempRect = new Rectangle();
              for (var i = 0; i < chars.length; i++) {
                var char = chars[i];
                tempRect.setTo(char.x, char.t, char.r - char.x, char.b);
                if (tempRect.contains(point.x, point.y)) {
                  return char;
                }
              }
              return null;
            },
            updateDisplayOrigin: function() {
              this._dirty = true;
              this.getTextBounds(false);
              return this;
            },
            setFont: function(key, size, align) {
              if (size === void 0) {
                size = this._fontSize;
              }
              if (align === void 0) {
                align = this._align;
              }
              if (key !== this.font) {
                var entry = this.scene.sys.cache.bitmapFont.get(key);
                if (entry) {
                  this.font = key;
                  this.fontData = entry.data;
                  this._fontSize = size;
                  this._align = align;
                  this.setTexture(entry.texture, entry.frame);
                  GetBitmapTextSize(this, false, true, this._bounds);
                }
              }
              return this;
            },
            setMaxWidth: function(value, wordWrapCharCode) {
              this._maxWidth = value;
              this._dirty = true;
              if (wordWrapCharCode !== void 0) {
                this.wordWrapCharCode = wordWrapCharCode;
              }
              return this;
            },
            align: {
              set: function(value) {
                this._align = value;
                this._dirty = true;
              },
              get: function() {
                return this._align;
              }
            },
            text: {
              set: function(value) {
                this.setText(value);
              },
              get: function() {
                return this._text;
              }
            },
            fontSize: {
              set: function(value) {
                this._fontSize = value;
                this._dirty = true;
              },
              get: function() {
                return this._fontSize;
              }
            },
            letterSpacing: {
              set: function(value) {
                this._letterSpacing = value;
                this._dirty = true;
              },
              get: function() {
                return this._letterSpacing;
              }
            },
            maxWidth: {
              set: function(value) {
                this._maxWidth = value;
                this._dirty = true;
              },
              get: function() {
                return this._maxWidth;
              }
            },
            width: {
              get: function() {
                this.getTextBounds(false);
                return this._bounds.global.width;
              }
            },
            height: {
              get: function() {
                this.getTextBounds(false);
                return this._bounds.global.height;
              }
            },
            toJSON: function() {
              var out = Components.ToJSON(this);
              var data = {
                font: this.font,
                text: this.text,
                fontSize: this.fontSize,
                letterSpacing: this.letterSpacing,
                align: this.align
              };
              out.data = data;
              return out;
            },
            preDestroy: function() {
              this.charColors.length = 0;
              this._bounds = null;
              this.fontData = null;
            }
          });
          BitmapText.ALIGN_LEFT = 0;
          BitmapText.ALIGN_CENTER = 1;
          BitmapText.ALIGN_RIGHT = 2;
          BitmapText.ParseFromAtlas = ParseFromAtlas;
          BitmapText.ParseXMLBitmapFont = ParseXMLBitmapFont;
          module2.exports = BitmapText;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Set2 = new Class({
            initialize: function Set3(elements) {
              this.entries = [];
              if (Array.isArray(elements)) {
                for (var i = 0; i < elements.length; i++) {
                  this.set(elements[i]);
                }
              }
            },
            set: function(value) {
              if (this.entries.indexOf(value) === -1) {
                this.entries.push(value);
              }
              return this;
            },
            get: function(property, value) {
              for (var i = 0; i < this.entries.length; i++) {
                var entry = this.entries[i];
                if (entry[property] === value) {
                  return entry;
                }
              }
            },
            getArray: function() {
              return this.entries.slice(0);
            },
            delete: function(value) {
              var index = this.entries.indexOf(value);
              if (index > -1) {
                this.entries.splice(index, 1);
              }
              return this;
            },
            dump: function() {
              console.group("Set");
              for (var i = 0; i < this.entries.length; i++) {
                var entry = this.entries[i];
                console.log(entry);
              }
              console.groupEnd();
            },
            each: function(callback, callbackScope) {
              var i;
              var temp = this.entries.slice();
              var len = temp.length;
              if (callbackScope) {
                for (i = 0; i < len; i++) {
                  if (callback.call(callbackScope, temp[i], i) === false) {
                    break;
                  }
                }
              } else {
                for (i = 0; i < len; i++) {
                  if (callback(temp[i], i) === false) {
                    break;
                  }
                }
              }
              return this;
            },
            iterate: function(callback, callbackScope) {
              var i;
              var len = this.entries.length;
              if (callbackScope) {
                for (i = 0; i < len; i++) {
                  if (callback.call(callbackScope, this.entries[i], i) === false) {
                    break;
                  }
                }
              } else {
                for (i = 0; i < len; i++) {
                  if (callback(this.entries[i], i) === false) {
                    break;
                  }
                }
              }
              return this;
            },
            iterateLocal: function(callbackKey) {
              var i;
              var args = [];
              for (i = 1; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              var len = this.entries.length;
              for (i = 0; i < len; i++) {
                var entry = this.entries[i];
                entry[callbackKey].apply(entry, args);
              }
              return this;
            },
            clear: function() {
              this.entries.length = 0;
              return this;
            },
            contains: function(value) {
              return this.entries.indexOf(value) > -1;
            },
            union: function(set) {
              var newSet = new Set2();
              set.entries.forEach(function(value) {
                newSet.set(value);
              });
              this.entries.forEach(function(value) {
                newSet.set(value);
              });
              return newSet;
            },
            intersect: function(set) {
              var newSet = new Set2();
              this.entries.forEach(function(value) {
                if (set.contains(value)) {
                  newSet.set(value);
                }
              });
              return newSet;
            },
            difference: function(set) {
              var newSet = new Set2();
              this.entries.forEach(function(value) {
                if (!set.contains(value)) {
                  newSet.set(value);
                }
              });
              return newSet;
            },
            size: {
              get: function() {
                return this.entries.length;
              },
              set: function(value) {
                if (value < this.entries.length) {
                  return this.entries.length = value;
                } else {
                  return this.entries.length;
                }
              }
            }
          });
          module2.exports = Set2;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var IntegerToColor = __webpack_require__(186);
          var PIPELINES_CONST = __webpack_require__(65);
          var Render = __webpack_require__(1176);
          var PointLight = new Class({
            Extends: GameObject,
            Mixins: [
              Components.AlphaSingle,
              Components.BlendMode,
              Components.Depth,
              Components.GetBounds,
              Components.Mask,
              Components.Pipeline,
              Components.ScrollFactor,
              Components.Transform,
              Components.Visible,
              Render
            ],
            initialize: function PointLight2(scene, x, y, color, radius, intensity, attenuation) {
              if (color === void 0) {
                color = 16777215;
              }
              if (radius === void 0) {
                radius = 128;
              }
              if (intensity === void 0) {
                intensity = 1;
              }
              if (attenuation === void 0) {
                attenuation = 0.1;
              }
              GameObject.call(this, scene, "PointLight");
              this.initPipeline(PIPELINES_CONST.POINTLIGHT_PIPELINE);
              this.setPosition(x, y);
              this.color = IntegerToColor(color);
              this.intensity = intensity;
              this.attenuation = attenuation;
              this.width = radius * 2;
              this.height = radius * 2;
              this._radius = radius;
            },
            radius: {
              get: function() {
                return this._radius;
              },
              set: function(value) {
                this._radius = value;
                this.width = value * 2;
                this.height = value * 2;
              }
            },
            originX: {
              get: function() {
                return 0.5;
              }
            },
            originY: {
              get: function() {
                return 0.5;
              }
            },
            displayOriginX: {
              get: function() {
                return this._radius;
              }
            },
            displayOriginY: {
              get: function() {
                return this._radius;
              }
            }
          });
          module2.exports = PointLight;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CircleToRectangle = function(circle, rect) {
            var halfWidth = rect.width / 2;
            var halfHeight = rect.height / 2;
            var cx = Math.abs(circle.x - rect.x - halfWidth);
            var cy = Math.abs(circle.y - rect.y - halfHeight);
            var xDist = halfWidth + circle.radius;
            var yDist = halfHeight + circle.radius;
            if (cx > xDist || cy > yDist) {
              return false;
            } else if (cx <= halfWidth || cy <= halfHeight) {
              return true;
            } else {
              var xCornerDist = cx - halfWidth;
              var yCornerDist = cy - halfHeight;
              var xCornerDistSq = xCornerDist * xCornerDist;
              var yCornerDistSq = yCornerDist * yCornerDist;
              var maxCornerDistSq = circle.radius * circle.radius;
              return xCornerDistSq + yCornerDistSq <= maxCornerDistSq;
            }
          };
          module2.exports = CircleToRectangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetValue = __webpack_require__(6);
          var inputPlugins = {};
          var InputPluginCache = {};
          InputPluginCache.register = function(key, plugin, mapping, settingsKey, configKey) {
            inputPlugins[key] = {plugin, mapping, settingsKey, configKey};
          };
          InputPluginCache.getPlugin = function(key) {
            return inputPlugins[key];
          };
          InputPluginCache.install = function(target) {
            var sys = target.scene.sys;
            var settings = sys.settings.input;
            var config2 = sys.game.config;
            for (var key in inputPlugins) {
              var source = inputPlugins[key].plugin;
              var mapping = inputPlugins[key].mapping;
              var settingsKey = inputPlugins[key].settingsKey;
              var configKey = inputPlugins[key].configKey;
              if (GetValue(settings, settingsKey, config2[configKey])) {
                target[mapping] = new source(target);
              }
            }
          };
          InputPluginCache.remove = function(key) {
            if (inputPlugins.hasOwnProperty(key)) {
              delete inputPlugins[key];
            }
          };
          module2.exports = InputPluginCache;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            ANY_KEY_DOWN: __webpack_require__(1317),
            ANY_KEY_UP: __webpack_require__(1318),
            COMBO_MATCH: __webpack_require__(1319),
            DOWN: __webpack_require__(1320),
            KEY_DOWN: __webpack_require__(1321),
            KEY_UP: __webpack_require__(1322),
            UP: __webpack_require__(1323)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetURL = function(file, baseURL) {
            if (!file.url) {
              return false;
            }
            if (file.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/)) {
              return file.url;
            } else {
              return baseURL + file.url;
            }
          };
          module2.exports = GetURL;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var XHRSettings = function(responseType, async, user, password, timeout, withCredentials) {
            if (responseType === void 0) {
              responseType = "";
            }
            if (async === void 0) {
              async = true;
            }
            if (user === void 0) {
              user = "";
            }
            if (password === void 0) {
              password = "";
            }
            if (timeout === void 0) {
              timeout = 0;
            }
            if (withCredentials === void 0) {
              withCredentials = false;
            }
            return {
              responseType,
              async,
              user,
              password,
              timeout,
              headers: void 0,
              header: void 0,
              headerValue: void 0,
              requestedWith: false,
              overrideMimeType: void 0,
              withCredentials
            };
          };
          module2.exports = XHRSettings;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(240);
          var Sprite = __webpack_require__(73);
          var ArcadeSprite = new Class({
            Extends: Sprite,
            Mixins: [
              Components.Acceleration,
              Components.Angular,
              Components.Bounce,
              Components.Debug,
              Components.Drag,
              Components.Enable,
              Components.Friction,
              Components.Gravity,
              Components.Immovable,
              Components.Mass,
              Components.Pushable,
              Components.Size,
              Components.Velocity
            ],
            initialize: function ArcadeSprite2(scene, x, y, texture, frame) {
              Sprite.call(this, scene, x, y, texture, frame);
              this.body = null;
            }
          });
          module2.exports = ArcadeSprite;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var IsInLayerBounds = __webpack_require__(118);
          var GetTileAt = function(tileX, tileY, nonNull, layer) {
            if (nonNull === void 0) {
              nonNull = false;
            }
            if (IsInLayerBounds(tileX, tileY, layer)) {
              var tile = layer.data[tileY][tileX] || null;
              if (!tile) {
                return null;
              } else if (tile.index === -1) {
                return nonNull ? tile : null;
              } else {
                return tile;
              }
            } else {
              return null;
            }
          };
          module2.exports = GetTileAt;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RunCull = function(layer, bounds, renderOrder, outputArray) {
            var mapData = layer.data;
            var mapWidth = layer.width;
            var mapHeight = layer.height;
            var tilemapLayer = layer.tilemapLayer;
            var drawLeft = Math.max(0, bounds.left);
            var drawRight = Math.min(mapWidth, bounds.right);
            var drawTop = Math.max(0, bounds.top);
            var drawBottom = Math.min(mapHeight, bounds.bottom);
            var x;
            var y;
            var tile;
            if (renderOrder === 0) {
              for (y = drawTop; y < drawBottom; y++) {
                for (x = drawLeft; mapData[y] && x < drawRight; x++) {
                  tile = mapData[y][x];
                  if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                    continue;
                  }
                  outputArray.push(tile);
                }
              }
            } else if (renderOrder === 1) {
              for (y = drawTop; y < drawBottom; y++) {
                for (x = drawRight; mapData[y] && x >= drawLeft; x--) {
                  tile = mapData[y][x];
                  if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                    continue;
                  }
                  outputArray.push(tile);
                }
              }
            } else if (renderOrder === 2) {
              for (y = drawBottom; y >= drawTop; y--) {
                for (x = drawLeft; mapData[y] && x < drawRight; x++) {
                  tile = mapData[y][x];
                  if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                    continue;
                  }
                  outputArray.push(tile);
                }
              }
            } else if (renderOrder === 3) {
              for (y = drawBottom; y >= drawTop; y--) {
                for (x = drawRight; mapData[y] && x >= drawLeft; x--) {
                  tile = mapData[y][x];
                  if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                    continue;
                  }
                  outputArray.push(tile);
                }
              }
            }
            tilemapLayer.tilesDrawn = outputArray.length;
            tilemapLayer.tilesTotal = mapWidth * mapHeight;
            return outputArray;
          };
          module2.exports = RunCull;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetLayerCollisionIndex = function(tileIndex, collides, layer) {
            var loc = layer.collideIndexes.indexOf(tileIndex);
            if (collides && loc === -1) {
              layer.collideIndexes.push(tileIndex);
            } else if (!collides && loc !== -1) {
              layer.collideIndexes.splice(loc, 1);
            }
          };
          module2.exports = SetLayerCollisionIndex;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Seth Berrier <berriers@uwstout.edu>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetFastValue = __webpack_require__(2);
          var CreateGroupLayer = function(json, groupl, parentstate) {
            if (!groupl) {
              return {
                i: 0,
                layers: json.layers,
                name: "",
                opacity: 1,
                visible: true,
                x: 0,
                y: 0
              };
            }
            var layerX = groupl.x + GetFastValue(groupl, "startx", 0) * json.tilewidth + GetFastValue(groupl, "offsetx", 0);
            var layerY = groupl.y + GetFastValue(groupl, "starty", 0) * json.tileheight + GetFastValue(groupl, "offsety", 0);
            return {
              i: 0,
              layers: groupl.layers,
              name: parentstate.name + groupl.name + "/",
              opacity: parentstate.opacity * groupl.opacity,
              visible: parentstate.visible && groupl.visible,
              x: parentstate.x + layerX,
              y: parentstate.y + layerY
            };
          };
          module2.exports = CreateGroupLayer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetNewValue = function(source, key, defaultValue) {
            var valueCallback;
            if (source.hasOwnProperty(key)) {
              var t = typeof source[key];
              if (t === "function") {
                valueCallback = function(target, targetKey, value, targetIndex, totalTargets, tween) {
                  return source[key](target, targetKey, value, targetIndex, totalTargets, tween);
                };
              } else {
                valueCallback = function() {
                  return source[key];
                };
              }
            } else if (typeof defaultValue === "function") {
              valueCallback = defaultValue;
            } else {
              valueCallback = function() {
                return defaultValue;
              };
            }
            return valueCallback;
          };
          module2.exports = GetNewValue;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Defaults = __webpack_require__(261);
          var GetAdvancedValue = __webpack_require__(13);
          var GetBoolean = __webpack_require__(96);
          var GetEaseFunction = __webpack_require__(80);
          var GetNewValue = __webpack_require__(160);
          var GetProps = __webpack_require__(579);
          var GetTargets = __webpack_require__(259);
          var GetValue = __webpack_require__(6);
          var GetValueOp = __webpack_require__(260);
          var Tween = __webpack_require__(262);
          var TweenData = __webpack_require__(264);
          var TweenBuilder = function(parent, config2, defaults) {
            if (defaults === void 0) {
              defaults = Defaults;
            }
            var targets = defaults.targets ? defaults.targets : GetTargets(config2);
            var props = GetProps(config2);
            var delay = GetNewValue(config2, "delay", defaults.delay);
            var duration = GetNewValue(config2, "duration", defaults.duration);
            var easeParams = GetValue(config2, "easeParams", defaults.easeParams);
            var ease = GetEaseFunction(GetValue(config2, "ease", defaults.ease), easeParams);
            var hold = GetNewValue(config2, "hold", defaults.hold);
            var repeat = GetNewValue(config2, "repeat", defaults.repeat);
            var repeatDelay = GetNewValue(config2, "repeatDelay", defaults.repeatDelay);
            var yoyo = GetBoolean(config2, "yoyo", defaults.yoyo);
            var flipX = GetBoolean(config2, "flipX", defaults.flipX);
            var flipY = GetBoolean(config2, "flipY", defaults.flipY);
            var data = [];
            for (var p = 0; p < props.length; p++) {
              var key = props[p].key;
              var value = props[p].value;
              for (var t = 0; t < targets.length; t++) {
                var ops = GetValueOp(key, value);
                var tweenData = TweenData(targets[t], t, key, ops.getEnd, ops.getStart, ops.getActive, GetEaseFunction(GetValue(value, "ease", ease), GetValue(value, "easeParams", easeParams)), GetNewValue(value, "delay", delay), GetNewValue(value, "duration", duration), GetBoolean(value, "yoyo", yoyo), GetNewValue(value, "hold", hold), GetNewValue(value, "repeat", repeat), GetNewValue(value, "repeatDelay", repeatDelay), GetBoolean(value, "flipX", flipX), GetBoolean(value, "flipY", flipY));
                data.push(tweenData);
              }
            }
            var tween = new Tween(parent, data, targets);
            tween.offset = GetAdvancedValue(config2, "offset", null);
            tween.completeDelay = GetAdvancedValue(config2, "completeDelay", 0);
            tween.loop = Math.round(GetAdvancedValue(config2, "loop", 0));
            tween.loopDelay = Math.round(GetAdvancedValue(config2, "loopDelay", 0));
            tween.paused = GetBoolean(config2, "paused", false);
            tween.useFrames = GetBoolean(config2, "useFrames", false);
            var scope = GetValue(config2, "callbackScope", tween);
            var tweenArray = [tween, null];
            var callbacks = Tween.TYPES;
            for (var i = 0; i < callbacks.length; i++) {
              var type = callbacks[i];
              var callback = GetValue(config2, type, false);
              if (callback) {
                var callbackScope = GetValue(config2, type + "Scope", scope);
                var callbackParams = GetValue(config2, type + "Params", []);
                tween.setCallback(type, callback, tweenArray.concat(callbackParams), callbackScope);
              }
            }
            return tween;
          };
          module2.exports = TweenBuilder;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CustomMap = __webpack_require__(99);
          var GetFastValue = __webpack_require__(2);
          var Events = __webpack_require__(130);
          var Animation = __webpack_require__(182);
          var AnimationState = new Class({
            initialize: function AnimationState2(parent) {
              this.parent = parent;
              this.animationManager = parent.scene.sys.anims;
              this.animationManager.on(Events.REMOVE_ANIMATION, this.globalRemove, this);
              this.textureManager = this.animationManager.textureManager;
              this.anims = null;
              this.isPlaying = false;
              this.hasStarted = false;
              this.currentAnim = null;
              this.currentFrame = null;
              this.nextAnim = null;
              this.nextAnimsQueue = [];
              this.timeScale = 1;
              this.frameRate = 0;
              this.duration = 0;
              this.msPerFrame = 0;
              this.skipMissedFrames = true;
              this.delay = 0;
              this.repeat = 0;
              this.repeatDelay = 0;
              this.yoyo = false;
              this.showOnStart = false;
              this.hideOnComplete = false;
              this.forward = true;
              this.inReverse = false;
              this.accumulator = 0;
              this.nextTick = 0;
              this.delayCounter = 0;
              this.repeatCounter = 0;
              this.pendingRepeat = false;
              this._paused = false;
              this._wasPlaying = false;
              this._pendingStop = 0;
              this._pendingStopValue;
            },
            chain: function(key) {
              var parent = this.parent;
              if (key === void 0) {
                this.nextAnimsQueue.length = 0;
                this.nextAnim = null;
                return parent;
              }
              if (!Array.isArray(key)) {
                key = [key];
              }
              for (var i = 0; i < key.length; i++) {
                var anim = key[i];
                if (this.nextAnim === null) {
                  this.nextAnim = anim;
                } else {
                  this.nextAnimsQueue.push(anim);
                }
              }
              return this.parent;
            },
            getName: function() {
              return this.currentAnim ? this.currentAnim.key : "";
            },
            getFrameName: function() {
              return this.currentFrame ? this.currentFrame.textureFrame : "";
            },
            load: function(key) {
              if (this.isPlaying) {
                this.stop();
              }
              var manager = this.animationManager;
              var animKey = typeof key === "string" ? key : GetFastValue(key, "key", null);
              var anim = this.exists(animKey) ? this.get(animKey) : manager.get(animKey);
              if (!anim) {
                console.warn("Missing animation: " + animKey);
              } else {
                this.currentAnim = anim;
                var totalFrames = anim.getTotalFrames();
                var frameRate = GetFastValue(key, "frameRate", anim.frameRate);
                var duration = GetFastValue(key, "duration", anim.duration);
                anim.calculateDuration(this, totalFrames, duration, frameRate);
                this.delay = GetFastValue(key, "delay", anim.delay);
                this.repeat = GetFastValue(key, "repeat", anim.repeat);
                this.repeatDelay = GetFastValue(key, "repeatDelay", anim.repeatDelay);
                this.yoyo = GetFastValue(key, "yoyo", anim.yoyo);
                this.showOnStart = GetFastValue(key, "showOnStart", anim.showOnStart);
                this.hideOnComplete = GetFastValue(key, "hideOnComplete", anim.hideOnComplete);
                this.skipMissedFrames = GetFastValue(key, "skipMissedFrames", anim.skipMissedFrames);
                this.timeScale = GetFastValue(key, "timeScale", this.timeScale);
                var startFrame = GetFastValue(key, "startFrame", 0);
                if (startFrame > anim.getTotalFrames()) {
                  startFrame = 0;
                }
                var frame = anim.frames[startFrame];
                if (startFrame === 0 && !this.forward) {
                  frame = anim.getLastFrame();
                }
                this.currentFrame = frame;
              }
              return this.parent;
            },
            pause: function(atFrame) {
              if (!this._paused) {
                this._paused = true;
                this._wasPlaying = this.isPlaying;
                this.isPlaying = false;
              }
              if (atFrame !== void 0) {
                this.setCurrentFrame(atFrame);
              }
              return this.parent;
            },
            resume: function(fromFrame) {
              if (this._paused) {
                this._paused = false;
                this.isPlaying = this._wasPlaying;
              }
              if (fromFrame !== void 0) {
                this.setCurrentFrame(fromFrame);
              }
              return this.parent;
            },
            playAfterDelay: function(key, delay) {
              if (!this.isPlaying) {
                this.delayCounter = delay;
                this.play(key, true);
              } else {
                var nextAnim = this.nextAnim;
                var queue = this.nextAnimsQueue;
                if (nextAnim) {
                  queue.unshift(nextAnim);
                }
                this.nextAnim = key;
                this._pendingStop = 1;
                this._pendingStopValue = delay;
              }
              return this.parent;
            },
            playAfterRepeat: function(key, repeatCount) {
              if (repeatCount === void 0) {
                repeatCount = 1;
              }
              if (!this.isPlaying) {
                this.play(key);
              } else {
                var nextAnim = this.nextAnim;
                var queue = this.nextAnimsQueue;
                if (nextAnim) {
                  queue.unshift(nextAnim);
                }
                if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter) {
                  repeatCount = this.repeatCounter;
                }
                this.nextAnim = key;
                this._pendingStop = 2;
                this._pendingStopValue = repeatCount;
              }
              return this.parent;
            },
            play: function(key, ignoreIfPlaying) {
              if (ignoreIfPlaying === void 0) {
                ignoreIfPlaying = false;
              }
              var currentAnim = this.currentAnim;
              var parent = this.parent;
              var animKey = typeof key === "string" ? key : key.key;
              if (ignoreIfPlaying && this.isPlaying && currentAnim.key === animKey) {
                return parent;
              }
              if (currentAnim && this.isPlaying) {
                var mix = this.animationManager.getMix(currentAnim.key, key);
                if (mix > 0) {
                  return this.playAfterDelay(key, mix);
                }
              }
              this.forward = true;
              this.inReverse = false;
              this._paused = false;
              this._wasPlaying = true;
              return this.startAnimation(key);
            },
            playReverse: function(key, ignoreIfPlaying) {
              if (ignoreIfPlaying === void 0) {
                ignoreIfPlaying = false;
              }
              var animKey = typeof key === "string" ? key : key.key;
              if (ignoreIfPlaying && this.isPlaying && this.currentAnim.key === animKey) {
                return this.parent;
              }
              this.forward = false;
              this.inReverse = true;
              this._paused = false;
              this._wasPlaying = true;
              return this.startAnimation(key);
            },
            startAnimation: function(key) {
              this.load(key);
              var anim = this.currentAnim;
              var gameObject = this.parent;
              if (!anim) {
                return gameObject;
              }
              this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat;
              anim.getFirstTick(this);
              this.isPlaying = true;
              this.pendingRepeat = false;
              this.hasStarted = false;
              this._pendingStop = 0;
              this._pendingStopValue = 0;
              this._paused = false;
              this.delayCounter += this.delay;
              if (this.delayCounter === 0) {
                this.handleStart();
              }
              return gameObject;
            },
            handleStart: function() {
              if (this.showOnStart) {
                this.parent.setVisible(true);
              }
              this.setCurrentFrame(this.currentFrame);
              this.hasStarted = true;
              this.emitEvents(Events.ANIMATION_START);
            },
            handleRepeat: function() {
              this.pendingRepeat = false;
              this.emitEvents(Events.ANIMATION_REPEAT);
            },
            handleStop: function() {
              this._pendingStop = 0;
              this.isPlaying = false;
              this.emitEvents(Events.ANIMATION_STOP);
            },
            handleComplete: function() {
              this._pendingStop = 0;
              this.isPlaying = false;
              if (this.hideOnComplete) {
                this.parent.setVisible(false);
              }
              this.emitEvents(Events.ANIMATION_COMPLETE, Events.ANIMATION_COMPLETE_KEY);
            },
            emitEvents: function(event, keyEvent) {
              var anim = this.currentAnim;
              var frame = this.currentFrame;
              var gameObject = this.parent;
              var frameKey = frame.textureFrame;
              gameObject.emit(event, anim, frame, gameObject, frameKey);
              if (keyEvent) {
                gameObject.emit(keyEvent + anim.key, anim, frame, gameObject, frameKey);
              }
            },
            reverse: function() {
              if (this.isPlaying) {
                this.inReverse = !this.inReverse;
                this.forward = !this.forward;
              }
              return this.parent;
            },
            getProgress: function() {
              var frame = this.currentFrame;
              if (!frame) {
                return 0;
              }
              var p = frame.progress;
              if (this.inReverse) {
                p *= -1;
              }
              return p;
            },
            setProgress: function(value) {
              if (!this.forward) {
                value = 1 - value;
              }
              this.setCurrentFrame(this.currentAnim.getFrameByProgress(value));
              return this.parent;
            },
            setRepeat: function(value) {
              this.repeatCounter = value === -1 ? Number.MAX_VALUE : value;
              return this.parent;
            },
            globalRemove: function(key, animation) {
              if (animation === void 0) {
                animation = this.currentAnim;
              }
              if (this.isPlaying && animation.key === this.currentAnim.key) {
                this.stop();
                this.setCurrentFrame(this.currentAnim.frames[0]);
              }
            },
            restart: function(includeDelay, resetRepeats) {
              if (includeDelay === void 0) {
                includeDelay = false;
              }
              if (resetRepeats === void 0) {
                resetRepeats = false;
              }
              var anim = this.currentAnim;
              var gameObject = this.parent;
              if (!anim) {
                return gameObject;
              }
              if (resetRepeats) {
                this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat;
              }
              anim.getFirstTick(this);
              this.emitEvents(Events.ANIMATION_RESTART);
              this.isPlaying = true;
              this.pendingRepeat = false;
              this.hasStarted = !includeDelay;
              this._pendingStop = 0;
              this._pendingStopValue = 0;
              this._paused = false;
              this.setCurrentFrame(anim.frames[0]);
              return this.parent;
            },
            complete: function() {
              this._pendingStop = 0;
              this.isPlaying = false;
              if (this.currentAnim) {
                this.handleComplete();
              }
              if (this.nextAnim) {
                var key = this.nextAnim;
                this.nextAnim = this.nextAnimsQueue.length > 0 ? this.nextAnimsQueue.shift() : null;
                this.play(key);
              }
              return this.parent;
            },
            stop: function() {
              this._pendingStop = 0;
              this.isPlaying = false;
              if (this.currentAnim) {
                this.handleStop();
              }
              if (this.nextAnim) {
                var key = this.nextAnim;
                this.nextAnim = this.nextAnimsQueue.shift();
                this.play(key);
              }
              return this.parent;
            },
            stopAfterDelay: function(delay) {
              this._pendingStop = 1;
              this._pendingStopValue = delay;
              return this.parent;
            },
            stopAfterRepeat: function(repeatCount) {
              if (repeatCount === void 0) {
                repeatCount = 1;
              }
              if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter) {
                repeatCount = this.repeatCounter;
              }
              this._pendingStop = 2;
              this._pendingStopValue = repeatCount;
              return this.parent;
            },
            stopOnFrame: function(frame) {
              this._pendingStop = 3;
              this._pendingStopValue = frame;
              return this.parent;
            },
            getTotalFrames: function() {
              return this.currentAnim ? this.currentAnim.getTotalFrames() : 0;
            },
            update: function(time, delta) {
              var anim = this.currentAnim;
              if (!this.isPlaying || !anim || anim.paused) {
                return;
              }
              this.accumulator += delta * this.timeScale;
              if (this._pendingStop === 1) {
                this._pendingStopValue -= delta;
                if (this._pendingStopValue <= 0) {
                  return this.stop();
                }
              }
              if (!this.hasStarted) {
                if (this.accumulator >= this.delayCounter) {
                  this.accumulator -= this.delayCounter;
                  this.handleStart();
                }
              } else if (this.accumulator >= this.nextTick) {
                if (this.forward) {
                  anim.nextFrame(this);
                } else {
                  anim.previousFrame(this);
                }
                if (this.isPlaying && this._pendingStop === 0 && this.skipMissedFrames && this.accumulator > this.nextTick) {
                  var safetyNet = 0;
                  do {
                    if (this.forward) {
                      anim.nextFrame(this);
                    } else {
                      anim.previousFrame(this);
                    }
                    safetyNet++;
                  } while (this.accumulator > this.nextTick && safetyNet < 60);
                }
              }
            },
            setCurrentFrame: function(animationFrame) {
              var gameObject = this.parent;
              this.currentFrame = animationFrame;
              gameObject.texture = animationFrame.frame.texture;
              gameObject.frame = animationFrame.frame;
              if (gameObject.isCropped) {
                gameObject.frame.updateCropUVs(gameObject._crop, gameObject.flipX, gameObject.flipY);
              }
              if (animationFrame.setAlpha) {
                gameObject.alpha = animationFrame.alpha;
              }
              gameObject.setSizeToFrame();
              if (gameObject._originComponent) {
                if (animationFrame.frame.customPivot) {
                  gameObject.setOrigin(animationFrame.frame.pivotX, animationFrame.frame.pivotY);
                } else {
                  gameObject.updateDisplayOrigin();
                }
              }
              if (this.isPlaying && this.hasStarted) {
                this.emitEvents(Events.ANIMATION_UPDATE);
                if (this._pendingStop === 3 && this._pendingStopValue === animationFrame) {
                  this.stop();
                }
              }
              return gameObject;
            },
            nextFrame: function() {
              if (this.currentAnim) {
                this.currentAnim.nextFrame(this);
              }
              return this.parent;
            },
            previousFrame: function() {
              if (this.currentAnim) {
                this.currentAnim.previousFrame(this);
              }
              return this.parent;
            },
            get: function(key) {
              return this.anims ? this.anims.get(key) : null;
            },
            exists: function(key) {
              return this.anims ? this.anims.has(key) : false;
            },
            create: function(config2) {
              var key = config2.key;
              var anim = false;
              if (key) {
                anim = this.get(key);
                if (!anim) {
                  anim = new Animation(this, key, config2);
                  if (!this.anims) {
                    this.anims = new CustomMap();
                  }
                  this.anims.set(key, anim);
                }
              }
              return anim;
            },
            generateFrameNames: function(key, config2) {
              return this.animationManager.generateFrameNames(key, config2);
            },
            generateFrameNumbers: function(key, config2) {
              return this.animationManager.generateFrameNumbers(key, config2);
            },
            remove: function(key) {
              var anim = this.get(key);
              if (anim) {
                if (this.currentAnim === anim) {
                  this.stop();
                }
                this.anims.delete(key);
              }
              return anim;
            },
            destroy: function() {
              this.animationManager.off(Events.REMOVE_ANIMATION, this.globalRemove, this);
              if (this.anims) {
                this.anims.clear();
              }
              this.animationManager = null;
              this.parent = null;
              this.nextAnim = null;
              this.nextAnimsQueue.length = 0;
              this.currentAnim = null;
              this.currentFrame = null;
            },
            isPaused: {
              get: function() {
                return this._paused;
              }
            }
          });
          module2.exports = AnimationState;
        },
        function(module2, exports2, __webpack_require__) {
          var Composite = {};
          module2.exports = Composite;
          var Events = __webpack_require__(268);
          var Common = __webpack_require__(50);
          var Bounds = __webpack_require__(117);
          var Body = __webpack_require__(71);
          (function() {
            Composite.create = function(options) {
              return Common.extend({
                id: Common.nextId(),
                type: "composite",
                parent: null,
                isModified: false,
                bodies: [],
                constraints: [],
                composites: [],
                label: "Composite",
                plugin: {}
              }, options);
            };
            Composite.setModified = function(composite, isModified, updateParents, updateChildren) {
              Events.trigger(composite, "compositeModified", composite);
              composite.isModified = isModified;
              if (updateParents && composite.parent) {
                Composite.setModified(composite.parent, isModified, updateParents, updateChildren);
              }
              if (updateChildren) {
                for (var i = 0; i < composite.composites.length; i++) {
                  var childComposite = composite.composites[i];
                  Composite.setModified(childComposite, isModified, updateParents, updateChildren);
                }
              }
            };
            Composite.add = function(composite, object) {
              var objects = [].concat(object);
              Events.trigger(composite, "beforeAdd", {object});
              for (var i = 0; i < objects.length; i++) {
                var obj = objects[i];
                switch (obj.type) {
                  case "body":
                    if (obj.parent !== obj) {
                      Common.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                      break;
                    }
                    Composite.addBody(composite, obj);
                    break;
                  case "constraint":
                    Composite.addConstraint(composite, obj);
                    break;
                  case "composite":
                    Composite.addComposite(composite, obj);
                    break;
                  case "mouseConstraint":
                    Composite.addConstraint(composite, obj.constraint);
                    break;
                }
              }
              Events.trigger(composite, "afterAdd", {object});
              return composite;
            };
            Composite.remove = function(composite, object, deep) {
              var objects = [].concat(object);
              Events.trigger(composite, "beforeRemove", {object});
              for (var i = 0; i < objects.length; i++) {
                var obj = objects[i];
                switch (obj.type) {
                  case "body":
                    Composite.removeBody(composite, obj, deep);
                    break;
                  case "constraint":
                    Composite.removeConstraint(composite, obj, deep);
                    break;
                  case "composite":
                    Composite.removeComposite(composite, obj, deep);
                    break;
                  case "mouseConstraint":
                    Composite.removeConstraint(composite, obj.constraint);
                    break;
                }
              }
              Events.trigger(composite, "afterRemove", {object});
              return composite;
            };
            Composite.addComposite = function(compositeA, compositeB) {
              compositeA.composites.push(compositeB);
              compositeB.parent = compositeA;
              Composite.setModified(compositeA, true, true, false);
              return compositeA;
            };
            Composite.removeComposite = function(compositeA, compositeB, deep) {
              var position = compositeA.composites.indexOf(compositeB);
              if (position !== -1) {
                Composite.removeCompositeAt(compositeA, position);
                Composite.setModified(compositeA, true, true, false);
              }
              if (deep) {
                for (var i = 0; i < compositeA.composites.length; i++) {
                  Composite.removeComposite(compositeA.composites[i], compositeB, true);
                }
              }
              return compositeA;
            };
            Composite.removeCompositeAt = function(composite, position) {
              composite.composites.splice(position, 1);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.addBody = function(composite, body) {
              composite.bodies.push(body);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.removeBody = function(composite, body, deep) {
              var position = composite.bodies.indexOf(body);
              if (position !== -1) {
                Composite.removeBodyAt(composite, position);
                Composite.setModified(composite, true, true, false);
              }
              if (deep) {
                for (var i = 0; i < composite.composites.length; i++) {
                  Composite.removeBody(composite.composites[i], body, true);
                }
              }
              return composite;
            };
            Composite.removeBodyAt = function(composite, position) {
              composite.bodies.splice(position, 1);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.addConstraint = function(composite, constraint) {
              composite.constraints.push(constraint);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.removeConstraint = function(composite, constraint, deep) {
              var position = composite.constraints.indexOf(constraint);
              if (position !== -1) {
                Composite.removeConstraintAt(composite, position);
              }
              if (deep) {
                for (var i = 0; i < composite.composites.length; i++) {
                  Composite.removeConstraint(composite.composites[i], constraint, true);
                }
              }
              return composite;
            };
            Composite.removeConstraintAt = function(composite, position) {
              composite.constraints.splice(position, 1);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.clear = function(composite, keepStatic, deep) {
              if (deep) {
                for (var i = 0; i < composite.composites.length; i++) {
                  Composite.clear(composite.composites[i], keepStatic, true);
                }
              }
              if (keepStatic) {
                composite.bodies = composite.bodies.filter(function(body) {
                  return body.isStatic;
                });
              } else {
                composite.bodies.length = 0;
              }
              composite.constraints.length = 0;
              composite.composites.length = 0;
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.allBodies = function(composite) {
              var bodies = [].concat(composite.bodies);
              for (var i = 0; i < composite.composites.length; i++)
                bodies = bodies.concat(Composite.allBodies(composite.composites[i]));
              return bodies;
            };
            Composite.allConstraints = function(composite) {
              var constraints = [].concat(composite.constraints);
              for (var i = 0; i < composite.composites.length; i++)
                constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));
              return constraints;
            };
            Composite.allComposites = function(composite) {
              var composites = [].concat(composite.composites);
              for (var i = 0; i < composite.composites.length; i++)
                composites = composites.concat(Composite.allComposites(composite.composites[i]));
              return composites;
            };
            Composite.get = function(composite, id, type) {
              var objects, object;
              switch (type) {
                case "body":
                  objects = Composite.allBodies(composite);
                  break;
                case "constraint":
                  objects = Composite.allConstraints(composite);
                  break;
                case "composite":
                  objects = Composite.allComposites(composite).concat(composite);
                  break;
              }
              if (!objects)
                return null;
              object = objects.filter(function(object2) {
                return object2.id.toString() === id.toString();
              });
              return object.length === 0 ? null : object[0];
            };
            Composite.move = function(compositeA, objects, compositeB) {
              Composite.remove(compositeA, objects);
              Composite.add(compositeB, objects);
              return compositeA;
            };
            Composite.rebase = function(composite) {
              var objects = Composite.allBodies(composite).concat(Composite.allConstraints(composite)).concat(Composite.allComposites(composite));
              for (var i = 0; i < objects.length; i++) {
                objects[i].id = Common.nextId();
              }
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.translate = function(composite, translation, recursive) {
              var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
              for (var i = 0; i < bodies.length; i++) {
                Body.translate(bodies[i], translation);
              }
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.rotate = function(composite, rotation, point, recursive) {
              var cos = Math.cos(rotation), sin = Math.sin(rotation), bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;
                Body.setPosition(body, {
                  x: point.x + (dx * cos - dy * sin),
                  y: point.y + (dx * sin + dy * cos)
                });
                Body.rotate(body, rotation);
              }
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.scale = function(composite, scaleX, scaleY, point, recursive) {
              var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;
                Body.setPosition(body, {
                  x: point.x + dx * scaleX,
                  y: point.y + dy * scaleY
                });
                Body.scale(body, scaleX, scaleY);
              }
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.bounds = function(composite) {
              var bodies = Composite.allBodies(composite), vertices = [];
              for (var i = 0; i < bodies.length; i += 1) {
                var body = bodies[i];
                vertices.push(body.bounds.min, body.bounds.max);
              }
              return Bounds.create(vertices);
            };
          })();
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ScaleModes = {
            DEFAULT: 0,
            LINEAR: 0,
            NEAREST: 1
          };
          module2.exports = ScaleModes;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var CircumferencePoint = function(circle, angle, out) {
            if (out === void 0) {
              out = new Point();
            }
            out.x = circle.x + circle.radius * Math.cos(angle);
            out.y = circle.y + circle.radius * Math.sin(angle);
            return out;
          };
          module2.exports = CircumferencePoint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var Random = function(circle, out) {
            if (out === void 0) {
              out = new Point();
            }
            var t = 2 * Math.PI * Math.random();
            var u = Math.random() + Math.random();
            var r = u > 1 ? 2 - u : u;
            var x = r * Math.cos(t);
            var y = r * Math.sin(t);
            out.x = circle.x + x * circle.radius;
            out.y = circle.y + y * circle.radius;
            return out;
          };
          module2.exports = Random;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Perimeter = __webpack_require__(128);
          var Point = __webpack_require__(4);
          var GetPoint = function(rectangle, position, out) {
            if (out === void 0) {
              out = new Point();
            }
            if (position <= 0 || position >= 1) {
              out.x = rectangle.x;
              out.y = rectangle.y;
              return out;
            }
            var p = Perimeter(rectangle) * position;
            if (position > 0.5) {
              p -= rectangle.width + rectangle.height;
              if (p <= rectangle.width) {
                out.x = rectangle.right - p;
                out.y = rectangle.bottom;
              } else {
                out.x = rectangle.x;
                out.y = rectangle.bottom - (p - rectangle.width);
              }
            } else if (p <= rectangle.width) {
              out.x = rectangle.x + p;
              out.y = rectangle.y;
            } else {
              out.x = rectangle.right;
              out.y = rectangle.y + (p - rectangle.width);
            }
            return out;
          };
          module2.exports = GetPoint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Length = __webpack_require__(64);
          var Point = __webpack_require__(4);
          var GetPoints = function(line, quantity, stepRate, out) {
            if (out === void 0) {
              out = [];
            }
            if (!quantity && stepRate > 0) {
              quantity = Length(line) / stepRate;
            }
            var x1 = line.x1;
            var y1 = line.y1;
            var x2 = line.x2;
            var y2 = line.y2;
            for (var i = 0; i < quantity; i++) {
              var position = i / quantity;
              var x = x1 + (x2 - x1) * position;
              var y = y1 + (y2 - y1) * position;
              out.push(new Point(x, y));
            }
            return out;
          };
          module2.exports = GetPoints;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var Random = function(line, out) {
            if (out === void 0) {
              out = new Point();
            }
            var t = Math.random();
            out.x = line.x1 + t * (line.x2 - line.x1);
            out.y = line.y1 + t * (line.y2 - line.y1);
            return out;
          };
          module2.exports = Random;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var Random = function(rect, out) {
            if (out === void 0) {
              out = new Point();
            }
            out.x = rect.x + Math.random() * rect.width;
            out.y = rect.y + Math.random() * rect.height;
            return out;
          };
          module2.exports = Random;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DeepCopy = __webpack_require__(172);
          var PIPELINE_CONST = __webpack_require__(65);
          var SpliceOne = __webpack_require__(74);
          var Pipeline = {
            defaultPipeline: null,
            pipeline: null,
            hasPostPipeline: false,
            postPipelines: null,
            pipelineData: null,
            initPipeline: function(pipeline) {
              if (pipeline === void 0) {
                pipeline = PIPELINE_CONST.MULTI_PIPELINE;
              }
              var renderer = this.scene.sys.renderer;
              if (!renderer) {
                return false;
              }
              var pipelines = renderer.pipelines;
              this.postPipelines = [];
              this.pipelineData = {};
              if (pipelines) {
                var instance = pipelines.get(pipeline);
                if (instance) {
                  this.defaultPipeline = instance;
                  this.pipeline = instance;
                  return true;
                }
              }
              return false;
            },
            setPipeline: function(pipeline, pipelineData, copyData) {
              var renderer = this.scene.sys.renderer;
              if (!renderer) {
                return this;
              }
              var pipelines = renderer.pipelines;
              if (pipelines) {
                var instance = pipelines.get(pipeline);
                if (instance) {
                  this.pipeline = instance;
                }
                if (pipelineData) {
                  this.pipelineData = copyData ? DeepCopy(pipelineData) : pipelineData;
                }
              }
              return this;
            },
            setPostPipeline: function(pipelines, pipelineData, copyData) {
              var renderer = this.scene.sys.renderer;
              if (!renderer) {
                return this;
              }
              var pipelineManager = renderer.pipelines;
              if (pipelineManager) {
                if (!Array.isArray(pipelines)) {
                  pipelines = [pipelines];
                }
                for (var i = 0; i < pipelines.length; i++) {
                  var instance = pipelineManager.getPostPipeline(pipelines[i], this);
                  if (instance) {
                    this.postPipelines.push(instance);
                  }
                }
                if (pipelineData) {
                  this.pipelineData = copyData ? DeepCopy(pipelineData) : pipelineData;
                }
              }
              this.hasPostPipeline = this.postPipelines.length > 0;
              return this;
            },
            setPipelineData: function(key, value) {
              var data = this.pipelineData;
              if (value === void 0) {
                delete data[key];
              } else {
                data[key] = value;
              }
              return this;
            },
            getPostPipeline: function(pipeline) {
              var pipelines = this.postPipelines;
              var results = [];
              for (var i = 0; i < pipelines.length; i++) {
                var instance = pipelines[i];
                if (typeof pipeline === "string" && instance.name === pipeline || instance instanceof pipeline) {
                  results.push(instance);
                }
              }
              return results.length === 1 ? results[0] : results;
            },
            resetPipeline: function(resetPostPipelines, resetData) {
              if (resetPostPipelines === void 0) {
                resetPostPipelines = false;
              }
              if (resetData === void 0) {
                resetData = false;
              }
              this.pipeline = this.defaultPipeline;
              if (resetPostPipelines) {
                this.postPipelines = [];
                this.hasPostPipeline = false;
              }
              if (resetData) {
                this.pipelineData = {};
              }
              return this.pipeline !== null;
            },
            resetPostPipeline: function(resetData) {
              if (resetData === void 0) {
                resetData = false;
              }
              var pipelines = this.postPipelines;
              for (var i = 0; i < pipelines.length; i++) {
                pipelines[i].destroy();
              }
              this.postPipelines = [];
              this.hasPostPipeline = false;
              if (resetData) {
                this.pipelineData = {};
              }
            },
            removePostPipeline: function(pipeline) {
              var pipelines = this.postPipelines;
              for (var i = pipelines.length - 1; i >= 0; i--) {
                var instance = pipelines[i];
                if (typeof pipeline === "string" && instance.name === pipeline || typeof pipeline !== "string" && instance instanceof pipeline) {
                  instance.destroy();
                  SpliceOne(pipelines, i);
                }
              }
              this.hasPostPipeline = this.postPipelines.length > 0;
              return this;
            },
            getPipelineName: function() {
              return this.pipeline.name;
            }
          };
          module2.exports = Pipeline;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DeepCopy = function(inObject) {
            var outObject;
            var value;
            var key;
            if (typeof inObject !== "object" || inObject === null) {
              return inObject;
            }
            outObject = Array.isArray(inObject) ? [] : {};
            for (key in inObject) {
              value = inObject[key];
              outObject[key] = DeepCopy(value);
            }
            return outObject;
          };
          module2.exports = DeepCopy;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ToJSON = function(gameObject) {
            var out = {
              name: gameObject.name,
              type: gameObject.type,
              x: gameObject.x,
              y: gameObject.y,
              depth: gameObject.depth,
              scale: {
                x: gameObject.scaleX,
                y: gameObject.scaleY
              },
              origin: {
                x: gameObject.originX,
                y: gameObject.originY
              },
              flipX: gameObject.flipX,
              flipY: gameObject.flipY,
              rotation: gameObject.rotation,
              alpha: gameObject.alpha,
              visible: gameObject.visible,
              blendMode: gameObject.blendMode,
              textureKey: "",
              frameKey: "",
              data: {}
            };
            if (gameObject.texture) {
              out.textureKey = gameObject.texture.key;
              out.frameKey = gameObject.frame.name;
            }
            return out;
          };
          module2.exports = ToJSON;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector29 = __webpack_require__(3);
          var TransformXY = function(x, y, positionX, positionY, rotation, scaleX, scaleY, output) {
            if (output === void 0) {
              output = new Vector29();
            }
            var radianSin = Math.sin(rotation);
            var radianCos = Math.cos(rotation);
            var a = radianCos * scaleX;
            var b = radianSin * scaleX;
            var c = -radianSin * scaleY;
            var d = radianCos * scaleY;
            var id = 1 / (a * d + c * -b);
            output.x = d * id * x + -c * id * y + (positionY * c - positionX * d) * id;
            output.y = a * id * y + -b * id * x + (-positionY * a + positionX * b) * id;
            return output;
          };
          module2.exports = TransformXY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateLeft = function(array, total) {
            if (total === void 0) {
              total = 1;
            }
            var element = null;
            for (var i = 0; i < total; i++) {
              element = array.shift();
              array.push(element);
            }
            return element;
          };
          module2.exports = RotateLeft;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateRight = function(array, total) {
            if (total === void 0) {
              total = 1;
            }
            var element = null;
            for (var i = 0; i < total; i++) {
              element = array.pop();
              array.unshift(element);
            }
            return element;
          };
          module2.exports = RotateRight;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var Random = function(ellipse, out) {
            if (out === void 0) {
              out = new Point();
            }
            var p = Math.random() * Math.PI * 2;
            var s = Math.sqrt(Math.random());
            out.x = ellipse.x + s * Math.cos(p) * ellipse.width / 2;
            out.y = ellipse.y + s * Math.sin(p) * ellipse.height / 2;
            return out;
          };
          module2.exports = Random;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var Random = function(triangle, out) {
            if (out === void 0) {
              out = new Point();
            }
            var ux = triangle.x2 - triangle.x1;
            var uy = triangle.y2 - triangle.y1;
            var vx = triangle.x3 - triangle.x1;
            var vy = triangle.y3 - triangle.y1;
            var r = Math.random();
            var s = Math.random();
            if (r + s >= 1) {
              r = 1 - r;
              s = 1 - s;
            }
            out.x = triangle.x1 + (ux * r + vx * s);
            out.y = triangle.y1 + (uy * r + vy * s);
            return out;
          };
          module2.exports = Random;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateAroundDistance = function(point, x, y, angle, distance) {
            var t = angle + Math.atan2(point.y - y, point.x - x);
            point.x = x + distance * Math.cos(t);
            point.y = y + distance * Math.sin(t);
            return point;
          };
          module2.exports = RotateAroundDistance;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SmootherStep = function(x, min, max) {
            x = Math.max(0, Math.min(1, (x - min) / (max - min)));
            return x * x * x * (x * (x * 6 - 15) + 10);
          };
          module2.exports = SmootherStep;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SmoothStep = function(x, min, max) {
            if (x <= min) {
              return 0;
            }
            if (x >= max) {
              return 1;
            }
            x = (x - min) / (max - min);
            return x * x * (3 - 2 * x);
          };
          module2.exports = SmoothStep;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(130);
          var FindClosestInSorted = __webpack_require__(312);
          var Frame = __webpack_require__(313);
          var GetValue = __webpack_require__(6);
          var SortByDigits = __webpack_require__(314);
          var Animation = new Class({
            initialize: function Animation2(manager, key, config2) {
              this.manager = manager;
              this.key = key;
              this.type = "frame";
              this.frames = this.getFrames(manager.textureManager, GetValue(config2, "frames", []), GetValue(config2, "defaultTextureKey", null), GetValue(config2, "sortFrames", true));
              this.frameRate = GetValue(config2, "frameRate", null);
              this.duration = GetValue(config2, "duration", null);
              this.msPerFrame;
              this.skipMissedFrames = GetValue(config2, "skipMissedFrames", true);
              this.delay = GetValue(config2, "delay", 0);
              this.repeat = GetValue(config2, "repeat", 0);
              this.repeatDelay = GetValue(config2, "repeatDelay", 0);
              this.yoyo = GetValue(config2, "yoyo", false);
              this.showOnStart = GetValue(config2, "showOnStart", false);
              this.hideOnComplete = GetValue(config2, "hideOnComplete", false);
              this.paused = false;
              this.calculateDuration(this, this.getTotalFrames(), this.duration, this.frameRate);
              if (this.manager.on) {
                this.manager.on(Events.PAUSE_ALL, this.pause, this);
                this.manager.on(Events.RESUME_ALL, this.resume, this);
              }
            },
            getTotalFrames: function() {
              return this.frames.length;
            },
            calculateDuration: function(target, totalFrames, duration, frameRate) {
              if (duration === null && frameRate === null) {
                target.frameRate = 24;
                target.duration = 24 / totalFrames * 1e3;
              } else if (duration && frameRate === null) {
                target.duration = duration;
                target.frameRate = totalFrames / (duration / 1e3);
              } else {
                target.frameRate = frameRate;
                target.duration = totalFrames / frameRate * 1e3;
              }
              target.msPerFrame = 1e3 / target.frameRate;
            },
            addFrame: function(config2) {
              return this.addFrameAt(this.frames.length, config2);
            },
            addFrameAt: function(index, config2) {
              var newFrames = this.getFrames(this.manager.textureManager, config2);
              if (newFrames.length > 0) {
                if (index === 0) {
                  this.frames = newFrames.concat(this.frames);
                } else if (index === this.frames.length) {
                  this.frames = this.frames.concat(newFrames);
                } else {
                  var pre = this.frames.slice(0, index);
                  var post = this.frames.slice(index);
                  this.frames = pre.concat(newFrames, post);
                }
                this.updateFrameSequence();
              }
              return this;
            },
            checkFrame: function(index) {
              return index >= 0 && index < this.frames.length;
            },
            getFirstTick: function(state) {
              state.accumulator = 0;
              state.nextTick = state.msPerFrame + state.currentFrame.duration;
            },
            getFrameAt: function(index) {
              return this.frames[index];
            },
            getFrames: function(textureManager, frames, defaultTextureKey, sortFrames) {
              if (sortFrames === void 0) {
                sortFrames = true;
              }
              var out = [];
              var prev;
              var animationFrame;
              var index = 1;
              var i;
              var textureKey;
              if (typeof frames === "string") {
                textureKey = frames;
                var texture = textureManager.get(textureKey);
                var frameKeys = texture.getFrameNames();
                if (sortFrames) {
                  SortByDigits(frameKeys);
                }
                frames = [];
                frameKeys.forEach(function(value) {
                  frames.push({key: textureKey, frame: value});
                });
              }
              if (!Array.isArray(frames) || frames.length === 0) {
                return out;
              }
              for (i = 0; i < frames.length; i++) {
                var item = frames[i];
                var key = GetValue(item, "key", defaultTextureKey);
                if (!key) {
                  continue;
                }
                var frame = GetValue(item, "frame", 0);
                var textureFrame = textureManager.getFrame(key, frame);
                animationFrame = new Frame(key, frame, index, textureFrame);
                animationFrame.duration = GetValue(item, "duration", 0);
                animationFrame.isFirst = !prev;
                if (prev) {
                  prev.nextFrame = animationFrame;
                  animationFrame.prevFrame = prev;
                }
                out.push(animationFrame);
                prev = animationFrame;
                index++;
              }
              if (out.length > 0) {
                animationFrame.isLast = true;
                animationFrame.nextFrame = out[0];
                out[0].prevFrame = animationFrame;
                var slice = 1 / (out.length - 1);
                for (i = 0; i < out.length; i++) {
                  out[i].progress = i * slice;
                }
              }
              return out;
            },
            getNextTick: function(state) {
              state.accumulator -= state.nextTick;
              state.nextTick = state.msPerFrame + state.currentFrame.duration;
            },
            getFrameByProgress: function(value) {
              value = Clamp(value, 0, 1);
              return FindClosestInSorted(value, this.frames, "progress");
            },
            nextFrame: function(state) {
              var frame = state.currentFrame;
              if (frame.isLast) {
                if (state.yoyo) {
                  this.handleYoyoFrame(state, false);
                } else if (state.repeatCounter > 0) {
                  if (state.inReverse && state.forward) {
                    state.forward = false;
                  } else {
                    this.repeatAnimation(state);
                  }
                } else {
                  state.complete();
                }
              } else {
                this.updateAndGetNextTick(state, frame.nextFrame);
              }
            },
            handleYoyoFrame: function(state, isReverse) {
              if (!isReverse) {
                isReverse = false;
              }
              if (state.inReverse === !isReverse && state.repeatCounter > 0) {
                if (state.repeatDelay === 0 || state.pendingRepeat) {
                  state.forward = isReverse;
                }
                this.repeatAnimation(state);
                return;
              }
              if (state.inReverse !== isReverse && state.repeatCounter === 0) {
                state.complete();
                return;
              }
              state.forward = isReverse;
              var frame = isReverse ? state.currentFrame.nextFrame : state.currentFrame.prevFrame;
              this.updateAndGetNextTick(state, frame);
            },
            getLastFrame: function() {
              return this.frames[this.frames.length - 1];
            },
            previousFrame: function(state) {
              var frame = state.currentFrame;
              if (frame.isFirst) {
                if (state.yoyo) {
                  this.handleYoyoFrame(state, true);
                } else if (state.repeatCounter > 0) {
                  if (state.inReverse && !state.forward) {
                    this.repeatAnimation(state);
                  } else {
                    state.forward = true;
                    this.repeatAnimation(state);
                  }
                } else {
                  state.complete();
                }
              } else {
                this.updateAndGetNextTick(state, frame.prevFrame);
              }
            },
            updateAndGetNextTick: function(state, frame) {
              state.setCurrentFrame(frame);
              this.getNextTick(state);
            },
            removeFrame: function(frame) {
              var index = this.frames.indexOf(frame);
              if (index !== -1) {
                this.removeFrameAt(index);
              }
              return this;
            },
            removeFrameAt: function(index) {
              this.frames.splice(index, 1);
              this.updateFrameSequence();
              return this;
            },
            repeatAnimation: function(state) {
              if (state._pendingStop === 2) {
                if (state._pendingStopValue === 0) {
                  return state.stop();
                } else {
                  state._pendingStopValue--;
                }
              }
              if (state.repeatDelay > 0 && !state.pendingRepeat) {
                state.pendingRepeat = true;
                state.accumulator -= state.nextTick;
                state.nextTick += state.repeatDelay;
              } else {
                state.repeatCounter--;
                if (state.forward) {
                  state.setCurrentFrame(state.currentFrame.nextFrame);
                } else {
                  state.setCurrentFrame(state.currentFrame.prevFrame);
                }
                if (state.isPlaying) {
                  this.getNextTick(state);
                  state.handleRepeat();
                }
              }
            },
            toJSON: function() {
              var output = {
                key: this.key,
                type: this.type,
                frames: [],
                frameRate: this.frameRate,
                duration: this.duration,
                skipMissedFrames: this.skipMissedFrames,
                delay: this.delay,
                repeat: this.repeat,
                repeatDelay: this.repeatDelay,
                yoyo: this.yoyo,
                showOnStart: this.showOnStart,
                hideOnComplete: this.hideOnComplete
              };
              this.frames.forEach(function(frame) {
                output.frames.push(frame.toJSON());
              });
              return output;
            },
            updateFrameSequence: function() {
              var len = this.frames.length;
              var slice = 1 / (len - 1);
              var frame;
              for (var i = 0; i < len; i++) {
                frame = this.frames[i];
                frame.index = i + 1;
                frame.isFirst = false;
                frame.isLast = false;
                frame.progress = i * slice;
                if (i === 0) {
                  frame.isFirst = true;
                  if (len === 1) {
                    frame.isLast = true;
                    frame.nextFrame = frame;
                    frame.prevFrame = frame;
                  } else {
                    frame.isLast = false;
                    frame.prevFrame = this.frames[len - 1];
                    frame.nextFrame = this.frames[i + 1];
                  }
                } else if (i === len - 1 && len > 1) {
                  frame.isLast = true;
                  frame.prevFrame = this.frames[len - 2];
                  frame.nextFrame = this.frames[0];
                } else if (len > 1) {
                  frame.prevFrame = this.frames[i - 1];
                  frame.nextFrame = this.frames[i + 1];
                }
              }
              return this;
            },
            pause: function() {
              this.paused = true;
              return this;
            },
            resume: function() {
              this.paused = false;
              return this;
            },
            destroy: function() {
              if (this.manager.off) {
                this.manager.off(Events.PAUSE_ALL, this.pause, this);
                this.manager.off(Events.RESUME_ALL, this.resume, this);
              }
              this.manager.remove(this.key);
              for (var i = 0; i < this.frames.length; i++) {
                this.frames[i].destroy();
              }
              this.frames = [];
              this.manager = null;
            }
          });
          module2.exports = Animation;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Pad = function(str, len, pad, dir) {
            if (len === void 0) {
              len = 0;
            }
            if (pad === void 0) {
              pad = " ";
            }
            if (dir === void 0) {
              dir = 3;
            }
            str = str.toString();
            var padlen = 0;
            if (len + 1 >= str.length) {
              switch (dir) {
                case 1:
                  str = new Array(len + 1 - str.length).join(pad) + str;
                  break;
                case 3:
                  var right = Math.ceil((padlen = len - str.length) / 2);
                  var left = padlen - right;
                  str = new Array(left + 1).join(pad) + str + new Array(right + 1).join(pad);
                  break;
                default:
                  str = str + new Array(len + 1 - str.length).join(pad);
                  break;
              }
            }
            return str;
          };
          module2.exports = Pad;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var HexStringToColor = __webpack_require__(321);
          var IntegerToColor = __webpack_require__(186);
          var ObjectToColor = __webpack_require__(325);
          var RGBStringToColor = __webpack_require__(326);
          var ValueToColor = function(input) {
            var t = typeof input;
            switch (t) {
              case "string":
                if (input.substr(0, 3).toLowerCase() === "rgb") {
                  return RGBStringToColor(input);
                } else {
                  return HexStringToColor(input);
                }
              case "number":
                return IntegerToColor(input);
              case "object":
                return ObjectToColor(input);
            }
          };
          module2.exports = ValueToColor;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetColor = __webpack_require__(100);
          function ConvertValue(n, h, s, v) {
            var k = (n + h * 6) % 6;
            var min = Math.min(k, 4 - k, 1);
            return Math.round(255 * (v - v * s * Math.max(0, min)));
          }
          var HSVToRGB = function(h, s, v, out) {
            if (s === void 0) {
              s = 1;
            }
            if (v === void 0) {
              v = 1;
            }
            var r = ConvertValue(5, h, s, v);
            var g = ConvertValue(3, h, s, v);
            var b = ConvertValue(1, h, s, v);
            if (!out) {
              return {r, g, b, color: GetColor(r, g, b)};
            } else if (out.setTo) {
              return out.setTo(r, g, b, out.alpha, false);
            } else {
              out.r = r;
              out.g = g;
              out.b = b;
              out.color = GetColor(r, g, b);
              return out;
            }
          };
          module2.exports = HSVToRGB;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Color = __webpack_require__(37);
          var IntegerToRGB = __webpack_require__(324);
          var IntegerToColor = function(input) {
            var rgb = IntegerToRGB(input);
            return new Color(rgb.r, rgb.g, rgb.b, rgb.a);
          };
          module2.exports = IntegerToColor;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CenterOn = function(rect, x, y) {
            rect.x = x - rect.width / 2;
            rect.y = y - rect.height / 2;
            return rect;
          };
          module2.exports = CenterOn;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var OS = __webpack_require__(102);
          var Browser = __webpack_require__(134);
          var CanvasPool = __webpack_require__(31);
          var Features = {
            canvas: false,
            canvasBitBltShift: null,
            file: false,
            fileSystem: false,
            getUserMedia: true,
            littleEndian: false,
            localStorage: false,
            pointerLock: false,
            support32bit: false,
            vibration: false,
            webGL: false,
            worker: false
          };
          function checkIsLittleEndian() {
            var a = new ArrayBuffer(4);
            var b = new Uint8Array(a);
            var c = new Uint32Array(a);
            b[0] = 161;
            b[1] = 178;
            b[2] = 195;
            b[3] = 212;
            if (c[0] === 3569595041) {
              return true;
            }
            if (c[0] === 2712847316) {
              return false;
            } else {
              return null;
            }
          }
          function init() {
            Features.canvas = !!window["CanvasRenderingContext2D"];
            try {
              Features.localStorage = !!localStorage.getItem;
            } catch (error) {
              Features.localStorage = false;
            }
            Features.file = !!window["File"] && !!window["FileReader"] && !!window["FileList"] && !!window["Blob"];
            Features.fileSystem = !!window["requestFileSystem"];
            var isUint8 = false;
            var testWebGL = function() {
              if (window["WebGLRenderingContext"]) {
                try {
                  var canvas = CanvasPool.createWebGL(this);
                  var ctx = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
                  var canvas2D = CanvasPool.create2D(this);
                  var ctx2D = canvas2D.getContext("2d");
                  var image = ctx2D.createImageData(1, 1);
                  isUint8 = image.data instanceof Uint8ClampedArray;
                  CanvasPool.remove(canvas);
                  CanvasPool.remove(canvas2D);
                  return !!ctx;
                } catch (e) {
                  return false;
                }
              }
              return false;
            };
            Features.webGL = testWebGL();
            Features.worker = !!window["Worker"];
            Features.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;
            window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
            Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL;
            if (Browser.firefox && Browser.firefoxVersion < 21) {
              Features.getUserMedia = false;
            }
            if (!OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome)) {
              Features.canvasBitBltShift = true;
            }
            if (Browser.safari || Browser.mobileSafari) {
              Features.canvasBitBltShift = false;
            }
            navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
            if (navigator.vibrate) {
              Features.vibration = true;
            }
            if (typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint32Array !== "undefined") {
              Features.littleEndian = checkIsLittleEndian();
            }
            Features.support32bit = typeof ArrayBuffer !== "undefined" && typeof Uint8ClampedArray !== "undefined" && typeof Int32Array !== "undefined" && Features.littleEndian !== null && isUint8;
            return Features;
          }
          module2.exports = init();
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var prefix = "";
          var Smoothing = function() {
            var getPrefix = function(context) {
              var vendors = ["i", "webkitI", "msI", "mozI", "oI"];
              for (var i = 0; i < vendors.length; i++) {
                var s = vendors[i] + "mageSmoothingEnabled";
                if (s in context) {
                  return s;
                }
              }
              return null;
            };
            var enable = function(context) {
              if (prefix === "") {
                prefix = getPrefix(context);
              }
              if (prefix) {
                context[prefix] = true;
              }
              return context;
            };
            var disable = function(context) {
              if (prefix === "") {
                prefix = getPrefix(context);
              }
              if (prefix) {
                context[prefix] = false;
              }
              return context;
            };
            var isEnabled = function(context) {
              return prefix !== null ? context[prefix] : null;
            };
            return {
              disable,
              enable,
              getPrefix,
              isEnabled
            };
          };
          module2.exports = Smoothing();
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(14);
          var Extend = __webpack_require__(17);
          var PhaserMath = {
            Angle: __webpack_require__(809),
            Distance: __webpack_require__(818),
            Easing: __webpack_require__(823),
            Fuzzy: __webpack_require__(824),
            Interpolation: __webpack_require__(827),
            Pow2: __webpack_require__(832),
            Snap: __webpack_require__(834),
            RandomDataGenerator: __webpack_require__(836),
            Average: __webpack_require__(837),
            Bernstein: __webpack_require__(350),
            Between: __webpack_require__(192),
            CatmullRom: __webpack_require__(191),
            CeilTo: __webpack_require__(838),
            Clamp: __webpack_require__(18),
            DegToRad: __webpack_require__(35),
            Difference: __webpack_require__(839),
            Euler: __webpack_require__(840),
            Factorial: __webpack_require__(351),
            FloatBetween: __webpack_require__(135),
            FloorTo: __webpack_require__(841),
            FromPercent: __webpack_require__(95),
            GetSpeed: __webpack_require__(842),
            IsEven: __webpack_require__(843),
            IsEvenStrict: __webpack_require__(844),
            Linear: __webpack_require__(133),
            MaxAdd: __webpack_require__(845),
            MinSub: __webpack_require__(846),
            Percent: __webpack_require__(847),
            RadToDeg: __webpack_require__(193),
            RandomXY: __webpack_require__(848),
            RandomXYZ: __webpack_require__(849),
            RandomXYZW: __webpack_require__(850),
            Rotate: __webpack_require__(356),
            RotateAround: __webpack_require__(302),
            RotateAroundDistance: __webpack_require__(179),
            RotateTo: __webpack_require__(851),
            RoundAwayFromZero: __webpack_require__(357),
            RoundTo: __webpack_require__(852),
            SinCosTableGenerator: __webpack_require__(853),
            SmootherStep: __webpack_require__(180),
            SmoothStep: __webpack_require__(181),
            ToXY: __webpack_require__(854),
            TransformXY: __webpack_require__(174),
            Within: __webpack_require__(855),
            Wrap: __webpack_require__(66),
            Vector2: __webpack_require__(3),
            Vector3: __webpack_require__(38),
            Vector4: __webpack_require__(138),
            Matrix3: __webpack_require__(358),
            Matrix4: __webpack_require__(67),
            Quaternion: __webpack_require__(359),
            RotateVec3: __webpack_require__(856)
          };
          PhaserMath = Extend(false, PhaserMath, CONST);
          module2.exports = PhaserMath;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CatmullRom = function(t, p0, p1, p2, p3) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            var t2 = t * t;
            var t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
          };
          module2.exports = CatmullRom;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Between = function(min, max) {
            return Math.floor(Math.random() * (max - min + 1) + min);
          };
          module2.exports = Between;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(14);
          var RadToDeg = function(radians) {
            return radians * CONST.RAD_TO_DEG;
          };
          module2.exports = RadToDeg;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DefaultPlugins = {
            Global: [
              "game",
              "anims",
              "cache",
              "plugins",
              "registry",
              "scale",
              "sound",
              "textures",
              "renderer"
            ],
            CoreScene: [
              "EventEmitter",
              "CameraManager",
              "GameObjectCreator",
              "GameObjectFactory",
              "ScenePlugin",
              "DisplayList",
              "UpdateList"
            ],
            DefaultScene: [
              "Clock",
              "DataManagerPlugin",
              "InputPlugin",
              "Loader",
              "TweenManager",
              "LightsPlugin"
            ]
          };
          if (false) {
          }
          if (false) {
          }
          module2.exports = DefaultPlugins;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var ColorMatrix = new Class({
            initialize: function ColorMatrix2() {
              this._matrix = [
                1,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                1,
                0
              ];
              this.alpha = 1;
              this._dirty = true;
              this._data;
            },
            set: function(value) {
              this._matrix = value;
              this._dirty = true;
              return this;
            },
            reset: function() {
              var m = this._matrix;
              m[0] = 1;
              m[1] = 0;
              m[2] = 0;
              m[3] = 0;
              m[4] = 0;
              m[5] = 0;
              m[6] = 1;
              m[7] = 0;
              m[8] = 0;
              m[9] = 0;
              m[10] = 0;
              m[11] = 0;
              m[12] = 1;
              m[13] = 0;
              m[14] = 0;
              m[15] = 0;
              m[16] = 0;
              m[17] = 0;
              m[18] = 1;
              m[19] = 0;
              this._dirty = true;
              return this;
            },
            getData: function() {
              if (this._dirty) {
                var f32 = new Float32Array(this._matrix);
                f32[4] /= 255;
                f32[9] /= 255;
                f32[14] /= 255;
                f32[19] /= 255;
                this._data = f32;
                this._dirty = false;
              }
              return this._data;
            },
            brightness: function(value, multiply) {
              if (value === void 0) {
                value = 0;
              }
              if (multiply === void 0) {
                multiply = false;
              }
              var b = value;
              return this.multiply([
                b,
                0,
                0,
                0,
                0,
                0,
                b,
                0,
                0,
                0,
                0,
                0,
                b,
                0,
                0,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            saturate: function(value, multiply) {
              if (value === void 0) {
                value = 0;
              }
              if (multiply === void 0) {
                multiply = false;
              }
              var x = value * 2 / 3 + 1;
              var y = (x - 1) * -0.5;
              return this.multiply([
                x,
                y,
                y,
                0,
                0,
                y,
                x,
                y,
                0,
                0,
                y,
                y,
                x,
                0,
                0,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            desaturate: function(multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.saturate(-1, multiply);
            },
            hue: function(rotation, multiply) {
              if (rotation === void 0) {
                rotation = 0;
              }
              if (multiply === void 0) {
                multiply = false;
              }
              rotation = rotation / 180 * Math.PI;
              var cos = Math.cos(rotation);
              var sin = Math.sin(rotation);
              var lumR = 0.213;
              var lumG = 0.715;
              var lumB = 0.072;
              return this.multiply([
                lumR + cos * (1 - lumR) + sin * -lumR,
                lumG + cos * -lumG + sin * -lumG,
                lumB + cos * -lumB + sin * (1 - lumB),
                0,
                0,
                lumR + cos * -lumR + sin * 0.143,
                lumG + cos * (1 - lumG) + sin * 0.14,
                lumB + cos * -lumB + sin * -0.283,
                0,
                0,
                lumR + cos * -lumR + sin * -(1 - lumR),
                lumG + cos * -lumG + sin * lumG,
                lumB + cos * (1 - lumB) + sin * lumB,
                0,
                0,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            grayscale: function(value, multiply) {
              if (value === void 0) {
                value = 1;
              }
              if (multiply === void 0) {
                multiply = false;
              }
              return this.saturate(-value, multiply);
            },
            blackWhite: function(multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([
                0.3,
                0.6,
                0.1,
                0,
                0,
                0.3,
                0.6,
                0.1,
                0,
                0,
                0.3,
                0.6,
                0.1,
                0,
                0,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            contrast: function(value, multiply) {
              if (value === void 0) {
                value = 0;
              }
              if (multiply === void 0) {
                multiply = false;
              }
              var v = value + 1;
              var o = -0.5 * (v - 1);
              return this.multiply([
                v,
                0,
                0,
                0,
                o,
                0,
                v,
                0,
                0,
                o,
                0,
                0,
                v,
                0,
                o,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            negative: function(multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([
                -1,
                0,
                0,
                1,
                0,
                0,
                -1,
                0,
                1,
                0,
                0,
                0,
                -1,
                1,
                0,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            desaturateLuminance: function(multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([
                0.2764723,
                0.929708,
                0.0938197,
                0,
                -37.1,
                0.2764723,
                0.929708,
                0.0938197,
                0,
                -37.1,
                0.2764723,
                0.929708,
                0.0938197,
                0,
                -37.1,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            sepia: function(multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([
                0.393,
                0.7689999,
                0.18899999,
                0,
                0,
                0.349,
                0.6859999,
                0.16799999,
                0,
                0,
                0.272,
                0.5339999,
                0.13099999,
                0,
                0,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            night: function(intensity, multiply) {
              if (intensity === void 0) {
                intensity = 0.1;
              }
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([
                intensity * -2,
                -intensity,
                0,
                0,
                0,
                -intensity,
                0,
                intensity,
                0,
                0,
                0,
                intensity,
                intensity * 2,
                0,
                0,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            lsd: function(multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([
                2,
                -0.4,
                0.5,
                0,
                0,
                -0.5,
                2,
                -0.4,
                0,
                0,
                -0.4,
                -0.5,
                3,
                0,
                0,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            brown: function(multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([
                0.5997023498159715,
                0.34553243048391263,
                -0.2708298674538042,
                0,
                47.43192855600873,
                -0.037703249837783157,
                0.8609577587992641,
                0.15059552388459913,
                0,
                -36.96841498319127,
                0.24113635128153335,
                -0.07441037908422492,
                0.44972182064877153,
                0,
                -7.562075277591283,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            vintagePinhole: function(multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([
                0.6279345635605994,
                0.3202183420819367,
                -0.03965408211312453,
                0,
                9.651285835294123,
                0.02578397704808868,
                0.6441188644374771,
                0.03259127616149294,
                0,
                7.462829176470591,
                0.0466055556782719,
                -0.0851232987247891,
                0.5241648018700465,
                0,
                5.159190588235296,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            kodachrome: function(multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([
                1.1285582396593525,
                -0.3967382283601348,
                -0.03992559172921793,
                0,
                63.72958762196502,
                -0.16404339962244616,
                1.0835251566291304,
                -0.05498805115633132,
                0,
                24.732407896706203,
                -0.16786010706155763,
                -0.5603416277695248,
                1.6014850761964943,
                0,
                35.62982807460946,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            technicolor: function(multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([
                1.9125277891456083,
                -0.8545344976951645,
                -0.09155508482755585,
                0,
                11.793603434377337,
                -0.3087833385928097,
                1.7658908555458428,
                -0.10601743074722245,
                0,
                -70.35205161461398,
                -0.231103377548616,
                -0.7501899197440212,
                1.847597816108189,
                0,
                30.950940869491138,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            polaroid: function(multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([
                1.438,
                -0.062,
                -0.062,
                0,
                0,
                -0.122,
                1.378,
                -0.122,
                0,
                0,
                -0.016,
                -0.016,
                1.483,
                0,
                0,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            shiftToBGR: function(multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([
                0,
                0,
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0
              ], multiply);
            },
            multiply: function(a, multiply) {
              if (!multiply) {
                this.reset();
              }
              var m = this._matrix;
              var c = [];
              for (var i = 0; i < 20; i++) {
                c[i] = m[i];
              }
              m[0] = c[0] * a[0] + c[1] * a[5] + c[2] * a[10] + c[3] * a[15];
              m[1] = c[0] * a[1] + c[1] * a[6] + c[2] * a[11] + c[3] * a[16];
              m[2] = c[0] * a[2] + c[1] * a[7] + c[2] * a[12] + c[3] * a[17];
              m[3] = c[0] * a[3] + c[1] * a[8] + c[2] * a[13] + c[3] * a[18];
              m[4] = c[0] * a[4] + c[1] * a[9] + c[2] * a[14] + c[3] * a[19] + c[4];
              m[5] = c[5] * a[0] + c[6] * a[5] + c[7] * a[10] + c[8] * a[15];
              m[6] = c[5] * a[1] + c[6] * a[6] + c[7] * a[11] + c[8] * a[16];
              m[7] = c[5] * a[2] + c[6] * a[7] + c[7] * a[12] + c[8] * a[17];
              m[8] = c[5] * a[3] + c[6] * a[8] + c[7] * a[13] + c[8] * a[18];
              m[9] = c[5] * a[4] + c[6] * a[9] + c[7] * a[14] + c[8] * a[19] + c[9];
              m[10] = c[10] * a[0] + c[11] * a[5] + c[12] * a[10] + c[13] * a[15];
              m[11] = c[10] * a[1] + c[11] * a[6] + c[12] * a[11] + c[13] * a[16];
              m[12] = c[10] * a[2] + c[11] * a[7] + c[12] * a[12] + c[13] * a[17];
              m[13] = c[10] * a[3] + c[11] * a[8] + c[12] * a[13] + c[13] * a[18];
              m[14] = c[10] * a[4] + c[11] * a[9] + c[12] * a[14] + c[13] * a[19] + c[14];
              m[15] = c[15] * a[0] + c[16] * a[5] + c[17] * a[10] + c[18] * a[15];
              m[16] = c[15] * a[1] + c[16] * a[6] + c[17] * a[11] + c[18] * a[16];
              m[17] = c[15] * a[2] + c[16] * a[7] + c[17] * a[12] + c[18] * a[17];
              m[18] = c[15] * a[3] + c[16] * a[8] + c[17] * a[13] + c[18] * a[18];
              m[19] = c[15] * a[4] + c[16] * a[9] + c[17] * a[14] + c[18] * a[19] + c[19];
              this._dirty = true;
              return this;
            }
          });
          module2.exports = ColorMatrix;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rectangle = __webpack_require__(10);
          var MATH_CONST = __webpack_require__(14);
          var FromPoints = function(points, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            if (points.length === 0) {
              return out;
            }
            var minX = Number.MAX_VALUE;
            var minY = Number.MAX_VALUE;
            var maxX = MATH_CONST.MIN_SAFE_INTEGER;
            var maxY = MATH_CONST.MIN_SAFE_INTEGER;
            var p;
            var px;
            var py;
            for (var i = 0; i < points.length; i++) {
              p = points[i];
              if (Array.isArray(p)) {
                px = p[0];
                py = p[1];
              } else {
                px = p.x;
                py = p.y;
              }
              minX = Math.min(minX, px);
              minY = Math.min(minY, py);
              maxX = Math.max(maxX, px);
              maxY = Math.max(maxY, py);
            }
            out.x = minX;
            out.y = minY;
            out.width = maxX - minX;
            out.height = maxY - minY;
            return out;
          };
          module2.exports = FromPoints;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var NOOP = __webpack_require__(1);
          var RGB = new Class({
            initialize: function RGB2(red, green, blue) {
              this._rgb = [0, 0, 0];
              this.onChangeCallback = NOOP;
              this.dirty = false;
              this.set(red, green, blue);
            },
            set: function(red, green, blue) {
              if (red === void 0) {
                red = 0;
              }
              if (green === void 0) {
                green = 0;
              }
              if (blue === void 0) {
                blue = 0;
              }
              this._rgb = [red, green, blue];
              this.onChange();
              return this;
            },
            equals: function(red, green, blue) {
              var rgb = this._rgb;
              return rgb.r === red && rgb.g === green && rgb.b === blue;
            },
            onChange: function() {
              this.dirty = true;
              var rgb = this._rgb;
              this.onChangeCallback.call(this, rgb[0], rgb[1], rgb[2]);
            },
            r: {
              get: function() {
                return this._rgb[0];
              },
              set: function(value) {
                this._rgb[0] = value;
                this.onChange();
              }
            },
            g: {
              get: function() {
                return this._rgb[1];
              },
              set: function(value) {
                this._rgb[1] = value;
                this.onChange();
              }
            },
            b: {
              get: function() {
                return this._rgb[2];
              },
              set: function(value) {
                this._rgb[2] = value;
                this.onChange();
              }
            },
            destroy: function() {
              this.onChangeCallback = null;
            }
          });
          module2.exports = RGB;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = {
            CENTER: __webpack_require__(397),
            ORIENTATION: __webpack_require__(398),
            SCALE_MODE: __webpack_require__(399),
            ZOOM: __webpack_require__(400)
          };
          module2.exports = CONST;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RemoveFromDOM = function(element) {
            if (element.parentNode) {
              element.parentNode.removeChild(element);
            }
          };
          module2.exports = RemoveFromDOM;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var INPUT_CONST = {
            MOUSE_DOWN: 0,
            MOUSE_MOVE: 1,
            MOUSE_UP: 2,
            TOUCH_START: 3,
            TOUCH_MOVE: 4,
            TOUCH_END: 5,
            POINTER_LOCK_CHANGE: 6,
            TOUCH_CANCEL: 7,
            MOUSE_WHEEL: 8
          };
          module2.exports = INPUT_CONST;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(142);
          var DefaultPlugins = __webpack_require__(194);
          var Events = __webpack_require__(21);
          var GetPhysicsPlugins = __webpack_require__(413);
          var GetScenePlugins = __webpack_require__(414);
          var GLOBAL_CONST = __webpack_require__(32);
          var NOOP = __webpack_require__(1);
          var Settings = __webpack_require__(415);
          var Systems = new Class({
            initialize: function Systems2(scene, config2) {
              this.scene = scene;
              this.game;
              this.renderer;
              if (false) {
              }
              this.config = config2;
              this.settings = Settings.create(config2);
              this.canvas;
              this.context;
              this.anims;
              this.cache;
              this.plugins;
              this.registry;
              this.scale;
              this.sound;
              this.textures;
              this.add;
              this.cameras;
              this.displayList;
              this.events;
              this.make;
              this.scenePlugin;
              this.updateList;
              this.sceneUpdate = NOOP;
            },
            init: function(game) {
              this.settings.status = CONST.INIT;
              this.sceneUpdate = NOOP;
              this.game = game;
              this.renderer = game.renderer;
              this.canvas = game.canvas;
              this.context = game.context;
              var pluginManager = game.plugins;
              this.plugins = pluginManager;
              pluginManager.addToScene(this, DefaultPlugins.Global, [DefaultPlugins.CoreScene, GetScenePlugins(this), GetPhysicsPlugins(this)]);
              this.events.emit(Events.BOOT, this);
              this.settings.isBooted = true;
            },
            install: function(plugin) {
              if (!Array.isArray(plugin)) {
                plugin = [plugin];
              }
              this.plugins.installLocal(this, plugin);
            },
            step: function(time, delta) {
              var events = this.events;
              events.emit(Events.PRE_UPDATE, time, delta);
              events.emit(Events.UPDATE, time, delta);
              this.sceneUpdate.call(this.scene, time, delta);
              events.emit(Events.POST_UPDATE, time, delta);
            },
            render: function(renderer) {
              var displayList = this.displayList;
              displayList.depthSort();
              this.cameras.render(renderer, displayList);
              this.events.emit(Events.RENDER, renderer);
            },
            queueDepthSort: function() {
              this.displayList.queueDepthSort();
            },
            depthSort: function() {
              this.displayList.depthSort();
            },
            pause: function(data) {
              var events = this.events;
              var settings = this.settings;
              if (this.settings.active) {
                settings.status = CONST.PAUSED;
                settings.active = false;
                events.emit(Events.PAUSE, this, data);
              }
              return this;
            },
            resume: function(data) {
              var events = this.events;
              var settings = this.settings;
              if (!this.settings.active) {
                settings.status = CONST.RUNNING;
                settings.active = true;
                events.emit(Events.RESUME, this, data);
              }
              return this;
            },
            sleep: function(data) {
              var events = this.events;
              var settings = this.settings;
              settings.status = CONST.SLEEPING;
              settings.active = false;
              settings.visible = false;
              events.emit(Events.SLEEP, this, data);
              return this;
            },
            wake: function(data) {
              var events = this.events;
              var settings = this.settings;
              settings.status = CONST.RUNNING;
              settings.active = true;
              settings.visible = true;
              events.emit(Events.WAKE, this, data);
              if (settings.isTransition) {
                events.emit(Events.TRANSITION_WAKE, settings.transitionFrom, settings.transitionDuration);
              }
              return this;
            },
            getData: function() {
              return this.settings.data;
            },
            isSleeping: function() {
              return this.settings.status === CONST.SLEEPING;
            },
            isActive: function() {
              return this.settings.status === CONST.RUNNING;
            },
            isPaused: function() {
              return this.settings.status === CONST.PAUSED;
            },
            isTransitioning: function() {
              return this.settings.isTransition || this.scenePlugin._target !== null;
            },
            isTransitionOut: function() {
              return this.scenePlugin._target !== null && this.scenePlugin._duration > 0;
            },
            isTransitionIn: function() {
              return this.settings.isTransition;
            },
            isVisible: function() {
              return this.settings.visible;
            },
            setVisible: function(value) {
              this.settings.visible = value;
              return this;
            },
            setActive: function(value, data) {
              if (value) {
                return this.resume(data);
              } else {
                return this.pause(data);
              }
            },
            start: function(data) {
              var events = this.events;
              var settings = this.settings;
              if (data) {
                settings.data = data;
              }
              settings.status = CONST.START;
              settings.active = true;
              settings.visible = true;
              events.emit(Events.START, this);
              events.emit(Events.READY, this, data);
            },
            shutdown: function(data) {
              var events = this.events;
              var settings = this.settings;
              events.off(Events.TRANSITION_INIT);
              events.off(Events.TRANSITION_START);
              events.off(Events.TRANSITION_COMPLETE);
              events.off(Events.TRANSITION_OUT);
              settings.status = CONST.SHUTDOWN;
              settings.active = false;
              settings.visible = false;
              if (this.renderer === GLOBAL_CONST.WEBGL) {
                this.renderer.resetTextures(true);
              }
              events.emit(Events.SHUTDOWN, this, data);
            },
            destroy: function() {
              var events = this.events;
              var settings = this.settings;
              settings.status = CONST.DESTROYED;
              settings.active = false;
              settings.visible = false;
              events.emit(Events.DESTROY, this);
              events.removeAllListeners();
              var props = ["scene", "game", "anims", "cache", "plugins", "registry", "sound", "textures", "add", "camera", "displayList", "events", "make", "scenePlugin", "updateList"];
              for (var i = 0; i < props.length; i++) {
                this[props[i]] = null;
              }
            }
          });
          module2.exports = Systems;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var UppercaseFirst = function(str) {
            return str && str[0].toUpperCase() + str.slice(1);
          };
          module2.exports = UppercaseFirst;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(32);
          var Class = __webpack_require__(0);
          var Frame = __webpack_require__(106);
          var TextureSource = __webpack_require__(418);
          var TEXTURE_MISSING_ERROR = "Texture.frame missing: ";
          var Texture = new Class({
            initialize: function Texture2(manager, key, source, width, height) {
              if (!Array.isArray(source)) {
                source = [source];
              }
              this.manager = manager;
              this.key = key;
              this.source = [];
              this.dataSource = [];
              this.frames = {};
              this.customData = {};
              this.firstFrame = "__BASE";
              this.frameTotal = 0;
              for (var i = 0; i < source.length; i++) {
                this.source.push(new TextureSource(this, source[i], width, height));
              }
            },
            add: function(name, sourceIndex, x, y, width, height) {
              if (this.has(name)) {
                return null;
              }
              var frame = new Frame(this, name, sourceIndex, x, y, width, height);
              this.frames[name] = frame;
              if (this.firstFrame === "__BASE") {
                this.firstFrame = name;
              }
              this.frameTotal++;
              return frame;
            },
            remove: function(name) {
              if (this.has(name)) {
                var frame = this.get(name);
                frame.destroy();
                delete this.frames[name];
                return true;
              }
              return false;
            },
            has: function(name) {
              return this.frames[name];
            },
            get: function(name) {
              if (!name) {
                name = this.firstFrame;
              }
              var frame = this.frames[name];
              if (!frame) {
                console.warn(TEXTURE_MISSING_ERROR + name);
                frame = this.frames[this.firstFrame];
              }
              return frame;
            },
            getTextureSourceIndex: function(source) {
              for (var i = 0; i < this.source.length; i++) {
                if (this.source[i] === source) {
                  return i;
                }
              }
              return -1;
            },
            getFramesFromTextureSource: function(sourceIndex, includeBase) {
              if (includeBase === void 0) {
                includeBase = false;
              }
              var out = [];
              for (var frameName in this.frames) {
                if (frameName === "__BASE" && !includeBase) {
                  continue;
                }
                var frame = this.frames[frameName];
                if (frame.sourceIndex === sourceIndex) {
                  out.push(frame);
                }
              }
              return out;
            },
            getFrameNames: function(includeBase) {
              if (includeBase === void 0) {
                includeBase = false;
              }
              var out = Object.keys(this.frames);
              if (!includeBase) {
                var idx = out.indexOf("__BASE");
                if (idx !== -1) {
                  out.splice(idx, 1);
                }
              }
              return out;
            },
            getSourceImage: function(name) {
              if (name === void 0 || name === null || this.frameTotal === 1) {
                name = "__BASE";
              }
              var frame = this.frames[name];
              if (frame) {
                return frame.source.image;
              } else {
                console.warn(TEXTURE_MISSING_ERROR + name);
                return this.frames["__BASE"].source.image;
              }
            },
            getDataSourceImage: function(name) {
              if (name === void 0 || name === null || this.frameTotal === 1) {
                name = "__BASE";
              }
              var frame = this.frames[name];
              var idx;
              if (!frame) {
                console.warn(TEXTURE_MISSING_ERROR + name);
                idx = this.frames["__BASE"].sourceIndex;
              } else {
                idx = frame.sourceIndex;
              }
              return this.dataSource[idx].image;
            },
            setDataSource: function(data) {
              if (!Array.isArray(data)) {
                data = [data];
              }
              for (var i = 0; i < data.length; i++) {
                var source = this.source[i];
                this.dataSource.push(new TextureSource(this, data[i], source.width, source.height));
              }
            },
            setFilter: function(filterMode) {
              var i;
              for (i = 0; i < this.source.length; i++) {
                this.source[i].setFilter(filterMode);
              }
              for (i = 0; i < this.dataSource.length; i++) {
                this.dataSource[i].setFilter(filterMode);
              }
            },
            destroy: function() {
              var i;
              for (i = 0; i < this.source.length; i++) {
                this.source[i].destroy();
              }
              for (i = 0; i < this.dataSource.length; i++) {
                this.dataSource[i].destroy();
              }
              for (var frameName in this.frames) {
                var frame = this.frames[frameName];
                frame.destroy();
              }
              this.source = [];
              this.dataSource = [];
              this.frames = {};
              this.manager.removeKey(this.key);
              var renderer = this.manager.game.renderer;
              if (renderer.type === CONST.WEBGL) {
                renderer.resetTextures(true);
              }
              this.manager = null;
            }
          });
          module2.exports = Texture;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SafeRange = __webpack_require__(78);
          var GetAll = function(array, property, value, startIndex, endIndex) {
            if (startIndex === void 0) {
              startIndex = 0;
            }
            if (endIndex === void 0) {
              endIndex = array.length;
            }
            var output = [];
            if (SafeRange(array, startIndex, endIndex)) {
              for (var i = startIndex; i < endIndex; i++) {
                var child = array[i];
                if (!property || property && value === void 0 && child.hasOwnProperty(property) || property && value !== void 0 && child[property] === value) {
                  output.push(child);
                }
              }
            }
            return output;
          };
          module2.exports = GetAll;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Matrix: __webpack_require__(1009),
            Add: __webpack_require__(1017),
            AddAt: __webpack_require__(1018),
            BringToTop: __webpack_require__(1019),
            CountAllMatching: __webpack_require__(1020),
            Each: __webpack_require__(1021),
            EachInRange: __webpack_require__(1022),
            FindClosestInSorted: __webpack_require__(312),
            GetAll: __webpack_require__(204),
            GetFirst: __webpack_require__(422),
            GetRandom: __webpack_require__(207),
            MoveDown: __webpack_require__(1023),
            MoveTo: __webpack_require__(1024),
            MoveUp: __webpack_require__(1025),
            NumberArray: __webpack_require__(316),
            NumberArrayStep: __webpack_require__(1026),
            QuickSelect: __webpack_require__(430),
            Range: __webpack_require__(431),
            Remove: __webpack_require__(89),
            RemoveAt: __webpack_require__(1027),
            RemoveBetween: __webpack_require__(1028),
            RemoveRandomElement: __webpack_require__(1029),
            Replace: __webpack_require__(1030),
            RotateLeft: __webpack_require__(175),
            RotateRight: __webpack_require__(176),
            SafeRange: __webpack_require__(78),
            SendToBack: __webpack_require__(1031),
            SetAll: __webpack_require__(1032),
            Shuffle: __webpack_require__(129),
            SortByDigits: __webpack_require__(314),
            SpliceOne: __webpack_require__(74),
            StableSort: __webpack_require__(79),
            Swap: __webpack_require__(1033)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CheckMatrix = function(matrix) {
            if (!Array.isArray(matrix) || matrix.length < 2 || !Array.isArray(matrix[0])) {
              return false;
            }
            var size = matrix[0].length;
            for (var i = 1; i < matrix.length; i++) {
              if (matrix[i].length !== size) {
                return false;
              }
            }
            return true;
          };
          module2.exports = CheckMatrix;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetRandom = function(array, startIndex, length) {
            if (startIndex === void 0) {
              startIndex = 0;
            }
            if (length === void 0) {
              length = array.length;
            }
            var randomIndex = startIndex + Math.floor(Math.random() * length);
            return array[randomIndex] === void 0 ? null : array[randomIndex];
          };
          module2.exports = GetRandom;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(432);
          var ProcessQueue = new Class({
            Extends: EventEmitter,
            initialize: function ProcessQueue2() {
              EventEmitter.call(this);
              this._pending = [];
              this._active = [];
              this._destroy = [];
              this._toProcess = 0;
              this.checkQueue = false;
            },
            add: function(item) {
              this._pending.push(item);
              this._toProcess++;
              return item;
            },
            remove: function(item) {
              this._destroy.push(item);
              this._toProcess++;
              return item;
            },
            removeAll: function() {
              var list = this._active;
              var destroy = this._destroy;
              var i = list.length;
              while (i--) {
                destroy.push(list[i]);
                this._toProcess++;
              }
              return this;
            },
            update: function() {
              if (this._toProcess === 0) {
                return this._active;
              }
              var list = this._destroy;
              var active = this._active;
              var i;
              var item;
              for (i = 0; i < list.length; i++) {
                item = list[i];
                var idx = active.indexOf(item);
                if (idx !== -1) {
                  active.splice(idx, 1);
                  this.emit(Events.PROCESS_QUEUE_REMOVE, item);
                }
              }
              list.length = 0;
              list = this._pending;
              for (i = 0; i < list.length; i++) {
                item = list[i];
                if (!this.checkQueue || this.checkQueue && active.indexOf(item) === -1) {
                  active.push(item);
                  this.emit(Events.PROCESS_QUEUE_ADD, item);
                }
              }
              list.length = 0;
              this._toProcess = 0;
              return active;
            },
            getActive: function() {
              return this._active;
            },
            length: {
              get: function() {
                return this._active.length;
              }
            },
            destroy: function() {
              this._toProcess = 0;
              this._pending = [];
              this._active = [];
              this._destroy = [];
            }
          });
          module2.exports = ProcessQueue;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          function getValue(node, attribute) {
            return parseInt(node.getAttribute(attribute), 10);
          }
          var ParseXMLBitmapFont = function(xml, frame, xSpacing, ySpacing, texture) {
            if (xSpacing === void 0) {
              xSpacing = 0;
            }
            if (ySpacing === void 0) {
              ySpacing = 0;
            }
            var textureX = frame.cutX;
            var textureY = frame.cutY;
            var textureWidth = frame.source.width;
            var textureHeight = frame.source.height;
            var sourceIndex = frame.sourceIndex;
            var data = {};
            var info = xml.getElementsByTagName("info")[0];
            var common = xml.getElementsByTagName("common")[0];
            data.font = info.getAttribute("face");
            data.size = getValue(info, "size");
            data.lineHeight = getValue(common, "lineHeight") + ySpacing;
            data.chars = {};
            var letters = xml.getElementsByTagName("char");
            var adjustForTrim = frame !== void 0 && frame.trimmed;
            if (adjustForTrim) {
              var top = frame.height;
              var left = frame.width;
            }
            for (var i = 0; i < letters.length; i++) {
              var node = letters[i];
              var charCode = getValue(node, "id");
              var letter = String.fromCharCode(charCode);
              var gx = getValue(node, "x");
              var gy = getValue(node, "y");
              var gw = getValue(node, "width");
              var gh = getValue(node, "height");
              if (adjustForTrim) {
                if (gx < left) {
                  left = gx;
                }
                if (gy < top) {
                  top = gy;
                }
              }
              if (adjustForTrim && top !== 0 && left !== 0) {
                gx -= frame.x;
                gy -= frame.y;
              }
              var u0 = (textureX + gx) / textureWidth;
              var v0 = (textureY + gy) / textureHeight;
              var u1 = (textureX + gx + gw) / textureWidth;
              var v1 = (textureY + gy + gh) / textureHeight;
              data.chars[charCode] = {
                x: gx,
                y: gy,
                width: gw,
                height: gh,
                centerX: Math.floor(gw / 2),
                centerY: Math.floor(gh / 2),
                xOffset: getValue(node, "xoffset"),
                yOffset: getValue(node, "yoffset"),
                xAdvance: getValue(node, "xadvance") + xSpacing,
                data: {},
                kerning: {},
                u0,
                v0,
                u1,
                v1
              };
              if (texture && gw !== 0 && gh !== 0) {
                var charFrame = texture.add(letter, sourceIndex, gx, gy, gw, gh);
                if (charFrame) {
                  charFrame.setUVs(gw, gh, u0, v0, u1, v1);
                }
              }
            }
            var kernings = xml.getElementsByTagName("kerning");
            for (i = 0; i < kernings.length; i++) {
              var kern = kernings[i];
              var first = getValue(kern, "first");
              var second = getValue(kern, "second");
              var amount = getValue(kern, "amount");
              data.chars[second].kerning[first] = amount;
            }
            return data;
          };
          module2.exports = ParseXMLBitmapFont;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BlitterRender = __webpack_require__(1043);
          var Bob = __webpack_require__(434);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var Frame = __webpack_require__(106);
          var GameObject = __webpack_require__(15);
          var List = __webpack_require__(107);
          var Blitter = new Class({
            Extends: GameObject,
            Mixins: [
              Components.Alpha,
              Components.BlendMode,
              Components.Depth,
              Components.Mask,
              Components.Pipeline,
              Components.ScrollFactor,
              Components.Size,
              Components.Texture,
              Components.Transform,
              Components.Visible,
              BlitterRender
            ],
            initialize: function Blitter2(scene, x, y, texture, frame) {
              GameObject.call(this, scene, "Blitter");
              this.setTexture(texture, frame);
              this.setPosition(x, y);
              this.initPipeline();
              this.children = new List();
              this.renderList = [];
              this.dirty = false;
            },
            create: function(x, y, frame, visible, index) {
              if (visible === void 0) {
                visible = true;
              }
              if (index === void 0) {
                index = this.children.length;
              }
              if (frame === void 0) {
                frame = this.frame;
              } else if (!(frame instanceof Frame)) {
                frame = this.texture.get(frame);
              }
              var bob = new Bob(this, x, y, frame, visible);
              this.children.addAt(bob, index, false);
              this.dirty = true;
              return bob;
            },
            createFromCallback: function(callback, quantity, frame, visible) {
              var bobs = this.createMultiple(quantity, frame, visible);
              for (var i = 0; i < bobs.length; i++) {
                var bob = bobs[i];
                callback.call(this, bob, i);
              }
              return bobs;
            },
            createMultiple: function(quantity, frame, visible) {
              if (frame === void 0) {
                frame = this.frame.name;
              }
              if (visible === void 0) {
                visible = true;
              }
              if (!Array.isArray(frame)) {
                frame = [frame];
              }
              var bobs = [];
              var _this = this;
              frame.forEach(function(singleFrame) {
                for (var i = 0; i < quantity; i++) {
                  bobs.push(_this.create(0, 0, singleFrame, visible));
                }
              });
              return bobs;
            },
            childCanRender: function(child) {
              return child.visible && child.alpha > 0;
            },
            getRenderList: function() {
              if (this.dirty) {
                this.renderList = this.children.list.filter(this.childCanRender, this);
                this.dirty = false;
              }
              return this.renderList;
            },
            clear: function() {
              this.children.removeAll();
              this.dirty = true;
            },
            preDestroy: function() {
              this.children.destroy();
              this.renderList = [];
            }
          });
          module2.exports = Blitter;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Felipe Alfonso <@bitnenfer>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ArrayUtils = __webpack_require__(205);
          var BlendModes = __webpack_require__(34);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var Events = __webpack_require__(75);
          var GameObject = __webpack_require__(15);
          var Rectangle = __webpack_require__(10);
          var Render = __webpack_require__(1046);
          var Union = __webpack_require__(435);
          var Vector29 = __webpack_require__(3);
          var Container = new Class({
            Extends: GameObject,
            Mixins: [
              Components.AlphaSingle,
              Components.BlendMode,
              Components.ComputedSize,
              Components.Depth,
              Components.Mask,
              Components.Pipeline,
              Components.Transform,
              Components.Visible,
              Render
            ],
            initialize: function Container2(scene, x, y, children) {
              GameObject.call(this, scene, "Container");
              this.list = [];
              this.exclusive = true;
              this.maxSize = -1;
              this.position = 0;
              this.localTransform = new Components.TransformMatrix();
              this.tempTransformMatrix = new Components.TransformMatrix();
              this._sortKey = "";
              this._sysEvents = scene.sys.events;
              this.scrollFactorX = 1;
              this.scrollFactorY = 1;
              this.initPipeline();
              this.setPosition(x, y);
              this.clearAlpha();
              this.setBlendMode(BlendModes.SKIP_CHECK);
              if (children) {
                this.add(children);
              }
            },
            originX: {
              get: function() {
                return 0.5;
              }
            },
            originY: {
              get: function() {
                return 0.5;
              }
            },
            displayOriginX: {
              get: function() {
                return this.width * 0.5;
              }
            },
            displayOriginY: {
              get: function() {
                return this.height * 0.5;
              }
            },
            setExclusive: function(value) {
              if (value === void 0) {
                value = true;
              }
              this.exclusive = value;
              return this;
            },
            getBounds: function(output) {
              if (output === void 0) {
                output = new Rectangle();
              }
              output.setTo(this.x, this.y, 0, 0);
              if (this.parentContainer) {
                var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
                var transformedPosition = parentMatrix.transformPoint(this.x, this.y);
                output.setTo(transformedPosition.x, transformedPosition.y, 0, 0);
              }
              if (this.list.length > 0) {
                var children = this.list;
                var tempRect = new Rectangle();
                var hasSetFirst = false;
                output.setEmpty();
                for (var i = 0; i < children.length; i++) {
                  var entry = children[i];
                  if (entry.getBounds) {
                    entry.getBounds(tempRect);
                    if (!hasSetFirst) {
                      output.setTo(tempRect.x, tempRect.y, tempRect.width, tempRect.height);
                      hasSetFirst = true;
                    } else {
                      Union(tempRect, output, output);
                    }
                  }
                }
              }
              return output;
            },
            addHandler: function(gameObject) {
              gameObject.once(Events.DESTROY, this.remove, this);
              if (this.exclusive) {
                if (gameObject.displayList) {
                  gameObject.displayList.remove(gameObject);
                }
                if (gameObject.parentContainer) {
                  gameObject.parentContainer.remove(gameObject);
                }
                if (this.displayList) {
                  gameObject.displayList = this.displayList;
                } else {
                  gameObject.displayList = this.scene.sys.displayList;
                }
                gameObject.parentContainer = this;
              }
              if (!this.scene.sys.displayList.exists(gameObject)) {
                gameObject.emit(Events.ADDED_TO_SCENE, gameObject, this.scene);
              }
            },
            removeHandler: function(gameObject) {
              gameObject.off(Events.DESTROY, this.remove);
              if (this.exclusive) {
                gameObject.parentContainer = null;
              }
              if (!this.scene.sys.displayList.exists(gameObject)) {
                gameObject.emit(Events.REMOVED_FROM_SCENE, gameObject, this.scene);
              }
            },
            pointToContainer: function(source, output) {
              if (output === void 0) {
                output = new Vector29();
              }
              if (this.parentContainer) {
                this.parentContainer.pointToContainer(source, output);
              } else {
                output = new Vector29(source.x, source.y);
              }
              var tempMatrix = this.tempTransformMatrix;
              tempMatrix.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY);
              tempMatrix.invert();
              tempMatrix.transformPoint(source.x, source.y, output);
              return output;
            },
            getBoundsTransformMatrix: function() {
              return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform);
            },
            add: function(child) {
              ArrayUtils.Add(this.list, child, this.maxSize, this.addHandler, this);
              return this;
            },
            addAt: function(child, index) {
              ArrayUtils.AddAt(this.list, child, index, this.maxSize, this.addHandler, this);
              return this;
            },
            getAt: function(index) {
              return this.list[index];
            },
            getIndex: function(child) {
              return this.list.indexOf(child);
            },
            sort: function(property, handler) {
              if (!property) {
                return this;
              }
              if (handler === void 0) {
                handler = function(childA, childB) {
                  return childA[property] - childB[property];
                };
              }
              ArrayUtils.StableSort(this.list, handler);
              return this;
            },
            getByName: function(name) {
              return ArrayUtils.GetFirst(this.list, "name", name);
            },
            getRandom: function(startIndex, length) {
              return ArrayUtils.GetRandom(this.list, startIndex, length);
            },
            getFirst: function(property, value, startIndex, endIndex) {
              return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
            },
            getAll: function(property, value, startIndex, endIndex) {
              return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
            },
            count: function(property, value, startIndex, endIndex) {
              return ArrayUtils.CountAllMatching(this.list, property, value, startIndex, endIndex);
            },
            swap: function(child1, child2) {
              ArrayUtils.Swap(this.list, child1, child2);
              return this;
            },
            moveTo: function(child, index) {
              ArrayUtils.MoveTo(this.list, child, index);
              return this;
            },
            remove: function(child, destroyChild) {
              var removed = ArrayUtils.Remove(this.list, child, this.removeHandler, this);
              if (destroyChild && removed) {
                if (!Array.isArray(removed)) {
                  removed = [removed];
                }
                for (var i = 0; i < removed.length; i++) {
                  removed[i].destroy();
                }
              }
              return this;
            },
            removeAt: function(index, destroyChild) {
              var removed = ArrayUtils.RemoveAt(this.list, index, this.removeHandler, this);
              if (destroyChild && removed) {
                removed.destroy();
              }
              return this;
            },
            removeBetween: function(startIndex, endIndex, destroyChild) {
              var removed = ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeHandler, this);
              if (destroyChild) {
                for (var i = 0; i < removed.length; i++) {
                  removed[i].destroy();
                }
              }
              return this;
            },
            removeAll: function(destroyChild) {
              var removed = ArrayUtils.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this);
              if (destroyChild) {
                for (var i = 0; i < removed.length; i++) {
                  removed[i].destroy();
                }
              }
              return this;
            },
            bringToTop: function(child) {
              ArrayUtils.BringToTop(this.list, child);
              return this;
            },
            sendToBack: function(child) {
              ArrayUtils.SendToBack(this.list, child);
              return this;
            },
            moveUp: function(child) {
              ArrayUtils.MoveUp(this.list, child);
              return this;
            },
            moveDown: function(child) {
              ArrayUtils.MoveDown(this.list, child);
              return this;
            },
            reverse: function() {
              this.list.reverse();
              return this;
            },
            shuffle: function() {
              ArrayUtils.Shuffle(this.list);
              return this;
            },
            replace: function(oldChild, newChild, destroyChild) {
              var moved = ArrayUtils.Replace(this.list, oldChild, newChild);
              if (moved) {
                this.addHandler(newChild);
                this.removeHandler(oldChild);
                if (destroyChild) {
                  oldChild.destroy();
                }
              }
              return this;
            },
            exists: function(child) {
              return this.list.indexOf(child) > -1;
            },
            setAll: function(property, value, startIndex, endIndex) {
              ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);
              return this;
            },
            each: function(callback, context) {
              var args = [null];
              var i;
              var temp = this.list.slice();
              var len = temp.length;
              for (i = 2; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (i = 0; i < len; i++) {
                args[0] = temp[i];
                callback.apply(context, args);
              }
              return this;
            },
            iterate: function(callback, context) {
              var args = [null];
              var i;
              for (i = 2; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (i = 0; i < this.list.length; i++) {
                args[0] = this.list[i];
                callback.apply(context, args);
              }
              return this;
            },
            setScrollFactor: function(x, y, updateChildren) {
              if (y === void 0) {
                y = x;
              }
              if (updateChildren === void 0) {
                updateChildren = false;
              }
              this.scrollFactorX = x;
              this.scrollFactorY = y;
              if (updateChildren) {
                ArrayUtils.SetAll(this.list, "scrollFactorX", x);
                ArrayUtils.SetAll(this.list, "scrollFactorY", y);
              }
              return this;
            },
            length: {
              get: function() {
                return this.list.length;
              }
            },
            first: {
              get: function() {
                this.position = 0;
                if (this.list.length > 0) {
                  return this.list[0];
                } else {
                  return null;
                }
              }
            },
            last: {
              get: function() {
                if (this.list.length > 0) {
                  this.position = this.list.length - 1;
                  return this.list[this.position];
                } else {
                  return null;
                }
              }
            },
            next: {
              get: function() {
                if (this.position < this.list.length) {
                  this.position++;
                  return this.list[this.position];
                } else {
                  return null;
                }
              }
            },
            previous: {
              get: function() {
                if (this.position > 0) {
                  this.position--;
                  return this.list[this.position];
                } else {
                  return null;
                }
              }
            },
            preDestroy: function() {
              this.removeAll(!!this.exclusive);
              this.localTransform.destroy();
              this.tempTransformMatrix.destroy();
              this.list = [];
            }
          });
          module2.exports = Container;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BitmapText = __webpack_require__(147);
          var Class = __webpack_require__(0);
          var Render = __webpack_require__(1051);
          var DynamicBitmapText = new Class({
            Extends: BitmapText,
            Mixins: [
              Render
            ],
            initialize: function DynamicBitmapText2(scene, x, y, font, text, size, align) {
              BitmapText.call(this, scene, x, y, font, text, size, align);
              this.type = "DynamicBitmapText";
              this.scrollX = 0;
              this.scrollY = 0;
              this.cropWidth = 0;
              this.cropHeight = 0;
              this.displayCallback;
              this.callbackData = {
                parent: this,
                color: 0,
                tint: {
                  topLeft: 0,
                  topRight: 0,
                  bottomLeft: 0,
                  bottomRight: 0
                },
                index: 0,
                charCode: 0,
                x: 0,
                y: 0,
                scale: 0,
                rotation: 0,
                data: 0
              };
            },
            setSize: function(width, height) {
              this.cropWidth = width;
              this.cropHeight = height;
              return this;
            },
            setDisplayCallback: function(callback) {
              this.displayCallback = callback;
              return this;
            },
            setScrollX: function(value) {
              this.scrollX = value;
              return this;
            },
            setScrollY: function(value) {
              this.scrollY = value;
              return this;
            }
          });
          module2.exports = DynamicBitmapText;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BaseCamera = __webpack_require__(131);
          var Class = __webpack_require__(0);
          var Commands = __webpack_require__(214);
          var ComponentsAlpha = __webpack_require__(297);
          var ComponentsBlendMode = __webpack_require__(298);
          var ComponentsDepth = __webpack_require__(299);
          var ComponentsMask = __webpack_require__(303);
          var ComponentsPipeline = __webpack_require__(171);
          var ComponentsScrollFactor = __webpack_require__(306);
          var ComponentsTransform = __webpack_require__(307);
          var ComponentsVisible = __webpack_require__(308);
          var Ellipse = __webpack_require__(108);
          var GameObject = __webpack_require__(15);
          var GetFastValue = __webpack_require__(2);
          var GetValue = __webpack_require__(6);
          var MATH_CONST = __webpack_require__(14);
          var PIPELINES_CONST = __webpack_require__(65);
          var Render = __webpack_require__(1057);
          var Graphics = new Class({
            Extends: GameObject,
            Mixins: [
              ComponentsAlpha,
              ComponentsBlendMode,
              ComponentsDepth,
              ComponentsMask,
              ComponentsPipeline,
              ComponentsTransform,
              ComponentsVisible,
              ComponentsScrollFactor,
              Render
            ],
            initialize: function Graphics2(scene, options) {
              var x = GetValue(options, "x", 0);
              var y = GetValue(options, "y", 0);
              GameObject.call(this, scene, "Graphics");
              this.setPosition(x, y);
              this.initPipeline(PIPELINES_CONST.GRAPHICS_PIPELINE);
              this.displayOriginX = 0;
              this.displayOriginY = 0;
              this.commandBuffer = [];
              this.defaultFillColor = -1;
              this.defaultFillAlpha = 1;
              this.defaultStrokeWidth = 1;
              this.defaultStrokeColor = -1;
              this.defaultStrokeAlpha = 1;
              this._lineWidth = 1;
              this.setDefaultStyles(options);
            },
            setDefaultStyles: function(options) {
              if (GetValue(options, "lineStyle", null)) {
                this.defaultStrokeWidth = GetValue(options, "lineStyle.width", 1);
                this.defaultStrokeColor = GetValue(options, "lineStyle.color", 16777215);
                this.defaultStrokeAlpha = GetValue(options, "lineStyle.alpha", 1);
                this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
              }
              if (GetValue(options, "fillStyle", null)) {
                this.defaultFillColor = GetValue(options, "fillStyle.color", 16777215);
                this.defaultFillAlpha = GetValue(options, "fillStyle.alpha", 1);
                this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
              }
              return this;
            },
            lineStyle: function(lineWidth, color, alpha) {
              if (alpha === void 0) {
                alpha = 1;
              }
              this.commandBuffer.push(Commands.LINE_STYLE, lineWidth, color, alpha);
              this._lineWidth = lineWidth;
              return this;
            },
            fillStyle: function(color, alpha) {
              if (alpha === void 0) {
                alpha = 1;
              }
              this.commandBuffer.push(Commands.FILL_STYLE, color, alpha);
              return this;
            },
            fillGradientStyle: function(topLeft, topRight, bottomLeft, bottomRight, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight) {
              if (alphaTopLeft === void 0) {
                alphaTopLeft = 1;
              }
              if (alphaTopRight === void 0) {
                alphaTopRight = alphaTopLeft;
              }
              if (alphaBottomLeft === void 0) {
                alphaBottomLeft = alphaTopLeft;
              }
              if (alphaBottomRight === void 0) {
                alphaBottomRight = alphaTopLeft;
              }
              this.commandBuffer.push(Commands.GRADIENT_FILL_STYLE, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight, topLeft, topRight, bottomLeft, bottomRight);
              return this;
            },
            lineGradientStyle: function(lineWidth, topLeft, topRight, bottomLeft, bottomRight, alpha) {
              if (alpha === void 0) {
                alpha = 1;
              }
              this.commandBuffer.push(Commands.GRADIENT_LINE_STYLE, lineWidth, alpha, topLeft, topRight, bottomLeft, bottomRight);
              return this;
            },
            beginPath: function() {
              this.commandBuffer.push(Commands.BEGIN_PATH);
              return this;
            },
            closePath: function() {
              this.commandBuffer.push(Commands.CLOSE_PATH);
              return this;
            },
            fillPath: function() {
              this.commandBuffer.push(Commands.FILL_PATH);
              return this;
            },
            fill: function() {
              this.commandBuffer.push(Commands.FILL_PATH);
              return this;
            },
            strokePath: function() {
              this.commandBuffer.push(Commands.STROKE_PATH);
              return this;
            },
            stroke: function() {
              this.commandBuffer.push(Commands.STROKE_PATH);
              return this;
            },
            fillCircleShape: function(circle) {
              return this.fillCircle(circle.x, circle.y, circle.radius);
            },
            strokeCircleShape: function(circle) {
              return this.strokeCircle(circle.x, circle.y, circle.radius);
            },
            fillCircle: function(x, y, radius) {
              this.beginPath();
              this.arc(x, y, radius, 0, MATH_CONST.PI2);
              this.fillPath();
              return this;
            },
            strokeCircle: function(x, y, radius) {
              this.beginPath();
              this.arc(x, y, radius, 0, MATH_CONST.PI2);
              this.strokePath();
              return this;
            },
            fillRectShape: function(rect) {
              return this.fillRect(rect.x, rect.y, rect.width, rect.height);
            },
            strokeRectShape: function(rect) {
              return this.strokeRect(rect.x, rect.y, rect.width, rect.height);
            },
            fillRect: function(x, y, width, height) {
              this.commandBuffer.push(Commands.FILL_RECT, x, y, width, height);
              return this;
            },
            strokeRect: function(x, y, width, height) {
              var lineWidthHalf = this._lineWidth / 2;
              var minx = x - lineWidthHalf;
              var maxx = x + lineWidthHalf;
              this.beginPath();
              this.moveTo(x, y);
              this.lineTo(x, y + height);
              this.strokePath();
              this.beginPath();
              this.moveTo(x + width, y);
              this.lineTo(x + width, y + height);
              this.strokePath();
              this.beginPath();
              this.moveTo(minx, y);
              this.lineTo(maxx + width, y);
              this.strokePath();
              this.beginPath();
              this.moveTo(minx, y + height);
              this.lineTo(maxx + width, y + height);
              this.strokePath();
              return this;
            },
            fillRoundedRect: function(x, y, width, height, radius) {
              if (radius === void 0) {
                radius = 20;
              }
              var tl = radius;
              var tr = radius;
              var bl = radius;
              var br = radius;
              if (typeof radius !== "number") {
                tl = GetFastValue(radius, "tl", 20);
                tr = GetFastValue(radius, "tr", 20);
                bl = GetFastValue(radius, "bl", 20);
                br = GetFastValue(radius, "br", 20);
              }
              this.beginPath();
              this.moveTo(x + tl, y);
              this.lineTo(x + width - tr, y);
              this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);
              this.lineTo(x + width, y + height - br);
              this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);
              this.lineTo(x + bl, y + height);
              this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);
              this.lineTo(x, y + tl);
              this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);
              this.fillPath();
              return this;
            },
            strokeRoundedRect: function(x, y, width, height, radius) {
              if (radius === void 0) {
                radius = 20;
              }
              var tl = radius;
              var tr = radius;
              var bl = radius;
              var br = radius;
              if (typeof radius !== "number") {
                tl = GetFastValue(radius, "tl", 20);
                tr = GetFastValue(radius, "tr", 20);
                bl = GetFastValue(radius, "bl", 20);
                br = GetFastValue(radius, "br", 20);
              }
              this.beginPath();
              this.moveTo(x + tl, y);
              this.lineTo(x + width - tr, y);
              this.moveTo(x + width - tr, y);
              this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);
              this.lineTo(x + width, y + height - br);
              this.moveTo(x + width, y + height - br);
              this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);
              this.lineTo(x + bl, y + height);
              this.moveTo(x + bl, y + height);
              this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);
              this.lineTo(x, y + tl);
              this.moveTo(x, y + tl);
              this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);
              this.strokePath();
              return this;
            },
            fillPointShape: function(point, size) {
              return this.fillPoint(point.x, point.y, size);
            },
            fillPoint: function(x, y, size) {
              if (!size || size < 1) {
                size = 1;
              } else {
                x -= size / 2;
                y -= size / 2;
              }
              this.commandBuffer.push(Commands.FILL_RECT, x, y, size, size);
              return this;
            },
            fillTriangleShape: function(triangle) {
              return this.fillTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
            },
            strokeTriangleShape: function(triangle) {
              return this.strokeTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
            },
            fillTriangle: function(x0, y0, x1, y1, x2, y2) {
              this.commandBuffer.push(Commands.FILL_TRIANGLE, x0, y0, x1, y1, x2, y2);
              return this;
            },
            strokeTriangle: function(x0, y0, x1, y1, x2, y2) {
              this.commandBuffer.push(Commands.STROKE_TRIANGLE, x0, y0, x1, y1, x2, y2);
              return this;
            },
            strokeLineShape: function(line) {
              return this.lineBetween(line.x1, line.y1, line.x2, line.y2);
            },
            lineBetween: function(x1, y1, x2, y2) {
              this.beginPath();
              this.moveTo(x1, y1);
              this.lineTo(x2, y2);
              this.strokePath();
              return this;
            },
            lineTo: function(x, y) {
              this.commandBuffer.push(Commands.LINE_TO, x, y);
              return this;
            },
            moveTo: function(x, y) {
              this.commandBuffer.push(Commands.MOVE_TO, x, y);
              return this;
            },
            strokePoints: function(points, closeShape, closePath, endIndex) {
              if (closeShape === void 0) {
                closeShape = false;
              }
              if (closePath === void 0) {
                closePath = false;
              }
              if (endIndex === void 0) {
                endIndex = points.length;
              }
              this.beginPath();
              this.moveTo(points[0].x, points[0].y);
              for (var i = 1; i < endIndex; i++) {
                this.lineTo(points[i].x, points[i].y);
              }
              if (closeShape) {
                this.lineTo(points[0].x, points[0].y);
              }
              if (closePath) {
                this.closePath();
              }
              this.strokePath();
              return this;
            },
            fillPoints: function(points, closeShape, closePath, endIndex) {
              if (closeShape === void 0) {
                closeShape = false;
              }
              if (closePath === void 0) {
                closePath = false;
              }
              if (endIndex === void 0) {
                endIndex = points.length;
              }
              this.beginPath();
              this.moveTo(points[0].x, points[0].y);
              for (var i = 1; i < endIndex; i++) {
                this.lineTo(points[i].x, points[i].y);
              }
              if (closeShape) {
                this.lineTo(points[0].x, points[0].y);
              }
              if (closePath) {
                this.closePath();
              }
              this.fillPath();
              return this;
            },
            strokeEllipseShape: function(ellipse, smoothness) {
              if (smoothness === void 0) {
                smoothness = 32;
              }
              var points = ellipse.getPoints(smoothness);
              return this.strokePoints(points, true);
            },
            strokeEllipse: function(x, y, width, height, smoothness) {
              if (smoothness === void 0) {
                smoothness = 32;
              }
              var ellipse = new Ellipse(x, y, width, height);
              var points = ellipse.getPoints(smoothness);
              return this.strokePoints(points, true);
            },
            fillEllipseShape: function(ellipse, smoothness) {
              if (smoothness === void 0) {
                smoothness = 32;
              }
              var points = ellipse.getPoints(smoothness);
              return this.fillPoints(points, true);
            },
            fillEllipse: function(x, y, width, height, smoothness) {
              if (smoothness === void 0) {
                smoothness = 32;
              }
              var ellipse = new Ellipse(x, y, width, height);
              var points = ellipse.getPoints(smoothness);
              return this.fillPoints(points, true);
            },
            arc: function(x, y, radius, startAngle, endAngle, anticlockwise, overshoot) {
              if (anticlockwise === void 0) {
                anticlockwise = false;
              }
              if (overshoot === void 0) {
                overshoot = 0;
              }
              this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise, overshoot);
              return this;
            },
            slice: function(x, y, radius, startAngle, endAngle, anticlockwise, overshoot) {
              if (anticlockwise === void 0) {
                anticlockwise = false;
              }
              if (overshoot === void 0) {
                overshoot = 0;
              }
              this.commandBuffer.push(Commands.BEGIN_PATH);
              this.commandBuffer.push(Commands.MOVE_TO, x, y);
              this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise, overshoot);
              this.commandBuffer.push(Commands.CLOSE_PATH);
              return this;
            },
            save: function() {
              this.commandBuffer.push(Commands.SAVE);
              return this;
            },
            restore: function() {
              this.commandBuffer.push(Commands.RESTORE);
              return this;
            },
            translateCanvas: function(x, y) {
              this.commandBuffer.push(Commands.TRANSLATE, x, y);
              return this;
            },
            scaleCanvas: function(x, y) {
              this.commandBuffer.push(Commands.SCALE, x, y);
              return this;
            },
            rotateCanvas: function(radians) {
              this.commandBuffer.push(Commands.ROTATE, radians);
              return this;
            },
            clear: function() {
              this.commandBuffer.length = 0;
              if (this.defaultFillColor > -1) {
                this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
              }
              if (this.defaultStrokeColor > -1) {
                this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
              }
              return this;
            },
            generateTexture: function(key, width, height) {
              var sys = this.scene.sys;
              var renderer = sys.game.renderer;
              if (width === void 0) {
                width = sys.scale.width;
              }
              if (height === void 0) {
                height = sys.scale.height;
              }
              Graphics.TargetCamera.setScene(this.scene);
              Graphics.TargetCamera.setViewport(0, 0, width, height);
              Graphics.TargetCamera.scrollX = this.x;
              Graphics.TargetCamera.scrollY = this.y;
              var texture;
              var ctx;
              if (typeof key === "string") {
                if (sys.textures.exists(key)) {
                  texture = sys.textures.get(key);
                  var src = texture.getSourceImage();
                  if (src instanceof HTMLCanvasElement) {
                    ctx = src.getContext("2d");
                  }
                } else {
                  texture = sys.textures.createCanvas(key, width, height);
                  ctx = texture.getSourceImage().getContext("2d");
                }
              } else if (key instanceof HTMLCanvasElement) {
                ctx = key.getContext("2d");
              }
              if (ctx) {
                this.renderCanvas(renderer, this, Graphics.TargetCamera, null, ctx, false);
                if (texture) {
                  texture.refresh();
                }
              }
              return this;
            },
            preDestroy: function() {
              this.commandBuffer = [];
            }
          });
          Graphics.TargetCamera = new BaseCamera();
          module2.exports = Graphics;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            ARC: 0,
            BEGIN_PATH: 1,
            CLOSE_PATH: 2,
            FILL_RECT: 3,
            LINE_TO: 4,
            MOVE_TO: 5,
            LINE_STYLE: 6,
            FILL_STYLE: 7,
            FILL_PATH: 8,
            STROKE_PATH: 9,
            FILL_TRIANGLE: 10,
            STROKE_TRIANGLE: 11,
            SAVE: 14,
            RESTORE: 15,
            TRANSLATE: 16,
            SCALE: 17,
            ROTATE: 18,
            GRADIENT_FILL_STYLE: 21,
            GRADIENT_LINE_STYLE: 22
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var CircumferencePoint = function(ellipse, angle, out) {
            if (out === void 0) {
              out = new Point();
            }
            var halfWidth = ellipse.width / 2;
            var halfHeight = ellipse.height / 2;
            out.x = ellipse.x + halfWidth * Math.cos(angle);
            out.y = ellipse.y + halfHeight * Math.sin(angle);
            return out;
          };
          module2.exports = CircumferencePoint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BlendModes = __webpack_require__(34);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var ComponentsToJSON = __webpack_require__(173);
          var DataManager = __webpack_require__(98);
          var EventEmitter = __webpack_require__(9);
          var GameObjectEvents = __webpack_require__(75);
          var List = __webpack_require__(107);
          var Render = __webpack_require__(1065);
          var SceneEvents = __webpack_require__(21);
          var StableSort = __webpack_require__(79);
          var Layer = new Class({
            Extends: List,
            Mixins: [
              Components.AlphaSingle,
              Components.BlendMode,
              Components.Depth,
              Components.Mask,
              Components.Pipeline,
              Components.Visible,
              EventEmitter,
              Render
            ],
            initialize: function Layer2(scene, children) {
              List.call(this, scene);
              EventEmitter.call(this);
              this.scene = scene;
              this.displayList = null;
              this.type = "Layer";
              this.state = 0;
              this.parentContainer = null;
              this.name = "";
              this.active = true;
              this.tabIndex = -1;
              this.data = null;
              this.renderFlags = 15;
              this.cameraFilter = 0;
              this.input = null;
              this.body = null;
              this.ignoreDestroy = false;
              this.systems = scene.sys;
              this.events = scene.sys.events;
              this.sortChildrenFlag = false;
              this.addCallback = this.addChildCallback;
              this.removeCallback = this.removeChildCallback;
              this.initPipeline();
              this.clearAlpha();
              this.setBlendMode(BlendModes.SKIP_CHECK);
              if (children) {
                this.add(children);
              }
              scene.sys.queueDepthSort();
            },
            setActive: function(value) {
              this.active = value;
              return this;
            },
            setName: function(value) {
              this.name = value;
              return this;
            },
            setState: function(value) {
              this.state = value;
              return this;
            },
            setDataEnabled: function() {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              return this;
            },
            setData: function(key, value) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              this.data.set(key, value);
              return this;
            },
            incData: function(key, value) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              this.data.inc(key, value);
              return this;
            },
            toggleData: function(key) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              this.data.toggle(key);
              return this;
            },
            getData: function(key) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              return this.data.get(key);
            },
            setInteractive: function() {
              return this;
            },
            disableInteractive: function() {
              return this;
            },
            removeInteractive: function() {
              return this;
            },
            addedToScene: function() {
            },
            removedFromScene: function() {
            },
            update: function() {
            },
            toJSON: function() {
              return ComponentsToJSON(this);
            },
            willRender: function(camera) {
              return !(this.renderFlags !== 15 || this.list.length === 0 || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
            },
            getIndexList: function() {
              var child = this;
              var parent = this.parentContainer;
              var indexes = [];
              while (parent) {
                indexes.unshift(parent.getIndex(child));
                child = parent;
                if (!parent.parentContainer) {
                  break;
                } else {
                  parent = parent.parentContainer;
                }
              }
              indexes.unshift(this.displayList.getIndex(child));
              return indexes;
            },
            addChildCallback: function(gameObject) {
              gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);
              if (gameObject.displayList) {
                gameObject.displayList.remove(gameObject);
              }
              gameObject.displayList = this;
              this.queueDepthSort();
              this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);
            },
            removeChildCallback: function(gameObject) {
              gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
              gameObject.displayList = null;
              this.queueDepthSort();
              this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
            },
            queueDepthSort: function() {
              this.sortChildrenFlag = true;
            },
            depthSort: function() {
              if (this.sortChildrenFlag) {
                StableSort(this.list, this.sortByDepth);
                this.sortChildrenFlag = false;
              }
            },
            sortByDepth: function(childA, childB) {
              return childA._depth - childB._depth;
            },
            getChildren: function() {
              return this.list;
            },
            destroy: function() {
              if (!this.scene || this.ignoreDestroy) {
                return;
              }
              this.emit(GameObjectEvents.DESTROY, this);
              var i = this.list.length;
              while (i--) {
                this.list[i].destroy();
              }
              this.removeAllListeners();
              this.resetPostPipeline(true);
              if (this.displayList) {
                this.displayList.queueDepthSort();
                this.displayList.remove(this);
              }
              if (this.data) {
                this.data.destroy();
                this.data = void 0;
              }
              this.active = false;
              this.visible = false;
              this.list = void 0;
              this.scene = void 0;
              this.displayList = void 0;
              this.systems = void 0;
              this.events = void 0;
            }
          });
          module2.exports = Layer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var GravityWell = __webpack_require__(444);
          var List = __webpack_require__(107);
          var ParticleEmitter = __webpack_require__(446);
          var Render = __webpack_require__(1069);
          var ParticleEmitterManager = new Class({
            Extends: GameObject,
            Mixins: [
              Components.Depth,
              Components.Mask,
              Components.Pipeline,
              Components.Transform,
              Components.Visible,
              Render
            ],
            initialize: function ParticleEmitterManager2(scene, texture, frame, emitters) {
              GameObject.call(this, scene, "ParticleEmitterManager");
              this.blendMode = -1;
              this.timeScale = 1;
              this.texture = null;
              this.frame = null;
              this.frameNames = [];
              if (frame !== null && (typeof frame === "object" || Array.isArray(frame))) {
                emitters = frame;
                frame = null;
              }
              this.setTexture(texture, frame);
              this.initPipeline();
              this.emitters = new List(this);
              this.wells = new List(this);
              if (emitters) {
                if (!Array.isArray(emitters)) {
                  emitters = [emitters];
                }
                for (var i = 0; i < emitters.length; i++) {
                  this.createEmitter(emitters[i]);
                }
              }
            },
            addedToScene: function() {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function() {
              this.scene.sys.updateList.remove(this);
            },
            setTexture: function(key, frame) {
              this.texture = this.scene.sys.textures.get(key);
              return this.setFrame(frame);
            },
            setFrame: function(frame) {
              this.frame = this.texture.get(frame);
              var frames = this.texture.getFramesFromTextureSource(this.frame.sourceIndex);
              var names = [];
              frames.forEach(function(sourceFrame) {
                names.push(sourceFrame.name);
              });
              this.frameNames = names;
              this.defaultFrame = this.frame;
              return this;
            },
            setEmitterFrames: function(frames, emitter) {
              if (!Array.isArray(frames)) {
                frames = [frames];
              }
              var out = emitter.frames;
              out.length = 0;
              for (var i = 0; i < frames.length; i++) {
                var frame = frames[i];
                if (this.frameNames.indexOf(frame) !== -1) {
                  out.push(this.texture.get(frame));
                }
              }
              if (out.length > 0) {
                emitter.defaultFrame = out[0];
              } else {
                emitter.defaultFrame = this.defaultFrame;
              }
              return this;
            },
            addEmitter: function(emitter) {
              return this.emitters.add(emitter);
            },
            createEmitter: function(config2) {
              return this.addEmitter(new ParticleEmitter(this, config2));
            },
            removeEmitter: function(emitter) {
              return this.emitters.remove(emitter, true);
            },
            addGravityWell: function(well) {
              return this.wells.add(well);
            },
            createGravityWell: function(config2) {
              return this.addGravityWell(new GravityWell(config2));
            },
            emitParticle: function(count, x, y) {
              var emitters = this.emitters.list;
              for (var i = 0; i < emitters.length; i++) {
                var emitter = emitters[i];
                if (emitter.active) {
                  emitter.emitParticle(count, x, y);
                }
              }
              return this;
            },
            emitParticleAt: function(x, y, count) {
              return this.emitParticle(count, x, y);
            },
            pause: function() {
              this.active = false;
              return this;
            },
            resume: function() {
              this.active = true;
              return this;
            },
            getProcessors: function() {
              return this.wells.getAll("active", true);
            },
            preUpdate: function(time, delta) {
              delta *= this.timeScale;
              var emitters = this.emitters.list;
              for (var i = 0; i < emitters.length; i++) {
                var emitter = emitters[i];
                if (emitter.active) {
                  emitter.preUpdate(time, delta);
                }
              }
            },
            setAlpha: function() {
            },
            setScrollFactor: function() {
            },
            setBlendMode: function() {
            }
          });
          module2.exports = ParticleEmitterManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BlendModes = __webpack_require__(34);
          var Camera = __webpack_require__(131);
          var CanvasPool = __webpack_require__(31);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var CONST = __webpack_require__(32);
          var Frame = __webpack_require__(106);
          var GameObject = __webpack_require__(15);
          var NOOP = __webpack_require__(1);
          var PIPELINE_CONST = __webpack_require__(65);
          var Render = __webpack_require__(1073);
          var RenderTarget = __webpack_require__(139);
          var Utils = __webpack_require__(12);
          var UUID = __webpack_require__(219);
          var RenderTexture = new Class({
            Extends: GameObject,
            Mixins: [
              Components.Alpha,
              Components.BlendMode,
              Components.ComputedSize,
              Components.Crop,
              Components.Depth,
              Components.Flip,
              Components.GetBounds,
              Components.Mask,
              Components.Origin,
              Components.Pipeline,
              Components.ScrollFactor,
              Components.Tint,
              Components.Transform,
              Components.Visible,
              Render
            ],
            initialize: function RenderTexture2(scene, x, y, width, height, key, frame) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 32;
              }
              if (height === void 0) {
                height = 32;
              }
              GameObject.call(this, scene, "RenderTexture");
              this.renderer = scene.sys.renderer;
              this.textureManager = scene.sys.textures;
              this.globalTint = 16777215;
              this.globalAlpha = 1;
              this.canvas = null;
              this.dirty = false;
              this._crop = this.resetCropObject();
              this.texture = null;
              this.frame = null;
              this._saved = false;
              if (key === void 0) {
                this.canvas = CanvasPool.create2D(this, width, height);
                this.texture = scene.sys.textures.addCanvas(UUID(), this.canvas);
                this.frame = this.texture.get();
              } else {
                this.texture = scene.sys.textures.get(key);
                this.frame = this.texture.get(frame);
                this.canvas = this.frame.source.image;
                this._saved = true;
                this.dirty = true;
                this.width = this.frame.cutWidth;
                this.height = this.frame.cutHeight;
              }
              this.context = this.canvas.getContext("2d");
              this._eraseMode = false;
              this.camera = new Camera(0, 0, width, height);
              this.renderTarget = null;
              var renderer = this.renderer;
              if (!renderer) {
                this.drawGameObject = NOOP;
              } else if (renderer.type === CONST.WEBGL) {
                this.drawGameObject = this.batchGameObjectWebGL;
                this.renderTarget = new RenderTarget(renderer, width, height, 1, 0, false);
              } else if (renderer.type === CONST.CANVAS) {
                this.drawGameObject = this.batchGameObjectCanvas;
              }
              this.camera.setScene(scene);
              this.setPosition(x, y);
              if (key === void 0) {
                this.setSize(width, height);
              }
              this.setOrigin(0, 0);
              this.initPipeline(PIPELINE_CONST.SINGLE_PIPELINE);
            },
            setSize: function(width, height) {
              return this.resize(width, height);
            },
            resize: function(width, height) {
              if (height === void 0) {
                height = width;
              }
              var frame = this.frame;
              if (width !== this.width || height !== this.height) {
                if (frame.name === "__BASE") {
                  this.canvas.width = width;
                  this.canvas.height = height;
                  this.texture.width = width;
                  this.texture.height = height;
                  var renderTarget = this.renderTarget;
                  if (renderTarget) {
                    renderTarget.resize(width, height);
                    frame.glTexture = renderTarget.texture;
                    frame.source.isRenderTexture = true;
                    frame.source.isGLTexture = true;
                    frame.source.glTexture = renderTarget.texture;
                  }
                  this.camera.setSize(width, height);
                  frame.source.width = width;
                  frame.source.height = height;
                  frame.setSize(width, height);
                  this.width = width;
                  this.height = height;
                }
              } else {
                var baseFrame = this.texture.getSourceImage();
                if (frame.cutX + width > baseFrame.width) {
                  width = baseFrame.width - frame.cutX;
                }
                if (frame.cutY + height > baseFrame.height) {
                  height = baseFrame.height - frame.cutY;
                }
                frame.setSize(width, height, frame.cutX, frame.cutY);
              }
              this.updateDisplayOrigin();
              var input = this.input;
              if (input && !input.customHitArea) {
                input.hitArea.width = width;
                input.hitArea.height = height;
              }
              return this;
            },
            setGlobalTint: function(tint) {
              this.globalTint = tint;
              return this;
            },
            setGlobalAlpha: function(alpha) {
              this.globalAlpha = alpha;
              return this;
            },
            saveTexture: function(key) {
              this.textureManager.renameTexture(this.texture.key, key);
              this._saved = true;
              return this.texture;
            },
            fill: function(rgb, alpha, x, y, width, height) {
              var frame = this.frame;
              var camera = this.camera;
              var renderer = this.renderer;
              if (alpha === void 0) {
                alpha = 1;
              }
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = frame.cutWidth;
              }
              if (height === void 0) {
                height = frame.cutHeight;
              }
              var r = (rgb >> 16 & 255) / 255;
              var g = (rgb >> 8 & 255) / 255;
              var b = (rgb & 255) / 255;
              var renderTarget = this.renderTarget;
              camera.preRender();
              if (renderTarget) {
                renderTarget.bind(true);
                var pipeline = this.pipeline;
                pipeline.manager.set(pipeline);
                var tw = renderTarget.width;
                var th = renderTarget.height;
                var rw = renderer.width;
                var rh = renderer.height;
                var sx = rw / tw;
                var sy = rh / th;
                pipeline.drawFillRect(x * sx, y * sy, width * sx, height * sy, Utils.getTintFromFloats(b, g, r, 1), alpha);
                renderTarget.unbind(true);
              } else {
                var ctx = this.context;
                renderer.setContext(ctx);
                ctx.fillStyle = "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
                ctx.fillRect(x + frame.cutX, y + frame.cutY, width, height);
                renderer.setContext();
              }
              this.dirty = true;
              return this;
            },
            clear: function() {
              if (this.dirty) {
                var renderTarget = this.renderTarget;
                if (renderTarget) {
                  renderTarget.clear();
                } else {
                  var ctx = this.context;
                  ctx.save();
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight);
                  ctx.restore();
                }
                this.dirty = false;
              }
              return this;
            },
            erase: function(entries, x, y) {
              this._eraseMode = true;
              this.draw(entries, x, y, 1, 16777215);
              this._eraseMode = false;
              return this;
            },
            draw: function(entries, x, y, alpha, tint) {
              this.beginDraw();
              this.batchDraw(entries, x, y, alpha, tint);
              this.endDraw();
              return this;
            },
            drawFrame: function(key, frame, x, y, alpha, tint) {
              this.beginDraw();
              this.batchDrawFrame(key, frame, x, y, alpha, tint);
              this.endDraw();
              return this;
            },
            beginDraw: function() {
              var camera = this.camera;
              var renderer = this.renderer;
              var renderTarget = this.renderTarget;
              camera.preRender();
              if (renderTarget) {
                renderer.beginCapture(renderTarget.width, renderTarget.height);
              } else {
                renderer.setContext(this.context);
              }
              return this;
            },
            batchDraw: function(entries, x, y, alpha, tint) {
              if (alpha === void 0) {
                alpha = this.globalAlpha;
              }
              if (tint === void 0) {
                tint = (this.globalTint >> 16) + (this.globalTint & 65280) + ((this.globalTint & 255) << 16);
              } else {
                tint = (tint >> 16) + (tint & 65280) + ((tint & 255) << 16);
              }
              if (!Array.isArray(entries)) {
                entries = [entries];
              }
              this.batchList(entries, x, y, alpha, tint);
              return this;
            },
            batchDrawFrame: function(key, frame, x, y, alpha, tint) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (alpha === void 0) {
                alpha = this.globalAlpha;
              }
              if (tint === void 0) {
                tint = (this.globalTint >> 16) + (this.globalTint & 65280) + ((this.globalTint & 255) << 16);
              } else {
                tint = (tint >> 16) + (tint & 65280) + ((tint & 255) << 16);
              }
              var textureFrame = this.textureManager.getFrame(key, frame);
              if (textureFrame) {
                if (this.renderTarget) {
                  this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);
                } else {
                  this.batchTextureFrame(textureFrame, x + this.frame.cutX, y + this.frame.cutY, alpha, tint);
                }
              }
              return this;
            },
            endDraw: function() {
              var renderer = this.renderer;
              var renderTarget = this.renderTarget;
              if (renderTarget) {
                var canvasTarget = renderer.endCapture();
                var util = renderer.pipelines.setUtility();
                util.blitFrame(canvasTarget, renderTarget, 1, false, false, this._eraseMode);
                renderer.resetScissor();
                renderer.resetViewport();
              } else {
                renderer.setContext();
              }
              this.dirty = true;
              return this;
            },
            batchList: function(children, x, y, alpha, tint) {
              for (var i = 0; i < children.length; i++) {
                var entry = children[i];
                if (!entry || entry === this) {
                  continue;
                }
                if (entry.renderWebGL || entry.renderCanvas) {
                  this.drawGameObject(entry, x, y);
                } else if (entry.isParent || entry.list) {
                  this.batchGroup(entry.getChildren(), x, y);
                } else if (typeof entry === "string") {
                  this.batchTextureFrameKey(entry, null, x, y, alpha, tint);
                } else if (entry instanceof Frame) {
                  this.batchTextureFrame(entry, x, y, alpha, tint);
                } else if (Array.isArray(entry)) {
                  this.batchList(entry, x, y, alpha, tint);
                }
              }
            },
            batchGroup: function(children, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              x += this.frame.cutX;
              y += this.frame.cutY;
              for (var i = 0; i < children.length; i++) {
                var entry = children[i];
                if (entry.willRender(this.camera)) {
                  var tx = entry.x + x;
                  var ty = entry.y + y;
                  this.drawGameObject(entry, tx, ty);
                }
              }
            },
            batchGameObjectWebGL: function(gameObject, x, y) {
              if (x === void 0) {
                x = gameObject.x;
              }
              if (y === void 0) {
                y = gameObject.y;
              }
              var prevX = gameObject.x;
              var prevY = gameObject.y;
              gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY);
              if (gameObject.renderDirect) {
                gameObject.renderDirect(this.renderer, gameObject, this.camera);
              } else {
                gameObject.renderWebGL(this.renderer, gameObject, this.camera);
              }
              gameObject.setPosition(prevX, prevY);
            },
            batchGameObjectCanvas: function(gameObject, x, y) {
              if (x === void 0) {
                x = gameObject.x;
              }
              if (y === void 0) {
                y = gameObject.y;
              }
              var prevX = gameObject.x;
              var prevY = gameObject.y;
              if (this._eraseMode) {
                var blendMode = gameObject.blendMode;
                gameObject.blendMode = BlendModes.ERASE;
              }
              gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY);
              gameObject.renderCanvas(this.renderer, gameObject, this.camera, null);
              gameObject.setPosition(prevX, prevY);
              if (this._eraseMode) {
                gameObject.blendMode = blendMode;
              }
            },
            batchTextureFrameKey: function(key, frame, x, y, alpha, tint) {
              var textureFrame = this.textureManager.getFrame(key, frame);
              if (textureFrame) {
                this.batchTextureFrame(textureFrame, x, y, alpha, tint);
              }
            },
            batchTextureFrame: function(textureFrame, x, y, alpha, tint) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              x += this.frame.cutX;
              y += this.frame.cutY;
              var renderTarget = this.renderTarget;
              if (renderTarget) {
                this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);
              } else {
                var ctx = this.context;
                var cd = textureFrame.canvasData;
                var source = textureFrame.source.image;
                var matrix = this.camera.matrix;
                ctx.save();
                ctx.globalCompositeOperation = this._eraseMode ? "destination-out" : "source-over";
                ctx.globalAlpha = alpha;
                matrix.setToContext(ctx);
                ctx.drawImage(source, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);
                ctx.restore();
              }
            },
            snapshotArea: function(x, y, width, height, callback, type, encoderOptions) {
              if (this.renderTarget) {
                this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, x, y, width, height, type, encoderOptions);
              } else {
                this.renderer.snapshotCanvas(this.canvas, callback, false, x, y, width, height, type, encoderOptions);
              }
              return this;
            },
            snapshot: function(callback, type, encoderOptions) {
              if (this.renderTarget) {
                this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, 0, 0, this.width, this.height, type, encoderOptions);
              } else {
                this.renderer.snapshotCanvas(this.canvas, callback, false, 0, 0, this.width, this.height, type, encoderOptions);
              }
              return this;
            },
            snapshotPixel: function(x, y, callback) {
              if (this.renderTarget) {
                this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, true, x, y);
              } else {
                this.renderer.snapshotCanvas(this.canvas, callback, true, x, y);
              }
              return this;
            },
            preDestroy: function() {
              if (!this._saved) {
                CanvasPool.remove(this.canvas);
                if (this.renderTarget) {
                  this.renderTarget.destroy();
                }
                this.texture.destroy();
                this.camera.destroy();
                this.canvas = null;
                this.context = null;
                this.texture = null;
              }
            }
          });
          module2.exports = RenderTexture;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var UUID = function() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
              var r = Math.random() * 16 | 0;
              var v = c === "x" ? r : r & 3 | 8;
              return v.toString(16);
            });
          };
          module2.exports = UUID;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AnimationState = __webpack_require__(162);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var PIPELINE_CONST = __webpack_require__(65);
          var RopeRender = __webpack_require__(1079);
          var Vector29 = __webpack_require__(3);
          var Rope = new Class({
            Extends: GameObject,
            Mixins: [
              Components.AlphaSingle,
              Components.BlendMode,
              Components.Depth,
              Components.Flip,
              Components.Mask,
              Components.Pipeline,
              Components.Size,
              Components.Texture,
              Components.Transform,
              Components.Visible,
              Components.ScrollFactor,
              RopeRender
            ],
            initialize: function Rope2(scene, x, y, texture, frame, points, horizontal, colors, alphas) {
              if (texture === void 0) {
                texture = "__DEFAULT";
              }
              if (points === void 0) {
                points = 2;
              }
              if (horizontal === void 0) {
                horizontal = true;
              }
              GameObject.call(this, scene, "Rope");
              this.anims = new AnimationState(this);
              this.points = points;
              this.vertices;
              this.uv;
              this.colors;
              this.alphas;
              this.tintFill = texture === "__DEFAULT" ? true : false;
              this.dirty = false;
              this.horizontal = horizontal;
              this._flipX = false;
              this._flipY = false;
              this._perp = new Vector29();
              this.debugCallback = null;
              this.debugGraphic = null;
              this.setTexture(texture, frame);
              this.setPosition(x, y);
              this.setSizeToFrame();
              this.initPipeline(PIPELINE_CONST.ROPE_PIPELINE);
              if (Array.isArray(points)) {
                this.resizeArrays(points.length);
              }
              this.setPoints(points, colors, alphas);
              this.updateVertices();
            },
            addedToScene: function() {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function() {
              this.scene.sys.updateList.remove(this);
            },
            preUpdate: function(time, delta) {
              var prevFrame = this.anims.currentFrame;
              this.anims.update(time, delta);
              if (this.anims.currentFrame !== prevFrame) {
                this.updateUVs();
                this.updateVertices();
              }
            },
            play: function(key, ignoreIfPlaying, startFrame) {
              this.anims.play(key, ignoreIfPlaying, startFrame);
              return this;
            },
            setDirty: function() {
              this.dirty = true;
              return this;
            },
            setHorizontal: function(points, colors, alphas) {
              if (points === void 0) {
                points = this.points.length;
              }
              if (this.horizontal) {
                return this;
              }
              this.horizontal = true;
              return this.setPoints(points, colors, alphas);
            },
            setVertical: function(points, colors, alphas) {
              if (points === void 0) {
                points = this.points.length;
              }
              if (!this.horizontal) {
                return this;
              }
              this.horizontal = false;
              return this.setPoints(points, colors, alphas);
            },
            setTintFill: function(value) {
              if (value === void 0) {
                value = false;
              }
              this.tintFill = value;
              return this;
            },
            setAlphas: function(alphas, bottomAlpha) {
              var total = this.points.length;
              if (total < 1) {
                return this;
              }
              var currentAlphas = this.alphas;
              if (alphas === void 0) {
                alphas = [1];
              } else if (!Array.isArray(alphas) && bottomAlpha === void 0) {
                alphas = [alphas];
              }
              var i;
              var index = 0;
              if (bottomAlpha !== void 0) {
                for (i = 0; i < total; i++) {
                  index = i * 2;
                  currentAlphas[index] = alphas;
                  currentAlphas[index + 1] = bottomAlpha;
                }
              } else if (alphas.length === total) {
                for (i = 0; i < total; i++) {
                  index = i * 2;
                  currentAlphas[index] = alphas[i];
                  currentAlphas[index + 1] = alphas[i];
                }
              } else {
                var prevAlpha = alphas[0];
                for (i = 0; i < total; i++) {
                  index = i * 2;
                  if (alphas.length > index) {
                    prevAlpha = alphas[index];
                  }
                  currentAlphas[index] = prevAlpha;
                  if (alphas.length > index + 1) {
                    prevAlpha = alphas[index + 1];
                  }
                  currentAlphas[index + 1] = prevAlpha;
                }
              }
              return this;
            },
            setColors: function(colors) {
              var total = this.points.length;
              if (total < 1) {
                return this;
              }
              var currentColors = this.colors;
              if (colors === void 0) {
                colors = [16777215];
              } else if (!Array.isArray(colors)) {
                colors = [colors];
              }
              var i;
              var index = 0;
              if (colors.length === total) {
                for (i = 0; i < total; i++) {
                  index = i * 2;
                  currentColors[index] = colors[i];
                  currentColors[index + 1] = colors[i];
                }
              } else {
                var prevColor = colors[0];
                for (i = 0; i < total; i++) {
                  index = i * 2;
                  if (colors.length > index) {
                    prevColor = colors[index];
                  }
                  currentColors[index] = prevColor;
                  if (colors.length > index + 1) {
                    prevColor = colors[index + 1];
                  }
                  currentColors[index + 1] = prevColor;
                }
              }
              return this;
            },
            setPoints: function(points, colors, alphas) {
              if (points === void 0) {
                points = 2;
              }
              if (typeof points === "number") {
                var segments = points;
                if (segments < 2) {
                  segments = 2;
                }
                points = [];
                var s;
                var frameSegment;
                var offset;
                if (this.horizontal) {
                  offset = -this.frame.halfWidth;
                  frameSegment = this.frame.width / (segments - 1);
                  for (s = 0; s < segments; s++) {
                    points.push({x: offset + s * frameSegment, y: 0});
                  }
                } else {
                  offset = -this.frame.halfHeight;
                  frameSegment = this.frame.height / (segments - 1);
                  for (s = 0; s < segments; s++) {
                    points.push({x: 0, y: offset + s * frameSegment});
                  }
                }
              }
              var total = points.length;
              var currentTotal = this.points.length;
              if (total < 1) {
                console.warn("Rope: Not enough points given");
                return this;
              } else if (total === 1) {
                points.unshift({x: 0, y: 0});
                total++;
              }
              if (currentTotal !== total) {
                this.resizeArrays(total);
              }
              this.points = points;
              this.updateUVs();
              if (colors !== void 0 && colors !== null) {
                this.setColors(colors);
              }
              if (alphas !== void 0 && alphas !== null) {
                this.setAlphas(alphas);
              }
              return this;
            },
            updateUVs: function() {
              var currentUVs = this.uv;
              var total = this.points.length;
              var u0 = this.frame.u0;
              var v0 = this.frame.v0;
              var u1 = this.frame.u1;
              var v1 = this.frame.v1;
              var partH = (u1 - u0) / (total - 1);
              var partV = (v1 - v0) / (total - 1);
              for (var i = 0; i < total; i++) {
                var index = i * 4;
                var uv0;
                var uv1;
                var uv2;
                var uv3;
                if (this.horizontal) {
                  if (this._flipX) {
                    uv0 = u1 - i * partH;
                    uv2 = u1 - i * partH;
                  } else {
                    uv0 = u0 + i * partH;
                    uv2 = u0 + i * partH;
                  }
                  if (this._flipY) {
                    uv1 = v1;
                    uv3 = v0;
                  } else {
                    uv1 = v0;
                    uv3 = v1;
                  }
                } else {
                  if (this._flipX) {
                    uv0 = u0;
                    uv2 = u1;
                  } else {
                    uv0 = u1;
                    uv2 = u0;
                  }
                  if (this._flipY) {
                    uv1 = v1 - i * partV;
                    uv3 = v1 - i * partV;
                  } else {
                    uv1 = v0 + i * partV;
                    uv3 = v0 + i * partV;
                  }
                }
                currentUVs[index + 0] = uv0;
                currentUVs[index + 1] = uv1;
                currentUVs[index + 2] = uv2;
                currentUVs[index + 3] = uv3;
              }
              return this;
            },
            resizeArrays: function(newSize) {
              var colors = this.colors;
              var alphas = this.alphas;
              this.vertices = new Float32Array(newSize * 4);
              this.uv = new Float32Array(newSize * 4);
              colors = new Uint32Array(newSize * 2);
              alphas = new Float32Array(newSize * 2);
              for (var i = 0; i < newSize * 2; i++) {
                colors[i] = 16777215;
                alphas[i] = 1;
              }
              this.colors = colors;
              this.alphas = alphas;
              this.dirty = true;
              return this;
            },
            updateVertices: function() {
              var perp = this._perp;
              var points = this.points;
              var vertices = this.vertices;
              var total = points.length;
              this.dirty = false;
              if (total < 1) {
                return;
              }
              var nextPoint;
              var lastPoint = points[0];
              var frameSize = this.horizontal ? this.frame.halfHeight : this.frame.halfWidth;
              for (var i = 0; i < total; i++) {
                var point = points[i];
                var index = i * 4;
                if (i < total - 1) {
                  nextPoint = points[i + 1];
                } else {
                  nextPoint = point;
                }
                perp.x = nextPoint.y - lastPoint.y;
                perp.y = -(nextPoint.x - lastPoint.x);
                var perpLength = perp.length();
                perp.x /= perpLength;
                perp.y /= perpLength;
                perp.x *= frameSize;
                perp.y *= frameSize;
                vertices[index] = point.x + perp.x;
                vertices[index + 1] = point.y + perp.y;
                vertices[index + 2] = point.x - perp.x;
                vertices[index + 3] = point.y - perp.y;
                lastPoint = point;
              }
              return this;
            },
            setDebug: function(graphic, callback) {
              this.debugGraphic = graphic;
              if (!graphic && !callback) {
                this.debugCallback = null;
              } else if (!callback) {
                this.debugCallback = this.renderDebugVerts;
              } else {
                this.debugCallback = callback;
              }
              return this;
            },
            renderDebugVerts: function(src, meshLength, verts) {
              var graphic = src.debugGraphic;
              var px0 = verts[0];
              var py0 = verts[1];
              var px1 = verts[2];
              var py1 = verts[3];
              graphic.lineBetween(px0, py0, px1, py1);
              for (var i = 4; i < meshLength; i += 4) {
                var x0 = verts[i + 0];
                var y0 = verts[i + 1];
                var x1 = verts[i + 2];
                var y1 = verts[i + 3];
                graphic.lineBetween(px0, py0, x0, y0);
                graphic.lineBetween(px1, py1, x1, y1);
                graphic.lineBetween(px1, py1, x0, y0);
                graphic.lineBetween(x0, y0, x1, y1);
                px0 = x0;
                py0 = y0;
                px1 = x1;
                py1 = y1;
              }
            },
            preDestroy: function() {
              this.anims.destroy();
              this.anims = void 0;
              this.points = null;
              this.vertices = null;
              this.uv = null;
              this.colors = null;
              this.alphas = null;
              this.debugCallback = null;
              this.debugGraphic = null;
            },
            flipX: {
              get: function() {
                return this._flipX;
              },
              set: function(value) {
                this._flipX = value;
                return this.updateUVs();
              }
            },
            flipY: {
              get: function() {
                return this._flipY;
              },
              set: function(value) {
                this._flipY = value;
                return this.updateUVs();
              }
            }
          });
          module2.exports = Rope;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AddToDOM = __webpack_require__(140);
          var CanvasPool = __webpack_require__(31);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameEvents = __webpack_require__(22);
          var GameObject = __webpack_require__(15);
          var GetTextSize = __webpack_require__(452);
          var GetValue = __webpack_require__(6);
          var RemoveFromDOM = __webpack_require__(199);
          var TextRender = __webpack_require__(1082);
          var TextStyle = __webpack_require__(453);
          var Text = new Class({
            Extends: GameObject,
            Mixins: [
              Components.Alpha,
              Components.BlendMode,
              Components.ComputedSize,
              Components.Crop,
              Components.Depth,
              Components.Flip,
              Components.GetBounds,
              Components.Mask,
              Components.Origin,
              Components.Pipeline,
              Components.ScrollFactor,
              Components.Tint,
              Components.Transform,
              Components.Visible,
              TextRender
            ],
            initialize: function Text2(scene, x, y, text, style) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              GameObject.call(this, scene, "Text");
              this.renderer = scene.sys.renderer;
              this.setPosition(x, y);
              this.setOrigin(0, 0);
              this.initPipeline();
              this.canvas = CanvasPool.create(this);
              this.context = this.canvas.getContext("2d");
              this.style = new TextStyle(this, style);
              this.autoRound = true;
              this.splitRegExp = /(?:\r\n|\r|\n)/;
              this._text = void 0;
              this.padding = {left: 0, right: 0, top: 0, bottom: 0};
              this.width = 1;
              this.height = 1;
              this.lineSpacing = 0;
              this.dirty = false;
              if (this.style.resolution === 0) {
                this.style.resolution = 1;
              }
              this._crop = this.resetCropObject();
              this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);
              this.frame = this.texture.get();
              this.frame.source.resolution = this.style.resolution;
              if (this.renderer && this.renderer.gl) {
                this.renderer.deleteTexture(this.frame.source.glTexture);
                this.frame.source.glTexture = null;
              }
              this.initRTL();
              this.setText(text);
              if (style && style.padding) {
                this.setPadding(style.padding);
              }
              if (style && style.lineSpacing) {
                this.setLineSpacing(style.lineSpacing);
              }
              scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function() {
                this.dirty = true;
              }, this);
            },
            initRTL: function() {
              if (!this.style.rtl) {
                return;
              }
              this.canvas.dir = "rtl";
              this.context.direction = "rtl";
              this.canvas.style.display = "none";
              AddToDOM(this.canvas, this.scene.sys.canvas);
              this.originX = 1;
            },
            runWordWrap: function(text) {
              var style = this.style;
              if (style.wordWrapCallback) {
                var wrappedLines = style.wordWrapCallback.call(style.wordWrapCallbackScope, text, this);
                if (Array.isArray(wrappedLines)) {
                  wrappedLines = wrappedLines.join("\n");
                }
                return wrappedLines;
              } else if (style.wordWrapWidth) {
                if (style.wordWrapUseAdvanced) {
                  return this.advancedWordWrap(text, this.context, this.style.wordWrapWidth);
                } else {
                  return this.basicWordWrap(text, this.context, this.style.wordWrapWidth);
                }
              } else {
                return text;
              }
            },
            advancedWordWrap: function(text, context, wordWrapWidth) {
              var output = "";
              var lines = text.replace(/ +/gi, " ").split(this.splitRegExp);
              var linesCount = lines.length;
              for (var i = 0; i < linesCount; i++) {
                var line = lines[i];
                var out = "";
                line = line.replace(/^ *|\s*$/gi, "");
                var lineWidth = context.measureText(line).width;
                if (lineWidth < wordWrapWidth) {
                  output += line + "\n";
                  continue;
                }
                var currentLineWidth = wordWrapWidth;
                var words = line.split(" ");
                for (var j = 0; j < words.length; j++) {
                  var word = words[j];
                  var wordWithSpace = word + " ";
                  var wordWidth = context.measureText(wordWithSpace).width;
                  if (wordWidth > currentLineWidth) {
                    if (j === 0) {
                      var newWord = wordWithSpace;
                      while (newWord.length) {
                        newWord = newWord.slice(0, -1);
                        wordWidth = context.measureText(newWord).width;
                        if (wordWidth <= currentLineWidth) {
                          break;
                        }
                      }
                      if (!newWord.length) {
                        throw new Error("This text's wordWrapWidth setting is less than a single character!");
                      }
                      var secondPart = word.substr(newWord.length);
                      words[j] = secondPart;
                      out += newWord;
                    }
                    var offset = words[j].length ? j : j + 1;
                    var remainder = words.slice(offset).join(" ").replace(/[ \n]*$/gi, "");
                    lines[i + 1] = remainder + " " + (lines[i + 1] || "");
                    linesCount = lines.length;
                    break;
                  } else {
                    out += wordWithSpace;
                    currentLineWidth -= wordWidth;
                  }
                }
                output += out.replace(/[ \n]*$/gi, "") + "\n";
              }
              output = output.replace(/[\s|\n]*$/gi, "");
              return output;
            },
            basicWordWrap: function(text, context, wordWrapWidth) {
              var result = "";
              var lines = text.split(this.splitRegExp);
              var lastLineIndex = lines.length - 1;
              var whiteSpaceWidth = context.measureText(" ").width;
              for (var i = 0; i <= lastLineIndex; i++) {
                var spaceLeft = wordWrapWidth;
                var words = lines[i].split(" ");
                var lastWordIndex = words.length - 1;
                for (var j = 0; j <= lastWordIndex; j++) {
                  var word = words[j];
                  var wordWidth = context.measureText(word).width;
                  var wordWidthWithSpace = wordWidth;
                  if (j < lastWordIndex) {
                    wordWidthWithSpace += whiteSpaceWidth;
                  }
                  if (wordWidthWithSpace > spaceLeft) {
                    if (j > 0) {
                      result += "\n";
                      spaceLeft = wordWrapWidth;
                    }
                  }
                  result += word;
                  if (j < lastWordIndex) {
                    result += " ";
                    spaceLeft -= wordWidthWithSpace;
                  } else {
                    spaceLeft -= wordWidth;
                  }
                }
                if (i < lastLineIndex) {
                  result += "\n";
                }
              }
              return result;
            },
            getWrappedText: function(text) {
              if (text === void 0) {
                text = this._text;
              }
              this.style.syncFont(this.canvas, this.context);
              var wrappedLines = this.runWordWrap(text);
              return wrappedLines.split(this.splitRegExp);
            },
            setText: function(value) {
              if (!value && value !== 0) {
                value = "";
              }
              if (Array.isArray(value)) {
                value = value.join("\n");
              }
              if (value !== this._text) {
                this._text = value.toString();
                this.updateText();
              }
              return this;
            },
            setStyle: function(style) {
              return this.style.setStyle(style);
            },
            setFont: function(font) {
              return this.style.setFont(font);
            },
            setFontFamily: function(family) {
              return this.style.setFontFamily(family);
            },
            setFontSize: function(size) {
              return this.style.setFontSize(size);
            },
            setFontStyle: function(style) {
              return this.style.setFontStyle(style);
            },
            setFixedSize: function(width, height) {
              return this.style.setFixedSize(width, height);
            },
            setBackgroundColor: function(color) {
              return this.style.setBackgroundColor(color);
            },
            setFill: function(fillStyle) {
              return this.style.setFill(fillStyle);
            },
            setColor: function(color) {
              return this.style.setColor(color);
            },
            setStroke: function(color, thickness) {
              return this.style.setStroke(color, thickness);
            },
            setShadow: function(x, y, color, blur, shadowStroke, shadowFill) {
              return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
            },
            setShadowOffset: function(x, y) {
              return this.style.setShadowOffset(x, y);
            },
            setShadowColor: function(color) {
              return this.style.setShadowColor(color);
            },
            setShadowBlur: function(blur) {
              return this.style.setShadowBlur(blur);
            },
            setShadowStroke: function(enabled) {
              return this.style.setShadowStroke(enabled);
            },
            setShadowFill: function(enabled) {
              return this.style.setShadowFill(enabled);
            },
            setWordWrapWidth: function(width, useAdvancedWrap) {
              return this.style.setWordWrapWidth(width, useAdvancedWrap);
            },
            setWordWrapCallback: function(callback, scope) {
              return this.style.setWordWrapCallback(callback, scope);
            },
            setAlign: function(align) {
              return this.style.setAlign(align);
            },
            setResolution: function(value) {
              return this.style.setResolution(value);
            },
            setLineSpacing: function(value) {
              this.lineSpacing = value;
              return this.updateText();
            },
            setPadding: function(left, top, right, bottom) {
              if (typeof left === "object") {
                var config2 = left;
                var x = GetValue(config2, "x", null);
                if (x !== null) {
                  left = x;
                  right = x;
                } else {
                  left = GetValue(config2, "left", 0);
                  right = GetValue(config2, "right", left);
                }
                var y = GetValue(config2, "y", null);
                if (y !== null) {
                  top = y;
                  bottom = y;
                } else {
                  top = GetValue(config2, "top", 0);
                  bottom = GetValue(config2, "bottom", top);
                }
              } else {
                if (left === void 0) {
                  left = 0;
                }
                if (top === void 0) {
                  top = left;
                }
                if (right === void 0) {
                  right = left;
                }
                if (bottom === void 0) {
                  bottom = top;
                }
              }
              this.padding.left = left;
              this.padding.top = top;
              this.padding.right = right;
              this.padding.bottom = bottom;
              return this.updateText();
            },
            setMaxLines: function(max) {
              return this.style.setMaxLines(max);
            },
            updateText: function() {
              var canvas = this.canvas;
              var context = this.context;
              var style = this.style;
              var resolution = style.resolution;
              var size = style.metrics;
              style.syncFont(canvas, context);
              var outputText = this._text;
              if (style.wordWrapWidth || style.wordWrapCallback) {
                outputText = this.runWordWrap(this._text);
              }
              var lines = outputText.split(this.splitRegExp);
              var textSize = GetTextSize(this, size, lines);
              var padding = this.padding;
              var textWidth;
              if (style.fixedWidth === 0) {
                this.width = textSize.width + padding.left + padding.right;
                textWidth = textSize.width;
              } else {
                this.width = style.fixedWidth;
                textWidth = this.width - padding.left - padding.right;
                if (textWidth < textSize.width) {
                  textWidth = textSize.width;
                }
              }
              if (style.fixedHeight === 0) {
                this.height = textSize.height + padding.top + padding.bottom;
              } else {
                this.height = style.fixedHeight;
              }
              var w = this.width;
              var h = this.height;
              this.updateDisplayOrigin();
              w *= resolution;
              h *= resolution;
              w = Math.max(w, 1);
              h = Math.max(h, 1);
              if (canvas.width !== w || canvas.height !== h) {
                canvas.width = w;
                canvas.height = h;
                this.frame.setSize(w, h);
                style.syncFont(canvas, context);
              } else {
                context.clearRect(0, 0, w, h);
              }
              context.save();
              context.scale(resolution, resolution);
              if (style.backgroundColor) {
                context.fillStyle = style.backgroundColor;
                context.fillRect(0, 0, w, h);
              }
              style.syncStyle(canvas, context);
              context.textBaseline = "alphabetic";
              context.translate(padding.left, padding.top);
              var linePositionX;
              var linePositionY;
              for (var i = 0; i < textSize.lines; i++) {
                linePositionX = style.strokeThickness / 2;
                linePositionY = style.strokeThickness / 2 + i * textSize.lineHeight + size.ascent;
                if (i > 0) {
                  linePositionY += textSize.lineSpacing * i;
                }
                if (style.rtl) {
                  linePositionX = w - linePositionX;
                } else if (style.align === "right") {
                  linePositionX += textWidth - textSize.lineWidths[i];
                } else if (style.align === "center") {
                  linePositionX += (textWidth - textSize.lineWidths[i]) / 2;
                } else if (style.align === "justify") {
                  var minimumLengthToApplyJustification = 0.85;
                  if (textSize.lineWidths[i] / textSize.width >= minimumLengthToApplyJustification) {
                    var extraSpace = textSize.width - textSize.lineWidths[i];
                    var spaceSize = context.measureText(" ").width;
                    var trimmedLine = lines[i].trim();
                    var array = trimmedLine.split(" ");
                    extraSpace += (lines[i].length - trimmedLine.length) * spaceSize;
                    var extraSpaceCharacters = Math.floor(extraSpace / spaceSize);
                    var idx = 0;
                    while (extraSpaceCharacters > 0) {
                      array[idx] += " ";
                      idx = (idx + 1) % (array.length - 1 || 1);
                      --extraSpaceCharacters;
                    }
                    lines[i] = array.join(" ");
                  }
                }
                if (this.autoRound) {
                  linePositionX = Math.round(linePositionX);
                  linePositionY = Math.round(linePositionY);
                }
                if (style.strokeThickness) {
                  this.style.syncShadow(context, style.shadowStroke);
                  context.strokeText(lines[i], linePositionX, linePositionY);
                }
                if (style.color) {
                  this.style.syncShadow(context, style.shadowFill);
                  context.fillText(lines[i], linePositionX, linePositionY);
                }
              }
              context.restore();
              if (this.renderer && this.renderer.gl) {
                this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
                this.frame.glTexture = this.frame.source.glTexture;
              }
              this.dirty = true;
              var input = this.input;
              if (input && !input.customHitArea) {
                input.hitArea.width = this.width;
                input.hitArea.height = this.height;
              }
              return this;
            },
            getTextMetrics: function() {
              return this.style.getTextMetrics();
            },
            text: {
              get: function() {
                return this._text;
              },
              set: function(value) {
                this.setText(value);
              }
            },
            toJSON: function() {
              var out = Components.ToJSON(this);
              var data = {
                autoRound: this.autoRound,
                text: this._text,
                style: this.style.toJSON(),
                padding: {
                  left: this.padding.left,
                  right: this.padding.right,
                  top: this.padding.top,
                  bottom: this.padding.bottom
                }
              };
              out.data = data;
              return out;
            },
            preDestroy: function() {
              if (this.style.rtl) {
                RemoveFromDOM(this.canvas);
              }
              CanvasPool.remove(this.canvas);
              this.texture.destroy();
            }
          });
          module2.exports = Text;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CanvasPool = __webpack_require__(31);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameEvents = __webpack_require__(22);
          var GameObject = __webpack_require__(15);
          var GetPowerOfTwo = __webpack_require__(355);
          var Smoothing = __webpack_require__(189);
          var TileSpriteRender = __webpack_require__(1085);
          var Vector29 = __webpack_require__(3);
          var _FLAG = 8;
          var TileSprite = new Class({
            Extends: GameObject,
            Mixins: [
              Components.Alpha,
              Components.BlendMode,
              Components.ComputedSize,
              Components.Crop,
              Components.Depth,
              Components.Flip,
              Components.GetBounds,
              Components.Mask,
              Components.Origin,
              Components.Pipeline,
              Components.ScrollFactor,
              Components.Tint,
              Components.Transform,
              Components.Visible,
              TileSpriteRender
            ],
            initialize: function TileSprite2(scene, x, y, width, height, textureKey, frameKey) {
              var renderer = scene.sys.renderer;
              GameObject.call(this, scene, "TileSprite");
              var displayTexture = scene.sys.textures.get(textureKey);
              var displayFrame = displayTexture.get(frameKey);
              if (!width || !height) {
                width = displayFrame.width;
                height = displayFrame.height;
              } else {
                width = Math.floor(width);
                height = Math.floor(height);
              }
              this._tilePosition = new Vector29();
              this._tileScale = new Vector29(1, 1);
              this.dirty = false;
              this.renderer = renderer;
              this.canvas = CanvasPool.create(this, width, height);
              this.context = this.canvas.getContext("2d");
              this.displayTexture = displayTexture;
              this.displayFrame = displayFrame;
              this._crop = this.resetCropObject();
              this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);
              this.frame = this.texture.get();
              this.potWidth = GetPowerOfTwo(displayFrame.width);
              this.potHeight = GetPowerOfTwo(displayFrame.height);
              this.fillCanvas = CanvasPool.create2D(this, this.potWidth, this.potHeight);
              this.fillContext = this.fillCanvas.getContext("2d");
              this.fillPattern = null;
              this.setPosition(x, y);
              this.setSize(width, height);
              this.setFrame(frameKey);
              this.setOriginFromFrame();
              this.initPipeline();
              scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function(renderer2) {
                var gl = renderer2.gl;
                this.dirty = true;
                this.fillPattern = null;
                this.fillPattern = renderer2.createTexture2D(0, gl.LINEAR, gl.LINEAR, gl.REPEAT, gl.REPEAT, gl.RGBA, this.fillCanvas, this.potWidth, this.potHeight);
              }, this);
            },
            setTexture: function(key, frame) {
              this.displayTexture = this.scene.sys.textures.get(key);
              return this.setFrame(frame);
            },
            setFrame: function(frame) {
              var newFrame = this.displayTexture.get(frame);
              this.potWidth = GetPowerOfTwo(newFrame.width);
              this.potHeight = GetPowerOfTwo(newFrame.height);
              this.canvas.width = 0;
              if (!newFrame.cutWidth || !newFrame.cutHeight) {
                this.renderFlags &= ~_FLAG;
              } else {
                this.renderFlags |= _FLAG;
              }
              this.displayFrame = newFrame;
              this.dirty = true;
              this.updateTileTexture();
              return this;
            },
            setTilePosition: function(x, y) {
              if (x !== void 0) {
                this.tilePositionX = x;
              }
              if (y !== void 0) {
                this.tilePositionY = y;
              }
              return this;
            },
            setTileScale: function(x, y) {
              if (x === void 0) {
                x = this.tileScaleX;
              }
              if (y === void 0) {
                y = x;
              }
              this.tileScaleX = x;
              this.tileScaleY = y;
              return this;
            },
            updateTileTexture: function() {
              if (!this.dirty || !this.renderer) {
                return;
              }
              var frame = this.displayFrame;
              if (frame.source.isRenderTexture || frame.source.isGLTexture) {
                console.warn("TileSprites can only use Image or Canvas based textures");
                this.dirty = false;
                return;
              }
              var ctx = this.fillContext;
              var canvas = this.fillCanvas;
              var fw = this.potWidth;
              var fh = this.potHeight;
              if (!this.renderer.gl) {
                fw = frame.cutWidth;
                fh = frame.cutHeight;
              }
              ctx.clearRect(0, 0, fw, fh);
              canvas.width = fw;
              canvas.height = fh;
              ctx.drawImage(frame.source.image, frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight, 0, 0, fw, fh);
              if (this.renderer.gl) {
                this.fillPattern = this.renderer.canvasToTexture(canvas, this.fillPattern);
              } else {
                this.fillPattern = ctx.createPattern(canvas, "repeat");
              }
              this.updateCanvas();
              this.dirty = false;
            },
            updateCanvas: function() {
              var canvas = this.canvas;
              if (canvas.width !== this.width || canvas.height !== this.height) {
                canvas.width = this.width;
                canvas.height = this.height;
                this.frame.setSize(this.width, this.height);
                this.updateDisplayOrigin();
                this.dirty = true;
              }
              if (!this.dirty || this.renderer && this.renderer.gl) {
                this.dirty = false;
                return;
              }
              var ctx = this.context;
              if (!this.scene.sys.game.config.antialias) {
                Smoothing.disable(ctx);
              }
              var scaleX = this._tileScale.x;
              var scaleY = this._tileScale.y;
              var positionX = this._tilePosition.x;
              var positionY = this._tilePosition.y;
              ctx.clearRect(0, 0, this.width, this.height);
              ctx.save();
              ctx.scale(scaleX, scaleY);
              ctx.translate(-positionX, -positionY);
              ctx.fillStyle = this.fillPattern;
              ctx.fillRect(positionX, positionY, this.width / scaleX, this.height / scaleY);
              ctx.restore();
              this.dirty = false;
            },
            preDestroy: function() {
              if (this.renderer && this.renderer.gl) {
                this.renderer.deleteTexture(this.fillPattern);
              }
              CanvasPool.remove(this.canvas);
              CanvasPool.remove(this.fillCanvas);
              this.fillPattern = null;
              this.fillContext = null;
              this.fillCanvas = null;
              this.displayTexture = null;
              this.displayFrame = null;
              this.texture.destroy();
              this.renderer = null;
            },
            tilePositionX: {
              get: function() {
                return this._tilePosition.x;
              },
              set: function(value) {
                this._tilePosition.x = value;
                this.dirty = true;
              }
            },
            tilePositionY: {
              get: function() {
                return this._tilePosition.y;
              },
              set: function(value) {
                this._tilePosition.y = value;
                this.dirty = true;
              }
            },
            tileScaleX: {
              get: function() {
                return this._tileScale.x;
              },
              set: function(value) {
                this._tileScale.x = value;
                this.dirty = true;
              }
            },
            tileScaleY: {
              get: function() {
                return this._tileScale.y;
              },
              set: function(value) {
                this._tileScale.y = value;
                this.dirty = true;
              }
            }
          });
          module2.exports = TileSprite;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Clamp = __webpack_require__(18);
          var Components = __webpack_require__(11);
          var Events = __webpack_require__(75);
          var GameEvents = __webpack_require__(22);
          var InputEvents = __webpack_require__(49);
          var GameObject = __webpack_require__(15);
          var SoundEvents = __webpack_require__(69);
          var UUID = __webpack_require__(219);
          var VideoRender = __webpack_require__(1088);
          var MATH_CONST = __webpack_require__(14);
          var Video = new Class({
            Extends: GameObject,
            Mixins: [
              Components.Alpha,
              Components.BlendMode,
              Components.Depth,
              Components.Flip,
              Components.GetBounds,
              Components.Mask,
              Components.Origin,
              Components.Pipeline,
              Components.ScrollFactor,
              Components.Size,
              Components.TextureCrop,
              Components.Tint,
              Components.Transform,
              Components.Visible,
              VideoRender
            ],
            initialize: function Video2(scene, x, y, key) {
              GameObject.call(this, scene, "Video");
              this.video = null;
              this.videoTexture = null;
              this.videoTextureSource = null;
              this.snapshotTexture = null;
              this.flipY = false;
              this._key = UUID();
              this.touchLocked = true;
              this.playWhenUnlocked = false;
              this.retryLimit = 20;
              this.retry = 0;
              this.retryInterval = 500;
              this._retryID = null;
              this._systemMuted = false;
              this._codeMuted = false;
              this._systemPaused = false;
              this._codePaused = false;
              this._callbacks = {
                play: this.playHandler.bind(this),
                error: this.loadErrorHandler.bind(this),
                end: this.completeHandler.bind(this),
                time: this.timeUpdateHandler.bind(this),
                seeking: this.seekingHandler.bind(this),
                seeked: this.seekedHandler.bind(this)
              };
              this._crop = this.resetCropObject();
              this.markers = {};
              this._markerIn = -1;
              this._markerOut = MATH_CONST.MAX_SAFE_INTEGER;
              this._lastUpdate = 0;
              this._cacheKey = "";
              this._isSeeking = false;
              this.removeVideoElementOnDestroy = false;
              this.setPosition(x, y);
              this.initPipeline();
              if (key) {
                this.changeSource(key, false);
              }
              var game = scene.sys.game.events;
              game.on(GameEvents.PAUSE, this.globalPause, this);
              game.on(GameEvents.RESUME, this.globalResume, this);
              var sound = scene.sys.sound;
              if (sound) {
                sound.on(SoundEvents.GLOBAL_MUTE, this.globalMute, this);
              }
            },
            addedToScene: function() {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function() {
              this.scene.sys.updateList.remove(this);
            },
            play: function(loop, markerIn, markerOut) {
              if (this.touchLocked && this.playWhenUnlocked || this.isPlaying()) {
                return this;
              }
              var video = this.video;
              if (!video) {
                console.warn("Video not loaded");
                return this;
              }
              if (loop === void 0) {
                loop = video.loop;
              }
              var sound = this.scene.sys.sound;
              if (sound && sound.mute) {
                this.setMute(true);
              }
              if (!isNaN(markerIn)) {
                this._markerIn = markerIn;
              }
              if (!isNaN(markerOut) && markerOut > markerIn) {
                this._markerOut = markerOut;
              }
              video.loop = loop;
              var callbacks = this._callbacks;
              var playPromise = video.play();
              if (playPromise !== void 0) {
                playPromise.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this));
              } else {
                video.addEventListener("playing", callbacks.play, true);
                if (video.readyState < 2) {
                  this.retry = this.retryLimit;
                  this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
                }
              }
              video.addEventListener("ended", callbacks.end, true);
              video.addEventListener("timeupdate", callbacks.time, true);
              video.addEventListener("seeking", callbacks.seeking, true);
              video.addEventListener("seeked", callbacks.seeked, true);
              return this;
            },
            changeSource: function(key, autoplay, loop, markerIn, markerOut) {
              if (autoplay === void 0) {
                autoplay = true;
              }
              var currentVideo = this.video;
              if (currentVideo) {
                this.stop();
              }
              var newVideo = this.scene.sys.cache.video.get(key);
              if (newVideo) {
                this.video = newVideo;
                this._cacheKey = key;
                this._codePaused = newVideo.paused;
                this._codeMuted = newVideo.muted;
                if (this.videoTexture) {
                  this.scene.sys.textures.remove(this._key);
                  this.videoTexture = this.scene.sys.textures.create(this._key, newVideo, newVideo.videoWidth, newVideo.videoHeight);
                  this.videoTextureSource = this.videoTexture.source[0];
                  this.videoTexture.add("__BASE", 0, 0, 0, newVideo.videoWidth, newVideo.videoHeight);
                  this.setTexture(this.videoTexture);
                  this.setSizeToFrame();
                  this.updateDisplayOrigin();
                  this.emit(Events.VIDEO_CREATED, this, newVideo.videoWidth, newVideo.videoHeight);
                } else {
                  this.updateTexture();
                }
                newVideo.currentTime = 0;
                this._lastUpdate = 0;
                if (autoplay) {
                  this.play(loop, markerIn, markerOut);
                }
              } else {
                this.video = null;
              }
              return this;
            },
            addMarker: function(key, markerIn, markerOut) {
              if (!isNaN(markerIn) && markerIn >= 0 && !isNaN(markerOut)) {
                this.markers[key] = [markerIn, markerOut];
              }
              return this;
            },
            playMarker: function(key, loop) {
              var marker = this.markers[key];
              if (marker) {
                this.play(loop, marker[0], marker[1]);
              }
              return this;
            },
            removeMarker: function(key) {
              delete this.markers[key];
              return this;
            },
            snapshot: function(width, height) {
              if (width === void 0) {
                width = this.width;
              }
              if (height === void 0) {
                height = this.height;
              }
              return this.snapshotArea(0, 0, this.width, this.height, width, height);
            },
            snapshotArea: function(x, y, srcWidth, srcHeight, destWidth, destHeight) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (srcWidth === void 0) {
                srcWidth = this.width;
              }
              if (srcHeight === void 0) {
                srcHeight = this.height;
              }
              if (destWidth === void 0) {
                destWidth = srcWidth;
              }
              if (destHeight === void 0) {
                destHeight = srcHeight;
              }
              var video = this.video;
              var snap = this.snapshotTexture;
              if (!snap) {
                snap = this.scene.sys.textures.createCanvas(UUID(), destWidth, destHeight);
                this.snapshotTexture = snap;
                if (video) {
                  snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);
                }
              } else {
                snap.setSize(destWidth, destHeight);
                if (video) {
                  snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);
                }
              }
              return snap.update();
            },
            saveSnapshotTexture: function(key) {
              if (this.snapshotTexture) {
                this.scene.sys.textures.renameTexture(this.snapshotTexture.key, key);
              } else {
                this.snapshotTexture = this.scene.sys.textures.createCanvas(key, this.width, this.height);
              }
              return this.snapshotTexture;
            },
            loadURL: function(url, loadEvent, noAudio) {
              if (loadEvent === void 0) {
                loadEvent = "loadeddata";
              }
              if (noAudio === void 0) {
                noAudio = false;
              }
              if (this.video) {
                this.stop();
              }
              if (this.videoTexture) {
                this.scene.sys.textures.remove(this._key);
              }
              var video = document.createElement("video");
              video.controls = false;
              if (noAudio) {
                video.muted = true;
                video.defaultMuted = true;
                video.setAttribute("autoplay", "autoplay");
              }
              video.setAttribute("playsinline", "playsinline");
              video.setAttribute("preload", "auto");
              video.addEventListener("error", this._callbacks.error, true);
              video.src = url;
              video.load();
              this.video = video;
              return this;
            },
            loadMediaStream: function(stream, loadEvent, noAudio) {
              if (loadEvent === void 0) {
                loadEvent = "loadeddata";
              }
              if (noAudio === void 0) {
                noAudio = false;
              }
              if (this.video) {
                this.stop();
              }
              if (this.videoTexture) {
                this.scene.sys.textures.remove(this._key);
              }
              var video = document.createElement("video");
              video.controls = false;
              if (noAudio) {
                video.muted = true;
                video.defaultMuted = true;
                video.setAttribute("autoplay", "autoplay");
              }
              video.setAttribute("playsinline", "playsinline");
              video.setAttribute("preload", "auto");
              video.addEventListener("error", this._callbacks.error, true);
              try {
                video.srcObject = stream;
              } catch (error) {
                video.src = window.URL.createObjectURL(stream);
              }
              video.load();
              this.video = video;
              return this;
            },
            playPromiseSuccessHandler: function() {
              this.touchLocked = false;
              this.emit(Events.VIDEO_PLAY, this);
              if (this._markerIn > -1) {
                this.video.currentTime = this._markerIn;
              }
            },
            playPromiseErrorHandler: function(error) {
              this.scene.sys.input.once(InputEvents.POINTER_DOWN, this.unlockHandler, this);
              this.touchLocked = true;
              this.playWhenUnlocked = true;
              this.emit(Events.VIDEO_ERROR, this, error);
            },
            playHandler: function() {
              this.touchLocked = false;
              this.emit(Events.VIDEO_PLAY, this);
              this.video.removeEventListener("playing", this._callbacks.play, true);
            },
            loadErrorHandler: function(event) {
              this.stop();
              this.emit(Events.VIDEO_ERROR, this, event);
            },
            unlockHandler: function() {
              this.touchLocked = false;
              this.playWhenUnlocked = false;
              this.emit(Events.VIDEO_UNLOCKED, this);
              if (this._markerIn > -1) {
                this.video.currentTime = this._markerIn;
              }
              this.video.play();
              this.emit(Events.VIDEO_PLAY, this);
            },
            completeHandler: function() {
              this.emit(Events.VIDEO_COMPLETE, this);
            },
            timeUpdateHandler: function() {
              if (this.video && this.video.currentTime < this._lastUpdate) {
                this.emit(Events.VIDEO_LOOP, this);
                this._lastUpdate = 0;
              }
            },
            preUpdate: function() {
              var video = this.video;
              if (video) {
                var currentTime = video.currentTime;
                if (currentTime !== this._lastUpdate) {
                  this._lastUpdate = currentTime;
                  this.updateTexture();
                  if (currentTime >= this._markerOut) {
                    if (video.loop) {
                      video.currentTime = this._markerIn;
                      this.updateTexture();
                      this._lastUpdate = currentTime;
                      this.emit(Events.VIDEO_LOOP, this);
                    } else {
                      this.emit(Events.VIDEO_COMPLETE, this);
                      this.stop();
                    }
                  }
                }
              }
            },
            checkVideoProgress: function() {
              if (this.video.readyState >= 2) {
                this.updateTexture();
              } else {
                this.retry--;
                if (this.retry > 0) {
                  this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
                } else {
                  this.emit(Events.VIDEO_TIMEOUT, this);
                }
              }
            },
            updateTexture: function() {
              var video = this.video;
              var width = video.videoWidth;
              var height = video.videoHeight;
              if (!this.videoTexture) {
                this.videoTexture = this.scene.sys.textures.create(this._key, video, width, height);
                this.videoTextureSource = this.videoTexture.source[0];
                this.videoTexture.add("__BASE", 0, 0, 0, width, height);
                this.setTexture(this.videoTexture);
                this.setSizeToFrame();
                this.updateDisplayOrigin();
                this.emit(Events.VIDEO_CREATED, this, width, height);
              } else {
                var textureSource = this.videoTextureSource;
                if (textureSource.source !== video) {
                  textureSource.source = video;
                  textureSource.width = width;
                  textureSource.height = height;
                }
                textureSource.update();
              }
            },
            getVideoKey: function() {
              return this._cacheKey;
            },
            seekTo: function(value) {
              var video = this.video;
              if (video) {
                var duration = video.duration;
                if (duration !== Infinity && !isNaN(duration)) {
                  var seekTime = duration * value;
                  this.setCurrentTime(seekTime);
                }
              }
              return this;
            },
            getCurrentTime: function() {
              return this.video ? this.video.currentTime : 0;
            },
            setCurrentTime: function(value) {
              var video = this.video;
              if (video) {
                if (typeof value === "string") {
                  var op = value[0];
                  var num = parseFloat(value.substr(1));
                  if (op === "+") {
                    value = video.currentTime + num;
                  } else if (op === "-") {
                    value = video.currentTime - num;
                  }
                }
                video.currentTime = value;
                this._lastUpdate = value;
              }
              return this;
            },
            isSeeking: function() {
              return this._isSeeking;
            },
            seekingHandler: function() {
              this._isSeeking = true;
              this.emit(Events.VIDEO_SEEKING, this);
            },
            seekedHandler: function() {
              this._isSeeking = false;
              this.emit(Events.VIDEO_SEEKED, this);
              var video = this.video;
              if (video) {
                this.updateTexture();
              }
            },
            getProgress: function() {
              var video = this.video;
              if (video) {
                var now = video.currentTime;
                var duration = video.duration;
                if (duration !== Infinity && !isNaN(duration)) {
                  return now / duration;
                }
              }
              return 0;
            },
            getDuration: function() {
              return this.video ? this.video.duration : 0;
            },
            setMute: function(value) {
              if (value === void 0) {
                value = true;
              }
              this._codeMuted = value;
              var video = this.video;
              if (video) {
                video.muted = this._systemMuted ? true : value;
              }
              return this;
            },
            isMuted: function() {
              return this._codeMuted;
            },
            globalMute: function(soundManager, value) {
              this._systemMuted = value;
              var video = this.video;
              if (video) {
                video.muted = this._codeMuted ? true : value;
              }
            },
            globalPause: function() {
              this._systemPaused = true;
              if (this.video) {
                this.video.pause();
              }
            },
            globalResume: function() {
              this._systemPaused = false;
              if (this.video && !this._codePaused) {
                this.video.play();
              }
            },
            setPaused: function(value) {
              if (value === void 0) {
                value = true;
              }
              var video = this.video;
              this._codePaused = value;
              if (video) {
                if (value) {
                  if (!video.paused) {
                    video.pause();
                  }
                } else if (!value) {
                  if (video.paused && !this._systemPaused) {
                    video.play();
                  }
                }
              }
              return this;
            },
            getVolume: function() {
              return this.video ? this.video.volume : 1;
            },
            setVolume: function(value) {
              if (value === void 0) {
                value = 1;
              }
              if (this.video) {
                this.video.volume = Clamp(value, 0, 1);
              }
              return this;
            },
            getPlaybackRate: function() {
              return this.video ? this.video.playbackRate : 1;
            },
            setPlaybackRate: function(rate) {
              if (this.video) {
                this.video.playbackRate = rate;
              }
              return this;
            },
            getLoop: function() {
              return this.video ? this.video.loop : false;
            },
            setLoop: function(value) {
              if (value === void 0) {
                value = true;
              }
              if (this.video) {
                this.video.loop = value;
              }
              return this;
            },
            isPlaying: function() {
              return this.video ? !(this.video.paused || this.video.ended) : false;
            },
            isPaused: function() {
              return this.video && this.video.paused || this._codePaused || this._systemPaused;
            },
            saveTexture: function(key, flipY) {
              if (flipY === void 0) {
                flipY = false;
              }
              if (this.videoTexture) {
                this.scene.sys.textures.renameTexture(this._key, key);
              }
              this._key = key;
              this.flipY = flipY;
              if (this.videoTextureSource) {
                this.videoTextureSource.setFlipY(flipY);
              }
              return this.videoTexture;
            },
            stop: function() {
              var video = this.video;
              if (video) {
                var callbacks = this._callbacks;
                for (var callback in callbacks) {
                  video.removeEventListener(callback, callbacks[callback], true);
                }
                video.pause();
              }
              if (this._retryID) {
                window.clearTimeout(this._retryID);
              }
              this.emit(Events.VIDEO_STOP, this);
              return this;
            },
            removeVideoElement: function() {
              var video = this.video;
              if (!video) {
                return;
              }
              if (video.parentNode) {
                video.parentNode.removeChild(video);
              }
              while (video.hasChildNodes()) {
                video.removeChild(video.firstChild);
              }
              video.removeAttribute("autoplay");
              video.removeAttribute("src");
              this.video = null;
            },
            preDestroy: function() {
              this.stop();
              if (this.removeVideoElementOnDestroy) {
                this.removeVideoElement();
              }
              var game = this.scene.sys.game.events;
              game.off(GameEvents.PAUSE, this.globalPause, this);
              game.off(GameEvents.RESUME, this.globalResume, this);
              var sound = this.scene.sys.sound;
              if (sound) {
                sound.off(SoundEvents.GLOBAL_MUTE, this.globalMute, this);
              }
              if (this._retryID) {
                window.clearTimeout(this._retryID);
              }
            }
          });
          module2.exports = Video;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Contains = __webpack_require__(225);
          var GetPoints = __webpack_require__(464);
          var GEOM_CONST = __webpack_require__(55);
          var Polygon = new Class({
            initialize: function Polygon2(points) {
              this.type = GEOM_CONST.POLYGON;
              this.area = 0;
              this.points = [];
              if (points) {
                this.setTo(points);
              }
            },
            contains: function(x, y) {
              return Contains(this, x, y);
            },
            setTo: function(points) {
              this.area = 0;
              this.points = [];
              if (typeof points === "string") {
                points = points.split(" ");
              }
              if (!Array.isArray(points)) {
                return this;
              }
              var p;
              var y0 = Number.MAX_VALUE;
              for (var i = 0; i < points.length; i++) {
                p = {x: 0, y: 0};
                if (typeof points[i] === "number" || typeof points[i] === "string") {
                  p.x = parseFloat(points[i]);
                  p.y = parseFloat(points[i + 1]);
                  i++;
                } else if (Array.isArray(points[i])) {
                  p.x = points[i][0];
                  p.y = points[i][1];
                } else {
                  p.x = points[i].x;
                  p.y = points[i].y;
                }
                this.points.push(p);
                if (p.y < y0) {
                  y0 = p.y;
                }
              }
              this.calculateArea(y0);
              return this;
            },
            calculateArea: function() {
              if (this.points.length < 3) {
                this.area = 0;
                return this.area;
              }
              var sum = 0;
              var p1;
              var p2;
              for (var i = 0; i < this.points.length - 1; i++) {
                p1 = this.points[i];
                p2 = this.points[i + 1];
                sum += (p2.x - p1.x) * (p1.y + p2.y);
              }
              p1 = this.points[0];
              p2 = this.points[this.points.length - 1];
              sum += (p1.x - p2.x) * (p2.y + p1.y);
              this.area = -sum * 0.5;
              return this.area;
            },
            getPoints: function(quantity, step, output) {
              return GetPoints(this, quantity, step, output);
            }
          });
          module2.exports = Polygon;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Contains = function(polygon, x, y) {
            var inside = false;
            for (var i = -1, j = polygon.points.length - 1; ++i < polygon.points.length; j = i) {
              var ix = polygon.points[i].x;
              var iy = polygon.points[i].y;
              var jx = polygon.points[j].x;
              var jy = polygon.points[j].y;
              if ((iy <= y && y < jy || jy <= y && y < iy) && x < (jx - ix) * (y - iy) / (jy - iy) + ix) {
                inside = !inside;
              }
            }
            return inside;
          };
          module2.exports = Contains;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var GetFastValue = __webpack_require__(2);
          var Extend = __webpack_require__(17);
          var SetValue = __webpack_require__(472);
          var ShaderRender = __webpack_require__(1170);
          var TransformMatrix = __webpack_require__(25);
          var Shader = new Class({
            Extends: GameObject,
            Mixins: [
              Components.ComputedSize,
              Components.Depth,
              Components.GetBounds,
              Components.Mask,
              Components.Origin,
              Components.ScrollFactor,
              Components.Transform,
              Components.Visible,
              ShaderRender
            ],
            initialize: function Shader2(scene, key, x, y, width, height, textures, textureData) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 128;
              }
              if (height === void 0) {
                height = 128;
              }
              GameObject.call(this, scene, "Shader");
              this.blendMode = -1;
              this.shader;
              var renderer = scene.sys.renderer;
              this.renderer = renderer;
              this.gl = renderer.gl;
              this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2));
              this.vertexBuffer = renderer.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW);
              this.program = null;
              this.bytes = new Uint8Array(this.vertexData);
              this.vertexViewF32 = new Float32Array(this.vertexData);
              this._tempMatrix1 = new TransformMatrix();
              this._tempMatrix2 = new TransformMatrix();
              this._tempMatrix3 = new TransformMatrix();
              this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
              this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
              this.uniforms = {};
              this.pointer = null;
              this._rendererWidth = renderer.width;
              this._rendererHeight = renderer.height;
              this._textureCount = 0;
              this.framebuffer = null;
              this.glTexture = null;
              this.renderToTexture = false;
              this.texture = null;
              this.setPosition(x, y);
              this.setSize(width, height);
              this.setOrigin(0.5, 0.5);
              this.setShader(key, textures, textureData);
            },
            willRender: function(camera) {
              if (this.renderToTexture) {
                return true;
              } else {
                return !(GameObject.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
              }
            },
            setRenderToTexture: function(key, flipY) {
              if (flipY === void 0) {
                flipY = false;
              }
              if (!this.renderToTexture) {
                var width = this.width;
                var height = this.height;
                var renderer = this.renderer;
                this.glTexture = renderer.createTextureFromSource(null, width, height, 0);
                this.glTexture.flipY = flipY;
                this.framebuffer = renderer.createFramebuffer(width, height, this.glTexture, false);
                this._rendererWidth = width;
                this._rendererHeight = height;
                this.renderToTexture = true;
                this.projOrtho(0, this.width, this.height, 0);
                if (key) {
                  this.texture = this.scene.sys.textures.addGLTexture(key, this.glTexture, width, height);
                }
              }
              if (this.shader) {
                renderer.pipelines.clear();
                this.load();
                this.flush();
                renderer.pipelines.rebind();
              }
              return this;
            },
            setShader: function(key, textures, textureData) {
              if (textures === void 0) {
                textures = [];
              }
              if (typeof key === "string") {
                var cache = this.scene.sys.cache.shader;
                if (!cache.has(key)) {
                  console.warn("Shader missing: " + key);
                  return this;
                }
                this.shader = cache.get(key);
              } else {
                this.shader = key;
              }
              var gl = this.gl;
              var renderer = this.renderer;
              if (this.program) {
                gl.deleteProgram(this.program);
              }
              var program = renderer.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);
              gl.uniformMatrix4fv(gl.getUniformLocation(program, "uViewMatrix"), false, this.viewMatrix);
              gl.uniformMatrix4fv(gl.getUniformLocation(program, "uProjectionMatrix"), false, this.projectionMatrix);
              gl.uniform2f(gl.getUniformLocation(program, "uResolution"), this.width, this.height);
              this.program = program;
              var d = new Date();
              var defaultUniforms = {
                resolution: {type: "2f", value: {x: this.width, y: this.height}},
                time: {type: "1f", value: 0},
                mouse: {type: "2f", value: {x: this.width / 2, y: this.height / 2}},
                date: {type: "4fv", value: [d.getFullYear(), d.getMonth(), d.getDate(), d.getHours() * 60 * 60 + d.getMinutes() * 60 + d.getSeconds()]},
                sampleRate: {type: "1f", value: 44100},
                iChannel0: {type: "sampler2D", value: null, textureData: {repeat: true}},
                iChannel1: {type: "sampler2D", value: null, textureData: {repeat: true}},
                iChannel2: {type: "sampler2D", value: null, textureData: {repeat: true}},
                iChannel3: {type: "sampler2D", value: null, textureData: {repeat: true}}
              };
              if (this.shader.uniforms) {
                this.uniforms = Extend(true, {}, this.shader.uniforms, defaultUniforms);
              } else {
                this.uniforms = defaultUniforms;
              }
              for (var i = 0; i < 4; i++) {
                if (textures[i]) {
                  this.setSampler2D("iChannel" + i, textures[i], i, textureData);
                }
              }
              this.initUniforms();
              this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0);
              return this;
            },
            setPointer: function(pointer) {
              this.pointer = pointer;
              return this;
            },
            projOrtho: function(left, right, bottom, top) {
              var near = -1e3;
              var far = 1e3;
              var leftRight = 1 / (left - right);
              var bottomTop = 1 / (bottom - top);
              var nearFar = 1 / (near - far);
              var pm = this.projectionMatrix;
              pm[0] = -2 * leftRight;
              pm[5] = -2 * bottomTop;
              pm[10] = 2 * nearFar;
              pm[12] = (left + right) * leftRight;
              pm[13] = (top + bottom) * bottomTop;
              pm[14] = (far + near) * nearFar;
              var program = this.program;
              var gl = this.gl;
              var renderer = this.renderer;
              renderer.setProgram(program);
              gl.uniformMatrix4fv(gl.getUniformLocation(program, "uProjectionMatrix"), false, this.projectionMatrix);
              this._rendererWidth = right;
              this._rendererHeight = bottom;
            },
            initUniforms: function() {
              var gl = this.gl;
              var map = this.renderer.glFuncMap;
              var program = this.program;
              this._textureCount = 0;
              for (var key in this.uniforms) {
                var uniform = this.uniforms[key];
                var type = uniform.type;
                var data = map[type];
                uniform.uniformLocation = gl.getUniformLocation(program, key);
                if (type !== "sampler2D") {
                  uniform.glMatrix = data.matrix;
                  uniform.glValueLength = data.length;
                  uniform.glFunc = data.func;
                }
              }
            },
            setSampler2DBuffer: function(uniformKey, texture, width, height, textureIndex, textureData) {
              if (textureIndex === void 0) {
                textureIndex = 0;
              }
              if (textureData === void 0) {
                textureData = {};
              }
              var uniform = this.uniforms[uniformKey];
              uniform.value = texture;
              textureData.width = width;
              textureData.height = height;
              uniform.textureData = textureData;
              this._textureCount = textureIndex;
              this.initSampler2D(uniform);
              return this;
            },
            setSampler2D: function(uniformKey, textureKey, textureIndex, textureData) {
              if (textureIndex === void 0) {
                textureIndex = 0;
              }
              var textureManager = this.scene.sys.textures;
              if (textureManager.exists(textureKey)) {
                var frame = textureManager.getFrame(textureKey);
                if (frame.glTexture && frame.glTexture.isRenderTexture) {
                  return this.setSampler2DBuffer(uniformKey, frame.glTexture, frame.width, frame.height, textureIndex, textureData);
                }
                var uniform = this.uniforms[uniformKey];
                var source = frame.source;
                uniform.textureKey = textureKey;
                uniform.source = source.image;
                uniform.value = frame.glTexture;
                if (source.isGLTexture) {
                  if (!textureData) {
                    textureData = {};
                  }
                  textureData.width = source.width;
                  textureData.height = source.height;
                }
                if (textureData) {
                  uniform.textureData = textureData;
                }
                this._textureCount = textureIndex;
                this.initSampler2D(uniform);
              }
              return this;
            },
            setUniform: function(key, value) {
              SetValue(this.uniforms, key, value);
              return this;
            },
            getUniform: function(key) {
              return GetFastValue(this.uniforms, key, null);
            },
            setChannel0: function(textureKey, textureData) {
              return this.setSampler2D("iChannel0", textureKey, 0, textureData);
            },
            setChannel1: function(textureKey, textureData) {
              return this.setSampler2D("iChannel1", textureKey, 1, textureData);
            },
            setChannel2: function(textureKey, textureData) {
              return this.setSampler2D("iChannel2", textureKey, 2, textureData);
            },
            setChannel3: function(textureKey, textureData) {
              return this.setSampler2D("iChannel3", textureKey, 3, textureData);
            },
            initSampler2D: function(uniform) {
              if (!uniform.value) {
                return;
              }
              var gl = this.gl;
              gl.activeTexture(gl.TEXTURE0 + this._textureCount);
              gl.bindTexture(gl.TEXTURE_2D, uniform.value);
              var data = uniform.textureData;
              if (data && !uniform.value.isRenderTexture) {
                var magFilter = gl[GetFastValue(data, "magFilter", "linear").toUpperCase()];
                var minFilter = gl[GetFastValue(data, "minFilter", "linear").toUpperCase()];
                var wrapS = gl[GetFastValue(data, "wrapS", "repeat").toUpperCase()];
                var wrapT = gl[GetFastValue(data, "wrapT", "repeat").toUpperCase()];
                var format = gl[GetFastValue(data, "format", "rgba").toUpperCase()];
                if (data.repeat) {
                  wrapS = gl.REPEAT;
                  wrapT = gl.REPEAT;
                }
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);
                if (data.width) {
                  var width = GetFastValue(data, "width", 512);
                  var height = GetFastValue(data, "height", 2);
                  var border = GetFastValue(data, "border", 0);
                  gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);
                } else {
                  gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.source);
                }
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
              }
              this.renderer.setProgram(this.program);
              gl.uniform1i(uniform.uniformLocation, this._textureCount);
              this._textureCount++;
            },
            syncUniforms: function() {
              var gl = this.gl;
              var uniforms = this.uniforms;
              var uniform;
              var length;
              var glFunc;
              var location;
              var value;
              var textureCount = 0;
              for (var key in uniforms) {
                uniform = uniforms[key];
                glFunc = uniform.glFunc;
                length = uniform.glValueLength;
                location = uniform.uniformLocation;
                value = uniform.value;
                if (value === null) {
                  continue;
                }
                if (length === 1) {
                  if (uniform.glMatrix) {
                    glFunc.call(gl, location, uniform.transpose, value);
                  } else {
                    glFunc.call(gl, location, value);
                  }
                } else if (length === 2) {
                  glFunc.call(gl, location, value.x, value.y);
                } else if (length === 3) {
                  glFunc.call(gl, location, value.x, value.y, value.z);
                } else if (length === 4) {
                  glFunc.call(gl, location, value.x, value.y, value.z, value.w);
                } else if (uniform.type === "sampler2D") {
                  gl.activeTexture(gl.TEXTURE0 + textureCount);
                  gl.bindTexture(gl.TEXTURE_2D, value);
                  gl.uniform1i(location, textureCount);
                  textureCount++;
                }
              }
            },
            load: function(matrix2D) {
              var gl = this.gl;
              var width = this.width;
              var height = this.height;
              var renderer = this.renderer;
              var program = this.program;
              var vm = this.viewMatrix;
              if (!this.renderToTexture) {
                var x = -this._displayOriginX;
                var y = -this._displayOriginY;
                vm[0] = matrix2D[0];
                vm[1] = matrix2D[1];
                vm[4] = matrix2D[2];
                vm[5] = matrix2D[3];
                vm[8] = matrix2D[4];
                vm[9] = matrix2D[5];
                vm[12] = vm[0] * x + vm[4] * y;
                vm[13] = vm[1] * x + vm[5] * y;
              }
              gl.useProgram(program);
              gl.uniformMatrix4fv(gl.getUniformLocation(program, "uViewMatrix"), false, vm);
              gl.uniform2f(gl.getUniformLocation(program, "uResolution"), this.width, this.height);
              var uniforms = this.uniforms;
              var res = uniforms.resolution;
              res.value.x = width;
              res.value.y = height;
              uniforms.time.value = renderer.game.loop.getDuration();
              var pointer = this.pointer;
              if (pointer) {
                var mouse = uniforms.mouse;
                var px = pointer.x / width;
                var py = 1 - pointer.y / height;
                mouse.value.x = px.toFixed(2);
                mouse.value.y = py.toFixed(2);
              }
              this.syncUniforms();
            },
            flush: function() {
              var width = this.width;
              var height = this.height;
              var program = this.program;
              var gl = this.gl;
              var vertexBuffer = this.vertexBuffer;
              var renderer = this.renderer;
              var vertexSize = Float32Array.BYTES_PER_ELEMENT * 2;
              if (this.renderToTexture) {
                renderer.setFramebuffer(this.framebuffer);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
              gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
              var location = gl.getAttribLocation(program, "inPosition");
              if (location !== -1) {
                gl.enableVertexAttribArray(location);
                gl.vertexAttribPointer(location, 2, gl.FLOAT, false, vertexSize, 0);
              }
              var vf = this.vertexViewF32;
              vf[3] = height;
              vf[4] = width;
              vf[5] = height;
              vf[8] = width;
              vf[9] = height;
              vf[10] = width;
              var vertexCount = 6;
              gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));
              gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
              if (this.renderToTexture) {
                renderer.setFramebuffer(null, false);
              }
            },
            setAlpha: function() {
            },
            setBlendMode: function() {
            },
            preDestroy: function() {
              var gl = this.gl;
              gl.deleteProgram(this.program);
              gl.deleteBuffer(this.vertexBuffer);
              if (this.renderToTexture) {
                this.renderer.deleteFramebuffer(this.framebuffer);
                this.texture.destroy();
                this.framebuffer = null;
                this.glTexture = null;
                this.texture = null;
              }
            }
          });
          module2.exports = Shader;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var DegToRad = __webpack_require__(35);
          var Face = __webpack_require__(113);
          var GameObject = __webpack_require__(15);
          var GenerateVerts = __webpack_require__(473);
          var GenerateObjVerts = __webpack_require__(474);
          var GetCalcMatrix = __webpack_require__(19);
          var Matrix4 = __webpack_require__(67);
          var MeshRender = __webpack_require__(1173);
          var StableSort = __webpack_require__(79);
          var Vector3 = __webpack_require__(38);
          var Vertex = __webpack_require__(115);
          var Mesh = new Class({
            Extends: GameObject,
            Mixins: [
              Components.AlphaSingle,
              Components.BlendMode,
              Components.Depth,
              Components.Mask,
              Components.Pipeline,
              Components.Size,
              Components.Texture,
              Components.Transform,
              Components.Visible,
              Components.ScrollFactor,
              MeshRender
            ],
            initialize: function Mesh2(scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (texture === void 0) {
                texture = "__WHITE";
              }
              GameObject.call(this, scene, "Mesh");
              this.faces = [];
              this.vertices = [];
              this.tintFill = false;
              this.debugCallback = null;
              this.debugGraphic = null;
              this.hideCCW = true;
              this.modelPosition = new Vector3();
              this.modelScale = new Vector3(1, 1, 1);
              this.modelRotation = new Vector3();
              this.dirtyCache = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              this.transformMatrix = new Matrix4();
              this.viewPosition = new Vector3();
              this.viewMatrix = new Matrix4();
              this.projectionMatrix = new Matrix4();
              this.totalRendered = 0;
              this.totalFrame = 0;
              this.ignoreDirtyCache = false;
              var renderer = scene.sys.renderer;
              this.setPosition(x, y);
              this.setTexture(texture, frame);
              this.setSize(renderer.width, renderer.height);
              this.initPipeline();
              this.setPerspective(renderer.width, renderer.height);
              if (vertices) {
                this.addVertices(vertices, uvs, indicies, containsZ, normals, colors, alphas);
              }
            },
            addedToScene: function() {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function() {
              this.scene.sys.updateList.remove(this);
            },
            panX: function(v) {
              this.viewPosition.addScale(Vector3.LEFT, v);
              this.dirtyCache[10] = 1;
              return this;
            },
            panY: function(v) {
              this.viewPosition.y += Vector3.DOWN.y * v;
              this.dirtyCache[10] = 1;
              return this;
            },
            panZ: function(amount) {
              this.viewPosition.z += amount;
              this.dirtyCache[10] = 1;
              return this;
            },
            setPerspective: function(width, height, fov, near, far) {
              if (fov === void 0) {
                fov = 45;
              }
              if (near === void 0) {
                near = 0.01;
              }
              if (far === void 0) {
                far = 1e3;
              }
              this.projectionMatrix.perspective(DegToRad(fov), width / height, near, far);
              this.dirtyCache[10] = 1;
              this.dirtyCache[11] = 0;
              return this;
            },
            setOrtho: function(scaleX, scaleY, near, far) {
              if (scaleX === void 0) {
                scaleX = this.scene.sys.renderer.getAspectRatio();
              }
              if (scaleY === void 0) {
                scaleY = 1;
              }
              if (near === void 0) {
                near = -1e3;
              }
              if (far === void 0) {
                far = 1e3;
              }
              this.projectionMatrix.ortho(-scaleX, scaleX, -scaleY, scaleY, near, far);
              this.dirtyCache[10] = 1;
              this.dirtyCache[11] = 1;
              return this;
            },
            clear: function() {
              this.faces.forEach(function(face) {
                face.destroy();
              });
              this.faces = [];
              this.vertices = [];
              return this;
            },
            addVerticesFromObj: function(key, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp) {
              var data = this.scene.sys.cache.obj.get(key);
              if (data) {
                GenerateObjVerts(data, this, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp);
              }
              return this;
            },
            sortByDepth: function(faceA, faceB) {
              return faceA.depth - faceB.depth;
            },
            depthSort: function() {
              StableSort(this.faces, this.sortByDepth);
              return this;
            },
            addVertex: function(x, y, z, u, v, color, alpha) {
              var vert = new Vertex(x, y, z, u, v, color, alpha);
              this.vertices.push(vert);
              return vert;
            },
            addFace: function(vertex1, vertex2, vertex3) {
              var face = new Face(vertex1, vertex2, vertex3);
              this.faces.push(face);
              this.dirtyCache[9] = -1;
              return face;
            },
            addVertices: function(vertices, uvs, indicies, containsZ, normals, colors, alphas) {
              var result = GenerateVerts(vertices, uvs, indicies, containsZ, normals, colors, alphas);
              if (result) {
                this.faces = this.faces.concat(result.faces);
                this.vertices = this.vertices.concat(result.vertices);
              }
              this.dirtyCache[9] = -1;
              return this;
            },
            getFaceCount: function() {
              return this.faces.length;
            },
            getVertexCount: function() {
              return this.vertices.length;
            },
            getFace: function(index) {
              return this.faces[index];
            },
            getFaceAt: function(x, y, camera) {
              if (camera === void 0) {
                camera = this.scene.sys.cameras.main;
              }
              var calcMatrix = GetCalcMatrix(this, camera).calc;
              var faces = this.faces;
              var results = [];
              for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                if (face.contains(x, y, calcMatrix)) {
                  results.push(face);
                }
              }
              return StableSort(results, this.sortByDepth);
            },
            setDebug: function(graphic, callback) {
              this.debugGraphic = graphic;
              if (!graphic && !callback) {
                this.debugCallback = null;
              } else if (!callback) {
                this.debugCallback = this.renderDebug;
              } else {
                this.debugCallback = callback;
              }
              return this;
            },
            isDirty: function() {
              var position = this.modelPosition;
              var rotation = this.modelRotation;
              var scale = this.modelScale;
              var dirtyCache = this.dirtyCache;
              var px = position.x;
              var py = position.y;
              var pz = position.z;
              var rx = rotation.x;
              var ry = rotation.y;
              var rz = rotation.z;
              var sx = scale.x;
              var sy = scale.y;
              var sz = scale.z;
              var faces = this.getFaceCount();
              var pxCached = dirtyCache[0];
              var pyCached = dirtyCache[1];
              var pzCached = dirtyCache[2];
              var rxCached = dirtyCache[3];
              var ryCached = dirtyCache[4];
              var rzCached = dirtyCache[5];
              var sxCached = dirtyCache[6];
              var syCached = dirtyCache[7];
              var szCached = dirtyCache[8];
              var fCached = dirtyCache[9];
              dirtyCache[0] = px;
              dirtyCache[1] = py;
              dirtyCache[2] = pz;
              dirtyCache[3] = rx;
              dirtyCache[4] = ry;
              dirtyCache[5] = rz;
              dirtyCache[6] = sx;
              dirtyCache[7] = sy;
              dirtyCache[8] = sz;
              dirtyCache[9] = faces;
              return pxCached !== px || pyCached !== py || pzCached !== pz || rxCached !== rx || ryCached !== ry || rzCached !== rz || sxCached !== sx || syCached !== sy || szCached !== sz || fCached !== faces;
            },
            preUpdate: function() {
              this.totalRendered = this.totalFrame;
              this.totalFrame = 0;
              var dirty = this.dirtyCache;
              if (!this.ignoreDirtyCache && !dirty[10] && !this.isDirty()) {
                return;
              }
              var width = this.width;
              var height = this.height;
              var viewMatrix = this.viewMatrix;
              var viewPosition = this.viewPosition;
              if (dirty[10]) {
                viewMatrix.identity();
                viewMatrix.translate(viewPosition);
                viewMatrix.invert();
                dirty[10] = 0;
              }
              var transformMatrix = this.transformMatrix;
              transformMatrix.setWorldMatrix(this.modelRotation, this.modelPosition, this.modelScale, this.viewMatrix, this.projectionMatrix);
              var z = viewPosition.z;
              var faces = this.faces;
              for (var i = 0; i < faces.length; i++) {
                faces[i].transformCoordinatesLocal(transformMatrix, width, height, z);
              }
              this.depthSort();
            },
            renderDebug: function(src, faces) {
              var graphic = src.debugGraphic;
              for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                var x0 = face.vertex1.tx;
                var y0 = face.vertex1.ty;
                var x1 = face.vertex2.tx;
                var y1 = face.vertex2.ty;
                var x2 = face.vertex3.tx;
                var y2 = face.vertex3.ty;
                graphic.strokeTriangle(x0, y0, x1, y1, x2, y2);
              }
            },
            preDestroy: function() {
              this.clear();
              this.debugCallback = null;
              this.debugGraphic = null;
            }
          });
          module2.exports = Mesh;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DistanceBetween = __webpack_require__(48);
          var CircleToCircle = function(circleA, circleB) {
            return DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= circleA.radius + circleB.radius;
          };
          module2.exports = CircleToCircle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Florian Vazelle
           * @author       Geoffrey Glaive
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var LineToCircle = __webpack_require__(230);
          var GetLineToCircle = function(line, circle, out) {
            if (out === void 0) {
              out = [];
            }
            if (LineToCircle(line, circle)) {
              var lx1 = line.x1;
              var ly1 = line.y1;
              var lx2 = line.x2;
              var ly2 = line.y2;
              var cx = circle.x;
              var cy = circle.y;
              var cr = circle.radius;
              var lDirX = lx2 - lx1;
              var lDirY = ly2 - ly1;
              var oDirX = lx1 - cx;
              var oDirY = ly1 - cy;
              var coefficientA = lDirX * lDirX + lDirY * lDirY;
              var coefficientB = 2 * (lDirX * oDirX + lDirY * oDirY);
              var coefficientC = oDirX * oDirX + oDirY * oDirY - cr * cr;
              var lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
              var x, y;
              if (lambda === 0) {
                var root = -coefficientB / (2 * coefficientA);
                x = lx1 + root * lDirX;
                y = ly1 + root * lDirY;
                if (root >= 0 && root <= 1) {
                  out.push(new Point(x, y));
                }
              } else if (lambda > 0) {
                var root1 = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);
                x = lx1 + root1 * lDirX;
                y = ly1 + root1 * lDirY;
                if (root1 >= 0 && root1 <= 1) {
                  out.push(new Point(x, y));
                }
                var root2 = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);
                x = lx1 + root2 * lDirX;
                y = ly1 + root2 * lDirY;
                if (root2 >= 0 && root2 <= 1) {
                  out.push(new Point(x, y));
                }
              }
            }
            return out;
          };
          module2.exports = GetLineToCircle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Contains = __webpack_require__(63);
          var Point = __webpack_require__(4);
          var tmp = new Point();
          var LineToCircle = function(line, circle, nearest) {
            if (nearest === void 0) {
              nearest = tmp;
            }
            if (Contains(circle, line.x1, line.y1)) {
              nearest.x = line.x1;
              nearest.y = line.y1;
              return true;
            }
            if (Contains(circle, line.x2, line.y2)) {
              nearest.x = line.x2;
              nearest.y = line.y2;
              return true;
            }
            var dx = line.x2 - line.x1;
            var dy = line.y2 - line.y1;
            var lcx = circle.x - line.x1;
            var lcy = circle.y - line.y1;
            var dLen2 = dx * dx + dy * dy;
            var px = dx;
            var py = dy;
            if (dLen2 > 0) {
              var dp = (lcx * dx + lcy * dy) / dLen2;
              px *= dp;
              py *= dp;
            }
            nearest.x = line.x1 + px;
            nearest.y = line.y1 + py;
            var pLen2 = px * px + py * py;
            return pLen2 <= dLen2 && px * dx + py * dy >= 0 && Contains(circle, nearest.x, nearest.y);
          };
          module2.exports = LineToCircle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Florian Vazelle
           * @author       Geoffrey Glaive
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var LineToLine = __webpack_require__(92);
          var LineToRectangle = __webpack_require__(482);
          var GetLineToRectangle = function(line, rect, out) {
            if (out === void 0) {
              out = [];
            }
            if (LineToRectangle(line, rect)) {
              var lineA = rect.getLineA();
              var lineB = rect.getLineB();
              var lineC = rect.getLineC();
              var lineD = rect.getLineD();
              var output = [new Point(), new Point(), new Point(), new Point()];
              var result = [
                LineToLine(lineA, line, output[0]),
                LineToLine(lineB, line, output[1]),
                LineToLine(lineC, line, output[2]),
                LineToLine(lineD, line, output[3])
              ];
              for (var i = 0; i < 4; i++) {
                if (result[i]) {
                  out.push(output[i]);
                }
              }
            }
            return out;
          };
          module2.exports = GetLineToRectangle;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ContainsArray = function(triangle, points, returnFirst, out) {
            if (returnFirst === void 0) {
              returnFirst = false;
            }
            if (out === void 0) {
              out = [];
            }
            var v0x = triangle.x3 - triangle.x1;
            var v0y = triangle.y3 - triangle.y1;
            var v1x = triangle.x2 - triangle.x1;
            var v1y = triangle.y2 - triangle.y1;
            var dot00 = v0x * v0x + v0y * v0y;
            var dot01 = v0x * v1x + v0y * v1y;
            var dot11 = v1x * v1x + v1y * v1y;
            var b = dot00 * dot11 - dot01 * dot01;
            var inv = b === 0 ? 0 : 1 / b;
            var u;
            var v;
            var v2x;
            var v2y;
            var dot02;
            var dot12;
            var x1 = triangle.x1;
            var y1 = triangle.y1;
            for (var i = 0; i < points.length; i++) {
              v2x = points[i].x - x1;
              v2y = points[i].y - y1;
              dot02 = v0x * v2x + v0y * v2y;
              dot12 = v1x * v2x + v1y * v2y;
              u = (dot11 * dot02 - dot01 * dot12) * inv;
              v = (dot00 * dot12 - dot01 * dot02) * inv;
              if (u >= 0 && v >= 0 && u + v < 1) {
                out.push({x: points[i].x, y: points[i].y});
                if (returnFirst) {
                  break;
                }
              }
            }
            return out;
          };
          module2.exports = ContainsArray;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateAroundXY = function(line, x, y, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var tx = line.x1 - x;
            var ty = line.y1 - y;
            line.x1 = tx * c - ty * s + x;
            line.y1 = tx * s + ty * c + y;
            tx = line.x2 - x;
            ty = line.y2 - y;
            line.x2 = tx * c - ty * s + x;
            line.y2 = tx * s + ty * c + y;
            return line;
          };
          module2.exports = RotateAroundXY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetAspectRatio = function(rect) {
            return rect.height === 0 ? NaN : rect.width / rect.height;
          };
          module2.exports = GetAspectRatio;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateAroundXY = function(triangle, x, y, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var tx = triangle.x1 - x;
            var ty = triangle.y1 - y;
            triangle.x1 = tx * c - ty * s + x;
            triangle.y1 = tx * s + ty * c + y;
            tx = triangle.x2 - x;
            ty = triangle.y2 - y;
            triangle.x2 = tx * c - ty * s + x;
            triangle.y2 = tx * s + ty * c + y;
            tx = triangle.x3 - x;
            ty = triangle.y3 - y;
            triangle.x3 = tx * c - ty * s + x;
            triangle.y3 = tx * s + ty * c + y;
            return triangle;
          };
          module2.exports = RotateAroundXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            BUTTON_DOWN: __webpack_require__(1304),
            BUTTON_UP: __webpack_require__(1305),
            CONNECTED: __webpack_require__(1306),
            DISCONNECTED: __webpack_require__(1307),
            GAMEPAD_BUTTON_DOWN: __webpack_require__(1308),
            GAMEPAD_BUTTON_UP: __webpack_require__(1309)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Extend = __webpack_require__(17);
          var XHRSettings = __webpack_require__(154);
          var MergeXHRSettings = function(global2, local) {
            var output = global2 === void 0 ? XHRSettings() : Extend({}, global2);
            if (local) {
              for (var setting in local) {
                if (local[setting] !== void 0) {
                  output[setting] = local[setting];
                }
              }
            }
            return output;
          };
          module2.exports = MergeXHRSettings;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var ParseXML = __webpack_require__(402);
          var XMLFile = new Class({
            Extends: File,
            initialize: function XMLFile2(loader, key, url, xhrSettings) {
              var extension = "xml";
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
              }
              var fileConfig = {
                type: "xml",
                cache: loader.cacheManager.xml,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              this.data = ParseXML(this.xhrLoader.responseText);
              if (this.data) {
                this.onProcessComplete();
              } else {
                console.warn("Invalid XMLFile: " + this.key);
                this.onProcessError();
              }
            }
          });
          FileTypesManager.register("xml", function(key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new XMLFile(this, key[i]));
              }
            } else {
              this.addFile(new XMLFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = XMLFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var TextFile = new Class({
            Extends: File,
            initialize: function TextFile2(loader, key, url, xhrSettings) {
              var type = "text";
              var extension = "txt";
              var cache = loader.cacheManager.text;
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
                type = GetFastValue(config2, "type", type);
                cache = GetFastValue(config2, "cache", cache);
              }
              var fileConfig = {
                type,
                cache,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("text", function(key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new TextFile(this, key[i]));
              }
            } else {
              this.addFile(new TextFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = TextFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Acceleration: __webpack_require__(1362),
            Angular: __webpack_require__(1363),
            Bounce: __webpack_require__(1364),
            Debug: __webpack_require__(1365),
            Drag: __webpack_require__(1366),
            Enable: __webpack_require__(1367),
            Friction: __webpack_require__(1368),
            Gravity: __webpack_require__(1369),
            Immovable: __webpack_require__(1370),
            Mass: __webpack_require__(1371),
            OverlapCirc: __webpack_require__(517),
            OverlapRect: __webpack_require__(241),
            Pushable: __webpack_require__(1372),
            Size: __webpack_require__(1373),
            Velocity: __webpack_require__(1374)
          };
        },
        function(module2, exports2) {
          var OverlapRect = function(world, x, y, width, height, includeDynamic, includeStatic) {
            if (includeDynamic === void 0) {
              includeDynamic = true;
            }
            if (includeStatic === void 0) {
              includeStatic = false;
            }
            var dynamicBodies = [];
            var staticBodies = [];
            var minMax = world.treeMinMax;
            minMax.minX = x;
            minMax.minY = y;
            minMax.maxX = x + width;
            minMax.maxY = y + height;
            if (includeStatic) {
              staticBodies = world.staticTree.search(minMax);
            }
            if (includeDynamic && world.useTree) {
              dynamicBodies = world.tree.search(minMax);
            } else if (includeDynamic) {
              var bodies = world.bodies;
              var fakeBody = {
                position: {
                  x,
                  y
                },
                left: x,
                top: y,
                right: x + width,
                bottom: y + height,
                isCircle: false
              };
              var intersects = world.intersects;
              bodies.iterate(function(target) {
                if (intersects(target, fakeBody)) {
                  dynamicBodies.push(target);
                }
              });
            }
            return staticBodies.concat(dynamicBodies);
          };
          module2.exports = OverlapRect;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            COLLIDE: __webpack_require__(1375),
            OVERLAP: __webpack_require__(1376),
            PAUSE: __webpack_require__(1377),
            RESUME: __webpack_require__(1378),
            TILE_COLLIDE: __webpack_require__(1379),
            TILE_OVERLAP: __webpack_require__(1380),
            WORLD_BOUNDS: __webpack_require__(1381),
            WORLD_STEP: __webpack_require__(1382)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(60);
          var GetOverlapX = function(body1, body2, overlapOnly, bias) {
            var overlap = 0;
            var maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + bias;
            if (body1._dx === 0 && body2._dx === 0) {
              body1.embedded = true;
              body2.embedded = true;
            } else if (body1._dx > body2._dx) {
              overlap = body1.right - body2.x;
              if (overlap > maxOverlap && !overlapOnly || body1.checkCollision.right === false || body2.checkCollision.left === false) {
                overlap = 0;
              } else {
                body1.touching.none = false;
                body1.touching.right = true;
                body2.touching.none = false;
                body2.touching.left = true;
                if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body1.blocked.none = false;
                  body1.blocked.right = true;
                }
                if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body2.blocked.none = false;
                  body2.blocked.left = true;
                }
              }
            } else if (body1._dx < body2._dx) {
              overlap = body1.x - body2.width - body2.x;
              if (-overlap > maxOverlap && !overlapOnly || body1.checkCollision.left === false || body2.checkCollision.right === false) {
                overlap = 0;
              } else {
                body1.touching.none = false;
                body1.touching.left = true;
                body2.touching.none = false;
                body2.touching.right = true;
                if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body1.blocked.none = false;
                  body1.blocked.left = true;
                }
                if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body2.blocked.none = false;
                  body2.blocked.right = true;
                }
              }
            }
            body1.overlapX = overlap;
            body2.overlapX = overlap;
            return overlap;
          };
          module2.exports = GetOverlapX;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(60);
          var GetOverlapY = function(body1, body2, overlapOnly, bias) {
            var overlap = 0;
            var maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + bias;
            if (body1._dy === 0 && body2._dy === 0) {
              body1.embedded = true;
              body2.embedded = true;
            } else if (body1._dy > body2._dy) {
              overlap = body1.bottom - body2.y;
              if (overlap > maxOverlap && !overlapOnly || body1.checkCollision.down === false || body2.checkCollision.up === false) {
                overlap = 0;
              } else {
                body1.touching.none = false;
                body1.touching.down = true;
                body2.touching.none = false;
                body2.touching.up = true;
                if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body1.blocked.none = false;
                  body1.blocked.down = true;
                }
                if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body2.blocked.none = false;
                  body2.blocked.up = true;
                }
              }
            } else if (body1._dy < body2._dy) {
              overlap = body1.y - body2.bottom;
              if (-overlap > maxOverlap && !overlapOnly || body1.checkCollision.up === false || body2.checkCollision.down === false) {
                overlap = 0;
              } else {
                body1.touching.none = false;
                body1.touching.up = true;
                body2.touching.none = false;
                body2.touching.down = true;
                if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body1.blocked.none = false;
                  body1.blocked.up = true;
                }
                if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body2.blocked.none = false;
                  body2.blocked.down = true;
                }
              }
            }
            body1.overlapY = overlap;
            body2.overlapY = overlap;
            return overlap;
          };
          module2.exports = GetOverlapY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TileIntersectsBody = function(tileWorldRect, body) {
            return !(body.right <= tileWorldRect.left || body.bottom <= tileWorldRect.top || body.position.x >= tileWorldRect.right || body.position.y >= tileWorldRect.bottom);
          };
          module2.exports = TileIntersectsBody;
        },
        function(module2, exports2, __webpack_require__) {
          var Constraint = {};
          module2.exports = Constraint;
          var Vertices = __webpack_require__(94);
          var Vector = __webpack_require__(116);
          var Sleeping = __webpack_require__(267);
          var Bounds = __webpack_require__(117);
          var Axes = __webpack_require__(585);
          var Common = __webpack_require__(50);
          (function() {
            Constraint._warming = 0.4;
            Constraint._torqueDampen = 1;
            Constraint._minLength = 1e-6;
            Constraint.create = function(options) {
              var constraint = options;
              if (constraint.bodyA && !constraint.pointA)
                constraint.pointA = {x: 0, y: 0};
              if (constraint.bodyB && !constraint.pointB)
                constraint.pointB = {x: 0, y: 0};
              var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA, initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB, length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));
              constraint.length = typeof constraint.length !== "undefined" ? constraint.length : length;
              constraint.id = constraint.id || Common.nextId();
              constraint.label = constraint.label || "Constraint";
              constraint.type = "constraint";
              constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);
              constraint.damping = constraint.damping || 0;
              constraint.angularStiffness = constraint.angularStiffness || 0;
              constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;
              constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;
              constraint.plugin = {};
              var render = {
                visible: true,
                type: "line",
                anchors: true,
                lineColor: null,
                lineOpacity: null,
                lineThickness: null,
                pinSize: null,
                anchorColor: null,
                anchorSize: null
              };
              if (constraint.length === 0 && constraint.stiffness > 0.1) {
                render.type = "pin";
                render.anchors = false;
              } else if (constraint.stiffness < 0.9) {
                render.type = "spring";
              }
              constraint.render = Common.extend(render, constraint.render);
              return constraint;
            };
            Constraint.preSolveAll = function(bodies) {
              for (var i = 0; i < bodies.length; i += 1) {
                var body = bodies[i], impulse = body.constraintImpulse;
                if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                  continue;
                }
                body.position.x += impulse.x;
                body.position.y += impulse.y;
                body.angle += impulse.angle;
              }
            };
            Constraint.solveAll = function(constraints, timeScale) {
              for (var i = 0; i < constraints.length; i += 1) {
                var constraint = constraints[i], fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic, fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
                if (fixedA || fixedB) {
                  Constraint.solve(constraints[i], timeScale);
                }
              }
              for (i = 0; i < constraints.length; i += 1) {
                constraint = constraints[i];
                fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic;
                fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
                if (!fixedA && !fixedB) {
                  Constraint.solve(constraints[i], timeScale);
                }
              }
            };
            Constraint.solve = function(constraint, timeScale) {
              var bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointA = constraint.pointA, pointB = constraint.pointB;
              if (!bodyA && !bodyB)
                return;
              if (bodyA && !bodyA.isStatic) {
                Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);
                constraint.angleA = bodyA.angle;
              }
              if (bodyB && !bodyB.isStatic) {
                Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);
                constraint.angleB = bodyB.angle;
              }
              var pointAWorld = pointA, pointBWorld = pointB;
              if (bodyA)
                pointAWorld = Vector.add(bodyA.position, pointA);
              if (bodyB)
                pointBWorld = Vector.add(bodyB.position, pointB);
              if (!pointAWorld || !pointBWorld)
                return;
              var delta = Vector.sub(pointAWorld, pointBWorld), currentLength = Vector.magnitude(delta);
              if (currentLength < Constraint._minLength) {
                currentLength = Constraint._minLength;
              }
              var difference = (currentLength - constraint.length) / currentLength, stiffness = constraint.stiffness < 1 ? constraint.stiffness * timeScale : constraint.stiffness, force = Vector.mult(delta, difference * stiffness), massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0), inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0), resistanceTotal = massTotal + inertiaTotal, torque, share, normal, normalVelocity, relativeVelocity;
              if (constraint.damping) {
                var zero = Vector.create();
                normal = Vector.div(delta, currentLength);
                relativeVelocity = Vector.sub(bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero, bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero);
                normalVelocity = Vector.dot(normal, relativeVelocity);
              }
              if (bodyA && !bodyA.isStatic) {
                share = bodyA.inverseMass / massTotal;
                bodyA.constraintImpulse.x -= force.x * share;
                bodyA.constraintImpulse.y -= force.y * share;
                bodyA.position.x -= force.x * share;
                bodyA.position.y -= force.y * share;
                if (constraint.damping) {
                  bodyA.positionPrev.x -= constraint.damping * normal.x * normalVelocity * share;
                  bodyA.positionPrev.y -= constraint.damping * normal.y * normalVelocity * share;
                }
                torque = Vector.cross(pointA, force) / resistanceTotal * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);
                bodyA.constraintImpulse.angle -= torque;
                bodyA.angle -= torque;
              }
              if (bodyB && !bodyB.isStatic) {
                share = bodyB.inverseMass / massTotal;
                bodyB.constraintImpulse.x += force.x * share;
                bodyB.constraintImpulse.y += force.y * share;
                bodyB.position.x += force.x * share;
                bodyB.position.y += force.y * share;
                if (constraint.damping) {
                  bodyB.positionPrev.x += constraint.damping * normal.x * normalVelocity * share;
                  bodyB.positionPrev.y += constraint.damping * normal.y * normalVelocity * share;
                }
                torque = Vector.cross(pointB, force) / resistanceTotal * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);
                bodyB.constraintImpulse.angle += torque;
                bodyB.angle += torque;
              }
            };
            Constraint.postSolveAll = function(bodies) {
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i], impulse = body.constraintImpulse;
                if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                  continue;
                }
                Sleeping.set(body, false);
                for (var j = 0; j < body.parts.length; j++) {
                  var part = body.parts[j];
                  Vertices.translate(part.vertices, impulse);
                  if (j > 0) {
                    part.position.x += impulse.x;
                    part.position.y += impulse.y;
                  }
                  if (impulse.angle !== 0) {
                    Vertices.rotate(part.vertices, impulse.angle, body.position);
                    Axes.rotate(part.axes, impulse.angle);
                    if (j > 0) {
                      Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);
                    }
                  }
                  Bounds.update(part.bounds, part.vertices, body.velocity);
                }
                impulse.angle *= Constraint._warming;
                impulse.x *= Constraint._warming;
                impulse.y *= Constraint._warming;
              }
            };
            Constraint.pointAWorld = function(constraint) {
              return {
                x: (constraint.bodyA ? constraint.bodyA.position.x : 0) + constraint.pointA.x,
                y: (constraint.bodyA ? constraint.bodyA.position.y : 0) + constraint.pointA.y
              };
            };
            Constraint.pointBWorld = function(constraint) {
              return {
                x: (constraint.bodyB ? constraint.bodyB.position.x : 0) + constraint.pointB.x,
                y: (constraint.bodyB ? constraint.bodyB.position.y : 0) + constraint.pointB.y
              };
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            CalculateFacesAt: __webpack_require__(248),
            CalculateFacesWithin: __webpack_require__(61),
            CheckIsoBounds: __webpack_require__(537),
            Copy: __webpack_require__(1414),
            CreateFromTiles: __webpack_require__(1415),
            CullBounds: __webpack_require__(539),
            CullTiles: __webpack_require__(540),
            Fill: __webpack_require__(1416),
            FilterTiles: __webpack_require__(1417),
            FindByIndex: __webpack_require__(1418),
            FindTile: __webpack_require__(1419),
            ForEachTile: __webpack_require__(1420),
            GetCullTilesFunction: __webpack_require__(1421),
            GetTileAt: __webpack_require__(156),
            GetTileAtWorldXY: __webpack_require__(1422),
            GetTilesWithin: __webpack_require__(26),
            GetTilesWithinShape: __webpack_require__(1423),
            GetTilesWithinWorldXY: __webpack_require__(523),
            GetTileToWorldXFunction: __webpack_require__(1424),
            GetTileToWorldXYFunction: __webpack_require__(1425),
            GetTileToWorldYFunction: __webpack_require__(1426),
            GetWorldToTileXFunction: __webpack_require__(1427),
            GetWorldToTileXYFunction: __webpack_require__(1428),
            GetWorldToTileYFunction: __webpack_require__(1429),
            HasTileAt: __webpack_require__(558),
            HasTileAtWorldXY: __webpack_require__(1430),
            HexagonalCullBounds: __webpack_require__(542),
            HexagonalCullTiles: __webpack_require__(541),
            HexagonalTileToWorldXY: __webpack_require__(546),
            HexagonalTileToWorldY: __webpack_require__(550),
            HexagonalWorldToTileXY: __webpack_require__(552),
            HexagonalWorldToTileY: __webpack_require__(556),
            IsInLayerBounds: __webpack_require__(118),
            IsometricCullTiles: __webpack_require__(543),
            IsometricTileToWorldXY: __webpack_require__(547),
            IsometricWorldToTileXY: __webpack_require__(553),
            PutTileAt: __webpack_require__(253),
            PutTileAtWorldXY: __webpack_require__(1431),
            PutTilesAt: __webpack_require__(1432),
            Randomize: __webpack_require__(1433),
            RemoveTileAt: __webpack_require__(559),
            RemoveTileAtWorldXY: __webpack_require__(1434),
            RenderDebug: __webpack_require__(1435),
            ReplaceByIndex: __webpack_require__(538),
            RunCull: __webpack_require__(157),
            SetCollision: __webpack_require__(1436),
            SetCollisionBetween: __webpack_require__(1437),
            SetCollisionByExclusion: __webpack_require__(1438),
            SetCollisionByProperty: __webpack_require__(1439),
            SetCollisionFromCollisionGroup: __webpack_require__(1440),
            SetLayerCollisionIndex: __webpack_require__(158),
            SetTileCollision: __webpack_require__(72),
            SetTileIndexCallback: __webpack_require__(1441),
            SetTileLocationCallback: __webpack_require__(1442),
            Shuffle: __webpack_require__(1443),
            StaggeredCullBounds: __webpack_require__(545),
            StaggeredCullTiles: __webpack_require__(544),
            StaggeredTileToWorldXY: __webpack_require__(548),
            StaggeredTileToWorldY: __webpack_require__(551),
            StaggeredWorldToTileXY: __webpack_require__(554),
            StaggeredWorldToTileY: __webpack_require__(557),
            SwapByIndex: __webpack_require__(1444),
            TileToWorldX: __webpack_require__(249),
            TileToWorldXY: __webpack_require__(549),
            TileToWorldY: __webpack_require__(250),
            WeightedRandomize: __webpack_require__(1445),
            WorldToTileX: __webpack_require__(251),
            WorldToTileXY: __webpack_require__(555),
            WorldToTileY: __webpack_require__(252)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTileAt = __webpack_require__(156);
          var CalculateFacesAt = function(tileX, tileY, layer) {
            var tile = GetTileAt(tileX, tileY, true, layer);
            var above = GetTileAt(tileX, tileY - 1, true, layer);
            var below = GetTileAt(tileX, tileY + 1, true, layer);
            var left = GetTileAt(tileX - 1, tileY, true, layer);
            var right = GetTileAt(tileX + 1, tileY, true, layer);
            var tileCollides = tile && tile.collides;
            if (tileCollides) {
              tile.faceTop = true;
              tile.faceBottom = true;
              tile.faceLeft = true;
              tile.faceRight = true;
            }
            if (above && above.collides) {
              if (tileCollides) {
                tile.faceTop = false;
              }
              above.faceBottom = !tileCollides;
            }
            if (below && below.collides) {
              if (tileCollides) {
                tile.faceBottom = false;
              }
              below.faceTop = !tileCollides;
            }
            if (left && left.collides) {
              if (tileCollides) {
                tile.faceLeft = false;
              }
              left.faceRight = !tileCollides;
            }
            if (right && right.collides) {
              if (tileCollides) {
                tile.faceRight = false;
              }
              right.faceLeft = !tileCollides;
            }
            if (tile && !tile.collides) {
              tile.resetFaces();
            }
            return tile;
          };
          module2.exports = CalculateFacesAt;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TileToWorldX = function(tileX, camera, layer) {
            var tileWidth = layer.baseTileWidth;
            var tilemapLayer = layer.tilemapLayer;
            var layerWorldX = 0;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
              tileWidth *= tilemapLayer.scaleX;
            }
            return layerWorldX + tileX * tileWidth;
          };
          module2.exports = TileToWorldX;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TileToWorldY = function(tileY, camera, layer) {
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            var layerWorldY = 0;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
              tileHeight *= tilemapLayer.scaleY;
            }
            return layerWorldY + tileY * tileHeight;
          };
          module2.exports = TileToWorldY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var WorldToTileX = function(worldX, snapToFloor, camera, layer) {
            if (snapToFloor === void 0) {
              snapToFloor = true;
            }
            var tileWidth = layer.baseTileWidth;
            var tilemapLayer = layer.tilemapLayer;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
              tileWidth *= tilemapLayer.scaleX;
            }
            return snapToFloor ? Math.floor(worldX / tileWidth) : worldX / tileWidth;
          };
          module2.exports = WorldToTileX;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var WorldToTileY = function(worldY, snapToFloor, camera, layer) {
            if (snapToFloor === void 0) {
              snapToFloor = true;
            }
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
              tileHeight *= tilemapLayer.scaleY;
            }
            return snapToFloor ? Math.floor(worldY / tileHeight) : worldY / tileHeight;
          };
          module2.exports = WorldToTileY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Tile = __webpack_require__(83);
          var IsInLayerBounds = __webpack_require__(118);
          var CalculateFacesAt = __webpack_require__(248);
          var SetTileCollision = __webpack_require__(72);
          var PutTileAt = function(tile, tileX, tileY, recalculateFaces, layer) {
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (!IsInLayerBounds(tileX, tileY, layer)) {
              return null;
            }
            var oldTile = layer.data[tileY][tileX];
            var oldTileCollides = oldTile && oldTile.collides;
            if (tile instanceof Tile) {
              if (layer.data[tileY][tileX] === null) {
                layer.data[tileY][tileX] = new Tile(layer, tile.index, tileX, tileY, layer.tileWidth, layer.tileHeight);
              }
              layer.data[tileY][tileX].copy(tile);
            } else {
              var index = tile;
              if (layer.data[tileY][tileX] === null) {
                layer.data[tileY][tileX] = new Tile(layer, index, tileX, tileY, layer.tileWidth, layer.tileHeight);
              } else {
                layer.data[tileY][tileX].index = index;
              }
            }
            var newTile = layer.data[tileY][tileX];
            var collides = layer.collideIndexes.indexOf(newTile.index) !== -1;
            SetTileCollision(newTile, collides);
            if (recalculateFaces && oldTileCollides !== newTile.collides) {
              CalculateFacesAt(tileX, tileY, layer);
            }
            return newTile;
          };
          module2.exports = PutTileAt;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(29);
          var FromOrientationString = function(orientation) {
            orientation = orientation.toLowerCase();
            if (orientation === "isometric") {
              return CONST.ISOMETRIC;
            } else if (orientation === "staggered") {
              return CONST.STAGGERED;
            } else if (orientation === "hexagonal") {
              return CONST.HEXAGONAL;
            } else {
              return CONST.ORTHOGONAL;
            }
          };
          module2.exports = FromOrientationString;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Formats = __webpack_require__(39);
          var LayerData = __webpack_require__(119);
          var MapData = __webpack_require__(120);
          var Tile = __webpack_require__(83);
          var Parse2DArray = function(name, data, tileWidth, tileHeight, insertNull) {
            var layerData = new LayerData({
              tileWidth,
              tileHeight
            });
            var mapData = new MapData({
              name,
              tileWidth,
              tileHeight,
              format: Formats.ARRAY_2D,
              layers: [layerData]
            });
            var tiles = [];
            var height = data.length;
            var width = 0;
            for (var y = 0; y < data.length; y++) {
              tiles[y] = [];
              var row = data[y];
              for (var x = 0; x < row.length; x++) {
                var tileIndex = parseInt(row[x], 10);
                if (isNaN(tileIndex) || tileIndex === -1) {
                  tiles[y][x] = insertNull ? null : new Tile(layerData, -1, x, y, tileWidth, tileHeight);
                } else {
                  tiles[y][x] = new Tile(layerData, tileIndex, x, y, tileWidth, tileHeight);
                }
              }
              if (width === 0) {
                width = row.length;
              }
            }
            mapData.width = layerData.width = width;
            mapData.height = layerData.height = height;
            mapData.widthInPixels = layerData.widthInPixels = width * tileWidth;
            mapData.heightInPixels = layerData.heightInPixels = height * tileHeight;
            layerData.data = tiles;
            return mapData;
          };
          module2.exports = Parse2DArray;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Pick = __webpack_require__(567);
          var ParseGID = __webpack_require__(257);
          var copyPoints = function(p) {
            return {x: p.x, y: p.y};
          };
          var commonObjectProps = ["id", "name", "type", "rotation", "properties", "visible", "x", "y", "width", "height"];
          var ParseObject = function(tiledObject, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            var parsedObject = Pick(tiledObject, commonObjectProps);
            parsedObject.x += offsetX;
            parsedObject.y += offsetY;
            if (tiledObject.gid) {
              var gidInfo = ParseGID(tiledObject.gid);
              parsedObject.gid = gidInfo.gid;
              parsedObject.flippedHorizontal = gidInfo.flippedHorizontal;
              parsedObject.flippedVertical = gidInfo.flippedVertical;
              parsedObject.flippedAntiDiagonal = gidInfo.flippedAntiDiagonal;
            } else if (tiledObject.polyline) {
              parsedObject.polyline = tiledObject.polyline.map(copyPoints);
            } else if (tiledObject.polygon) {
              parsedObject.polygon = tiledObject.polygon.map(copyPoints);
            } else if (tiledObject.ellipse) {
              parsedObject.ellipse = tiledObject.ellipse;
            } else if (tiledObject.text) {
              parsedObject.text = tiledObject.text;
            } else if (tiledObject.point) {
              parsedObject.point = true;
            } else {
              parsedObject.rectangle = true;
            }
            return parsedObject;
          };
          module2.exports = ParseObject;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FLIPPED_HORIZONTAL = 2147483648;
          var FLIPPED_VERTICAL = 1073741824;
          var FLIPPED_ANTI_DIAGONAL = 536870912;
          var ParseGID = function(gid) {
            var flippedHorizontal = Boolean(gid & FLIPPED_HORIZONTAL);
            var flippedVertical = Boolean(gid & FLIPPED_VERTICAL);
            var flippedAntiDiagonal = Boolean(gid & FLIPPED_ANTI_DIAGONAL);
            gid = gid & ~(FLIPPED_HORIZONTAL | FLIPPED_VERTICAL | FLIPPED_ANTI_DIAGONAL);
            var rotation = 0;
            var flipped = false;
            if (flippedHorizontal && flippedVertical && flippedAntiDiagonal) {
              rotation = Math.PI / 2;
              flipped = true;
            } else if (flippedHorizontal && flippedVertical && !flippedAntiDiagonal) {
              rotation = Math.PI;
              flipped = false;
            } else if (flippedHorizontal && !flippedVertical && flippedAntiDiagonal) {
              rotation = Math.PI / 2;
              flipped = false;
            } else if (flippedHorizontal && !flippedVertical && !flippedAntiDiagonal) {
              rotation = 0;
              flipped = true;
            } else if (!flippedHorizontal && flippedVertical && flippedAntiDiagonal) {
              rotation = 3 * Math.PI / 2;
              flipped = false;
            } else if (!flippedHorizontal && flippedVertical && !flippedAntiDiagonal) {
              rotation = Math.PI;
              flipped = true;
            } else if (!flippedHorizontal && !flippedVertical && flippedAntiDiagonal) {
              rotation = 3 * Math.PI / 2;
              flipped = true;
            } else if (!flippedHorizontal && !flippedVertical && !flippedAntiDiagonal) {
              rotation = 0;
              flipped = false;
            }
            return {
              gid,
              flippedHorizontal,
              flippedVertical,
              flippedAntiDiagonal,
              rotation,
              flipped
            };
          };
          module2.exports = ParseGID;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Formats = __webpack_require__(39);
          var MapData = __webpack_require__(120);
          var Parse = __webpack_require__(560);
          var Tilemap = __webpack_require__(576);
          var ParseToTilemap = function(scene, key, tileWidth, tileHeight, width, height, data, insertNull) {
            if (tileWidth === void 0) {
              tileWidth = 32;
            }
            if (tileHeight === void 0) {
              tileHeight = 32;
            }
            if (width === void 0) {
              width = 10;
            }
            if (height === void 0) {
              height = 10;
            }
            if (insertNull === void 0) {
              insertNull = false;
            }
            var mapData = null;
            if (Array.isArray(data)) {
              var name = key !== void 0 ? key : "map";
              mapData = Parse(name, Formats.ARRAY_2D, data, tileWidth, tileHeight, insertNull);
            } else if (key !== void 0) {
              var tilemapData = scene.cache.tilemap.get(key);
              if (!tilemapData) {
                console.warn("No map data found for key " + key);
              } else {
                mapData = Parse(key, tilemapData.format, tilemapData.data, tileWidth, tileHeight, insertNull);
              }
            }
            if (mapData === null) {
              mapData = new MapData({
                tileWidth,
                tileHeight,
                width,
                height
              });
            }
            return new Tilemap(scene, mapData);
          };
          module2.exports = ParseToTilemap;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetValue = __webpack_require__(6);
          var GetTargets = function(config2) {
            var targets = GetValue(config2, "targets", null);
            if (targets === null) {
              return targets;
            }
            if (typeof targets === "function") {
              targets = targets.call();
            }
            if (!Array.isArray(targets)) {
              targets = [targets];
            }
            return targets;
          };
          module2.exports = GetTargets;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          function hasGetActive(def) {
            return !!def.getActive && typeof def.getActive === "function";
          }
          function hasGetStart(def) {
            return !!def.getStart && typeof def.getStart === "function";
          }
          function hasGetEnd(def) {
            return !!def.getEnd && typeof def.getEnd === "function";
          }
          function hasGetters(def) {
            return hasGetStart(def) || hasGetEnd(def) || hasGetActive(def);
          }
          var GetValueOp = function(key, propertyValue) {
            var callbacks;
            var getEnd = function(target, key2, value) {
              return value;
            };
            var getStart = function(target, key2, value) {
              return value;
            };
            var getActive = null;
            var t = typeof propertyValue;
            if (t === "number") {
              getEnd = function() {
                return propertyValue;
              };
            } else if (t === "string") {
              var op = propertyValue[0];
              var num = parseFloat(propertyValue.substr(2));
              switch (op) {
                case "+":
                  getEnd = function(target, key2, value) {
                    return value + num;
                  };
                  break;
                case "-":
                  getEnd = function(target, key2, value) {
                    return value - num;
                  };
                  break;
                case "*":
                  getEnd = function(target, key2, value) {
                    return value * num;
                  };
                  break;
                case "/":
                  getEnd = function(target, key2, value) {
                    return value / num;
                  };
                  break;
                default:
                  getEnd = function() {
                    return parseFloat(propertyValue);
                  };
              }
            } else if (t === "function") {
              getEnd = propertyValue;
            } else if (t === "object") {
              if (hasGetters(propertyValue)) {
                if (hasGetActive(propertyValue)) {
                  getActive = propertyValue.getActive;
                }
                if (hasGetEnd(propertyValue)) {
                  getEnd = propertyValue.getEnd;
                }
                if (hasGetStart(propertyValue)) {
                  getStart = propertyValue.getStart;
                }
              } else if (propertyValue.hasOwnProperty("value")) {
                callbacks = GetValueOp(key, propertyValue.value);
              } else {
                var hasTo = propertyValue.hasOwnProperty("to");
                var hasFrom = propertyValue.hasOwnProperty("from");
                var hasStart = propertyValue.hasOwnProperty("start");
                if (hasTo && (hasFrom || hasStart)) {
                  callbacks = GetValueOp(key, propertyValue.to);
                  if (hasStart) {
                    var startCallbacks = GetValueOp(key, propertyValue.start);
                    callbacks.getActive = startCallbacks.getEnd;
                  }
                  if (hasFrom) {
                    var fromCallbacks = GetValueOp(key, propertyValue.from);
                    callbacks.getStart = fromCallbacks.getEnd;
                  }
                }
              }
            }
            if (!callbacks) {
              callbacks = {
                getActive,
                getEnd,
                getStart
              };
            }
            return callbacks;
          };
          module2.exports = GetValueOp;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TWEEN_DEFAULTS = {
            targets: null,
            delay: 0,
            duration: 1e3,
            ease: "Power0",
            easeParams: null,
            hold: 0,
            repeat: 0,
            repeatDelay: 0,
            yoyo: false,
            flipX: false,
            flipY: false
          };
          module2.exports = TWEEN_DEFAULTS;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(263);
          var GameObjectCreator = __webpack_require__(16);
          var GameObjectFactory = __webpack_require__(5);
          var TWEEN_CONST = __webpack_require__(97);
          var MATH_CONST = __webpack_require__(14);
          var Tween = new Class({
            Extends: EventEmitter,
            initialize: function Tween2(parent, data, targets) {
              EventEmitter.call(this);
              this.parent = parent;
              this.parentIsTimeline = parent.hasOwnProperty("isTimeline");
              this.data = data;
              this.totalData = data.length;
              this.targets = targets;
              this.totalTargets = targets.length;
              this.useFrames = false;
              this.timeScale = 1;
              this.loop = 0;
              this.loopDelay = 0;
              this.loopCounter = 0;
              this.startDelay = 0;
              this.hasStarted = false;
              this.isSeeking = false;
              this.completeDelay = 0;
              this.countdown = 0;
              this.offset = 0;
              this.calculatedOffset = 0;
              this.state = TWEEN_CONST.PENDING_ADD;
              this._pausedState = TWEEN_CONST.INIT;
              this.paused = false;
              this.elapsed = 0;
              this.totalElapsed = 0;
              this.duration = 0;
              this.progress = 0;
              this.totalDuration = 0;
              this.totalProgress = 0;
              this.callbacks = {
                onActive: null,
                onComplete: null,
                onLoop: null,
                onRepeat: null,
                onStart: null,
                onStop: null,
                onUpdate: null,
                onYoyo: null
              };
              this.callbackScope;
            },
            getValue: function(index) {
              if (index === void 0) {
                index = 0;
              }
              return this.data[index].current;
            },
            setTimeScale: function(value) {
              this.timeScale = value;
              return this;
            },
            getTimeScale: function() {
              return this.timeScale;
            },
            isPlaying: function() {
              return this.state === TWEEN_CONST.ACTIVE;
            },
            isPaused: function() {
              return this.state === TWEEN_CONST.PAUSED;
            },
            hasTarget: function(target) {
              return this.targets.indexOf(target) !== -1;
            },
            updateTo: function(key, value, startToCurrent) {
              if (startToCurrent === void 0) {
                startToCurrent = false;
              }
              for (var i = 0; i < this.totalData; i++) {
                var tweenData = this.data[i];
                if (tweenData.key === key) {
                  tweenData.end = value;
                  if (startToCurrent) {
                    tweenData.start = tweenData.current;
                  }
                }
              }
              return this;
            },
            restart: function() {
              this.elapsed = 0;
              this.progress = 0;
              this.totalElapsed = 0;
              this.totalProgress = 0;
              if (this.state === TWEEN_CONST.ACTIVE) {
                return this.seek(0);
              } else if (this.state === TWEEN_CONST.REMOVED) {
                this.seek(0);
                this.parent.makeActive(this);
                return this;
              } else if (this.state === TWEEN_CONST.PENDING_ADD) {
                return this;
              } else {
                return this.play();
              }
            },
            calcDuration: function() {
              var maxDuration = 0;
              var minDelay = MATH_CONST.MAX_SAFE_INTEGER;
              var data = this.data;
              for (var i = 0; i < this.totalData; i++) {
                var tweenData = data[i];
                tweenData.t1 = tweenData.duration + tweenData.hold;
                if (tweenData.yoyo) {
                  tweenData.t1 += tweenData.duration;
                }
                tweenData.t2 = tweenData.t1 + tweenData.repeatDelay;
                tweenData.totalDuration = tweenData.delay + tweenData.t1;
                if (tweenData.repeat === -1) {
                  tweenData.totalDuration += tweenData.t2 * 999999999999;
                } else if (tweenData.repeat > 0) {
                  tweenData.totalDuration += tweenData.t2 * tweenData.repeat;
                }
                if (tweenData.totalDuration > maxDuration) {
                  maxDuration = tweenData.totalDuration;
                }
                if (tweenData.delay < minDelay) {
                  minDelay = tweenData.delay;
                }
              }
              this.duration = Math.max(maxDuration, 1e-3);
              this.loopCounter = this.loop === -1 ? 999999999999 : this.loop;
              if (this.loopCounter > 0) {
                this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter;
              } else {
                this.totalDuration = this.duration + this.completeDelay;
              }
              this.startDelay = minDelay;
            },
            init: function() {
              if (this.paused && !this.parentIsTimeline) {
                this.state = TWEEN_CONST.PENDING_ADD;
                this._pausedState = TWEEN_CONST.INIT;
                return false;
              }
              var data = this.data;
              var totalTargets = this.totalTargets;
              for (var i = 0; i < this.totalData; i++) {
                var tweenData = data[i];
                var target = tweenData.target;
                var gen = tweenData.gen;
                var key = tweenData.key;
                var targetIndex = tweenData.index;
                tweenData.delay = gen.delay(target, key, 0, targetIndex, totalTargets, this);
                tweenData.duration = Math.max(gen.duration(target, key, 0, targetIndex, totalTargets, this), 1e-3);
                tweenData.hold = gen.hold(target, key, 0, targetIndex, totalTargets, this);
                tweenData.repeat = gen.repeat(target, key, 0, targetIndex, totalTargets, this);
                tweenData.repeatDelay = gen.repeatDelay(target, key, 0, targetIndex, totalTargets, this);
              }
              this.calcDuration();
              this.progress = 0;
              this.totalProgress = 0;
              this.elapsed = 0;
              this.totalElapsed = 0;
              this.state = TWEEN_CONST.INIT;
              return true;
            },
            makeActive: function() {
              this.parent.makeActive(this);
              this.dispatchTweenEvent(Events.TWEEN_ACTIVE, this.callbacks.onActive);
            },
            nextState: function() {
              if (this.loopCounter > 0) {
                this.elapsed = 0;
                this.progress = 0;
                this.loopCounter--;
                this.resetTweenData(true);
                if (this.loopDelay > 0) {
                  this.countdown = this.loopDelay;
                  this.state = TWEEN_CONST.LOOP_DELAY;
                } else {
                  this.state = TWEEN_CONST.ACTIVE;
                  this.dispatchTweenEvent(Events.TWEEN_LOOP, this.callbacks.onLoop);
                }
              } else if (this.completeDelay > 0) {
                this.state = TWEEN_CONST.COMPLETE_DELAY;
                this.countdown = this.completeDelay;
              } else {
                this.state = TWEEN_CONST.PENDING_REMOVE;
                this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete);
              }
            },
            pause: function() {
              if (this.state === TWEEN_CONST.PAUSED) {
                return this;
              }
              this.paused = true;
              this._pausedState = this.state;
              this.state = TWEEN_CONST.PAUSED;
              return this;
            },
            play: function(resetFromTimeline) {
              if (resetFromTimeline === void 0) {
                resetFromTimeline = false;
              }
              var state = this.state;
              if (state === TWEEN_CONST.INIT && !this.parentIsTimeline) {
                this.resetTweenData(false);
                this.state = TWEEN_CONST.ACTIVE;
                return this;
              } else if (state === TWEEN_CONST.ACTIVE || state === TWEEN_CONST.PENDING_ADD && this._pausedState === TWEEN_CONST.PENDING_ADD) {
                return this;
              } else if (!this.parentIsTimeline && (state === TWEEN_CONST.PENDING_REMOVE || state === TWEEN_CONST.REMOVED)) {
                this.seek(0);
                this.parent.makeActive(this);
                return this;
              }
              if (this.parentIsTimeline) {
                this.resetTweenData(resetFromTimeline);
                if (this.calculatedOffset === 0) {
                  this.state = TWEEN_CONST.ACTIVE;
                } else {
                  this.countdown = this.calculatedOffset;
                  this.state = TWEEN_CONST.OFFSET_DELAY;
                }
              } else if (this.paused) {
                this.paused = false;
                this.makeActive();
              } else {
                this.resetTweenData(resetFromTimeline);
                this.state = TWEEN_CONST.ACTIVE;
                this.makeActive();
              }
              return this;
            },
            resetTweenData: function(resetFromLoop) {
              var data = this.data;
              var total = this.totalData;
              var totalTargets = this.totalTargets;
              for (var i = 0; i < total; i++) {
                var tweenData = data[i];
                var target = tweenData.target;
                var key = tweenData.key;
                var targetIndex = tweenData.index;
                tweenData.progress = 0;
                tweenData.elapsed = 0;
                tweenData.repeatCounter = tweenData.repeat === -1 ? 999999999999 : tweenData.repeat;
                if (resetFromLoop) {
                  tweenData.start = tweenData.getStartValue(target, key, tweenData.start, targetIndex, totalTargets, this);
                  tweenData.end = tweenData.getEndValue(target, key, tweenData.end, targetIndex, totalTargets, this);
                  tweenData.current = tweenData.start;
                  tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
                } else {
                  tweenData.state = TWEEN_CONST.PENDING_RENDER;
                }
                if (tweenData.delay > 0) {
                  tweenData.elapsed = tweenData.delay;
                  tweenData.state = TWEEN_CONST.DELAY;
                }
                if (tweenData.getActiveValue) {
                  target[key] = tweenData.getActiveValue(tweenData.target, tweenData.key, tweenData.start);
                }
              }
            },
            resume: function() {
              if (this.state === TWEEN_CONST.PAUSED) {
                this.paused = false;
                this.state = this._pausedState;
              } else {
                this.play();
              }
              return this;
            },
            seek: function(toPosition, delta) {
              if (delta === void 0) {
                delta = 16.6;
              }
              if (this.state === TWEEN_CONST.REMOVED) {
                this.makeActive();
              }
              this.elapsed = 0;
              this.progress = 0;
              this.totalElapsed = 0;
              this.totalProgress = 0;
              var data = this.data;
              var totalTargets = this.totalTargets;
              for (var i = 0; i < this.totalData; i++) {
                var tweenData = data[i];
                var target = tweenData.target;
                var gen = tweenData.gen;
                var key = tweenData.key;
                var targetIndex = tweenData.index;
                tweenData.progress = 0;
                tweenData.elapsed = 0;
                tweenData.repeatCounter = tweenData.repeat === -1 ? 999999999999 : tweenData.repeat;
                tweenData.delay = gen.delay(target, key, 0, targetIndex, totalTargets, this);
                tweenData.duration = Math.max(gen.duration(target, key, 0, targetIndex, totalTargets, this), 1e-3);
                tweenData.hold = gen.hold(target, key, 0, targetIndex, totalTargets, this);
                tweenData.repeat = gen.repeat(target, key, 0, targetIndex, totalTargets, this);
                tweenData.repeatDelay = gen.repeatDelay(target, key, 0, targetIndex, totalTargets, this);
                tweenData.current = tweenData.start;
                tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
                this.updateTweenData(this, tweenData, 0, targetIndex, totalTargets);
                if (tweenData.delay > 0) {
                  tweenData.elapsed = tweenData.delay;
                  tweenData.state = TWEEN_CONST.DELAY;
                }
              }
              this.calcDuration();
              var wasPaused = false;
              if (this.state === TWEEN_CONST.PAUSED) {
                wasPaused = true;
                this.state = TWEEN_CONST.ACTIVE;
              }
              this.isSeeking = true;
              do {
                this.update(0, delta);
              } while (this.totalProgress < toPosition);
              this.isSeeking = false;
              if (wasPaused) {
                this.state = TWEEN_CONST.PAUSED;
              }
              return this;
            },
            setCallback: function(type, callback, params, scope) {
              this.callbacks[type] = {func: callback, scope, params};
              return this;
            },
            complete: function(delay) {
              if (delay === void 0) {
                delay = 0;
              }
              if (delay) {
                this.state = TWEEN_CONST.COMPLETE_DELAY;
                this.countdown = delay;
              } else {
                this.state = TWEEN_CONST.PENDING_REMOVE;
                this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete);
              }
              return this;
            },
            remove: function() {
              this.parent.remove(this);
              return this;
            },
            stop: function(resetTo) {
              if (this.state === TWEEN_CONST.ACTIVE) {
                if (resetTo !== void 0) {
                  this.seek(resetTo);
                }
              }
              if (this.state !== TWEEN_CONST.REMOVED) {
                if (this.state === TWEEN_CONST.PAUSED || this.state === TWEEN_CONST.PENDING_ADD) {
                  if (this.parentIsTimeline) {
                    this.parent.manager._destroy.push(this);
                    this.parent.manager._toProcess++;
                  } else {
                    this.parent._destroy.push(this);
                    this.parent._toProcess++;
                  }
                }
                this.dispatchTweenEvent(Events.TWEEN_STOP, this.callbacks.onStop);
                this.removeAllListeners();
                this.state = TWEEN_CONST.PENDING_REMOVE;
              }
              return this;
            },
            update: function(timestamp, delta) {
              if (this.state === TWEEN_CONST.PAUSED) {
                return false;
              }
              if (this.useFrames) {
                delta = 1 * this.parent.timeScale;
              }
              delta *= this.timeScale;
              this.elapsed += delta;
              this.progress = Math.min(this.elapsed / this.duration, 1);
              this.totalElapsed += delta;
              this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);
              switch (this.state) {
                case TWEEN_CONST.ACTIVE:
                  if (!this.hasStarted && !this.isSeeking) {
                    this.startDelay -= delta;
                    if (this.startDelay <= 0) {
                      this.hasStarted = true;
                      this.dispatchTweenEvent(Events.TWEEN_START, this.callbacks.onStart);
                    }
                  }
                  var stillRunning = false;
                  for (var i = 0; i < this.totalData; i++) {
                    var tweenData = this.data[i];
                    if (this.updateTweenData(this, tweenData, delta)) {
                      stillRunning = true;
                    }
                  }
                  if (!stillRunning) {
                    this.nextState();
                  }
                  break;
                case TWEEN_CONST.LOOP_DELAY:
                  this.countdown -= delta;
                  if (this.countdown <= 0) {
                    this.state = TWEEN_CONST.ACTIVE;
                    this.dispatchTweenEvent(Events.TWEEN_LOOP, this.callbacks.onLoop);
                  }
                  break;
                case TWEEN_CONST.OFFSET_DELAY:
                  this.countdown -= delta;
                  if (this.countdown <= 0) {
                    this.state = TWEEN_CONST.ACTIVE;
                  }
                  break;
                case TWEEN_CONST.COMPLETE_DELAY:
                  this.countdown -= delta;
                  if (this.countdown <= 0) {
                    this.state = TWEEN_CONST.PENDING_REMOVE;
                    this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete);
                  }
                  break;
              }
              return this.state === TWEEN_CONST.PENDING_REMOVE;
            },
            dispatchTweenDataEvent: function(event, callback, tweenData) {
              if (!this.isSeeking) {
                this.emit(event, this, tweenData.key, tweenData.target, tweenData.current, tweenData.previous);
                if (callback) {
                  callback.params[1] = tweenData.target;
                  callback.func.apply(callback.scope, callback.params);
                }
              }
            },
            dispatchTweenEvent: function(event, callback) {
              if (!this.isSeeking) {
                this.emit(event, this, this.targets);
                if (callback) {
                  callback.params[1] = this.targets;
                  callback.func.apply(callback.scope, callback.params);
                }
              }
            },
            setStateFromEnd: function(tween, tweenData, diff) {
              if (tweenData.yoyo) {
                tweenData.elapsed = diff;
                tweenData.progress = diff / tweenData.duration;
                if (tweenData.flipX) {
                  tweenData.target.toggleFlipX();
                }
                if (tweenData.flipY) {
                  tweenData.target.toggleFlipY();
                }
                this.dispatchTweenDataEvent(Events.TWEEN_YOYO, tween.callbacks.onYoyo, tweenData);
                tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
                return TWEEN_CONST.PLAYING_BACKWARD;
              } else if (tweenData.repeatCounter > 0) {
                tweenData.repeatCounter--;
                tweenData.elapsed = diff;
                tweenData.progress = diff / tweenData.duration;
                if (tweenData.flipX) {
                  tweenData.target.toggleFlipX();
                }
                if (tweenData.flipY) {
                  tweenData.target.toggleFlipY();
                }
                tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
                tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
                if (tweenData.repeatDelay > 0) {
                  tweenData.elapsed = tweenData.repeatDelay - diff;
                  tweenData.current = tweenData.start;
                  tweenData.target[tweenData.key] = tweenData.current;
                  return TWEEN_CONST.REPEAT_DELAY;
                } else {
                  this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData);
                  return TWEEN_CONST.PLAYING_FORWARD;
                }
              }
              return TWEEN_CONST.COMPLETE;
            },
            setStateFromStart: function(tween, tweenData, diff) {
              if (tweenData.repeatCounter > 0) {
                tweenData.repeatCounter--;
                tweenData.elapsed = diff;
                tweenData.progress = diff / tweenData.duration;
                if (tweenData.flipX) {
                  tweenData.target.toggleFlipX();
                }
                if (tweenData.flipY) {
                  tweenData.target.toggleFlipY();
                }
                tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
                if (tweenData.repeatDelay > 0) {
                  tweenData.elapsed = tweenData.repeatDelay - diff;
                  tweenData.current = tweenData.start;
                  tweenData.target[tweenData.key] = tweenData.current;
                  return TWEEN_CONST.REPEAT_DELAY;
                } else {
                  this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData);
                  return TWEEN_CONST.PLAYING_FORWARD;
                }
              }
              return TWEEN_CONST.COMPLETE;
            },
            updateTweenData: function(tween, tweenData, delta) {
              var target = tweenData.target;
              switch (tweenData.state) {
                case TWEEN_CONST.PLAYING_FORWARD:
                case TWEEN_CONST.PLAYING_BACKWARD:
                  if (!target) {
                    tweenData.state = TWEEN_CONST.COMPLETE;
                    break;
                  }
                  var elapsed = tweenData.elapsed;
                  var duration = tweenData.duration;
                  var diff = 0;
                  elapsed += delta;
                  if (elapsed > duration) {
                    diff = elapsed - duration;
                    elapsed = duration;
                  }
                  var forward = tweenData.state === TWEEN_CONST.PLAYING_FORWARD;
                  var progress = elapsed / duration;
                  tweenData.elapsed = elapsed;
                  tweenData.progress = progress;
                  tweenData.previous = tweenData.current;
                  if (progress === 1) {
                    if (forward) {
                      tweenData.current = tweenData.end;
                      target[tweenData.key] = tweenData.end;
                      if (tweenData.hold > 0) {
                        tweenData.elapsed = tweenData.hold - diff;
                        tweenData.state = TWEEN_CONST.HOLD_DELAY;
                      } else {
                        tweenData.state = this.setStateFromEnd(tween, tweenData, diff);
                      }
                    } else {
                      tweenData.current = tweenData.start;
                      target[tweenData.key] = tweenData.start;
                      tweenData.state = this.setStateFromStart(tween, tweenData, diff);
                    }
                  } else {
                    var v = forward ? tweenData.ease(progress) : tweenData.ease(1 - progress);
                    tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v;
                    target[tweenData.key] = tweenData.current;
                  }
                  this.dispatchTweenDataEvent(Events.TWEEN_UPDATE, tween.callbacks.onUpdate, tweenData);
                  break;
                case TWEEN_CONST.DELAY:
                  tweenData.elapsed -= delta;
                  if (tweenData.elapsed <= 0) {
                    tweenData.elapsed = Math.abs(tweenData.elapsed);
                    tweenData.state = TWEEN_CONST.PENDING_RENDER;
                  }
                  break;
                case TWEEN_CONST.REPEAT_DELAY:
                  tweenData.elapsed -= delta;
                  if (tweenData.elapsed <= 0) {
                    tweenData.elapsed = Math.abs(tweenData.elapsed);
                    tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
                    this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData);
                  }
                  break;
                case TWEEN_CONST.HOLD_DELAY:
                  tweenData.elapsed -= delta;
                  if (tweenData.elapsed <= 0) {
                    tweenData.state = this.setStateFromEnd(tween, tweenData, Math.abs(tweenData.elapsed));
                  }
                  break;
                case TWEEN_CONST.PENDING_RENDER:
                  if (target) {
                    tweenData.start = tweenData.getStartValue(target, tweenData.key, target[tweenData.key], tweenData.index, tween.totalTargets, tween);
                    tweenData.end = tweenData.getEndValue(target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
                    tweenData.current = tweenData.start;
                    target[tweenData.key] = tweenData.start;
                    tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
                  } else {
                    tweenData.state = TWEEN_CONST.COMPLETE;
                  }
                  break;
              }
              return tweenData.state !== TWEEN_CONST.COMPLETE;
            }
          });
          Tween.TYPES = [
            "onActive",
            "onComplete",
            "onLoop",
            "onRepeat",
            "onStart",
            "onStop",
            "onUpdate",
            "onYoyo"
          ];
          GameObjectFactory.register("tween", function(config2) {
            return this.scene.sys.tweens.add(config2);
          });
          GameObjectCreator.register("tween", function(config2) {
            return this.scene.sys.tweens.create(config2);
          });
          module2.exports = Tween;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            TIMELINE_COMPLETE: __webpack_require__(1459),
            TIMELINE_LOOP: __webpack_require__(1460),
            TIMELINE_PAUSE: __webpack_require__(1461),
            TIMELINE_RESUME: __webpack_require__(1462),
            TIMELINE_START: __webpack_require__(1463),
            TIMELINE_UPDATE: __webpack_require__(1464),
            TWEEN_ACTIVE: __webpack_require__(1465),
            TWEEN_COMPLETE: __webpack_require__(1466),
            TWEEN_LOOP: __webpack_require__(1467),
            TWEEN_REPEAT: __webpack_require__(1468),
            TWEEN_START: __webpack_require__(1469),
            TWEEN_STOP: __webpack_require__(1470),
            TWEEN_UPDATE: __webpack_require__(1471),
            TWEEN_YOYO: __webpack_require__(1472)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TweenData = function(target, index, key, getEnd, getStart, getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY) {
            return {
              target,
              index,
              key,
              getActiveValue: getActive,
              getEndValue: getEnd,
              getStartValue: getStart,
              ease,
              duration: 0,
              totalDuration: 0,
              delay: 0,
              yoyo,
              hold: 0,
              repeat: 0,
              repeatDelay: 0,
              flipX,
              flipY,
              progress: 0,
              elapsed: 0,
              repeatCounter: 0,
              start: 0,
              previous: 0,
              current: 0,
              end: 0,
              t1: 0,
              t2: 0,
              gen: {
                delay,
                duration,
                hold,
                repeat,
                repeatDelay
              },
              state: 0
            };
          };
          module2.exports = TweenData;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MathWrap = __webpack_require__(66);
          var Wrap = function(angle) {
            return MathWrap(angle, -Math.PI, Math.PI);
          };
          module2.exports = Wrap;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Wrap = __webpack_require__(66);
          var WrapDegrees = function(angle) {
            return Wrap(angle, -180, 180);
          };
          module2.exports = WrapDegrees;
        },
        function(module2, exports2, __webpack_require__) {
          var Sleeping = {};
          module2.exports = Sleeping;
          var Events = __webpack_require__(268);
          (function() {
            Sleeping._motionWakeThreshold = 0.18;
            Sleeping._motionSleepThreshold = 0.08;
            Sleeping._minBias = 0.9;
            Sleeping.update = function(bodies, timeScale) {
              var timeFactor = timeScale * timeScale * timeScale;
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i], motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;
                if (body.force.x !== 0 || body.force.y !== 0) {
                  Sleeping.set(body, false);
                  continue;
                }
                var minMotion = Math.min(body.motion, motion), maxMotion = Math.max(body.motion, motion);
                body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;
                if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {
                  body.sleepCounter += 1;
                  if (body.sleepCounter >= body.sleepThreshold)
                    Sleeping.set(body, true);
                } else if (body.sleepCounter > 0) {
                  body.sleepCounter -= 1;
                }
              }
            };
            Sleeping.afterCollisions = function(pairs, timeScale) {
              var timeFactor = timeScale * timeScale * timeScale;
              for (var i = 0; i < pairs.length; i++) {
                var pair = pairs[i];
                if (!pair.isActive)
                  continue;
                var collision = pair.collision, bodyA = collision.bodyA.parent, bodyB = collision.bodyB.parent;
                if (bodyA.isSleeping && bodyB.isSleeping || bodyA.isStatic || bodyB.isStatic)
                  continue;
                if (bodyA.isSleeping || bodyB.isSleeping) {
                  var sleepingBody = bodyA.isSleeping && !bodyA.isStatic ? bodyA : bodyB, movingBody = sleepingBody === bodyA ? bodyB : bodyA;
                  if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {
                    Sleeping.set(sleepingBody, false);
                  }
                }
              }
            };
            Sleeping.set = function(body, isSleeping) {
              var wasSleeping = body.isSleeping;
              if (isSleeping) {
                body.isSleeping = true;
                body.sleepCounter = body.sleepThreshold;
                body.positionImpulse.x = 0;
                body.positionImpulse.y = 0;
                body.positionPrev.x = body.position.x;
                body.positionPrev.y = body.position.y;
                body.anglePrev = body.angle;
                body.speed = 0;
                body.angularSpeed = 0;
                body.motion = 0;
                if (!wasSleeping) {
                  Events.trigger(body, "sleepStart");
                }
              } else {
                body.isSleeping = false;
                body.sleepCounter = 0;
                if (wasSleeping) {
                  Events.trigger(body, "sleepEnd");
                }
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Events = {};
          module2.exports = Events;
          var Common = __webpack_require__(50);
          (function() {
            Events.on = function(object, eventNames, callback) {
              var names = eventNames.split(" "), name;
              for (var i = 0; i < names.length; i++) {
                name = names[i];
                object.events = object.events || {};
                object.events[name] = object.events[name] || [];
                object.events[name].push(callback);
              }
              return callback;
            };
            Events.off = function(object, eventNames, callback) {
              if (!eventNames) {
                object.events = {};
                return;
              }
              if (typeof eventNames === "function") {
                callback = eventNames;
                eventNames = Common.keys(object.events).join(" ");
              }
              var names = eventNames.split(" ");
              for (var i = 0; i < names.length; i++) {
                var callbacks = object.events[names[i]], newCallbacks = [];
                if (callback && callbacks) {
                  for (var j = 0; j < callbacks.length; j++) {
                    if (callbacks[j] !== callback)
                      newCallbacks.push(callbacks[j]);
                  }
                }
                object.events[names[i]] = newCallbacks;
              }
            };
            Events.trigger = function(object, eventNames, event) {
              var names, name, callbacks, eventClone;
              var events = object.events;
              if (events && Common.keys(events).length > 0) {
                if (!event)
                  event = {};
                names = eventNames.split(" ");
                for (var i = 0; i < names.length; i++) {
                  name = names[i];
                  callbacks = events[name];
                  if (callbacks) {
                    eventClone = Common.clone(event, false);
                    eventClone.name = name;
                    eventClone.source = object;
                    for (var j = 0; j < callbacks.length; j++) {
                      callbacks[j].apply(object, [eventClone]);
                    }
                  }
                }
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            AlignTo: __webpack_require__(599),
            Angle: __webpack_require__(600),
            Call: __webpack_require__(601),
            GetFirst: __webpack_require__(602),
            GetLast: __webpack_require__(603),
            GridAlign: __webpack_require__(604),
            IncAlpha: __webpack_require__(654),
            IncX: __webpack_require__(655),
            IncXY: __webpack_require__(656),
            IncY: __webpack_require__(657),
            PlaceOnCircle: __webpack_require__(658),
            PlaceOnEllipse: __webpack_require__(659),
            PlaceOnLine: __webpack_require__(660),
            PlaceOnRectangle: __webpack_require__(661),
            PlaceOnTriangle: __webpack_require__(662),
            PlayAnimation: __webpack_require__(663),
            PropertyValueInc: __webpack_require__(44),
            PropertyValueSet: __webpack_require__(27),
            RandomCircle: __webpack_require__(664),
            RandomEllipse: __webpack_require__(665),
            RandomLine: __webpack_require__(666),
            RandomRectangle: __webpack_require__(667),
            RandomTriangle: __webpack_require__(668),
            Rotate: __webpack_require__(669),
            RotateAround: __webpack_require__(670),
            RotateAroundDistance: __webpack_require__(671),
            ScaleX: __webpack_require__(672),
            ScaleXY: __webpack_require__(673),
            ScaleY: __webpack_require__(674),
            SetAlpha: __webpack_require__(675),
            SetBlendMode: __webpack_require__(676),
            SetDepth: __webpack_require__(677),
            SetHitArea: __webpack_require__(678),
            SetOrigin: __webpack_require__(679),
            SetRotation: __webpack_require__(680),
            SetScale: __webpack_require__(681),
            SetScaleX: __webpack_require__(682),
            SetScaleY: __webpack_require__(683),
            SetScrollFactor: __webpack_require__(684),
            SetScrollFactorX: __webpack_require__(685),
            SetScrollFactorY: __webpack_require__(686),
            SetTint: __webpack_require__(687),
            SetVisible: __webpack_require__(688),
            SetX: __webpack_require__(689),
            SetXY: __webpack_require__(690),
            SetY: __webpack_require__(691),
            ShiftPosition: __webpack_require__(692),
            Shuffle: __webpack_require__(693),
            SmootherStep: __webpack_require__(694),
            SmoothStep: __webpack_require__(695),
            Spread: __webpack_require__(696),
            ToggleVisible: __webpack_require__(697),
            WrapInRectangle: __webpack_require__(698)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       samme
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ALIGN_CONST = __webpack_require__(122);
          var AlignToMap = [];
          AlignToMap[ALIGN_CONST.BOTTOM_CENTER] = __webpack_require__(271);
          AlignToMap[ALIGN_CONST.BOTTOM_LEFT] = __webpack_require__(272);
          AlignToMap[ALIGN_CONST.BOTTOM_RIGHT] = __webpack_require__(273);
          AlignToMap[ALIGN_CONST.LEFT_BOTTOM] = __webpack_require__(274);
          AlignToMap[ALIGN_CONST.LEFT_CENTER] = __webpack_require__(275);
          AlignToMap[ALIGN_CONST.LEFT_TOP] = __webpack_require__(276);
          AlignToMap[ALIGN_CONST.RIGHT_BOTTOM] = __webpack_require__(277);
          AlignToMap[ALIGN_CONST.RIGHT_CENTER] = __webpack_require__(278);
          AlignToMap[ALIGN_CONST.RIGHT_TOP] = __webpack_require__(279);
          AlignToMap[ALIGN_CONST.TOP_CENTER] = __webpack_require__(280);
          AlignToMap[ALIGN_CONST.TOP_LEFT] = __webpack_require__(281);
          AlignToMap[ALIGN_CONST.TOP_RIGHT] = __webpack_require__(282);
          var QuickSet = function(child, alignTo, position, offsetX, offsetY) {
            return AlignToMap[position](child, alignTo, offsetX, offsetY);
          };
          module2.exports = QuickSet;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetBottom = __webpack_require__(40);
          var GetCenterX = __webpack_require__(84);
          var SetCenterX = __webpack_require__(85);
          var SetTop = __webpack_require__(51);
          var BottomCenter = function(gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetCenterX(gameObject, GetCenterX(alignTo) + offsetX);
            SetTop(gameObject, GetBottom(alignTo) + offsetY);
            return gameObject;
          };
          module2.exports = BottomCenter;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetBottom = __webpack_require__(40);
          var GetLeft = __webpack_require__(41);
          var SetLeft = __webpack_require__(52);
          var SetTop = __webpack_require__(51);
          var BottomLeft = function(gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetLeft(alignTo) - offsetX);
            SetTop(gameObject, GetBottom(alignTo) + offsetY);
            return gameObject;
          };
          module2.exports = BottomLeft;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetBottom = __webpack_require__(40);
          var GetRight = __webpack_require__(42);
          var SetRight = __webpack_require__(53);
          var SetTop = __webpack_require__(51);
          var BottomRight = function(gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetRight(alignTo) + offsetX);
            SetTop(gameObject, GetBottom(alignTo) + offsetY);
            return gameObject;
          };
          module2.exports = BottomRight;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetBottom = __webpack_require__(40);
          var GetLeft = __webpack_require__(41);
          var SetBottom = __webpack_require__(54);
          var SetRight = __webpack_require__(53);
          var LeftBottom = function(gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetLeft(alignTo) - offsetX);
            SetBottom(gameObject, GetBottom(alignTo) + offsetY);
            return gameObject;
          };
          module2.exports = LeftBottom;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCenterY = __webpack_require__(86);
          var GetLeft = __webpack_require__(41);
          var SetCenterY = __webpack_require__(87);
          var SetRight = __webpack_require__(53);
          var LeftCenter = function(gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetLeft(alignTo) - offsetX);
            SetCenterY(gameObject, GetCenterY(alignTo) + offsetY);
            return gameObject;
          };
          module2.exports = LeftCenter;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetLeft = __webpack_require__(41);
          var GetTop = __webpack_require__(43);
          var SetRight = __webpack_require__(53);
          var SetTop = __webpack_require__(51);
          var LeftTop = function(gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetLeft(alignTo) - offsetX);
            SetTop(gameObject, GetTop(alignTo) - offsetY);
            return gameObject;
          };
          module2.exports = LeftTop;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetBottom = __webpack_require__(40);
          var GetRight = __webpack_require__(42);
          var SetBottom = __webpack_require__(54);
          var SetLeft = __webpack_require__(52);
          var RightBottom = function(gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetRight(alignTo) + offsetX);
            SetBottom(gameObject, GetBottom(alignTo) + offsetY);
            return gameObject;
          };
          module2.exports = RightBottom;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCenterY = __webpack_require__(86);
          var GetRight = __webpack_require__(42);
          var SetCenterY = __webpack_require__(87);
          var SetLeft = __webpack_require__(52);
          var RightCenter = function(gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetRight(alignTo) + offsetX);
            SetCenterY(gameObject, GetCenterY(alignTo) + offsetY);
            return gameObject;
          };
          module2.exports = RightCenter;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetRight = __webpack_require__(42);
          var GetTop = __webpack_require__(43);
          var SetLeft = __webpack_require__(52);
          var SetTop = __webpack_require__(51);
          var RightTop = function(gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetRight(alignTo) + offsetX);
            SetTop(gameObject, GetTop(alignTo) - offsetY);
            return gameObject;
          };
          module2.exports = RightTop;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCenterX = __webpack_require__(84);
          var GetTop = __webpack_require__(43);
          var SetBottom = __webpack_require__(54);
          var SetCenterX = __webpack_require__(85);
          var TopCenter = function(gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetCenterX(gameObject, GetCenterX(alignTo) + offsetX);
            SetBottom(gameObject, GetTop(alignTo) - offsetY);
            return gameObject;
          };
          module2.exports = TopCenter;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetLeft = __webpack_require__(41);
          var GetTop = __webpack_require__(43);
          var SetBottom = __webpack_require__(54);
          var SetLeft = __webpack_require__(52);
          var TopLeft = function(gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetLeft(alignTo) - offsetX);
            SetBottom(gameObject, GetTop(alignTo) - offsetY);
            return gameObject;
          };
          module2.exports = TopLeft;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetRight = __webpack_require__(42);
          var GetTop = __webpack_require__(43);
          var SetBottom = __webpack_require__(54);
          var SetRight = __webpack_require__(53);
          var TopRight = function(gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetRight(alignTo) + offsetX);
            SetBottom(gameObject, GetTop(alignTo) - offsetY);
            return gameObject;
          };
          module2.exports = TopRight;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ALIGN_CONST = __webpack_require__(122);
          var AlignInMap = [];
          AlignInMap[ALIGN_CONST.BOTTOM_CENTER] = __webpack_require__(284);
          AlignInMap[ALIGN_CONST.BOTTOM_LEFT] = __webpack_require__(285);
          AlignInMap[ALIGN_CONST.BOTTOM_RIGHT] = __webpack_require__(286);
          AlignInMap[ALIGN_CONST.CENTER] = __webpack_require__(287);
          AlignInMap[ALIGN_CONST.LEFT_CENTER] = __webpack_require__(289);
          AlignInMap[ALIGN_CONST.RIGHT_CENTER] = __webpack_require__(290);
          AlignInMap[ALIGN_CONST.TOP_CENTER] = __webpack_require__(291);
          AlignInMap[ALIGN_CONST.TOP_LEFT] = __webpack_require__(292);
          AlignInMap[ALIGN_CONST.TOP_RIGHT] = __webpack_require__(293);
          AlignInMap[ALIGN_CONST.LEFT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_LEFT];
          AlignInMap[ALIGN_CONST.LEFT_TOP] = AlignInMap[ALIGN_CONST.TOP_LEFT];
          AlignInMap[ALIGN_CONST.RIGHT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_RIGHT];
          AlignInMap[ALIGN_CONST.RIGHT_TOP] = AlignInMap[ALIGN_CONST.TOP_RIGHT];
          var QuickSet = function(child, alignIn, position, offsetX, offsetY) {
            return AlignInMap[position](child, alignIn, offsetX, offsetY);
          };
          module2.exports = QuickSet;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetBottom = __webpack_require__(40);
          var GetCenterX = __webpack_require__(84);
          var SetBottom = __webpack_require__(54);
          var SetCenterX = __webpack_require__(85);
          var BottomCenter = function(gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
            SetBottom(gameObject, GetBottom(alignIn) + offsetY);
            return gameObject;
          };
          module2.exports = BottomCenter;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetBottom = __webpack_require__(40);
          var GetLeft = __webpack_require__(41);
          var SetBottom = __webpack_require__(54);
          var SetLeft = __webpack_require__(52);
          var BottomLeft = function(gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetLeft(alignIn) - offsetX);
            SetBottom(gameObject, GetBottom(alignIn) + offsetY);
            return gameObject;
          };
          module2.exports = BottomLeft;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetBottom = __webpack_require__(40);
          var GetRight = __webpack_require__(42);
          var SetBottom = __webpack_require__(54);
          var SetRight = __webpack_require__(53);
          var BottomRight = function(gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetRight(alignIn) + offsetX);
            SetBottom(gameObject, GetBottom(alignIn) + offsetY);
            return gameObject;
          };
          module2.exports = BottomRight;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CenterOn = __webpack_require__(288);
          var GetCenterX = __webpack_require__(84);
          var GetCenterY = __webpack_require__(86);
          var Center = function(gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            CenterOn(gameObject, GetCenterX(alignIn) + offsetX, GetCenterY(alignIn) + offsetY);
            return gameObject;
          };
          module2.exports = Center;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetCenterX = __webpack_require__(85);
          var SetCenterY = __webpack_require__(87);
          var CenterOn = function(gameObject, x, y) {
            SetCenterX(gameObject, x);
            return SetCenterY(gameObject, y);
          };
          module2.exports = CenterOn;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCenterY = __webpack_require__(86);
          var GetLeft = __webpack_require__(41);
          var SetCenterY = __webpack_require__(87);
          var SetLeft = __webpack_require__(52);
          var LeftCenter = function(gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetLeft(alignIn) - offsetX);
            SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
            return gameObject;
          };
          module2.exports = LeftCenter;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCenterY = __webpack_require__(86);
          var GetRight = __webpack_require__(42);
          var SetCenterY = __webpack_require__(87);
          var SetRight = __webpack_require__(53);
          var RightCenter = function(gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetRight(alignIn) + offsetX);
            SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
            return gameObject;
          };
          module2.exports = RightCenter;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCenterX = __webpack_require__(84);
          var GetTop = __webpack_require__(43);
          var SetCenterX = __webpack_require__(85);
          var SetTop = __webpack_require__(51);
          var TopCenter = function(gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
            SetTop(gameObject, GetTop(alignIn) - offsetY);
            return gameObject;
          };
          module2.exports = TopCenter;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetLeft = __webpack_require__(41);
          var GetTop = __webpack_require__(43);
          var SetLeft = __webpack_require__(52);
          var SetTop = __webpack_require__(51);
          var TopLeft = function(gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetLeft(alignIn) - offsetX);
            SetTop(gameObject, GetTop(alignIn) - offsetY);
            return gameObject;
          };
          module2.exports = TopLeft;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetRight = __webpack_require__(42);
          var GetTop = __webpack_require__(43);
          var SetRight = __webpack_require__(53);
          var SetTop = __webpack_require__(51);
          var TopRight = function(gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetRight(alignIn) + offsetX);
            SetTop(gameObject, GetTop(alignIn) - offsetY);
            return gameObject;
          };
          module2.exports = TopRight;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CircumferencePoint = __webpack_require__(165);
          var FromPercent = __webpack_require__(95);
          var MATH_CONST = __webpack_require__(14);
          var Point = __webpack_require__(4);
          var GetPoint = function(circle, position, out) {
            if (out === void 0) {
              out = new Point();
            }
            var angle = FromPercent(position, 0, MATH_CONST.PI2);
            return CircumferencePoint(circle, angle, out);
          };
          module2.exports = GetPoint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Circumference = __webpack_require__(296);
          var CircumferencePoint = __webpack_require__(165);
          var FromPercent = __webpack_require__(95);
          var MATH_CONST = __webpack_require__(14);
          var GetPoints = function(circle, quantity, stepRate, out) {
            if (out === void 0) {
              out = [];
            }
            if (!quantity && stepRate > 0) {
              quantity = Circumference(circle) / stepRate;
            }
            for (var i = 0; i < quantity; i++) {
              var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);
              out.push(CircumferencePoint(circle, angle));
            }
            return out;
          };
          module2.exports = GetPoints;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Circumference = function(circle) {
            return 2 * (Math.PI * circle.radius);
          };
          module2.exports = Circumference;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clamp = __webpack_require__(18);
          var _FLAG = 2;
          var AlphaSingle = {
            _alpha: 1,
            clearAlpha: function() {
              return this.setAlpha(1);
            },
            setAlpha: function(value) {
              if (value === void 0) {
                value = 1;
              }
              this.alpha = value;
              return this;
            },
            alpha: {
              get: function() {
                return this._alpha;
              },
              set: function(value) {
                var v = Clamp(value, 0, 1);
                this._alpha = v;
                if (v === 0) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
              }
            }
          };
          module2.exports = AlphaSingle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BlendModes = __webpack_require__(34);
          var BlendMode = {
            _blendMode: BlendModes.NORMAL,
            blendMode: {
              get: function() {
                return this._blendMode;
              },
              set: function(value) {
                if (typeof value === "string") {
                  value = BlendModes[value];
                }
                value |= 0;
                if (value >= -1) {
                  this._blendMode = value;
                }
              }
            },
            setBlendMode: function(value) {
              this.blendMode = value;
              return this;
            }
          };
          module2.exports = BlendMode;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Depth = {
            _depth: 0,
            depth: {
              get: function() {
                return this._depth;
              },
              set: function(value) {
                if (this.displayList) {
                  this.displayList.queueDepthSort();
                }
                this._depth = value;
              }
            },
            setDepth: function(value) {
              if (value === void 0) {
                value = 0;
              }
              this.depth = value;
              return this;
            }
          };
          module2.exports = Depth;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetPoint = __webpack_require__(167);
          var Perimeter = __webpack_require__(128);
          var GetPoints = function(rectangle, quantity, stepRate, out) {
            if (out === void 0) {
              out = [];
            }
            if (!quantity && stepRate > 0) {
              quantity = Perimeter(rectangle) / stepRate;
            }
            for (var i = 0; i < quantity; i++) {
              var position = i / quantity;
              out.push(GetPoint(rectangle, position));
            }
            return out;
          };
          module2.exports = GetPoints;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var GetPoint = function(line, position, out) {
            if (out === void 0) {
              out = new Point();
            }
            out.x = line.x1 + (line.x2 - line.x1) * position;
            out.y = line.y1 + (line.y2 - line.y1) * position;
            return out;
          };
          module2.exports = GetPoint;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateAround = function(point, x, y, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var tx = point.x - x;
            var ty = point.y - y;
            point.x = tx * c - ty * s + x;
            point.y = tx * s + ty * c + y;
            return point;
          };
          module2.exports = RotateAround;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BitmapMask = __webpack_require__(304);
          var GeometryMask = __webpack_require__(305);
          var Mask = {
            mask: null,
            setMask: function(mask) {
              this.mask = mask;
              return this;
            },
            clearMask: function(destroyMask) {
              if (destroyMask === void 0) {
                destroyMask = false;
              }
              if (destroyMask && this.mask) {
                this.mask.destroy();
              }
              this.mask = null;
              return this;
            },
            createBitmapMask: function(renderable) {
              if (renderable === void 0 && (this.texture || this.shader)) {
                renderable = this;
              }
              return new BitmapMask(this.scene, renderable);
            },
            createGeometryMask: function(graphics) {
              if (graphics === void 0 && this.type === "Graphics") {
                graphics = this;
              }
              return new GeometryMask(this.scene, graphics);
            }
          };
          module2.exports = Mask;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GameEvents = __webpack_require__(22);
          var RenderEvents = __webpack_require__(88);
          var BitmapMask = new Class({
            initialize: function BitmapMask2(scene, renderable) {
              var renderer = scene.sys.renderer;
              this.renderer = renderer;
              this.bitmapMask = renderable;
              this.maskTexture = null;
              this.mainTexture = null;
              this.dirty = true;
              this.mainFramebuffer = null;
              this.maskFramebuffer = null;
              this.invertAlpha = false;
              this.isStencil = false;
              this.createMask();
              scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, this.createMask, this);
              renderer.on(RenderEvents.RESIZE, this.createMask, this);
            },
            createMask: function() {
              var renderer = this.renderer;
              if (!renderer.gl) {
                return;
              }
              if (this.mainTexture) {
                this.clearMask();
              }
              var width = renderer.width;
              var height = renderer.height;
              var pot = (width & width - 1) === 0 && (height & height - 1) === 0;
              var gl = renderer.gl;
              var wrap = pot ? gl.REPEAT : gl.CLAMP_TO_EDGE;
              var filter2 = gl.LINEAR;
              this.mainTexture = renderer.createTexture2D(0, filter2, filter2, wrap, wrap, gl.RGBA, null, width, height);
              this.maskTexture = renderer.createTexture2D(0, filter2, filter2, wrap, wrap, gl.RGBA, null, width, height);
              this.mainFramebuffer = renderer.createFramebuffer(width, height, this.mainTexture, true);
              this.maskFramebuffer = renderer.createFramebuffer(width, height, this.maskTexture, true);
            },
            clearMask: function() {
              var renderer = this.renderer;
              if (!renderer.gl || !this.mainTexture) {
                return;
              }
              renderer.deleteTexture(this.mainTexture);
              renderer.deleteTexture(this.maskTexture);
              renderer.deleteFramebuffer(this.mainFramebuffer);
              renderer.deleteFramebuffer(this.maskFramebuffer);
              this.mainTexture = null;
              this.maskTexture = null;
              this.mainFramebuffer = null;
              this.maskFramebuffer = null;
            },
            setBitmap: function(renderable) {
              this.bitmapMask = renderable;
            },
            preRenderWebGL: function(renderer, maskedObject, camera) {
              renderer.pipelines.BITMAPMASK_PIPELINE.beginMask(this, maskedObject, camera);
            },
            postRenderWebGL: function(renderer, camera) {
              renderer.pipelines.BITMAPMASK_PIPELINE.endMask(this, camera);
            },
            preRenderCanvas: function() {
            },
            postRenderCanvas: function() {
            },
            destroy: function() {
              this.clearMask();
              this.renderer.off(RenderEvents.RESIZE, this.createMask, this);
              this.bitmapMask = null;
              this.prevFramebuffer = null;
              this.renderer = null;
            }
          });
          module2.exports = BitmapMask;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GeometryMask = new Class({
            initialize: function GeometryMask2(scene, graphicsGeometry) {
              this.geometryMask = graphicsGeometry;
              this.invertAlpha = false;
              this.isStencil = true;
              this.level = 0;
            },
            setShape: function(graphicsGeometry) {
              this.geometryMask = graphicsGeometry;
              return this;
            },
            setInvertAlpha: function(value) {
              if (value === void 0) {
                value = true;
              }
              this.invertAlpha = value;
              return this;
            },
            preRenderWebGL: function(renderer, child, camera) {
              var gl = renderer.gl;
              renderer.flush();
              if (renderer.maskStack.length === 0) {
                gl.enable(gl.STENCIL_TEST);
                gl.clear(gl.STENCIL_BUFFER_BIT);
                renderer.maskCount = 0;
              }
              if (renderer.currentCameraMask.mask !== this) {
                renderer.currentMask.mask = this;
              }
              renderer.maskStack.push({mask: this, camera});
              this.applyStencil(renderer, camera, true);
              renderer.maskCount++;
            },
            applyStencil: function(renderer, camera, inc) {
              var gl = renderer.gl;
              var geometryMask = this.geometryMask;
              var level = renderer.maskCount;
              gl.colorMask(false, false, false, false);
              if (inc) {
                gl.stencilFunc(gl.EQUAL, level, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
              } else {
                gl.stencilFunc(gl.EQUAL, level + 1, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
              }
              geometryMask.renderWebGL(renderer, geometryMask, camera);
              renderer.flush();
              gl.colorMask(true, true, true, true);
              gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
              if (inc) {
                if (this.invertAlpha) {
                  gl.stencilFunc(gl.NOTEQUAL, level + 1, 255);
                } else {
                  gl.stencilFunc(gl.EQUAL, level + 1, 255);
                }
              } else if (this.invertAlpha) {
                gl.stencilFunc(gl.NOTEQUAL, level, 255);
              } else {
                gl.stencilFunc(gl.EQUAL, level, 255);
              }
            },
            postRenderWebGL: function(renderer) {
              var gl = renderer.gl;
              renderer.maskStack.pop();
              renderer.maskCount--;
              renderer.flush();
              var current = renderer.currentMask;
              if (renderer.maskStack.length === 0) {
                current.mask = null;
                gl.disable(gl.STENCIL_TEST);
              } else {
                var prev = renderer.maskStack[renderer.maskStack.length - 1];
                prev.mask.applyStencil(renderer, prev.camera, false);
                if (renderer.currentCameraMask.mask !== prev.mask) {
                  current.mask = prev.mask;
                  current.camera = prev.camera;
                } else {
                  current.mask = null;
                }
              }
            },
            preRenderCanvas: function(renderer, mask, camera) {
              var geometryMask = this.geometryMask;
              renderer.currentContext.save();
              geometryMask.renderCanvas(renderer, geometryMask, camera, null, null, true);
              renderer.currentContext.clip();
            },
            postRenderCanvas: function(renderer) {
              renderer.currentContext.restore();
            },
            destroy: function() {
              this.geometryMask = null;
            }
          });
          module2.exports = GeometryMask;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ScrollFactor = {
            scrollFactorX: 1,
            scrollFactorY: 1,
            setScrollFactor: function(x, y) {
              if (y === void 0) {
                y = x;
              }
              this.scrollFactorX = x;
              this.scrollFactorY = y;
              return this;
            }
          };
          module2.exports = ScrollFactor;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MATH_CONST = __webpack_require__(14);
          var TransformMatrix = __webpack_require__(25);
          var TransformXY = __webpack_require__(174);
          var WrapAngle = __webpack_require__(265);
          var WrapAngleDegrees = __webpack_require__(266);
          var Vector29 = __webpack_require__(3);
          var _FLAG = 4;
          var Transform = {
            _scaleX: 1,
            _scaleY: 1,
            _rotation: 0,
            x: 0,
            y: 0,
            z: 0,
            w: 0,
            scale: {
              get: function() {
                return (this._scaleX + this._scaleY) / 2;
              },
              set: function(value) {
                this._scaleX = value;
                this._scaleY = value;
                if (value === 0) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
              }
            },
            scaleX: {
              get: function() {
                return this._scaleX;
              },
              set: function(value) {
                this._scaleX = value;
                if (value === 0) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
              }
            },
            scaleY: {
              get: function() {
                return this._scaleY;
              },
              set: function(value) {
                this._scaleY = value;
                if (value === 0) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
              }
            },
            angle: {
              get: function() {
                return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);
              },
              set: function(value) {
                this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
              }
            },
            rotation: {
              get: function() {
                return this._rotation;
              },
              set: function(value) {
                this._rotation = WrapAngle(value);
              }
            },
            setPosition: function(x, y, z, w) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = x;
              }
              if (z === void 0) {
                z = 0;
              }
              if (w === void 0) {
                w = 0;
              }
              this.x = x;
              this.y = y;
              this.z = z;
              this.w = w;
              return this;
            },
            copyPosition: function(source) {
              if (source.x !== void 0) {
                this.x = source.x;
              }
              if (source.y !== void 0) {
                this.y = source.y;
              }
              if (source.z !== void 0) {
                this.z = source.z;
              }
              if (source.w !== void 0) {
                this.w = source.w;
              }
              return this;
            },
            setRandomPosition: function(x, y, width, height) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = this.scene.sys.scale.width;
              }
              if (height === void 0) {
                height = this.scene.sys.scale.height;
              }
              this.x = x + Math.random() * width;
              this.y = y + Math.random() * height;
              return this;
            },
            setRotation: function(radians) {
              if (radians === void 0) {
                radians = 0;
              }
              this.rotation = radians;
              return this;
            },
            setAngle: function(degrees) {
              if (degrees === void 0) {
                degrees = 0;
              }
              this.angle = degrees;
              return this;
            },
            setScale: function(x, y) {
              if (x === void 0) {
                x = 1;
              }
              if (y === void 0) {
                y = x;
              }
              this.scaleX = x;
              this.scaleY = y;
              return this;
            },
            setX: function(value) {
              if (value === void 0) {
                value = 0;
              }
              this.x = value;
              return this;
            },
            setY: function(value) {
              if (value === void 0) {
                value = 0;
              }
              this.y = value;
              return this;
            },
            setZ: function(value) {
              if (value === void 0) {
                value = 0;
              }
              this.z = value;
              return this;
            },
            setW: function(value) {
              if (value === void 0) {
                value = 0;
              }
              this.w = value;
              return this;
            },
            getLocalTransformMatrix: function(tempMatrix) {
              if (tempMatrix === void 0) {
                tempMatrix = new TransformMatrix();
              }
              return tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
            },
            getWorldTransformMatrix: function(tempMatrix, parentMatrix) {
              if (tempMatrix === void 0) {
                tempMatrix = new TransformMatrix();
              }
              if (parentMatrix === void 0) {
                parentMatrix = new TransformMatrix();
              }
              var parent = this.parentContainer;
              if (!parent) {
                return this.getLocalTransformMatrix(tempMatrix);
              }
              tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
              while (parent) {
                parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY);
                parentMatrix.multiply(tempMatrix, tempMatrix);
                parent = parent.parentContainer;
              }
              return tempMatrix;
            },
            getLocalPoint: function(x, y, point, camera) {
              if (!point) {
                point = new Vector29();
              }
              if (!camera) {
                camera = this.scene.sys.cameras.main;
              }
              var csx = camera.scrollX;
              var csy = camera.scrollY;
              var px = x + csx * this.scrollFactorX - csx;
              var py = y + csy * this.scrollFactorY - csy;
              if (this.parentContainer) {
                this.getWorldTransformMatrix().applyInverse(px, py, point);
              } else {
                TransformXY(px, py, this.x, this.y, this.rotation, this.scaleX, this.scaleY, point);
              }
              if (this._originComponent) {
                point.x += this._displayOriginX;
                point.y += this._displayOriginY;
              }
              return point;
            },
            getParentRotation: function() {
              var rotation = 0;
              var parent = this.parentContainer;
              while (parent) {
                rotation += parent.rotation;
                parent = parent.parentContainer;
              }
              return rotation;
            }
          };
          module2.exports = Transform;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var _FLAG = 1;
          var Visible = {
            _visible: true,
            visible: {
              get: function() {
                return this._visible;
              },
              set: function(value) {
                if (value) {
                  this._visible = true;
                  this.renderFlags |= _FLAG;
                } else {
                  this._visible = false;
                  this.renderFlags &= ~_FLAG;
                }
              }
            },
            setVisible: function(value) {
              this.visible = value;
              return this;
            }
          };
          module2.exports = Visible;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            CHANGE_DATA: __webpack_require__(636),
            CHANGE_DATA_KEY: __webpack_require__(637),
            DESTROY: __webpack_require__(638),
            REMOVE_DATA: __webpack_require__(639),
            SET_DATA: __webpack_require__(640)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Perimeter = __webpack_require__(128);
          var Point = __webpack_require__(4);
          var MarchingAnts = function(rect, step, quantity, out) {
            if (out === void 0) {
              out = [];
            }
            if (!step && !quantity) {
              return out;
            }
            if (!step) {
              step = Perimeter(rect) / quantity;
            } else {
              quantity = Math.round(Perimeter(rect) / step);
            }
            var x = rect.x;
            var y = rect.y;
            var face = 0;
            for (var i = 0; i < quantity; i++) {
              out.push(new Point(x, y));
              switch (face) {
                case 0:
                  x += step;
                  if (x >= rect.right) {
                    face = 1;
                    y += x - rect.right;
                    x = rect.right;
                  }
                  break;
                case 1:
                  y += step;
                  if (y >= rect.bottom) {
                    face = 2;
                    x -= y - rect.bottom;
                    y = rect.bottom;
                  }
                  break;
                case 2:
                  x -= step;
                  if (x <= rect.left) {
                    face = 3;
                    y -= rect.left - x;
                    x = rect.left;
                  }
                  break;
                case 3:
                  y -= step;
                  if (y <= rect.top) {
                    face = 0;
                    y = rect.top;
                  }
                  break;
              }
            }
            return out;
          };
          module2.exports = MarchingAnts;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BresenhamPoints = function(line, stepRate, results) {
            if (stepRate === void 0) {
              stepRate = 1;
            }
            if (results === void 0) {
              results = [];
            }
            var x1 = Math.round(line.x1);
            var y1 = Math.round(line.y1);
            var x2 = Math.round(line.x2);
            var y2 = Math.round(line.y2);
            var dx = Math.abs(x2 - x1);
            var dy = Math.abs(y2 - y1);
            var sx = x1 < x2 ? 1 : -1;
            var sy = y1 < y2 ? 1 : -1;
            var err = dx - dy;
            results.push({x: x1, y: y1});
            var i = 1;
            while (!(x1 === x2 && y1 === y2)) {
              var e2 = err << 1;
              if (e2 > -dy) {
                err -= dy;
                x1 += sx;
              }
              if (e2 < dx) {
                err += dx;
                y1 += sy;
              }
              if (i % stepRate === 0) {
                results.push({x: x1, y: y1});
              }
              i++;
            }
            return results;
          };
          module2.exports = BresenhamPoints;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FindClosestInSorted = function(value, array, key) {
            if (!array.length) {
              return NaN;
            } else if (array.length === 1) {
              return array[0];
            }
            var i = 1;
            var low;
            var high;
            if (key) {
              if (value < array[0][key]) {
                return array[0];
              }
              while (array[i][key] < value) {
                i++;
              }
            } else {
              while (array[i] < value) {
                i++;
              }
            }
            if (i > array.length) {
              i = array.length;
            }
            if (key) {
              low = array[i - 1][key];
              high = array[i][key];
              return high - value <= value - low ? array[i] : array[i - 1];
            } else {
              low = array[i - 1];
              high = array[i];
              return high - value <= value - low ? high : low;
            }
          };
          module2.exports = FindClosestInSorted;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var AnimationFrame = new Class({
            initialize: function AnimationFrame2(textureKey, textureFrame, index, frame, isKeyFrame) {
              if (isKeyFrame === void 0) {
                isKeyFrame = false;
              }
              this.textureKey = textureKey;
              this.textureFrame = textureFrame;
              this.index = index;
              this.frame = frame;
              this.isFirst = false;
              this.isLast = false;
              this.prevFrame = null;
              this.nextFrame = null;
              this.duration = 0;
              this.progress = 0;
              this.isKeyFrame = isKeyFrame;
            },
            toJSON: function() {
              return {
                key: this.textureKey,
                frame: this.textureFrame,
                duration: this.duration,
                keyframe: this.isKeyFrame
              };
            },
            destroy: function() {
              this.frame = void 0;
            }
          });
          module2.exports = AnimationFrame;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SortByDigits = function(array) {
            var re = /\D/g;
            array.sort(function(a, b) {
              return parseInt(a.replace(re, ""), 10) - parseInt(b.replace(re, ""), 10);
            });
            return array;
          };
          module2.exports = SortByDigits;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Animation = __webpack_require__(182);
          var Class = __webpack_require__(0);
          var CustomMap = __webpack_require__(99);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(130);
          var GameEvents = __webpack_require__(22);
          var GetFastValue = __webpack_require__(2);
          var GetValue = __webpack_require__(6);
          var Pad = __webpack_require__(183);
          var NumberArray = __webpack_require__(316);
          var AnimationManager = new Class({
            Extends: EventEmitter,
            initialize: function AnimationManager2(game) {
              EventEmitter.call(this);
              this.game = game;
              this.textureManager = null;
              this.globalTimeScale = 1;
              this.anims = new CustomMap();
              this.mixes = new CustomMap();
              this.paused = false;
              this.name = "AnimationManager";
              game.events.once(GameEvents.BOOT, this.boot, this);
            },
            boot: function() {
              this.textureManager = this.game.textures;
              this.game.events.once(GameEvents.DESTROY, this.destroy, this);
            },
            addMix: function(animA, animB, delay) {
              var anims = this.anims;
              var mixes = this.mixes;
              var keyA = typeof animA === "string" ? animA : animA.key;
              var keyB = typeof animB === "string" ? animB : animB.key;
              if (anims.has(keyA) && anims.has(keyB)) {
                var mixObj = mixes.get(keyA);
                if (!mixObj) {
                  mixObj = {};
                }
                mixObj[keyB] = delay;
                mixes.set(keyA, mixObj);
              }
              return this;
            },
            removeMix: function(animA, animB) {
              var mixes = this.mixes;
              var keyA = typeof animA === "string" ? animA : animA.key;
              var mixObj = mixes.get(keyA);
              if (mixObj) {
                if (animB) {
                  var keyB = typeof animB === "string" ? animB : animB.key;
                  if (mixObj.hasOwnProperty(keyB)) {
                    delete mixObj[keyB];
                  }
                } else if (!animB) {
                  mixes.delete(keyA);
                }
              }
              return this;
            },
            getMix: function(animA, animB) {
              var mixes = this.mixes;
              var keyA = typeof animA === "string" ? animA : animA.key;
              var keyB = typeof animB === "string" ? animB : animB.key;
              var mixObj = mixes.get(keyA);
              if (mixObj && mixObj.hasOwnProperty(keyB)) {
                return mixObj[keyB];
              } else {
                return 0;
              }
            },
            add: function(key, animation) {
              if (this.anims.has(key)) {
                console.warn("Animation key exists: " + key);
                return this;
              }
              animation.key = key;
              this.anims.set(key, animation);
              this.emit(Events.ADD_ANIMATION, key, animation);
              return this;
            },
            exists: function(key) {
              return this.anims.has(key);
            },
            createFromAseprite: function(key, tags) {
              var output = [];
              var data = this.game.cache.json.get(key);
              if (!data) {
                return output;
              }
              var _this = this;
              var meta = GetValue(data, "meta", null);
              var frames = GetValue(data, "frames", null);
              if (meta && frames) {
                var frameTags = GetValue(meta, "frameTags", []);
                frameTags.forEach(function(tag) {
                  var animFrames = [];
                  var name = GetFastValue(tag, "name", null);
                  var from = GetFastValue(tag, "from", 0);
                  var to = GetFastValue(tag, "to", 0);
                  var direction = GetFastValue(tag, "direction", "forward");
                  if (!name) {
                    return;
                  }
                  if (!tags || tags && tags.indexOf(name) > -1) {
                    var tempFrames = [];
                    var minDuration = Number.MAX_SAFE_INTEGER;
                    for (var i = from; i <= to; i++) {
                      var frameKey = i.toString();
                      var frame = frames[frameKey];
                      if (frame) {
                        var frameDuration = GetFastValue(frame, "duration", Number.MAX_SAFE_INTEGER);
                        if (frameDuration < minDuration) {
                          minDuration = frameDuration;
                        }
                        tempFrames.push({frame: frameKey, duration: frameDuration});
                      }
                    }
                    tempFrames.forEach(function(entry) {
                      animFrames.push({
                        key,
                        frame: entry.frame,
                        duration: minDuration - entry.duration
                      });
                    });
                    var totalDuration = minDuration * animFrames.length;
                    if (direction === "reverse") {
                      animFrames = animFrames.reverse();
                    }
                    var createConfig = {
                      key: name,
                      frames: animFrames,
                      duration: totalDuration,
                      yoyo: direction === "pingpong"
                    };
                    var result = _this.create(createConfig);
                    if (result) {
                      output.push(result);
                    }
                  }
                });
              }
              return output;
            },
            create: function(config2) {
              var key = config2.key;
              var anim = false;
              if (key) {
                anim = this.get(key);
                if (!anim) {
                  anim = new Animation(this, key, config2);
                  this.anims.set(key, anim);
                  this.emit(Events.ADD_ANIMATION, key, anim);
                }
              }
              return anim;
            },
            fromJSON: function(data, clearCurrentAnimations) {
              if (clearCurrentAnimations === void 0) {
                clearCurrentAnimations = false;
              }
              if (clearCurrentAnimations) {
                this.anims.clear();
              }
              if (typeof data === "string") {
                data = JSON.parse(data);
              }
              var output = [];
              if (data.hasOwnProperty("anims") && Array.isArray(data.anims)) {
                for (var i = 0; i < data.anims.length; i++) {
                  output.push(this.create(data.anims[i]));
                }
                if (data.hasOwnProperty("globalTimeScale")) {
                  this.globalTimeScale = data.globalTimeScale;
                }
              } else if (data.hasOwnProperty("key") && data.type === "frame") {
                output.push(this.create(data));
              }
              return output;
            },
            generateFrameNames: function(key, config2) {
              var prefix = GetValue(config2, "prefix", "");
              var start = GetValue(config2, "start", 0);
              var end = GetValue(config2, "end", 0);
              var suffix = GetValue(config2, "suffix", "");
              var zeroPad = GetValue(config2, "zeroPad", 0);
              var out = GetValue(config2, "outputArray", []);
              var frames = GetValue(config2, "frames", false);
              var texture = this.textureManager.get(key);
              if (!texture) {
                return out;
              }
              var i;
              if (!config2) {
                frames = texture.getFrameNames();
                for (i = 0; i < frames.length; i++) {
                  out.push({key, frame: frames[i]});
                }
              } else {
                if (!frames) {
                  frames = NumberArray(start, end);
                }
                for (i = 0; i < frames.length; i++) {
                  var frame = prefix + Pad(frames[i], zeroPad, "0", 1) + suffix;
                  if (texture.has(frame)) {
                    out.push({key, frame});
                  } else {
                    console.warn("generateFrameNames: Frame missing: " + frame + " from texture: " + key);
                  }
                }
              }
              return out;
            },
            generateFrameNumbers: function(key, config2) {
              var start = GetValue(config2, "start", 0);
              var end = GetValue(config2, "end", -1);
              var first = GetValue(config2, "first", false);
              var out = GetValue(config2, "outputArray", []);
              var frames = GetValue(config2, "frames", false);
              var texture = this.textureManager.get(key);
              if (!texture) {
                return out;
              }
              if (first && texture.has(first)) {
                out.push({key, frame: first});
              }
              if (!frames) {
                if (end === -1) {
                  end = texture.frameTotal - 2;
                }
                frames = NumberArray(start, end);
              }
              for (var i = 0; i < frames.length; i++) {
                if (texture.has(frames[i])) {
                  out.push({key, frame: frames[i]});
                } else {
                  console.warn("generateFrameNumbers: Frame " + i + " missing from texture: " + key);
                }
              }
              return out;
            },
            get: function(key) {
              return this.anims.get(key);
            },
            pauseAll: function() {
              if (!this.paused) {
                this.paused = true;
                this.emit(Events.PAUSE_ALL);
              }
              return this;
            },
            play: function(key, children) {
              if (!Array.isArray(children)) {
                children = [children];
              }
              for (var i = 0; i < children.length; i++) {
                children[i].anims.play(key);
              }
              return this;
            },
            staggerPlay: function(key, children, stagger, staggerFirst) {
              if (stagger === void 0) {
                stagger = 0;
              }
              if (staggerFirst === void 0) {
                staggerFirst = true;
              }
              if (!Array.isArray(children)) {
                children = [children];
              }
              var len = children.length;
              if (!staggerFirst) {
                len--;
              }
              for (var i = 0; i < children.length; i++) {
                var time = stagger < 0 ? Math.abs(stagger) * (len - i) : stagger * i;
                children[i].anims.playAfterDelay(key, time);
              }
              return this;
            },
            remove: function(key) {
              var anim = this.get(key);
              if (anim) {
                this.emit(Events.REMOVE_ANIMATION, key, anim);
                this.anims.delete(key);
                this.removeMix(key);
              }
              return anim;
            },
            resumeAll: function() {
              if (this.paused) {
                this.paused = false;
                this.emit(Events.RESUME_ALL);
              }
              return this;
            },
            toJSON: function(key) {
              var output = {
                anims: [],
                globalTimeScale: this.globalTimeScale
              };
              if (key !== void 0 && key !== "") {
                output.anims.push(this.anims.get(key).toJSON());
              } else {
                this.anims.each(function(animationKey, animation) {
                  output.anims.push(animation.toJSON());
                });
              }
              return output;
            },
            destroy: function() {
              this.anims.clear();
              this.mixes.clear();
              this.textureManager = null;
              this.game = null;
            }
          });
          module2.exports = AnimationManager;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var NumberArray = function(start, end, prefix, suffix) {
            var result = [];
            var i;
            var asString = false;
            if (prefix || suffix) {
              asString = true;
              if (!prefix) {
                prefix = "";
              }
              if (!suffix) {
                suffix = "";
              }
            }
            if (end < start) {
              for (i = start; i >= end; i--) {
                if (asString) {
                  result.push(prefix + i.toString() + suffix);
                } else {
                  result.push(i);
                }
              }
            } else {
              for (i = start; i <= end; i++) {
                if (asString) {
                  result.push(prefix + i.toString() + suffix);
                } else {
                  result.push(i);
                }
              }
            }
            return result;
          };
          module2.exports = NumberArray;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CustomMap = __webpack_require__(99);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(318);
          var BaseCache = new Class({
            initialize: function BaseCache2() {
              this.entries = new CustomMap();
              this.events = new EventEmitter();
            },
            add: function(key, data) {
              this.entries.set(key, data);
              this.events.emit(Events.ADD, this, key, data);
              return this;
            },
            has: function(key) {
              return this.entries.has(key);
            },
            exists: function(key) {
              return this.entries.has(key);
            },
            get: function(key) {
              return this.entries.get(key);
            },
            remove: function(key) {
              var entry = this.get(key);
              if (entry) {
                this.entries.delete(key);
                this.events.emit(Events.REMOVE, this, key, entry.data);
              }
              return this;
            },
            getKeys: function() {
              return this.entries.keys();
            },
            destroy: function() {
              this.entries.clear();
              this.events.removeAllListeners();
              this.entries = null;
              this.events = null;
            }
          });
          module2.exports = BaseCache;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            ADD: __webpack_require__(712),
            REMOVE: __webpack_require__(713)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BaseCache = __webpack_require__(317);
          var Class = __webpack_require__(0);
          var GameEvents = __webpack_require__(22);
          var CacheManager = new Class({
            initialize: function CacheManager2(game) {
              this.game = game;
              this.binary = new BaseCache();
              this.bitmapFont = new BaseCache();
              this.json = new BaseCache();
              this.physics = new BaseCache();
              this.shader = new BaseCache();
              this.audio = new BaseCache();
              this.video = new BaseCache();
              this.text = new BaseCache();
              this.html = new BaseCache();
              this.obj = new BaseCache();
              this.tilemap = new BaseCache();
              this.xml = new BaseCache();
              this.custom = {};
              this.game.events.once(GameEvents.DESTROY, this.destroy, this);
            },
            addCustom: function(key) {
              if (!this.custom.hasOwnProperty(key)) {
                this.custom[key] = new BaseCache();
              }
              return this.custom[key];
            },
            destroy: function() {
              var keys = [
                "binary",
                "bitmapFont",
                "json",
                "physics",
                "shader",
                "audio",
                "video",
                "text",
                "html",
                "obj",
                "tilemap",
                "xml"
              ];
              for (var i = 0; i < keys.length; i++) {
                this[keys[i]].destroy();
                this[keys[i]] = null;
              }
              for (var key in this.custom) {
                this.custom[key].destroy();
              }
              this.custom = null;
              this.game = null;
            }
          });
          module2.exports = CacheManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BaseCamera = __webpack_require__(131);
          var CenterOn = __webpack_require__(187);
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var Effects = __webpack_require__(327);
          var Events = __webpack_require__(36);
          var Linear = __webpack_require__(133);
          var Rectangle = __webpack_require__(10);
          var Vector29 = __webpack_require__(3);
          var Camera = new Class({
            Extends: BaseCamera,
            Mixins: [
              Components.Flip,
              Components.Tint,
              Components.Pipeline
            ],
            initialize: function Camera2(x, y, width, height) {
              BaseCamera.call(this, x, y, width, height);
              this.postPipelines = [];
              this.pipelineData = {};
              this.inputEnabled = true;
              this.fadeEffect = new Effects.Fade(this);
              this.flashEffect = new Effects.Flash(this);
              this.shakeEffect = new Effects.Shake(this);
              this.panEffect = new Effects.Pan(this);
              this.rotateToEffect = new Effects.RotateTo(this);
              this.zoomEffect = new Effects.Zoom(this);
              this.lerp = new Vector29(1, 1);
              this.followOffset = new Vector29();
              this.deadzone = null;
              this._follow = null;
            },
            setDeadzone: function(width, height) {
              if (width === void 0) {
                this.deadzone = null;
              } else {
                if (this.deadzone) {
                  this.deadzone.width = width;
                  this.deadzone.height = height;
                } else {
                  this.deadzone = new Rectangle(0, 0, width, height);
                }
                if (this._follow) {
                  var originX = this.width / 2;
                  var originY = this.height / 2;
                  var fx = this._follow.x - this.followOffset.x;
                  var fy = this._follow.y - this.followOffset.y;
                  this.midPoint.set(fx, fy);
                  this.scrollX = fx - originX;
                  this.scrollY = fy - originY;
                }
                CenterOn(this.deadzone, this.midPoint.x, this.midPoint.y);
              }
              return this;
            },
            fadeIn: function(duration, red, green, blue, callback, context) {
              return this.fadeEffect.start(false, duration, red, green, blue, true, callback, context);
            },
            fadeOut: function(duration, red, green, blue, callback, context) {
              return this.fadeEffect.start(true, duration, red, green, blue, true, callback, context);
            },
            fadeFrom: function(duration, red, green, blue, force, callback, context) {
              return this.fadeEffect.start(false, duration, red, green, blue, force, callback, context);
            },
            fade: function(duration, red, green, blue, force, callback, context) {
              return this.fadeEffect.start(true, duration, red, green, blue, force, callback, context);
            },
            flash: function(duration, red, green, blue, force, callback, context) {
              return this.flashEffect.start(duration, red, green, blue, force, callback, context);
            },
            shake: function(duration, intensity, force, callback, context) {
              return this.shakeEffect.start(duration, intensity, force, callback, context);
            },
            pan: function(x, y, duration, ease, force, callback, context) {
              return this.panEffect.start(x, y, duration, ease, force, callback, context);
            },
            rotateTo: function(radians, shortestPath, duration, ease, force, callback, context) {
              return this.rotateToEffect.start(radians, shortestPath, duration, ease, force, callback, context);
            },
            zoomTo: function(zoom, duration, ease, force, callback, context) {
              return this.zoomEffect.start(zoom, duration, ease, force, callback, context);
            },
            preRender: function() {
              this.renderList.length = 0;
              var width = this.width;
              var height = this.height;
              var halfWidth = width * 0.5;
              var halfHeight = height * 0.5;
              var zoom = this.zoom;
              var matrix = this.matrix;
              var originX = width * this.originX;
              var originY = height * this.originY;
              var follow = this._follow;
              var deadzone = this.deadzone;
              var sx = this.scrollX;
              var sy = this.scrollY;
              if (deadzone) {
                CenterOn(deadzone, this.midPoint.x, this.midPoint.y);
              }
              var emitFollowEvent = false;
              if (follow && !this.panEffect.isRunning) {
                var fx = follow.x - this.followOffset.x;
                var fy = follow.y - this.followOffset.y;
                if (deadzone) {
                  if (fx < deadzone.x) {
                    sx = Linear(sx, sx - (deadzone.x - fx), this.lerp.x);
                  } else if (fx > deadzone.right) {
                    sx = Linear(sx, sx + (fx - deadzone.right), this.lerp.x);
                  }
                  if (fy < deadzone.y) {
                    sy = Linear(sy, sy - (deadzone.y - fy), this.lerp.y);
                  } else if (fy > deadzone.bottom) {
                    sy = Linear(sy, sy + (fy - deadzone.bottom), this.lerp.y);
                  }
                } else {
                  sx = Linear(sx, fx - originX, this.lerp.x);
                  sy = Linear(sy, fy - originY, this.lerp.y);
                }
                emitFollowEvent = true;
              }
              if (this.useBounds) {
                sx = this.clampX(sx);
                sy = this.clampY(sy);
              }
              if (this.roundPixels) {
                originX = Math.round(originX);
                originY = Math.round(originY);
                sx = Math.round(sx);
                sy = Math.round(sy);
              }
              this.scrollX = sx;
              this.scrollY = sy;
              var midX = sx + halfWidth;
              var midY = sy + halfHeight;
              this.midPoint.set(midX, midY);
              var displayWidth = width / zoom;
              var displayHeight = height / zoom;
              var vwx = midX - displayWidth / 2;
              var vwy = midY - displayHeight / 2;
              if (this.roundPixels) {
                vwx = Math.round(vwx);
                vwy = Math.round(vwy);
              }
              this.worldView.setTo(vwx, vwy, displayWidth, displayHeight);
              matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoom, zoom);
              matrix.translate(-originX, -originY);
              this.shakeEffect.preRender();
              if (emitFollowEvent) {
                this.emit(Events.FOLLOW_UPDATE, this, follow);
              }
            },
            setLerp: function(x, y) {
              if (x === void 0) {
                x = 1;
              }
              if (y === void 0) {
                y = x;
              }
              this.lerp.set(x, y);
              return this;
            },
            setFollowOffset: function(x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              this.followOffset.set(x, y);
              return this;
            },
            startFollow: function(target, roundPixels, lerpX, lerpY, offsetX, offsetY) {
              if (roundPixels === void 0) {
                roundPixels = false;
              }
              if (lerpX === void 0) {
                lerpX = 1;
              }
              if (lerpY === void 0) {
                lerpY = lerpX;
              }
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = offsetX;
              }
              this._follow = target;
              this.roundPixels = roundPixels;
              lerpX = Clamp(lerpX, 0, 1);
              lerpY = Clamp(lerpY, 0, 1);
              this.lerp.set(lerpX, lerpY);
              this.followOffset.set(offsetX, offsetY);
              var originX = this.width / 2;
              var originY = this.height / 2;
              var fx = target.x - offsetX;
              var fy = target.y - offsetY;
              this.midPoint.set(fx, fy);
              this.scrollX = fx - originX;
              this.scrollY = fy - originY;
              if (this.useBounds) {
                this.scrollX = this.clampX(this.scrollX);
                this.scrollY = this.clampY(this.scrollY);
              }
              return this;
            },
            stopFollow: function() {
              this._follow = null;
              return this;
            },
            resetFX: function() {
              this.rotateToEffect.reset();
              this.panEffect.reset();
              this.shakeEffect.reset();
              this.flashEffect.reset();
              this.fadeEffect.reset();
              return this;
            },
            update: function(time, delta) {
              if (this.visible) {
                this.rotateToEffect.update(time, delta);
                this.panEffect.update(time, delta);
                this.zoomEffect.update(time, delta);
                this.shakeEffect.update(time, delta);
                this.flashEffect.update(time, delta);
                this.fadeEffect.update(time, delta);
              }
            },
            destroy: function() {
              this.resetFX();
              BaseCamera.prototype.destroy.call(this);
              this._follow = null;
              this.deadzone = null;
            }
          });
          module2.exports = Camera;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Color = __webpack_require__(37);
          var HexStringToColor = function(hex) {
            var color = new Color();
            hex = hex.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r2, g2, b2) {
              return r2 + r2 + g2 + g2 + b2 + b2;
            });
            var result = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (result) {
              var r = parseInt(result[1], 16);
              var g = parseInt(result[2], 16);
              var b = parseInt(result[3], 16);
              color.setTo(r, g, b);
            }
            return color;
          };
          module2.exports = HexStringToColor;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetColor32 = function(red, green, blue, alpha) {
            return alpha << 24 | red << 16 | green << 8 | blue;
          };
          module2.exports = GetColor32;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RGBToHSV = function(r, g, b, out) {
            if (out === void 0) {
              out = {h: 0, s: 0, v: 0};
            }
            r /= 255;
            g /= 255;
            b /= 255;
            var min = Math.min(r, g, b);
            var max = Math.max(r, g, b);
            var d = max - min;
            var h = 0;
            var s = max === 0 ? 0 : d / max;
            var v = max;
            if (max !== min) {
              if (max === r) {
                h = (g - b) / d + (g < b ? 6 : 0);
              } else if (max === g) {
                h = (b - r) / d + 2;
              } else if (max === b) {
                h = (r - g) / d + 4;
              }
              h /= 6;
            }
            if (out.hasOwnProperty("_h")) {
              out._h = h;
              out._s = s;
              out._v = v;
            } else {
              out.h = h;
              out.s = s;
              out.v = v;
            }
            return out;
          };
          module2.exports = RGBToHSV;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var IntegerToRGB = function(color) {
            if (color > 16777215) {
              return {
                a: color >>> 24,
                r: color >> 16 & 255,
                g: color >> 8 & 255,
                b: color & 255
              };
            } else {
              return {
                a: 255,
                r: color >> 16 & 255,
                g: color >> 8 & 255,
                b: color & 255
              };
            }
          };
          module2.exports = IntegerToRGB;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Color = __webpack_require__(37);
          var ObjectToColor = function(input) {
            return new Color(input.r, input.g, input.b, input.a);
          };
          module2.exports = ObjectToColor;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Color = __webpack_require__(37);
          var RGBStringToColor = function(rgb) {
            var color = new Color();
            var result = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(rgb.toLowerCase());
            if (result) {
              var r = parseInt(result[1], 10);
              var g = parseInt(result[2], 10);
              var b = parseInt(result[3], 10);
              var a = result[4] !== void 0 ? parseFloat(result[4]) : 1;
              color.setTo(r, g, b, a * 255);
            }
            return color;
          };
          module2.exports = RGBStringToColor;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Fade: __webpack_require__(737),
            Flash: __webpack_require__(738),
            Pan: __webpack_require__(739),
            Shake: __webpack_require__(772),
            RotateTo: __webpack_require__(773),
            Zoom: __webpack_require__(774)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            In: __webpack_require__(740),
            Out: __webpack_require__(741),
            InOut: __webpack_require__(742)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            In: __webpack_require__(743),
            Out: __webpack_require__(744),
            InOut: __webpack_require__(745)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            In: __webpack_require__(746),
            Out: __webpack_require__(747),
            InOut: __webpack_require__(748)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            In: __webpack_require__(749),
            Out: __webpack_require__(750),
            InOut: __webpack_require__(751)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            In: __webpack_require__(752),
            Out: __webpack_require__(753),
            InOut: __webpack_require__(754)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            In: __webpack_require__(755),
            Out: __webpack_require__(756),
            InOut: __webpack_require__(757)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = __webpack_require__(758);
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            In: __webpack_require__(759),
            Out: __webpack_require__(760),
            InOut: __webpack_require__(761)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            In: __webpack_require__(762),
            Out: __webpack_require__(763),
            InOut: __webpack_require__(764)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            In: __webpack_require__(765),
            Out: __webpack_require__(766),
            InOut: __webpack_require__(767)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            In: __webpack_require__(768),
            Out: __webpack_require__(769),
            InOut: __webpack_require__(770)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = __webpack_require__(771);
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(32);
          var Device = __webpack_require__(341);
          var GetFastValue = __webpack_require__(2);
          var GetValue = __webpack_require__(6);
          var IsPlainObject = __webpack_require__(7);
          var PhaserMath = __webpack_require__(190);
          var NOOP = __webpack_require__(1);
          var DefaultPlugins = __webpack_require__(194);
          var ValueToColor = __webpack_require__(184);
          var Config = new Class({
            initialize: function Config2(config2) {
              if (config2 === void 0) {
                config2 = {};
              }
              var defaultBannerColor = [
                "#ff0000",
                "#ffff00",
                "#00ff00",
                "#00ffff",
                "#000000"
              ];
              var defaultBannerTextColor = "#ffffff";
              this.width = GetValue(config2, "width", 1024);
              this.height = GetValue(config2, "height", 768);
              this.zoom = GetValue(config2, "zoom", 1);
              this.parent = GetValue(config2, "parent", void 0);
              this.scaleMode = GetValue(config2, "scaleMode", 0);
              this.expandParent = GetValue(config2, "expandParent", true);
              this.autoRound = GetValue(config2, "autoRound", false);
              this.autoCenter = GetValue(config2, "autoCenter", 0);
              this.resizeInterval = GetValue(config2, "resizeInterval", 500);
              this.fullscreenTarget = GetValue(config2, "fullscreenTarget", null);
              this.minWidth = GetValue(config2, "minWidth", 0);
              this.maxWidth = GetValue(config2, "maxWidth", 0);
              this.minHeight = GetValue(config2, "minHeight", 0);
              this.maxHeight = GetValue(config2, "maxHeight", 0);
              var scaleConfig = GetValue(config2, "scale", null);
              if (scaleConfig) {
                this.width = GetValue(scaleConfig, "width", this.width);
                this.height = GetValue(scaleConfig, "height", this.height);
                this.zoom = GetValue(scaleConfig, "zoom", this.zoom);
                this.parent = GetValue(scaleConfig, "parent", this.parent);
                this.scaleMode = GetValue(scaleConfig, "mode", this.scaleMode);
                this.expandParent = GetValue(scaleConfig, "expandParent", this.expandParent);
                this.autoRound = GetValue(scaleConfig, "autoRound", this.autoRound);
                this.autoCenter = GetValue(scaleConfig, "autoCenter", this.autoCenter);
                this.resizeInterval = GetValue(scaleConfig, "resizeInterval", this.resizeInterval);
                this.fullscreenTarget = GetValue(scaleConfig, "fullscreenTarget", this.fullscreenTarget);
                this.minWidth = GetValue(scaleConfig, "min.width", this.minWidth);
                this.maxWidth = GetValue(scaleConfig, "max.width", this.maxWidth);
                this.minHeight = GetValue(scaleConfig, "min.height", this.minHeight);
                this.maxHeight = GetValue(scaleConfig, "max.height", this.maxHeight);
              }
              this.renderType = GetValue(config2, "type", CONST.AUTO);
              this.canvas = GetValue(config2, "canvas", null);
              this.context = GetValue(config2, "context", null);
              this.canvasStyle = GetValue(config2, "canvasStyle", null);
              this.customEnvironment = GetValue(config2, "customEnvironment", false);
              this.sceneConfig = GetValue(config2, "scene", null);
              this.seed = GetValue(config2, "seed", [(Date.now() * Math.random()).toString()]);
              PhaserMath.RND = new PhaserMath.RandomDataGenerator(this.seed);
              this.gameTitle = GetValue(config2, "title", "");
              this.gameURL = GetValue(config2, "url", "https://phaser.io");
              this.gameVersion = GetValue(config2, "version", "");
              this.autoFocus = GetValue(config2, "autoFocus", true);
              this.domCreateContainer = GetValue(config2, "dom.createContainer", false);
              this.domBehindCanvas = GetValue(config2, "dom.behindCanvas", false);
              this.inputKeyboard = GetValue(config2, "input.keyboard", true);
              this.inputKeyboardEventTarget = GetValue(config2, "input.keyboard.target", window);
              this.inputKeyboardCapture = GetValue(config2, "input.keyboard.capture", []);
              this.inputMouse = GetValue(config2, "input.mouse", true);
              this.inputMouseEventTarget = GetValue(config2, "input.mouse.target", null);
              this.inputMousePreventDefaultDown = GetValue(config2, "input.mouse.preventDefaultDown", true);
              this.inputMousePreventDefaultUp = GetValue(config2, "input.mouse.preventDefaultUp", true);
              this.inputMousePreventDefaultMove = GetValue(config2, "input.mouse.preventDefaultMove", true);
              this.inputMousePreventDefaultWheel = GetValue(config2, "input.mouse.preventDefaultWheel", true);
              this.inputTouch = GetValue(config2, "input.touch", Device.input.touch);
              this.inputTouchEventTarget = GetValue(config2, "input.touch.target", null);
              this.inputTouchCapture = GetValue(config2, "input.touch.capture", true);
              this.inputActivePointers = GetValue(config2, "input.activePointers", 1);
              this.inputSmoothFactor = GetValue(config2, "input.smoothFactor", 0);
              this.inputWindowEvents = GetValue(config2, "input.windowEvents", true);
              this.inputGamepad = GetValue(config2, "input.gamepad", false);
              this.inputGamepadEventTarget = GetValue(config2, "input.gamepad.target", window);
              this.disableContextMenu = GetValue(config2, "disableContextMenu", false);
              this.audio = GetValue(config2, "audio", {});
              this.hideBanner = GetValue(config2, "banner", null) === false;
              this.hidePhaser = GetValue(config2, "banner.hidePhaser", false);
              this.bannerTextColor = GetValue(config2, "banner.text", defaultBannerTextColor);
              this.bannerBackgroundColor = GetValue(config2, "banner.background", defaultBannerColor);
              if (this.gameTitle === "" && this.hidePhaser) {
                this.hideBanner = true;
              }
              this.fps = GetValue(config2, "fps", null);
              var renderConfig = GetValue(config2, "render", config2);
              this.pipeline = GetValue(renderConfig, "pipeline", null);
              this.antialias = GetValue(renderConfig, "antialias", true);
              this.antialiasGL = GetValue(renderConfig, "antialiasGL", true);
              this.mipmapFilter = GetValue(renderConfig, "mipmapFilter", "LINEAR");
              this.desynchronized = GetValue(renderConfig, "desynchronized", false);
              this.roundPixels = GetValue(renderConfig, "roundPixels", false);
              this.pixelArt = GetValue(renderConfig, "pixelArt", this.zoom !== 1);
              if (this.pixelArt) {
                this.antialias = false;
                this.antialiasGL = false;
                this.roundPixels = true;
              }
              this.transparent = GetValue(renderConfig, "transparent", false);
              this.clearBeforeRender = GetValue(renderConfig, "clearBeforeRender", true);
              this.premultipliedAlpha = GetValue(renderConfig, "premultipliedAlpha", true);
              this.failIfMajorPerformanceCaveat = GetValue(renderConfig, "failIfMajorPerformanceCaveat", false);
              this.powerPreference = GetValue(renderConfig, "powerPreference", "default");
              this.batchSize = GetValue(renderConfig, "batchSize", 4096);
              this.maxTextures = GetValue(renderConfig, "maxTextures", -1);
              this.maxLights = GetValue(renderConfig, "maxLights", 10);
              var bgc = GetValue(config2, "backgroundColor", 0);
              this.backgroundColor = ValueToColor(bgc);
              if (this.transparent) {
                this.backgroundColor = ValueToColor(0);
                this.backgroundColor.alpha = 0;
              }
              this.preBoot = GetValue(config2, "callbacks.preBoot", NOOP);
              this.postBoot = GetValue(config2, "callbacks.postBoot", NOOP);
              this.physics = GetValue(config2, "physics", {});
              this.defaultPhysicsSystem = GetValue(this.physics, "default", false);
              this.loaderBaseURL = GetValue(config2, "loader.baseURL", "");
              this.loaderPath = GetValue(config2, "loader.path", "");
              var defaultParallel = Device.os.android ? 6 : 32;
              this.loaderMaxParallelDownloads = GetValue(config2, "loader.maxParallelDownloads", defaultParallel);
              this.loaderCrossOrigin = GetValue(config2, "loader.crossOrigin", void 0);
              this.loaderResponseType = GetValue(config2, "loader.responseType", "");
              this.loaderAsync = GetValue(config2, "loader.async", true);
              this.loaderUser = GetValue(config2, "loader.user", "");
              this.loaderPassword = GetValue(config2, "loader.password", "");
              this.loaderTimeout = GetValue(config2, "loader.timeout", 0);
              this.loaderWithCredentials = GetValue(config2, "loader.withCredentials", false);
              this.installGlobalPlugins = [];
              this.installScenePlugins = [];
              var plugins = GetValue(config2, "plugins", null);
              var defaultPlugins = DefaultPlugins.DefaultScene;
              if (plugins) {
                if (Array.isArray(plugins)) {
                  this.defaultPlugins = plugins;
                } else if (IsPlainObject(plugins)) {
                  this.installGlobalPlugins = GetFastValue(plugins, "global", []);
                  this.installScenePlugins = GetFastValue(plugins, "scene", []);
                  if (Array.isArray(plugins.default)) {
                    defaultPlugins = plugins.default;
                  } else if (Array.isArray(plugins.defaultMerge)) {
                    defaultPlugins = defaultPlugins.concat(plugins.defaultMerge);
                  }
                }
              }
              this.defaultPlugins = defaultPlugins;
              var pngPrefix = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg";
              this.defaultImage = GetValue(config2, "images.default", pngPrefix + "AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==");
              this.missingImage = GetValue(config2, "images.missing", pngPrefix + "CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==");
              this.whiteImage = GetValue(config2, "images.white", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABdJREFUeNpi/P//PwMMMDEgAdwcgAADAJZuAwXJYZOzAAAAAElFTkSuQmCC");
              if (window) {
                if (window.FORCE_WEBGL) {
                  this.renderType = CONST.WEBGL;
                } else if (window.FORCE_CANVAS) {
                  this.renderType = CONST.CANVAS;
                }
              }
            }
          });
          module2.exports = Config;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            os: __webpack_require__(102),
            browser: __webpack_require__(134),
            features: __webpack_require__(188),
            input: __webpack_require__(805),
            audio: __webpack_require__(806),
            video: __webpack_require__(807),
            fullscreen: __webpack_require__(808),
            canvasFeatures: __webpack_require__(342)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CanvasPool = __webpack_require__(31);
          var CanvasFeatures = {
            supportInverseAlpha: false,
            supportNewBlendModes: false
          };
          function checkBlendMode() {
            var pngHead = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/";
            var pngEnd = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==";
            var magenta = new Image();
            magenta.onload = function() {
              var yellow = new Image();
              yellow.onload = function() {
                var canvas = CanvasPool.create(yellow, 6, 1);
                var context = canvas.getContext("2d");
                context.globalCompositeOperation = "multiply";
                context.drawImage(magenta, 0, 0);
                context.drawImage(yellow, 2, 0);
                if (!context.getImageData(2, 0, 1, 1)) {
                  return false;
                }
                var data = context.getImageData(2, 0, 1, 1).data;
                CanvasPool.remove(yellow);
                CanvasFeatures.supportNewBlendModes = data[0] === 255 && data[1] === 0 && data[2] === 0;
              };
              yellow.src = pngHead + "/wCKxvRF" + pngEnd;
            };
            magenta.src = pngHead + "AP804Oa6" + pngEnd;
            return false;
          }
          function checkInverseAlpha() {
            var canvas = CanvasPool.create(this, 2, 1);
            var context = canvas.getContext("2d");
            context.fillStyle = "rgba(10, 20, 30, 0.5)";
            context.fillRect(0, 0, 1, 1);
            var s1 = context.getImageData(0, 0, 1, 1);
            if (s1 === null) {
              return false;
            }
            context.putImageData(s1, 1, 0);
            var s2 = context.getImageData(1, 0, 1, 1);
            return s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3];
          }
          function init() {
            if (document !== void 0) {
              CanvasFeatures.supportNewBlendModes = checkBlendMode();
              CanvasFeatures.supportInverseAlpha = checkInverseAlpha();
            }
            return CanvasFeatures;
          }
          module2.exports = init();
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Between = function(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
          };
          module2.exports = Between;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BetweenPoints = function(point1, point2) {
            return Math.atan2(point2.y - point1.y, point2.x - point1.x);
          };
          module2.exports = BetweenPoints;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Normalize = function(angle) {
            angle = angle % (2 * Math.PI);
            if (angle >= 0) {
              return angle;
            } else {
              return angle + 2 * Math.PI;
            }
          };
          module2.exports = Normalize;
        },
        function(module2, exports2) {
          /**
           * @author       samme
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DistanceBetweenPoints = function(a, b) {
            var dx = a.x - b.x;
            var dy = a.y - b.y;
            return Math.sqrt(dx * dx + dy * dy);
          };
          module2.exports = DistanceBetweenPoints;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DistanceSquared = function(x1, y1, x2, y2) {
            var dx = x1 - x2;
            var dy = y1 - y2;
            return dx * dx + dy * dy;
          };
          module2.exports = DistanceSquared;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GreaterThan = function(a, b, epsilon) {
            if (epsilon === void 0) {
              epsilon = 1e-4;
            }
            return a > b - epsilon;
          };
          module2.exports = GreaterThan;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var LessThan = function(a, b, epsilon) {
            if (epsilon === void 0) {
              epsilon = 1e-4;
            }
            return a < b + epsilon;
          };
          module2.exports = LessThan;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Factorial = __webpack_require__(351);
          var Bernstein = function(n, i) {
            return Factorial(n) / Factorial(i) / Factorial(n - i);
          };
          module2.exports = Bernstein;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Factorial = function(value) {
            if (value === 0) {
              return 1;
            }
            var res = value;
            while (--value) {
              res *= value;
            }
            return res;
          };
          module2.exports = Factorial;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          function P0(t, p) {
            var k = 1 - t;
            return k * k * k * p;
          }
          function P1(t, p) {
            var k = 1 - t;
            return 3 * k * k * t * p;
          }
          function P2(t, p) {
            return 3 * (1 - t) * t * t * p;
          }
          function P3(t, p) {
            return t * t * t * p;
          }
          var CubicBezierInterpolation = function(t, p0, p1, p2, p3) {
            return P0(t, p0) + P1(t, p1) + P2(t, p2) + P3(t, p3);
          };
          module2.exports = CubicBezierInterpolation;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          function P0(t, p) {
            var k = 1 - t;
            return k * k * p;
          }
          function P1(t, p) {
            return 2 * (1 - t) * t * p;
          }
          function P2(t, p) {
            return t * t * p;
          }
          var QuadraticBezierInterpolation = function(t, p0, p1, p2) {
            return P0(t, p0) + P1(t, p1) + P2(t, p2);
          };
          module2.exports = QuadraticBezierInterpolation;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SmoothStep = __webpack_require__(181);
          var SmoothStepInterpolation = function(t, min, max) {
            return min + (max - min) * SmoothStep(t, 0, 1);
          };
          module2.exports = SmoothStepInterpolation;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetPowerOfTwo = function(value) {
            var index = Math.log(value) / 0.6931471805599453;
            return 1 << Math.ceil(index);
          };
          module2.exports = GetPowerOfTwo;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rotate = function(point, angle) {
            var x = point.x;
            var y = point.y;
            point.x = x * Math.cos(angle) - y * Math.sin(angle);
            point.y = x * Math.sin(angle) + y * Math.cos(angle);
            return point;
          };
          module2.exports = Rotate;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RoundAwayFromZero = function(value) {
            return value > 0 ? Math.ceil(value) : Math.floor(value);
          };
          module2.exports = RoundAwayFromZero;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Matrix3 = new Class({
            initialize: function Matrix32(m) {
              this.val = new Float32Array(9);
              if (m) {
                this.copy(m);
              } else {
                this.identity();
              }
            },
            clone: function() {
              return new Matrix3(this);
            },
            set: function(src) {
              return this.copy(src);
            },
            copy: function(src) {
              var out = this.val;
              var a = src.val;
              out[0] = a[0];
              out[1] = a[1];
              out[2] = a[2];
              out[3] = a[3];
              out[4] = a[4];
              out[5] = a[5];
              out[6] = a[6];
              out[7] = a[7];
              out[8] = a[8];
              return this;
            },
            fromMat4: function(m) {
              var a = m.val;
              var out = this.val;
              out[0] = a[0];
              out[1] = a[1];
              out[2] = a[2];
              out[3] = a[4];
              out[4] = a[5];
              out[5] = a[6];
              out[6] = a[8];
              out[7] = a[9];
              out[8] = a[10];
              return this;
            },
            fromArray: function(a) {
              var out = this.val;
              out[0] = a[0];
              out[1] = a[1];
              out[2] = a[2];
              out[3] = a[3];
              out[4] = a[4];
              out[5] = a[5];
              out[6] = a[6];
              out[7] = a[7];
              out[8] = a[8];
              return this;
            },
            identity: function() {
              var out = this.val;
              out[0] = 1;
              out[1] = 0;
              out[2] = 0;
              out[3] = 0;
              out[4] = 1;
              out[5] = 0;
              out[6] = 0;
              out[7] = 0;
              out[8] = 1;
              return this;
            },
            transpose: function() {
              var a = this.val;
              var a01 = a[1];
              var a02 = a[2];
              var a12 = a[5];
              a[1] = a[3];
              a[2] = a[6];
              a[3] = a01;
              a[5] = a[7];
              a[6] = a02;
              a[7] = a12;
              return this;
            },
            invert: function() {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a10 = a[3];
              var a11 = a[4];
              var a12 = a[5];
              var a20 = a[6];
              var a21 = a[7];
              var a22 = a[8];
              var b01 = a22 * a11 - a12 * a21;
              var b11 = -a22 * a10 + a12 * a20;
              var b21 = a21 * a10 - a11 * a20;
              var det = a00 * b01 + a01 * b11 + a02 * b21;
              if (!det) {
                return null;
              }
              det = 1 / det;
              a[0] = b01 * det;
              a[1] = (-a22 * a01 + a02 * a21) * det;
              a[2] = (a12 * a01 - a02 * a11) * det;
              a[3] = b11 * det;
              a[4] = (a22 * a00 - a02 * a20) * det;
              a[5] = (-a12 * a00 + a02 * a10) * det;
              a[6] = b21 * det;
              a[7] = (-a21 * a00 + a01 * a20) * det;
              a[8] = (a11 * a00 - a01 * a10) * det;
              return this;
            },
            adjoint: function() {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a10 = a[3];
              var a11 = a[4];
              var a12 = a[5];
              var a20 = a[6];
              var a21 = a[7];
              var a22 = a[8];
              a[0] = a11 * a22 - a12 * a21;
              a[1] = a02 * a21 - a01 * a22;
              a[2] = a01 * a12 - a02 * a11;
              a[3] = a12 * a20 - a10 * a22;
              a[4] = a00 * a22 - a02 * a20;
              a[5] = a02 * a10 - a00 * a12;
              a[6] = a10 * a21 - a11 * a20;
              a[7] = a01 * a20 - a00 * a21;
              a[8] = a00 * a11 - a01 * a10;
              return this;
            },
            determinant: function() {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a10 = a[3];
              var a11 = a[4];
              var a12 = a[5];
              var a20 = a[6];
              var a21 = a[7];
              var a22 = a[8];
              return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
            },
            multiply: function(src) {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a10 = a[3];
              var a11 = a[4];
              var a12 = a[5];
              var a20 = a[6];
              var a21 = a[7];
              var a22 = a[8];
              var b = src.val;
              var b00 = b[0];
              var b01 = b[1];
              var b02 = b[2];
              var b10 = b[3];
              var b11 = b[4];
              var b12 = b[5];
              var b20 = b[6];
              var b21 = b[7];
              var b22 = b[8];
              a[0] = b00 * a00 + b01 * a10 + b02 * a20;
              a[1] = b00 * a01 + b01 * a11 + b02 * a21;
              a[2] = b00 * a02 + b01 * a12 + b02 * a22;
              a[3] = b10 * a00 + b11 * a10 + b12 * a20;
              a[4] = b10 * a01 + b11 * a11 + b12 * a21;
              a[5] = b10 * a02 + b11 * a12 + b12 * a22;
              a[6] = b20 * a00 + b21 * a10 + b22 * a20;
              a[7] = b20 * a01 + b21 * a11 + b22 * a21;
              a[8] = b20 * a02 + b21 * a12 + b22 * a22;
              return this;
            },
            translate: function(v) {
              var a = this.val;
              var x = v.x;
              var y = v.y;
              a[6] = x * a[0] + y * a[3] + a[6];
              a[7] = x * a[1] + y * a[4] + a[7];
              a[8] = x * a[2] + y * a[5] + a[8];
              return this;
            },
            rotate: function(rad) {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a10 = a[3];
              var a11 = a[4];
              var a12 = a[5];
              var s = Math.sin(rad);
              var c = Math.cos(rad);
              a[0] = c * a00 + s * a10;
              a[1] = c * a01 + s * a11;
              a[2] = c * a02 + s * a12;
              a[3] = c * a10 - s * a00;
              a[4] = c * a11 - s * a01;
              a[5] = c * a12 - s * a02;
              return this;
            },
            scale: function(v) {
              var a = this.val;
              var x = v.x;
              var y = v.y;
              a[0] = x * a[0];
              a[1] = x * a[1];
              a[2] = x * a[2];
              a[3] = y * a[3];
              a[4] = y * a[4];
              a[5] = y * a[5];
              return this;
            },
            fromQuat: function(q) {
              var x = q.x;
              var y = q.y;
              var z = q.z;
              var w = q.w;
              var x2 = x + x;
              var y2 = y + y;
              var z2 = z + z;
              var xx = x * x2;
              var xy = x * y2;
              var xz = x * z2;
              var yy = y * y2;
              var yz = y * z2;
              var zz = z * z2;
              var wx = w * x2;
              var wy = w * y2;
              var wz = w * z2;
              var out = this.val;
              out[0] = 1 - (yy + zz);
              out[3] = xy + wz;
              out[6] = xz - wy;
              out[1] = xy - wz;
              out[4] = 1 - (xx + zz);
              out[7] = yz + wx;
              out[2] = xz + wy;
              out[5] = yz - wx;
              out[8] = 1 - (xx + yy);
              return this;
            },
            normalFromMat4: function(m) {
              var a = m.val;
              var out = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              var a30 = a[12];
              var a31 = a[13];
              var a32 = a[14];
              var a33 = a[15];
              var b00 = a00 * a11 - a01 * a10;
              var b01 = a00 * a12 - a02 * a10;
              var b02 = a00 * a13 - a03 * a10;
              var b03 = a01 * a12 - a02 * a11;
              var b04 = a01 * a13 - a03 * a11;
              var b05 = a02 * a13 - a03 * a12;
              var b06 = a20 * a31 - a21 * a30;
              var b07 = a20 * a32 - a22 * a30;
              var b08 = a20 * a33 - a23 * a30;
              var b09 = a21 * a32 - a22 * a31;
              var b10 = a21 * a33 - a23 * a31;
              var b11 = a22 * a33 - a23 * a32;
              var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
              if (!det) {
                return null;
              }
              det = 1 / det;
              out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
              out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
              out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
              out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
              out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
              out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
              out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
              out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
              out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
              return this;
            }
          });
          module2.exports = Matrix3;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Matrix3 = __webpack_require__(358);
          var NOOP = __webpack_require__(1);
          var Vector3 = __webpack_require__(38);
          var EPSILON = 1e-6;
          var siNext = new Int8Array([1, 2, 0]);
          var tmp = new Float32Array([0, 0, 0]);
          var xUnitVec3 = new Vector3(1, 0, 0);
          var yUnitVec3 = new Vector3(0, 1, 0);
          var tmpvec = new Vector3();
          var tmpMat3 = new Matrix3();
          var Quaternion = new Class({
            initialize: function Quaternion2(x, y, z, w) {
              this.onChangeCallback = NOOP;
              this.set(x, y, z, w);
            },
            x: {
              get: function() {
                return this._x;
              },
              set: function(value) {
                this._x = value;
                this.onChangeCallback(this);
              }
            },
            y: {
              get: function() {
                return this._y;
              },
              set: function(value) {
                this._y = value;
                this.onChangeCallback(this);
              }
            },
            z: {
              get: function() {
                return this._z;
              },
              set: function(value) {
                this._z = value;
                this.onChangeCallback(this);
              }
            },
            w: {
              get: function() {
                return this._w;
              },
              set: function(value) {
                this._w = value;
                this.onChangeCallback(this);
              }
            },
            copy: function(src) {
              return this.set(src);
            },
            set: function(x, y, z, w, update) {
              if (update === void 0) {
                update = true;
              }
              if (typeof x === "object") {
                this._x = x.x || 0;
                this._y = x.y || 0;
                this._z = x.z || 0;
                this._w = x.w || 0;
              } else {
                this._x = x || 0;
                this._y = y || 0;
                this._z = z || 0;
                this._w = w || 0;
              }
              if (update) {
                this.onChangeCallback(this);
              }
              return this;
            },
            add: function(v) {
              this._x += v.x;
              this._y += v.y;
              this._z += v.z;
              this._w += v.w;
              this.onChangeCallback(this);
              return this;
            },
            subtract: function(v) {
              this._x -= v.x;
              this._y -= v.y;
              this._z -= v.z;
              this._w -= v.w;
              this.onChangeCallback(this);
              return this;
            },
            scale: function(scale) {
              this._x *= scale;
              this._y *= scale;
              this._z *= scale;
              this._w *= scale;
              this.onChangeCallback(this);
              return this;
            },
            length: function() {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var w = this.w;
              return Math.sqrt(x * x + y * y + z * z + w * w);
            },
            lengthSq: function() {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var w = this.w;
              return x * x + y * y + z * z + w * w;
            },
            normalize: function() {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var w = this.w;
              var len = x * x + y * y + z * z + w * w;
              if (len > 0) {
                len = 1 / Math.sqrt(len);
                this._x = x * len;
                this._y = y * len;
                this._z = z * len;
                this._w = w * len;
              }
              this.onChangeCallback(this);
              return this;
            },
            dot: function(v) {
              return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
            },
            lerp: function(v, t) {
              if (t === void 0) {
                t = 0;
              }
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var aw = this.w;
              return this.set(ax + t * (v.x - ax), ay + t * (v.y - ay), az + t * (v.z - az), aw + t * (v.w - aw));
            },
            rotationTo: function(a, b) {
              var dot = a.x * b.x + a.y * b.y + a.z * b.z;
              if (dot < -0.999999) {
                if (tmpvec.copy(xUnitVec3).cross(a).length() < EPSILON) {
                  tmpvec.copy(yUnitVec3).cross(a);
                }
                tmpvec.normalize();
                return this.setAxisAngle(tmpvec, Math.PI);
              } else if (dot > 0.999999) {
                return this.set(0, 0, 0, 1);
              } else {
                tmpvec.copy(a).cross(b);
                this._x = tmpvec.x;
                this._y = tmpvec.y;
                this._z = tmpvec.z;
                this._w = 1 + dot;
                return this.normalize();
              }
            },
            setAxes: function(view, right, up) {
              var m = tmpMat3.val;
              m[0] = right.x;
              m[3] = right.y;
              m[6] = right.z;
              m[1] = up.x;
              m[4] = up.y;
              m[7] = up.z;
              m[2] = -view.x;
              m[5] = -view.y;
              m[8] = -view.z;
              return this.fromMat3(tmpMat3).normalize();
            },
            identity: function() {
              return this.set(0, 0, 0, 1);
            },
            setAxisAngle: function(axis, rad) {
              rad = rad * 0.5;
              var s = Math.sin(rad);
              return this.set(s * axis.x, s * axis.y, s * axis.z, Math.cos(rad));
            },
            multiply: function(b) {
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var aw = this.w;
              var bx = b.x;
              var by = b.y;
              var bz = b.z;
              var bw = b.w;
              return this.set(ax * bw + aw * bx + ay * bz - az * by, ay * bw + aw * by + az * bx - ax * bz, az * bw + aw * bz + ax * by - ay * bx, aw * bw - ax * bx - ay * by - az * bz);
            },
            slerp: function(b, t) {
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var aw = this.w;
              var bx = b.x;
              var by = b.y;
              var bz = b.z;
              var bw = b.w;
              var cosom = ax * bx + ay * by + az * bz + aw * bw;
              if (cosom < 0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
              }
              var scale0 = 1 - t;
              var scale1 = t;
              if (1 - cosom > EPSILON) {
                var omega = Math.acos(cosom);
                var sinom = Math.sin(omega);
                scale0 = Math.sin((1 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
              }
              return this.set(scale0 * ax + scale1 * bx, scale0 * ay + scale1 * by, scale0 * az + scale1 * bz, scale0 * aw + scale1 * bw);
            },
            invert: function() {
              var a0 = this.x;
              var a1 = this.y;
              var a2 = this.z;
              var a3 = this.w;
              var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
              var invDot = dot ? 1 / dot : 0;
              return this.set(-a0 * invDot, -a1 * invDot, -a2 * invDot, a3 * invDot);
            },
            conjugate: function() {
              this._x = -this.x;
              this._y = -this.y;
              this._z = -this.z;
              this.onChangeCallback(this);
              return this;
            },
            rotateX: function(rad) {
              rad *= 0.5;
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var aw = this.w;
              var bx = Math.sin(rad);
              var bw = Math.cos(rad);
              return this.set(ax * bw + aw * bx, ay * bw + az * bx, az * bw - ay * bx, aw * bw - ax * bx);
            },
            rotateY: function(rad) {
              rad *= 0.5;
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var aw = this.w;
              var by = Math.sin(rad);
              var bw = Math.cos(rad);
              return this.set(ax * bw - az * by, ay * bw + aw * by, az * bw + ax * by, aw * bw - ay * by);
            },
            rotateZ: function(rad) {
              rad *= 0.5;
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var aw = this.w;
              var bz = Math.sin(rad);
              var bw = Math.cos(rad);
              return this.set(ax * bw + ay * bz, ay * bw - ax * bz, az * bw + aw * bz, aw * bw - az * bz);
            },
            calculateW: function() {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              this.w = -Math.sqrt(1 - x * x - y * y - z * z);
              return this;
            },
            setFromEuler: function(euler, update) {
              var x = euler.x / 2;
              var y = euler.y / 2;
              var z = euler.z / 2;
              var c1 = Math.cos(x);
              var c2 = Math.cos(y);
              var c3 = Math.cos(z);
              var s1 = Math.sin(x);
              var s2 = Math.sin(y);
              var s3 = Math.sin(z);
              switch (euler.order) {
                case "XYZ": {
                  this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
                  break;
                }
                case "YXZ": {
                  this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
                  break;
                }
                case "ZXY": {
                  this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
                  break;
                }
                case "ZYX": {
                  this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
                  break;
                }
                case "YZX": {
                  this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
                  break;
                }
                case "XZY": {
                  this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
                  break;
                }
              }
              return this;
            },
            setFromRotationMatrix: function(mat4) {
              var m = mat4.val;
              var m11 = m[0];
              var m12 = m[4];
              var m13 = m[8];
              var m21 = m[1];
              var m22 = m[5];
              var m23 = m[9];
              var m31 = m[2];
              var m32 = m[6];
              var m33 = m[10];
              var trace = m11 + m22 + m33;
              var s;
              if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1);
                this.set((m32 - m23) * s, (m13 - m31) * s, (m21 - m12) * s, 0.25 / s);
              } else if (m11 > m22 && m11 > m33) {
                s = 2 * Math.sqrt(1 + m11 - m22 - m33);
                this.set(0.25 * s, (m12 + m21) / s, (m13 + m31) / s, (m32 - m23) / s);
              } else if (m22 > m33) {
                s = 2 * Math.sqrt(1 + m22 - m11 - m33);
                this.set((m12 + m21) / s, 0.25 * s, (m23 + m32) / s, (m13 - m31) / s);
              } else {
                s = 2 * Math.sqrt(1 + m33 - m11 - m22);
                this.set((m13 + m31) / s, (m23 + m32) / s, 0.25 * s, (m21 - m12) / s);
              }
              return this;
            },
            fromMat3: function(mat) {
              var m = mat.val;
              var fTrace = m[0] + m[4] + m[8];
              var fRoot;
              if (fTrace > 0) {
                fRoot = Math.sqrt(fTrace + 1);
                this.w = 0.5 * fRoot;
                fRoot = 0.5 / fRoot;
                this._x = (m[7] - m[5]) * fRoot;
                this._y = (m[2] - m[6]) * fRoot;
                this._z = (m[3] - m[1]) * fRoot;
              } else {
                var i = 0;
                if (m[4] > m[0]) {
                  i = 1;
                }
                if (m[8] > m[i * 3 + i]) {
                  i = 2;
                }
                var j = siNext[i];
                var k = siNext[j];
                fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
                tmp[i] = 0.5 * fRoot;
                fRoot = 0.5 / fRoot;
                tmp[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
                tmp[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
                this._x = tmp[0];
                this._y = tmp[1];
                this._z = tmp[2];
                this._w = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;
              }
              this.onChangeCallback(this);
              return this;
            }
          });
          module2.exports = Quaternion;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CanvasInterpolation = __webpack_require__(361);
          var CanvasPool = __webpack_require__(31);
          var CONST = __webpack_require__(32);
          var Features = __webpack_require__(188);
          var CreateRenderer = function(game) {
            var config2 = game.config;
            if ((config2.customEnvironment || config2.canvas) && config2.renderType === CONST.AUTO) {
              throw new Error("Must set explicit renderType in custom environment");
            }
            if (!config2.customEnvironment && !config2.canvas && config2.renderType !== CONST.HEADLESS) {
              if (config2.renderType === CONST.CANVAS || config2.renderType !== CONST.CANVAS && !Features.webGL) {
                if (Features.canvas) {
                  config2.renderType = CONST.CANVAS;
                } else {
                  throw new Error("Cannot create Canvas or WebGL context, aborting.");
                }
              } else {
                config2.renderType = CONST.WEBGL;
              }
            }
            if (!config2.antialias) {
              CanvasPool.disableSmoothing();
            }
            var baseSize = game.scale.baseSize;
            var width = baseSize.width;
            var height = baseSize.height;
            if (config2.canvas) {
              game.canvas = config2.canvas;
              game.canvas.width = width;
              game.canvas.height = height;
            } else {
              game.canvas = CanvasPool.create(game, width, height, config2.renderType);
            }
            if (config2.canvasStyle) {
              game.canvas.style = config2.canvasStyle;
            }
            if (!config2.antialias) {
              CanvasInterpolation.setCrisp(game.canvas);
            }
            if (config2.renderType === CONST.HEADLESS) {
              return;
            }
            var CanvasRenderer;
            var WebGLRenderer;
            if (true) {
              CanvasRenderer = __webpack_require__(362);
              WebGLRenderer = __webpack_require__(365);
              if (config2.renderType === CONST.WEBGL) {
                game.renderer = new WebGLRenderer(game);
              } else {
                game.renderer = new CanvasRenderer(game);
                game.context = game.renderer.gameContext;
              }
            }
            if (false) {
            }
            if (false) {
            }
          };
          module2.exports = CreateRenderer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CanvasInterpolation = {
            setCrisp: function(canvas) {
              var types = ["optimizeSpeed", "-moz-crisp-edges", "-o-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "crisp-edges", "pixelated"];
              types.forEach(function(type) {
                canvas.style["image-rendering"] = type;
              });
              canvas.style.msInterpolationMode = "nearest-neighbor";
              return canvas;
            },
            setBicubic: function(canvas) {
              canvas.style["image-rendering"] = "auto";
              canvas.style.msInterpolationMode = "bicubic";
              return canvas;
            }
          };
          module2.exports = CanvasInterpolation;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Felipe Alfonso <@bitnenfer>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CameraEvents = __webpack_require__(36);
          var CanvasSnapshot = __webpack_require__(363);
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(32);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(88);
          var GetBlendModes = __webpack_require__(364);
          var ScaleEvents = __webpack_require__(101);
          var TextureEvents = __webpack_require__(103);
          var TransformMatrix = __webpack_require__(25);
          var CanvasRenderer = new Class({
            Extends: EventEmitter,
            initialize: function CanvasRenderer2(game) {
              EventEmitter.call(this);
              var gameConfig = game.config;
              this.config = {
                clearBeforeRender: gameConfig.clearBeforeRender,
                backgroundColor: gameConfig.backgroundColor,
                antialias: gameConfig.antialias,
                roundPixels: gameConfig.roundPixels
              };
              this.game = game;
              this.type = CONST.CANVAS;
              this.drawCount = 0;
              this.width = 0;
              this.height = 0;
              this.gameCanvas = game.canvas;
              var contextOptions = {
                alpha: game.config.transparent,
                desynchronized: game.config.desynchronized
              };
              this.gameContext = gameConfig.context ? gameConfig.context : this.gameCanvas.getContext("2d", contextOptions);
              this.currentContext = this.gameContext;
              this.antialias = game.config.antialias;
              this.blendModes = GetBlendModes();
              this.snapshotState = {
                x: 0,
                y: 0,
                width: 1,
                height: 1,
                getPixel: false,
                callback: null,
                type: "image/png",
                encoder: 0.92
              };
              this._tempMatrix1 = new TransformMatrix();
              this._tempMatrix2 = new TransformMatrix();
              this._tempMatrix3 = new TransformMatrix();
              this.isBooted = false;
              this.init();
            },
            init: function() {
              this.game.textures.once(TextureEvents.READY, this.boot, this);
            },
            boot: function() {
              var game = this.game;
              var baseSize = game.scale.baseSize;
              this.width = baseSize.width;
              this.height = baseSize.height;
              this.isBooted = true;
              game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
              this.resize(baseSize.width, baseSize.height);
            },
            onResize: function(gameSize, baseSize) {
              if (baseSize.width !== this.width || baseSize.height !== this.height) {
                this.resize(baseSize.width, baseSize.height);
              }
            },
            resize: function(width, height) {
              this.width = width;
              this.height = height;
              this.emit(Events.RESIZE, width, height);
            },
            resetTransform: function() {
              this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
            },
            setBlendMode: function(blendMode) {
              this.currentContext.globalCompositeOperation = blendMode;
              return this;
            },
            setContext: function(ctx) {
              this.currentContext = ctx ? ctx : this.gameContext;
              return this;
            },
            setAlpha: function(alpha) {
              this.currentContext.globalAlpha = alpha;
              return this;
            },
            preRender: function() {
              var ctx = this.gameContext;
              var config2 = this.config;
              var width = this.width;
              var height = this.height;
              ctx.globalAlpha = 1;
              ctx.globalCompositeOperation = "source-over";
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              if (config2.clearBeforeRender) {
                ctx.clearRect(0, 0, width, height);
              }
              if (!config2.transparent) {
                ctx.fillStyle = config2.backgroundColor.rgba;
                ctx.fillRect(0, 0, width, height);
              }
              ctx.save();
              this.drawCount = 0;
              this.emit(Events.PRE_RENDER);
            },
            render: function(scene, children, camera) {
              var childCount = children.length;
              this.emit(Events.RENDER, scene, camera);
              var cx = camera.x;
              var cy = camera.y;
              var cw = camera.width;
              var ch = camera.height;
              var ctx = camera.renderToTexture ? camera.context : scene.sys.context;
              ctx.save();
              if (this.game.scene.customViewports) {
                ctx.beginPath();
                ctx.rect(cx, cy, cw, ch);
                ctx.clip();
              }
              this.currentContext = ctx;
              var mask = camera.mask;
              if (mask) {
                mask.preRenderCanvas(this, null, camera._maskCamera);
              }
              if (!camera.transparent) {
                ctx.fillStyle = camera.backgroundColor.rgba;
                ctx.fillRect(cx, cy, cw, ch);
              }
              ctx.globalAlpha = camera.alpha;
              ctx.globalCompositeOperation = "source-over";
              this.drawCount += childCount;
              if (camera.renderToTexture) {
                camera.emit(CameraEvents.PRE_RENDER, camera);
              }
              camera.matrix.copyToContext(ctx);
              for (var i = 0; i < childCount; i++) {
                var child = children[i];
                if (child.mask) {
                  child.mask.preRenderCanvas(this, child, camera);
                }
                child.renderCanvas(this, child, camera);
                if (child.mask) {
                  child.mask.postRenderCanvas(this, child, camera);
                }
              }
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.globalCompositeOperation = "source-over";
              ctx.globalAlpha = 1;
              camera.flashEffect.postRenderCanvas(ctx);
              camera.fadeEffect.postRenderCanvas(ctx);
              camera.dirty = false;
              if (mask) {
                mask.postRenderCanvas(this);
              }
              ctx.restore();
              if (camera.renderToTexture) {
                camera.emit(CameraEvents.POST_RENDER, camera);
                if (camera.renderToGame) {
                  scene.sys.context.drawImage(camera.canvas, cx, cy);
                }
              }
            },
            postRender: function() {
              var ctx = this.gameContext;
              ctx.restore();
              this.emit(Events.POST_RENDER);
              var state = this.snapshotState;
              if (state.callback) {
                CanvasSnapshot(this.gameCanvas, state);
                state.callback = null;
              }
            },
            snapshotCanvas: function(canvas, callback, getPixel, x, y, width, height, type, encoderOptions) {
              if (getPixel === void 0) {
                getPixel = false;
              }
              this.snapshotArea(x, y, width, height, callback, type, encoderOptions);
              var state = this.snapshotState;
              state.getPixel = getPixel;
              CanvasSnapshot(this.canvas, state);
              state.callback = null;
              return this;
            },
            snapshot: function(callback, type, encoderOptions) {
              return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, callback, type, encoderOptions);
            },
            snapshotArea: function(x, y, width, height, callback, type, encoderOptions) {
              var state = this.snapshotState;
              state.callback = callback;
              state.type = type;
              state.encoder = encoderOptions;
              state.getPixel = false;
              state.x = x;
              state.y = y;
              state.width = Math.min(width, this.gameCanvas.width);
              state.height = Math.min(height, this.gameCanvas.height);
              return this;
            },
            snapshotPixel: function(x, y, callback) {
              this.snapshotArea(x, y, 1, 1, callback);
              this.snapshotState.getPixel = true;
              return this;
            },
            batchSprite: function(sprite, frame, camera, parentTransformMatrix) {
              var alpha = camera.alpha * sprite.alpha;
              if (alpha === 0) {
                return;
              }
              var ctx = this.currentContext;
              var camMatrix = this._tempMatrix1;
              var spriteMatrix = this._tempMatrix2;
              var cd = frame.canvasData;
              var frameX = cd.x;
              var frameY = cd.y;
              var frameWidth = frame.cutWidth;
              var frameHeight = frame.cutHeight;
              var customPivot = frame.customPivot;
              var res = frame.source.resolution;
              var displayOriginX = sprite.displayOriginX;
              var displayOriginY = sprite.displayOriginY;
              var x = -displayOriginX + frame.x;
              var y = -displayOriginY + frame.y;
              if (sprite.isCropped) {
                var crop = sprite._crop;
                if (crop.flipX !== sprite.flipX || crop.flipY !== sprite.flipY) {
                  frame.updateCropUVs(crop, sprite.flipX, sprite.flipY);
                }
                frameWidth = crop.cw;
                frameHeight = crop.ch;
                frameX = crop.cx;
                frameY = crop.cy;
                x = -displayOriginX + crop.x;
                y = -displayOriginY + crop.y;
                if (sprite.flipX) {
                  if (x >= 0) {
                    x = -(x + frameWidth);
                  } else if (x < 0) {
                    x = Math.abs(x) - frameWidth;
                  }
                }
                if (sprite.flipY) {
                  if (y >= 0) {
                    y = -(y + frameHeight);
                  } else if (y < 0) {
                    y = Math.abs(y) - frameHeight;
                  }
                }
              }
              var flipX = 1;
              var flipY = 1;
              if (sprite.flipX) {
                if (!customPivot) {
                  x += -frame.realWidth + displayOriginX * 2;
                }
                flipX = -1;
              }
              if (sprite.flipY) {
                if (!customPivot) {
                  y += -frame.realHeight + displayOriginY * 2;
                }
                flipY = -1;
              }
              spriteMatrix.applyITRS(sprite.x, sprite.y, sprite.rotation, sprite.scaleX * flipX, sprite.scaleY * flipY);
              camMatrix.copyFrom(camera.matrix);
              if (parentTransformMatrix) {
                camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY);
                spriteMatrix.e = sprite.x;
                spriteMatrix.f = sprite.y;
              } else {
                spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX;
                spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY;
              }
              camMatrix.multiply(spriteMatrix);
              ctx.save();
              camMatrix.setToContext(ctx);
              ctx.globalCompositeOperation = this.blendModes[sprite.blendMode];
              ctx.globalAlpha = alpha;
              ctx.imageSmoothingEnabled = !(!this.antialias || frame.source.scaleMode);
              if (sprite.mask) {
                sprite.mask.preRenderCanvas(this, sprite, camera);
              }
              ctx.drawImage(frame.source.image, frameX, frameY, frameWidth, frameHeight, x, y, frameWidth / res, frameHeight / res);
              if (sprite.mask) {
                sprite.mask.postRenderCanvas(this, sprite, camera);
              }
              ctx.restore();
            },
            destroy: function() {
              this.removeAllListeners();
              this.game = null;
              this.gameCanvas = null;
              this.gameContext = null;
            }
          });
          module2.exports = CanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CanvasPool = __webpack_require__(31);
          var Color = __webpack_require__(37);
          var GetFastValue = __webpack_require__(2);
          var CanvasSnapshot = function(canvas, config2) {
            var callback = GetFastValue(config2, "callback");
            var type = GetFastValue(config2, "type", "image/png");
            var encoderOptions = GetFastValue(config2, "encoder", 0.92);
            var x = Math.abs(Math.round(GetFastValue(config2, "x", 0)));
            var y = Math.abs(Math.round(GetFastValue(config2, "y", 0)));
            var width = GetFastValue(config2, "width", canvas.width);
            var height = GetFastValue(config2, "height", canvas.height);
            var getPixel = GetFastValue(config2, "getPixel", false);
            if (getPixel) {
              var context = canvas.getContext("2d");
              var imageData = context.getImageData(x, y, 1, 1);
              var data = imageData.data;
              callback.call(null, new Color(data[0], data[1], data[2], data[3] / 255));
            } else if (x !== 0 || y !== 0 || width !== canvas.width || height !== canvas.height) {
              var copyCanvas = CanvasPool.createWebGL(this, width, height);
              var ctx = copyCanvas.getContext("2d");
              ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);
              var image1 = new Image();
              image1.onerror = function() {
                callback.call(null);
                CanvasPool.remove(copyCanvas);
              };
              image1.onload = function() {
                callback.call(null, image1);
                CanvasPool.remove(copyCanvas);
              };
              image1.src = copyCanvas.toDataURL(type, encoderOptions);
            } else {
              var image2 = new Image();
              image2.onerror = function() {
                callback.call(null);
              };
              image2.onload = function() {
                callback.call(null, image2);
              };
              image2.src = canvas.toDataURL(type, encoderOptions);
            }
          };
          module2.exports = CanvasSnapshot;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var modes = __webpack_require__(34);
          var CanvasFeatures = __webpack_require__(342);
          var GetBlendModes = function() {
            var output = [];
            var useNew = CanvasFeatures.supportNewBlendModes;
            var so = "source-over";
            output[modes.NORMAL] = so;
            output[modes.ADD] = "lighter";
            output[modes.MULTIPLY] = useNew ? "multiply" : so;
            output[modes.SCREEN] = useNew ? "screen" : so;
            output[modes.OVERLAY] = useNew ? "overlay" : so;
            output[modes.DARKEN] = useNew ? "darken" : so;
            output[modes.LIGHTEN] = useNew ? "lighten" : so;
            output[modes.COLOR_DODGE] = useNew ? "color-dodge" : so;
            output[modes.COLOR_BURN] = useNew ? "color-burn" : so;
            output[modes.HARD_LIGHT] = useNew ? "hard-light" : so;
            output[modes.SOFT_LIGHT] = useNew ? "soft-light" : so;
            output[modes.DIFFERENCE] = useNew ? "difference" : so;
            output[modes.EXCLUSION] = useNew ? "exclusion" : so;
            output[modes.HUE] = useNew ? "hue" : so;
            output[modes.SATURATION] = useNew ? "saturation" : so;
            output[modes.COLOR] = useNew ? "color" : so;
            output[modes.LUMINOSITY] = useNew ? "luminosity" : so;
            output[modes.ERASE] = "destination-out";
            output[modes.SOURCE_IN] = "source-in";
            output[modes.SOURCE_OUT] = "source-out";
            output[modes.SOURCE_ATOP] = "source-atop";
            output[modes.DESTINATION_OVER] = "destination-over";
            output[modes.DESTINATION_IN] = "destination-in";
            output[modes.DESTINATION_OUT] = "destination-out";
            output[modes.DESTINATION_ATOP] = "destination-atop";
            output[modes.LIGHTER] = "lighter";
            output[modes.COPY] = "copy";
            output[modes.XOR] = "xor";
            return output;
          };
          module2.exports = GetBlendModes;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Felipe Alfonso <@bitnenfer>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ArrayRemove = __webpack_require__(89);
          var CameraEvents = __webpack_require__(36);
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(32);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(88);
          var GameEvents = __webpack_require__(22);
          var IsSizePowerOfTwo = __webpack_require__(136);
          var Matrix4 = __webpack_require__(67);
          var NOOP = __webpack_require__(1);
          var PipelineManager = __webpack_require__(366);
          var RenderTarget = __webpack_require__(139);
          var ScaleEvents = __webpack_require__(101);
          var TextureEvents = __webpack_require__(103);
          var Utils = __webpack_require__(12);
          var WebGLSnapshot = __webpack_require__(377);
          var WebGLRenderer = new Class({
            Extends: EventEmitter,
            initialize: function WebGLRenderer2(game) {
              EventEmitter.call(this);
              var gameConfig = game.config;
              var contextCreationConfig = {
                alpha: gameConfig.transparent,
                desynchronized: gameConfig.desynchronized,
                depth: false,
                antialias: gameConfig.antialiasGL,
                premultipliedAlpha: gameConfig.premultipliedAlpha,
                stencil: true,
                failIfMajorPerformanceCaveat: gameConfig.failIfMajorPerformanceCaveat,
                powerPreference: gameConfig.powerPreference
              };
              this.config = {
                clearBeforeRender: gameConfig.clearBeforeRender,
                antialias: gameConfig.antialias,
                backgroundColor: gameConfig.backgroundColor,
                contextCreation: contextCreationConfig,
                roundPixels: gameConfig.roundPixels,
                maxTextures: gameConfig.maxTextures,
                maxTextureSize: gameConfig.maxTextureSize,
                batchSize: gameConfig.batchSize,
                maxLights: gameConfig.maxLights,
                mipmapFilter: gameConfig.mipmapFilter
              };
              this.game = game;
              this.type = CONST.WEBGL;
              this.pipelines = null;
              this.width = 0;
              this.height = 0;
              this.canvas = game.canvas;
              this.blendModes = [];
              this.contextLost = false;
              this.snapshotState = {
                x: 0,
                y: 0,
                width: 1,
                height: 1,
                getPixel: false,
                callback: null,
                type: "image/png",
                encoder: 0.92,
                isFramebuffer: false,
                bufferWidth: 0,
                bufferHeight: 0
              };
              this.currentActiveTexture = 0;
              this.startActiveTexture = 0;
              this.maxTextures = 0;
              this.textureIndexes;
              this.tempTextures;
              this.textureZero;
              this.normalTexture;
              this.currentFramebuffer = null;
              this.fboStack = [];
              this.currentProgram = null;
              this.currentBlendMode = Infinity;
              this.currentScissorEnabled = false;
              this.currentScissor = null;
              this.scissorStack = [];
              this.contextLostHandler = NOOP;
              this.contextRestoredHandler = NOOP;
              this.gl = null;
              this.supportedExtensions = null;
              this.instancedArraysExtension = null;
              this.vaoExtension = null;
              this.extensions = {};
              this.glFormats = [];
              this.compression = {
                ETC1: false,
                PVRTC: false,
                S3TC: false
              };
              this.drawingBufferHeight = 0;
              this.blankTexture = null;
              this.whiteTexture = null;
              this.maskCount = 0;
              this.maskStack = [];
              this.currentMask = {mask: null, camera: null};
              this.currentCameraMask = {mask: null, camera: null};
              this.glFuncMap = null;
              this.currentType = "";
              this.newType = false;
              this.nextTypeMatch = false;
              this.finalType = false;
              this.mipmapFilter = null;
              this.textureFlush = 0;
              this.isTextureClean = false;
              this.defaultScissor = [0, 0, 0, 0];
              this.isBooted = false;
              this.renderTarget = null;
              this.projectionMatrix;
              this.projectionWidth = 0;
              this.projectionHeight = 0;
              this.init(this.config);
            },
            init: function(config2) {
              var gl;
              var game = this.game;
              var canvas = this.canvas;
              var clearColor = config2.backgroundColor;
              if (game.config.context) {
                gl = game.config.context;
              } else {
                gl = canvas.getContext("webgl", config2.contextCreation) || canvas.getContext("experimental-webgl", config2.contextCreation);
              }
              if (!gl || gl.isContextLost()) {
                this.contextLost = true;
                throw new Error("WebGL unsupported");
              }
              this.gl = gl;
              var _this = this;
              this.contextLostHandler = function(event) {
                _this.contextLost = true;
                _this.game.events.emit(GameEvents.CONTEXT_LOST, _this);
                event.preventDefault();
              };
              this.contextRestoredHandler = function() {
                _this.contextLost = false;
                _this.init(_this.config);
                _this.game.events.emit(GameEvents.CONTEXT_RESTORED, _this);
              };
              canvas.addEventListener("webglcontextlost", this.contextLostHandler, false);
              canvas.addEventListener("webglcontextrestored", this.contextRestoredHandler, false);
              game.context = gl;
              for (var i = 0; i <= 27; i++) {
                this.blendModes.push({func: [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], equation: gl.FUNC_ADD});
              }
              this.blendModes[1].func = [gl.ONE, gl.DST_ALPHA];
              this.blendModes[2].func = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
              this.blendModes[3].func = [gl.ONE, gl.ONE_MINUS_SRC_COLOR];
              this.blendModes[17] = {func: [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA], equation: gl.FUNC_REVERSE_SUBTRACT};
              this.glFormats[0] = gl.BYTE;
              this.glFormats[1] = gl.SHORT;
              this.glFormats[2] = gl.UNSIGNED_BYTE;
              this.glFormats[3] = gl.UNSIGNED_SHORT;
              this.glFormats[4] = gl.FLOAT;
              this.glFuncMap = {
                mat2: {func: gl.uniformMatrix2fv, length: 1, matrix: true},
                mat3: {func: gl.uniformMatrix3fv, length: 1, matrix: true},
                mat4: {func: gl.uniformMatrix4fv, length: 1, matrix: true},
                "1f": {func: gl.uniform1f, length: 1},
                "1fv": {func: gl.uniform1fv, length: 1},
                "1i": {func: gl.uniform1i, length: 1},
                "1iv": {func: gl.uniform1iv, length: 1},
                "2f": {func: gl.uniform2f, length: 2},
                "2fv": {func: gl.uniform2fv, length: 1},
                "2i": {func: gl.uniform2i, length: 2},
                "2iv": {func: gl.uniform2iv, length: 1},
                "3f": {func: gl.uniform3f, length: 3},
                "3fv": {func: gl.uniform3fv, length: 1},
                "3i": {func: gl.uniform3i, length: 3},
                "3iv": {func: gl.uniform3iv, length: 1},
                "4f": {func: gl.uniform4f, length: 4},
                "4fv": {func: gl.uniform4fv, length: 1},
                "4i": {func: gl.uniform4i, length: 4},
                "4iv": {func: gl.uniform4iv, length: 1}
              };
              var exts = gl.getSupportedExtensions();
              if (!config2.maxTextures || config2.maxTextures === -1) {
                config2.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
              }
              if (!config2.maxTextureSize) {
                config2.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
              }
              var extString = "WEBGL_compressed_texture_";
              var wkExtString = "WEBKIT_" + extString;
              this.compression.ETC1 = gl.getExtension(extString + "etc1") || gl.getExtension(wkExtString + "etc1");
              this.compression.PVRTC = gl.getExtension(extString + "pvrtc") || gl.getExtension(wkExtString + "pvrtc");
              this.compression.S3TC = gl.getExtension(extString + "s3tc") || gl.getExtension(wkExtString + "s3tc");
              this.supportedExtensions = exts;
              var angleString = "ANGLE_instanced_arrays";
              this.instancedArraysExtension = exts.indexOf(angleString) > -1 ? gl.getExtension(angleString) : null;
              var vaoString = "OES_vertex_array_object";
              this.vaoExtension = exts.indexOf(vaoString) > -1 ? gl.getExtension(vaoString) : null;
              gl.disable(gl.DEPTH_TEST);
              gl.disable(gl.CULL_FACE);
              gl.enable(gl.BLEND);
              gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);
              this.mipmapFilter = gl[config2.mipmapFilter];
              this.maxTextures = Utils.checkShaderMax(gl, config2.maxTextures);
              this.textureIndexes = [];
              var tempTextures = this.tempTextures;
              if (Array.isArray(tempTextures)) {
                for (var t = 0; i < this.maxTextures; t++) {
                  gl.deleteTexture(tempTextures[t]);
                }
              } else {
                tempTextures = new Array(this.maxTextures);
              }
              for (var index = 0; index < this.maxTextures; index++) {
                var tempTexture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0 + index);
                gl.bindTexture(gl.TEXTURE_2D, tempTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));
                tempTextures[index] = tempTexture;
                this.textureIndexes.push(index);
              }
              this.tempTextures = tempTextures;
              this.currentActiveTexture = 1;
              this.startActiveTexture++;
              gl.activeTexture(gl.TEXTURE1);
              this.pipelines = new PipelineManager(this);
              this.setBlendMode(CONST.BlendModes.NORMAL);
              this.projectionMatrix = new Matrix4().identity();
              game.textures.once(TextureEvents.READY, this.boot, this);
              return this;
            },
            boot: function() {
              var game = this.game;
              var pipelineManager = this.pipelines;
              var baseSize = game.scale.baseSize;
              this.width = baseSize.width;
              this.height = baseSize.height;
              this.isBooted = true;
              this.renderTarget = new RenderTarget(this, this.width, this.height, 1, 0, true, true);
              pipelineManager.boot(game.config.pipeline);
              this.blankTexture = game.textures.getFrame("__DEFAULT");
              this.whiteTexture = game.textures.getFrame("__WHITE");
              var gl = this.gl;
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.enable(gl.SCISSOR_TEST);
              game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
              this.resize(baseSize.width, baseSize.height);
            },
            onResize: function(gameSize, baseSize) {
              if (baseSize.width !== this.width || baseSize.height !== this.height) {
                this.resize(baseSize.width, baseSize.height);
              }
            },
            beginCapture: function(width, height) {
              if (width === void 0) {
                width = this.width;
              }
              if (height === void 0) {
                height = this.height;
              }
              this.renderTarget.bind(true, width, height);
              this.setProjectionMatrix(width, height);
              this.resetTextures();
            },
            endCapture: function() {
              this.renderTarget.unbind(true);
              this.resetProjectionMatrix();
              return this.renderTarget;
            },
            resize: function(width, height) {
              var gl = this.gl;
              this.width = width;
              this.height = height;
              this.setProjectionMatrix(width, height);
              gl.viewport(0, 0, width, height);
              this.drawingBufferHeight = gl.drawingBufferHeight;
              gl.scissor(0, gl.drawingBufferHeight - height, width, height);
              this.defaultScissor[2] = width;
              this.defaultScissor[3] = height;
              this.emit(Events.RESIZE, width, height);
              return this;
            },
            getAspectRatio: function() {
              return this.width / this.height;
            },
            setProjectionMatrix: function(width, height) {
              if (width !== this.projectionWidth || height !== this.projectionHeight) {
                this.projectionWidth = width;
                this.projectionHeight = height;
                this.projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);
              }
              return this;
            },
            resetProjectionMatrix: function() {
              this.projectionWidth = this.width;
              this.projectionHeight = this.height;
              this.projectionMatrix.ortho(0, this.width, this.height, 0, -1e3, 1e3);
            },
            hasExtension: function(extensionName) {
              return this.supportedExtensions ? this.supportedExtensions.indexOf(extensionName) : false;
            },
            getExtension: function(extensionName) {
              if (!this.hasExtension(extensionName)) {
                return null;
              }
              if (!(extensionName in this.extensions)) {
                this.extensions[extensionName] = this.gl.getExtension(extensionName);
              }
              return this.extensions[extensionName];
            },
            flush: function() {
              this.pipelines.flush();
            },
            pushScissor: function(x, y, width, height, drawingBufferHeight) {
              if (drawingBufferHeight === void 0) {
                drawingBufferHeight = this.drawingBufferHeight;
              }
              var scissorStack = this.scissorStack;
              var scissor = [x, y, width, height];
              scissorStack.push(scissor);
              this.setScissor(x, y, width, height, drawingBufferHeight);
              this.currentScissor = scissor;
              return scissor;
            },
            setScissor: function(x, y, width, height, drawingBufferHeight) {
              if (drawingBufferHeight === void 0) {
                drawingBufferHeight = this.drawingBufferHeight;
              }
              var gl = this.gl;
              var current = this.currentScissor;
              var setScissor = width > 0 && height > 0;
              if (current && setScissor) {
                var cx = current[0];
                var cy = current[1];
                var cw = current[2];
                var ch = current[3];
                setScissor = cx !== x || cy !== y || cw !== width || ch !== height;
              }
              if (setScissor) {
                this.flush();
                gl.scissor(x, drawingBufferHeight - y - height, width, height);
              }
            },
            resetScissor: function() {
              var gl = this.gl;
              gl.enable(gl.SCISSOR_TEST);
              var current = this.currentScissor;
              if (current) {
                var x = current[0];
                var y = current[1];
                var width = current[2];
                var height = current[3];
                if (width > 0 && height > 0) {
                  gl.scissor(x, this.drawingBufferHeight - y - height, width, height);
                }
              }
            },
            popScissor: function() {
              var scissorStack = this.scissorStack;
              scissorStack.pop();
              var scissor = scissorStack[scissorStack.length - 1];
              if (scissor) {
                this.setScissor(scissor[0], scissor[1], scissor[2], scissor[3]);
              }
              this.currentScissor = scissor;
            },
            hasActiveStencilMask: function() {
              var mask = this.currentMask.mask;
              var camMask = this.currentCameraMask.mask;
              return mask && mask.isStencil || camMask && camMask.isStencil;
            },
            resetViewport: function() {
              var gl = this.gl;
              gl.viewport(0, 0, this.width, this.height);
              this.drawingBufferHeight = gl.drawingBufferHeight;
            },
            setBlendMode: function(blendModeId, force) {
              if (force === void 0) {
                force = false;
              }
              var gl = this.gl;
              var blendMode = this.blendModes[blendModeId];
              if (force || blendModeId !== CONST.BlendModes.SKIP_CHECK && this.currentBlendMode !== blendModeId) {
                this.flush();
                gl.enable(gl.BLEND);
                gl.blendEquation(blendMode.equation);
                if (blendMode.func.length > 2) {
                  gl.blendFuncSeparate(blendMode.func[0], blendMode.func[1], blendMode.func[2], blendMode.func[3]);
                } else {
                  gl.blendFunc(blendMode.func[0], blendMode.func[1]);
                }
                this.currentBlendMode = blendModeId;
                return true;
              }
              return false;
            },
            addBlendMode: function(func, equation) {
              var index = this.blendModes.push({func, equation});
              return index - 1;
            },
            updateBlendMode: function(index, func, equation) {
              if (this.blendModes[index]) {
                this.blendModes[index].func = func;
                if (equation) {
                  this.blendModes[index].equation = equation;
                }
              }
              return this;
            },
            removeBlendMode: function(index) {
              if (index > 17 && this.blendModes[index]) {
                this.blendModes.splice(index, 1);
              }
              return this;
            },
            setBlankTexture: function() {
              this.setTexture2D(this.blankTexture.glTexture);
            },
            setTextureSource: function(textureSource) {
              if (this.pipelines.forceZero()) {
                this.setTextureZero(textureSource.glTexture, true);
                return 0;
              }
              var gl = this.gl;
              var currentActiveTexture = this.currentActiveTexture;
              if (textureSource.glIndexCounter < this.startActiveTexture) {
                textureSource.glIndexCounter = this.startActiveTexture;
                if (currentActiveTexture < this.maxTextures) {
                  textureSource.glIndex = currentActiveTexture;
                  gl.activeTexture(gl.TEXTURE0 + currentActiveTexture);
                  gl.bindTexture(gl.TEXTURE_2D, textureSource.glTexture);
                  this.currentActiveTexture++;
                } else {
                  this.flush();
                  this.startActiveTexture++;
                  this.textureFlush++;
                  textureSource.glIndexCounter = this.startActiveTexture;
                  textureSource.glIndex = 1;
                  gl.activeTexture(gl.TEXTURE1);
                  gl.bindTexture(gl.TEXTURE_2D, textureSource.glTexture);
                  this.currentActiveTexture = 2;
                }
              }
              this.isTextureClean = false;
              return textureSource.glIndex;
            },
            isNewNormalMap: function(texture, normalMap) {
              return this.textureZero !== texture || this.normalTexture !== normalMap;
            },
            setTextureZero: function(texture, flush) {
              if (this.textureZero !== texture) {
                if (flush) {
                  this.flush();
                }
                var gl = this.gl;
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                this.textureZero = texture;
              }
            },
            clearTextureZero: function() {
              this.textureZero = null;
            },
            setNormalMap: function(texture) {
              if (this.normalTexture !== texture) {
                var gl = this.gl;
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                this.normalTexture = texture;
                if (this.currentActiveTexture === 1) {
                  this.currentActiveTexture = 2;
                }
              }
            },
            clearNormalMap: function() {
              this.normalTexture = null;
              this.startActiveTexture++;
              this.currentActiveTexture = 1;
              this.textureFlush++;
            },
            unbindTextures: function() {
              var gl = this.gl;
              var temp = this.tempTextures;
              for (var i = 0; i < temp.length; i++) {
                gl.activeTexture(gl.TEXTURE0 + i);
                gl.bindTexture(gl.TEXTURE_2D, null);
              }
              this.normalTexture = null;
              this.textureZero = null;
              this.currentActiveTexture = 1;
              this.startActiveTexture++;
              this.textureFlush++;
            },
            resetTextures: function(all) {
              if (all === void 0) {
                all = false;
              }
              if (this.isTextureClean) {
                return;
              }
              this.flush();
              var gl = this.gl;
              var temp = this.tempTextures;
              if (all) {
                for (var i = 0; i < temp.length; i++) {
                  gl.activeTexture(gl.TEXTURE0 + i);
                  gl.bindTexture(gl.TEXTURE_2D, temp[i]);
                }
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, temp[1]);
                this.isTextureClean = true;
              } else {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, temp[0]);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, temp[1]);
              }
              this.normalTexture = null;
              this.textureZero = null;
              this.currentActiveTexture = 1;
              this.startActiveTexture++;
              this.textureFlush++;
            },
            setTexture2D: function(texture) {
              if (this.pipelines.forceZero()) {
                this.setTextureZero(texture, true);
                return 0;
              }
              var gl = this.gl;
              var currentActiveTexture = this.currentActiveTexture;
              if (texture.glIndexCounter < this.startActiveTexture) {
                texture.glIndexCounter = this.startActiveTexture;
                if (currentActiveTexture < this.maxTextures) {
                  texture.glIndex = currentActiveTexture;
                  gl.activeTexture(gl.TEXTURE0 + currentActiveTexture);
                  gl.bindTexture(gl.TEXTURE_2D, texture);
                  this.currentActiveTexture++;
                } else {
                  this.flush();
                  this.startActiveTexture++;
                  this.textureFlush++;
                  texture.glIndexCounter = this.startActiveTexture;
                  texture.glIndex = 1;
                  gl.activeTexture(gl.TEXTURE1);
                  gl.bindTexture(gl.TEXTURE_2D, texture);
                  this.currentActiveTexture = 2;
                }
              }
              this.isTextureClean = false;
              return texture.glIndex;
            },
            pushFramebuffer: function(framebuffer, updateScissor, resetTextures, setViewport) {
              if (framebuffer === this.currentFramebuffer) {
                return this;
              }
              this.fboStack.push(framebuffer);
              return this.setFramebuffer(framebuffer, updateScissor, resetTextures, setViewport);
            },
            setFramebuffer: function(framebuffer, updateScissor, resetTextures, setViewport) {
              if (updateScissor === void 0) {
                updateScissor = false;
              }
              if (resetTextures === void 0) {
                resetTextures = false;
              }
              if (setViewport === void 0) {
                setViewport = true;
              }
              if (framebuffer === this.currentFramebuffer) {
                return this;
              }
              var gl = this.gl;
              var width = this.width;
              var height = this.height;
              if (framebuffer && framebuffer.renderTexture && setViewport) {
                width = framebuffer.renderTexture.width;
                height = framebuffer.renderTexture.height;
              } else {
                this.flush();
              }
              gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
              if (setViewport) {
                gl.viewport(0, 0, width, height);
              }
              if (updateScissor) {
                if (framebuffer) {
                  this.drawingBufferHeight = height;
                  this.pushScissor(0, 0, width, height);
                } else {
                  this.drawingBufferHeight = this.height;
                  this.popScissor();
                }
              }
              this.currentFramebuffer = framebuffer;
              if (resetTextures) {
                this.resetTextures();
              }
              return this;
            },
            popFramebuffer: function(updateScissor, resetTextures, setViewport) {
              if (updateScissor === void 0) {
                updateScissor = false;
              }
              if (resetTextures === void 0) {
                resetTextures = false;
              }
              if (setViewport === void 0) {
                setViewport = true;
              }
              var fboStack = this.fboStack;
              fboStack.pop();
              var framebuffer = fboStack[fboStack.length - 1];
              if (!framebuffer) {
                framebuffer = null;
              }
              this.setFramebuffer(framebuffer, updateScissor, resetTextures, setViewport);
              return framebuffer;
            },
            setProgram: function(program) {
              if (program !== this.currentProgram) {
                this.flush();
                this.gl.useProgram(program);
                this.currentProgram = program;
                return true;
              }
              return false;
            },
            resetProgram: function() {
              this.gl.useProgram(this.currentProgram);
              return this;
            },
            createTextureFromSource: function(source, width, height, scaleMode) {
              var gl = this.gl;
              var minFilter = gl.NEAREST;
              var magFilter = gl.NEAREST;
              var wrap = gl.CLAMP_TO_EDGE;
              var texture = null;
              width = source ? source.width : width;
              height = source ? source.height : height;
              var pow = IsSizePowerOfTwo(width, height);
              if (pow) {
                wrap = gl.REPEAT;
              }
              if (scaleMode === CONST.ScaleModes.LINEAR && this.config.antialias) {
                minFilter = pow ? this.mipmapFilter : gl.LINEAR;
                magFilter = gl.LINEAR;
              }
              if (!source && typeof width === "number" && typeof height === "number") {
                texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, null, width, height);
              } else {
                texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, source);
              }
              return texture;
            },
            createTexture2D: function(mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma, forceSize, flipY) {
              pma = pma === void 0 || pma === null ? true : pma;
              if (forceSize === void 0) {
                forceSize = false;
              }
              if (flipY === void 0) {
                flipY = false;
              }
              var gl = this.gl;
              var texture = gl.createTexture();
              gl.activeTexture(gl.TEXTURE0);
              var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
              gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, pma);
              gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
              if (pixels === null || pixels === void 0) {
                gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, null);
              } else {
                if (!forceSize) {
                  width = pixels.width;
                  height = pixels.height;
                }
                gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, format, gl.UNSIGNED_BYTE, pixels);
              }
              if (IsSizePowerOfTwo(width, height)) {
                gl.generateMipmap(gl.TEXTURE_2D);
              }
              if (currentTexture) {
                gl.bindTexture(gl.TEXTURE_2D, currentTexture);
              }
              texture.isAlphaPremultiplied = pma;
              texture.isRenderTexture = false;
              texture.width = width;
              texture.height = height;
              texture.glIndex = 0;
              texture.glIndexCounter = -1;
              return texture;
            },
            createFramebuffer: function(width, height, renderTexture, addDepthStencilBuffer) {
              var gl = this.gl;
              var framebuffer = gl.createFramebuffer();
              var complete = 0;
              this.setFramebuffer(framebuffer);
              if (addDepthStencilBuffer) {
                var depthStencilBuffer = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilBuffer);
              }
              renderTexture.isRenderTexture = true;
              renderTexture.isAlphaPremultiplied = false;
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);
              complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
              if (complete !== gl.FRAMEBUFFER_COMPLETE) {
                var errors = {
                  36054: "Incomplete Attachment",
                  36055: "Missing Attachment",
                  36057: "Incomplete Dimensions",
                  36061: "Framebuffer Unsupported"
                };
                throw new Error("Framebuffer status: " + errors[complete]);
              }
              framebuffer.renderTexture = renderTexture;
              this.setFramebuffer(null);
              this.resetTextures();
              return framebuffer;
            },
            createProgram: function(vertexShader, fragmentShader) {
              var gl = this.gl;
              var program = gl.createProgram();
              var vs = gl.createShader(gl.VERTEX_SHADER);
              var fs = gl.createShader(gl.FRAGMENT_SHADER);
              gl.shaderSource(vs, vertexShader);
              gl.shaderSource(fs, fragmentShader);
              gl.compileShader(vs);
              gl.compileShader(fs);
              if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
                throw new Error("Vertex Shader failed:\n" + gl.getShaderInfoLog(vs));
              }
              if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
                throw new Error("Fragment Shader failed:\n" + gl.getShaderInfoLog(fs));
              }
              gl.attachShader(program, vs);
              gl.attachShader(program, fs);
              gl.linkProgram(program);
              if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw new Error("Link Program failed:\n" + gl.getProgramInfoLog(program));
              }
              gl.useProgram(program);
              return program;
            },
            createVertexBuffer: function(initialDataOrSize, bufferUsage) {
              var gl = this.gl;
              var vertexBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, initialDataOrSize, bufferUsage);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              return vertexBuffer;
            },
            createIndexBuffer: function(initialDataOrSize, bufferUsage) {
              var gl = this.gl;
              var indexBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, initialDataOrSize, bufferUsage);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              return indexBuffer;
            },
            deleteTexture: function(texture, reset) {
              if (texture) {
                this.gl.deleteTexture(texture);
              }
              if (reset) {
                this.resetTextures();
              }
              return this;
            },
            deleteFramebuffer: function(framebuffer) {
              if (framebuffer) {
                this.gl.deleteFramebuffer(framebuffer);
                ArrayRemove(this.fboStack, framebuffer);
                if (this.currentFramebuffer === framebuffer) {
                  this.currentFramebuffer = null;
                }
              }
              return this;
            },
            deleteProgram: function(program) {
              if (program) {
                this.gl.deleteProgram(program);
              }
              return this;
            },
            deleteBuffer: function(buffer) {
              this.gl.deleteBuffer(buffer);
              return this;
            },
            preRenderCamera: function(camera) {
              var cx = camera.x;
              var cy = camera.y;
              var cw = camera.width;
              var ch = camera.height;
              var color = camera.backgroundColor;
              camera.emit(CameraEvents.PRE_RENDER, camera);
              this.pipelines.preBatchCamera(camera);
              this.pushScissor(cx, cy, cw, ch);
              if (camera.mask) {
                this.currentCameraMask.mask = camera.mask;
                this.currentCameraMask.camera = camera._maskCamera;
                camera.mask.preRenderWebGL(this, camera, camera._maskCamera);
              }
              if (color.alphaGL > 0) {
                var pipeline = this.pipelines.setMulti();
                pipeline.drawFillRect(cx, cy, cw, ch, Utils.getTintFromFloats(color.blueGL, color.greenGL, color.redGL, 1), color.alphaGL);
              }
            },
            getCurrentStencilMask: function() {
              var prev = null;
              var stack = this.maskStack;
              var cameraMask = this.currentCameraMask;
              if (stack.length > 0) {
                prev = stack[stack.length - 1];
              } else if (cameraMask.mask && cameraMask.mask.isStencil) {
                prev = cameraMask;
              }
              return prev;
            },
            postRenderCamera: function(camera) {
              var flashEffect = camera.flashEffect;
              var fadeEffect = camera.fadeEffect;
              if (flashEffect.isRunning || (fadeEffect.isRunning || fadeEffect.isComplete)) {
                var pipeline = this.pipelines.setMulti();
                flashEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);
                fadeEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);
              }
              camera.dirty = false;
              this.popScissor();
              if (camera.mask) {
                this.currentCameraMask.mask = null;
                camera.mask.postRenderWebGL(this, camera._maskCamera);
              }
              this.pipelines.postBatchCamera(camera);
              camera.emit(CameraEvents.POST_RENDER, camera);
            },
            preRender: function() {
              if (this.contextLost) {
                return;
              }
              var gl = this.gl;
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              if (this.config.clearBeforeRender) {
                var clearColor = this.config.backgroundColor;
                gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
              }
              gl.enable(gl.SCISSOR_TEST);
              this.currentScissor = this.defaultScissor;
              this.scissorStack.length = 0;
              this.scissorStack.push(this.currentScissor);
              if (this.game.scene.customViewports) {
                gl.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height);
              }
              this.currentMask.mask = null;
              this.currentCameraMask.mask = null;
              this.maskStack.length = 0;
              this.textureFlush = 0;
              this.emit(Events.PRE_RENDER);
            },
            render: function(scene, children, camera) {
              if (this.contextLost) {
                return;
              }
              var childCount = children.length;
              this.emit(Events.RENDER, scene, camera);
              this.preRenderCamera(camera);
              if (childCount === 0) {
                this.setBlendMode(CONST.BlendModes.NORMAL);
                this.postRenderCamera(camera);
                return;
              }
              this.currentType = "";
              var current = this.currentMask;
              for (var i = 0; i < childCount; i++) {
                this.finalType = i === childCount - 1;
                var child = children[i];
                var mask = child.mask;
                current = this.currentMask;
                if (current.mask && current.mask !== mask) {
                  current.mask.postRenderWebGL(this, current.camera);
                }
                if (mask && current.mask !== mask) {
                  mask.preRenderWebGL(this, child, camera);
                }
                if (child.blendMode !== this.currentBlendMode) {
                  this.setBlendMode(child.blendMode);
                }
                var type = child.type;
                if (type !== this.currentType) {
                  this.newType = true;
                  this.currentType = type;
                }
                if (!this.finalType) {
                  this.nextTypeMatch = children[i + 1].type === this.currentType;
                } else {
                  this.nextTypeMatch = false;
                }
                child.renderWebGL(this, child, camera);
                this.newType = false;
              }
              current = this.currentMask;
              if (current.mask) {
                current.mask.postRenderWebGL(this, current.camera);
              }
              this.setBlendMode(CONST.BlendModes.NORMAL);
              this.postRenderCamera(camera);
            },
            postRender: function() {
              if (this.contextLost) {
                return;
              }
              this.flush();
              this.emit(Events.POST_RENDER);
              var state = this.snapshotState;
              if (state.callback) {
                WebGLSnapshot(this.canvas, state);
                state.callback = null;
              }
              if (this.textureFlush > 0) {
                this.startActiveTexture++;
                this.currentActiveTexture = 1;
              }
            },
            snapshot: function(callback, type, encoderOptions) {
              return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, callback, type, encoderOptions);
            },
            snapshotArea: function(x, y, width, height, callback, type, encoderOptions) {
              var state = this.snapshotState;
              state.callback = callback;
              state.type = type;
              state.encoder = encoderOptions;
              state.getPixel = false;
              state.x = x;
              state.y = y;
              state.width = Math.min(width, this.gl.drawingBufferWidth);
              state.height = Math.min(height, this.gl.drawingBufferHeight);
              return this;
            },
            snapshotPixel: function(x, y, callback) {
              this.snapshotArea(x, y, 1, 1, callback);
              this.snapshotState.getPixel = true;
              return this;
            },
            snapshotFramebuffer: function(framebuffer, bufferWidth, bufferHeight, callback, getPixel, x, y, width, height, type, encoderOptions) {
              if (getPixel === void 0) {
                getPixel = false;
              }
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = bufferWidth;
              }
              if (height === void 0) {
                height = bufferHeight;
              }
              var currentFramebuffer = this.currentFramebuffer;
              this.snapshotArea(x, y, width, height, callback, type, encoderOptions);
              var state = this.snapshotState;
              state.getPixel = getPixel;
              state.isFramebuffer = true;
              state.bufferWidth = bufferWidth;
              state.bufferHeight = bufferHeight;
              this.setFramebuffer(framebuffer);
              WebGLSnapshot(this.canvas, state);
              this.setFramebuffer(currentFramebuffer);
              state.callback = null;
              state.isFramebuffer = false;
              return this;
            },
            canvasToTexture: function(srcCanvas, dstTexture, noRepeat, flipY) {
              if (noRepeat === void 0) {
                noRepeat = false;
              }
              if (flipY === void 0) {
                flipY = false;
              }
              if (!dstTexture) {
                return this.createCanvasTexture(srcCanvas, noRepeat, flipY);
              } else {
                return this.updateCanvasTexture(srcCanvas, dstTexture, flipY);
              }
            },
            createCanvasTexture: function(srcCanvas, noRepeat, flipY) {
              if (noRepeat === void 0) {
                noRepeat = false;
              }
              if (flipY === void 0) {
                flipY = false;
              }
              var gl = this.gl;
              var minFilter = gl.NEAREST;
              var magFilter = gl.NEAREST;
              var width = srcCanvas.width;
              var height = srcCanvas.height;
              var wrapping = gl.CLAMP_TO_EDGE;
              var pow = IsSizePowerOfTwo(width, height);
              if (!noRepeat && pow) {
                wrapping = gl.REPEAT;
              }
              if (this.config.antialias) {
                minFilter = pow ? this.mipmapFilter : gl.LINEAR;
                magFilter = gl.LINEAR;
              }
              return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcCanvas, width, height, true, false, flipY);
            },
            updateCanvasTexture: function(srcCanvas, dstTexture, flipY) {
              if (flipY === void 0) {
                flipY = false;
              }
              var gl = this.gl;
              var width = srcCanvas.width;
              var height = srcCanvas.height;
              if (width > 0 && height > 0) {
                gl.activeTexture(gl.TEXTURE0);
                var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
                gl.bindTexture(gl.TEXTURE_2D, dstTexture);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);
                dstTexture.width = width;
                dstTexture.height = height;
                if (currentTexture) {
                  gl.bindTexture(gl.TEXTURE_2D, currentTexture);
                }
              }
              return dstTexture;
            },
            createVideoTexture: function(srcVideo, noRepeat, flipY) {
              if (noRepeat === void 0) {
                noRepeat = false;
              }
              if (flipY === void 0) {
                flipY = false;
              }
              var gl = this.gl;
              var minFilter = gl.NEAREST;
              var magFilter = gl.NEAREST;
              var width = srcVideo.videoWidth;
              var height = srcVideo.videoHeight;
              var wrapping = gl.CLAMP_TO_EDGE;
              var pow = IsSizePowerOfTwo(width, height);
              if (!noRepeat && pow) {
                wrapping = gl.REPEAT;
              }
              if (this.config.antialias) {
                minFilter = pow ? this.mipmapFilter : gl.LINEAR;
                magFilter = gl.LINEAR;
              }
              return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcVideo, width, height, true, true, flipY);
            },
            updateVideoTexture: function(srcVideo, dstTexture, flipY) {
              if (flipY === void 0) {
                flipY = false;
              }
              var gl = this.gl;
              var width = srcVideo.videoWidth;
              var height = srcVideo.videoHeight;
              if (width > 0 && height > 0) {
                gl.activeTexture(gl.TEXTURE0);
                var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
                gl.bindTexture(gl.TEXTURE_2D, dstTexture);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcVideo);
                dstTexture.width = width;
                dstTexture.height = height;
                if (currentTexture) {
                  gl.bindTexture(gl.TEXTURE_2D, currentTexture);
                }
              }
              return dstTexture;
            },
            setTextureFilter: function(texture, filter2) {
              var gl = this.gl;
              var glFilter = [gl.LINEAR, gl.NEAREST][filter2];
              gl.activeTexture(gl.TEXTURE0);
              var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);
              if (currentTexture) {
                gl.bindTexture(gl.TEXTURE_2D, currentTexture);
              }
              return this;
            },
            getMaxTextureSize: function() {
              return this.config.maxTextureSize;
            },
            destroy: function() {
              this.canvas.removeEventListener("webglcontextlost", this.contextLostHandler, false);
              this.canvas.removeEventListener("webglcontextrestored", this.contextRestoredHandler, false);
              var gl = this.gl;
              var temp = this.tempTextures;
              for (var i = 0; i < temp.length; i++) {
                gl.deleteTexture(temp[i]);
              }
              this.pipelines.destroy();
              this.removeAllListeners();
              this.fboStack = [];
              this.maskStack = [];
              this.extensions = {};
              this.textureIndexes = [];
              this.gl = null;
              this.game = null;
              this.canvas = null;
              this.contextLost = true;
              this.currentMask = null;
              this.currentCameraMask = null;
            }
          });
          module2.exports = WebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(65);
          var CustomMap = __webpack_require__(99);
          var BitmapMaskPipeline = __webpack_require__(367);
          var GraphicsPipeline = __webpack_require__(370);
          var LightPipeline = __webpack_require__(371);
          var MultiPipeline = __webpack_require__(105);
          var PointLightPipeline = __webpack_require__(372);
          var RopePipeline = __webpack_require__(373);
          var SinglePipeline = __webpack_require__(374);
          var UtilityPipeline = __webpack_require__(375);
          var PipelineManager = new Class({
            initialize: function PipelineManager2(renderer) {
              this.game = renderer.game;
              this.renderer = renderer;
              this.classes = new CustomMap([
                [CONST.UTILITY_PIPELINE, UtilityPipeline],
                [CONST.MULTI_PIPELINE, MultiPipeline],
                [CONST.BITMAPMASK_PIPELINE, BitmapMaskPipeline],
                [CONST.SINGLE_PIPELINE, SinglePipeline],
                [CONST.ROPE_PIPELINE, RopePipeline],
                [CONST.LIGHT_PIPELINE, LightPipeline],
                [CONST.POINTLIGHT_PIPELINE, PointLightPipeline],
                [CONST.GRAPHICS_PIPELINE, GraphicsPipeline]
              ]);
              this.postPipelineClasses = new CustomMap();
              this.pipelines = new CustomMap();
              this.current = null;
              this.previous = null;
              this.MULTI_PIPELINE = null;
              this.BITMAPMASK_PIPELINE = null;
              this.UTILITY_PIPELINE = null;
              this.fullFrame1;
              this.fullFrame2;
              this.halfFrame1;
              this.halfFrame2;
            },
            boot: function(pipelineConfig) {
              var instance;
              var pipelineName;
              var _this = this;
              var game = this.game;
              this.classes.each(function(pipelineName2, pipeline) {
                instance = _this.add(pipelineName2, new pipeline({game}));
                if (pipelineName2 === CONST.UTILITY_PIPELINE) {
                  _this.UTILITY_PIPELINE = instance;
                  _this.fullFrame1 = instance.fullFrame1;
                  _this.fullFrame2 = instance.fullFrame2;
                  _this.halfFrame1 = instance.halfFrame1;
                  _this.halfFrame2 = instance.halfFrame2;
                }
              });
              this.MULTI_PIPELINE = this.get(CONST.MULTI_PIPELINE);
              this.BITMAPMASK_PIPELINE = this.get(CONST.BITMAPMASK_PIPELINE);
              if (pipelineConfig) {
                for (pipelineName in pipelineConfig) {
                  var pipelineClass = pipelineConfig[pipelineName];
                  instance = new pipelineClass(game);
                  if (instance.isPostFX) {
                    this.postPipelineClasses.set(pipelineName, pipelineClass);
                  } else if (!this.has(pipelineName)) {
                    this.classes.set(pipelineName, pipelineClass);
                    this.add(pipelineName, instance);
                  }
                }
              }
            },
            add: function(name, pipeline) {
              if (pipeline.isPostFX) {
                console.warn(name + " is a Post Pipeline. Use `addPostPipeline` instead");
                return;
              }
              var pipelines = this.pipelines;
              var renderer = this.renderer;
              if (!pipelines.has(name)) {
                pipeline.name = name;
                pipeline.manager = this;
                pipelines.set(name, pipeline);
              } else {
                console.warn("Pipeline exists: " + name);
              }
              if (!pipeline.hasBooted) {
                pipeline.boot();
              }
              if (renderer.width !== 0 && renderer.height !== 0) {
                pipeline.resize(renderer.width, renderer.height);
              }
              return pipeline;
            },
            addPostPipeline: function(name, pipeline) {
              if (!this.postPipelineClasses.has(name)) {
                this.postPipelineClasses.set(name, pipeline);
              }
            },
            flush: function() {
              if (this.current) {
                this.current.flush();
              }
            },
            has: function(pipeline) {
              var pipelines = this.pipelines;
              if (typeof pipeline === "string") {
                return pipelines.has(pipeline);
              } else if (pipelines.contains(pipeline)) {
                return true;
              }
              return false;
            },
            get: function(pipeline) {
              var pipelines = this.pipelines;
              if (typeof pipeline === "string") {
                return pipelines.get(pipeline);
              } else if (pipelines.contains(pipeline)) {
                return pipeline;
              }
            },
            getPostPipeline: function(pipeline, gameObject) {
              var pipelineClasses = this.postPipelineClasses;
              var instance;
              if (typeof pipeline === "string") {
                instance = pipelineClasses.get(pipeline);
              } else if (typeof pipeline === "function") {
                if (pipelineClasses.contains(pipeline)) {
                  instance = pipeline;
                }
              } else if (typeof pipeline === "object") {
                instance = pipelineClasses.get(pipeline.name);
              }
              if (instance) {
                var newPipeline = new instance(this.game);
                if (gameObject) {
                  newPipeline.gameObject = gameObject;
                }
                return newPipeline;
              }
            },
            remove: function(name, removeClass, removePostPipelineClass) {
              if (removeClass === void 0) {
                removeClass = true;
              }
              if (removePostPipelineClass === void 0) {
                removePostPipelineClass = true;
              }
              this.pipelines.delete(name);
              if (removeClass) {
                this.classes.delete(name);
              }
              if (removePostPipelineClass) {
                this.postPipelineClasses.delete(name);
              }
            },
            set: function(pipeline, gameObject, currentShader) {
              if (pipeline.isPostFX) {
                return;
              }
              if (!this.isCurrent(pipeline, currentShader)) {
                this.flush();
                if (this.current) {
                  this.current.unbind();
                }
                this.current = pipeline;
                pipeline.bind(currentShader);
              }
              pipeline.updateProjectionMatrix();
              pipeline.onBind(gameObject);
              return pipeline;
            },
            preBatch: function(gameObject) {
              if (gameObject.hasPostPipeline) {
                this.flush();
                var pipelines = gameObject.postPipelines;
                for (var i = pipelines.length - 1; i >= 0; i--) {
                  var pipeline = pipelines[i];
                  if (pipeline.active) {
                    pipeline.preBatch(gameObject);
                  }
                }
              }
            },
            postBatch: function(gameObject) {
              if (gameObject.hasPostPipeline) {
                this.flush();
                var pipelines = gameObject.postPipelines;
                for (var i = 0; i < pipelines.length; i++) {
                  var pipeline = pipelines[i];
                  if (pipeline.active) {
                    pipeline.postBatch(gameObject);
                  }
                }
              }
            },
            preBatchCamera: function(camera) {
              if (camera.hasPostPipeline) {
                this.flush();
                var pipelines = camera.postPipelines;
                for (var i = pipelines.length - 1; i >= 0; i--) {
                  var pipeline = pipelines[i];
                  if (pipeline.active) {
                    pipeline.preBatch(camera);
                  }
                }
              }
            },
            postBatchCamera: function(camera) {
              if (camera.hasPostPipeline) {
                this.flush();
                var pipelines = camera.postPipelines;
                for (var i = 0; i < pipelines.length; i++) {
                  var pipeline = pipelines[i];
                  if (pipeline.active) {
                    pipeline.postBatch(camera);
                  }
                }
              }
            },
            isCurrent: function(pipeline, currentShader) {
              var renderer = this.renderer;
              var current = this.current;
              if (current && !currentShader) {
                currentShader = current.currentShader;
              }
              return !(current !== pipeline || currentShader.program !== renderer.currentProgram);
            },
            copyFrame: function(source, target, brightness, clear, clearAlpha) {
              this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(source, target, brightness, clear, clearAlpha);
              return this;
            },
            copyToGame: function(source) {
              this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(source);
              return this;
            },
            drawFrame: function(source, target, clearAlpha, colorMatrix) {
              this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(source, target, clearAlpha, colorMatrix);
              return this;
            },
            blendFrames: function(source1, source2, target, strength, clearAlpha) {
              this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(source1, source2, target, strength, clearAlpha);
              return this;
            },
            blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
              this.setUtility(this.UTILITY_PIPELINE.addShader).blendFramesAdditive(source1, source2, target, strength, clearAlpha);
              return this;
            },
            clearFrame: function(target, clearAlpha) {
              this.UTILITY_PIPELINE.clearFrame(target, clearAlpha);
              return this;
            },
            blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode) {
              this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);
              return this;
            },
            copyFrameRect: function(source, target, x, y, width, height, clear, clearAlpha) {
              this.UTILITY_PIPELINE.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);
              return this;
            },
            forceZero: function() {
              return this.current && this.current.forceZero;
            },
            setMulti: function() {
              return this.set(this.MULTI_PIPELINE);
            },
            setUtility: function(currentShader) {
              return this.UTILITY_PIPELINE.bind(currentShader);
            },
            rebind: function(pipeline) {
              if (pipeline === void 0 && this.previous) {
                pipeline = this.previous;
              }
              var renderer = this.renderer;
              var gl = renderer.gl;
              gl.disable(gl.DEPTH_TEST);
              gl.disable(gl.CULL_FACE);
              if (renderer.hasActiveStencilMask()) {
                gl.clear(gl.DEPTH_BUFFER_BIT);
              } else {
                gl.disable(gl.STENCIL_TEST);
                gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
              }
              gl.viewport(0, 0, renderer.width, renderer.height);
              renderer.currentProgram = null;
              renderer.setBlendMode(0, true);
              if (pipeline) {
                this.current = pipeline;
                pipeline.rebind();
              }
              renderer.resetTextures();
            },
            clear: function() {
              var renderer = this.renderer;
              this.flush();
              if (this.current) {
                this.current.unbind();
                this.previous = this.current;
                this.current = null;
              } else {
                this.previous = null;
              }
              renderer.currentProgram = null;
              renderer.setBlendMode(0, true);
            },
            destroy: function() {
              this.flush();
              this.classes.clear();
              this.postPipelineClasses.clear();
              this.pipelines.clear();
              this.renderer = null;
              this.game = null;
              this.classes = null;
              this.postPipelineClasses = null;
              this.pipelines = null;
              this.current = null;
              this.previous = null;
            }
          });
          module2.exports = PipelineManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Felipe Alfonso <@bitnenfer>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var ShaderSourceFS = __webpack_require__(862);
          var ShaderSourceVS = __webpack_require__(863);
          var WEBGL_CONST = __webpack_require__(104);
          var WebGLPipeline = __webpack_require__(57);
          var BitmapMaskPipeline = new Class({
            Extends: WebGLPipeline,
            initialize: function BitmapMaskPipeline2(config2) {
              config2.fragShader = GetFastValue(config2, "fragShader", ShaderSourceFS), config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS), config2.batchSize = GetFastValue(config2, "batchSize", 1), config2.vertices = GetFastValue(config2, "vertices", [-1, 1, -1, -7, 7, 1]), config2.attributes = GetFastValue(config2, "attributes", [
                {
                  name: "inPosition",
                  size: 2,
                  type: WEBGL_CONST.FLOAT
                }
              ]);
              WebGLPipeline.call(this, config2);
            },
            boot: function() {
              WebGLPipeline.prototype.boot.call(this);
              this.set1i("uMainSampler", 0);
              this.set1i("uMaskSampler", 1);
            },
            resize: function(width, height) {
              WebGLPipeline.prototype.resize.call(this, width, height);
              this.set2f("uResolution", width, height);
            },
            beginMask: function(mask, maskedObject, camera) {
              var gl = this.gl;
              if (mask.bitmapMask && gl) {
                var renderer = this.renderer;
                renderer.flush();
                renderer.pushFramebuffer(mask.mainFramebuffer);
                gl.disable(gl.STENCIL_TEST);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                if (renderer.currentCameraMask.mask !== mask) {
                  renderer.currentMask.mask = mask;
                  renderer.currentMask.camera = camera;
                }
              }
            },
            endMask: function(mask, camera) {
              var gl = this.gl;
              var renderer = this.renderer;
              var bitmapMask = mask.bitmapMask;
              if (bitmapMask && gl) {
                renderer.flush();
                renderer.pushFramebuffer(mask.maskFramebuffer);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                renderer.setBlendMode(0, true);
                bitmapMask.renderWebGL(renderer, bitmapMask, camera);
                renderer.flush();
                renderer.popFramebuffer();
                renderer.popFramebuffer();
                var prev = renderer.getCurrentStencilMask();
                if (prev) {
                  gl.enable(gl.STENCIL_TEST);
                  prev.mask.applyStencil(renderer, prev.camera, true);
                } else {
                  renderer.currentMask.mask = null;
                }
                renderer.pipelines.set(this);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, mask.maskTexture);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, mask.mainTexture);
                this.set1i("uInvertMaskAlpha", mask.invertAlpha);
                gl.drawArrays(this.topology, 0, 3);
                renderer.resetTextures();
              }
            }
          });
          module2.exports = BitmapMaskPipeline;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            AFTER_FLUSH: __webpack_require__(864),
            BEFORE_FLUSH: __webpack_require__(865),
            BIND: __webpack_require__(866),
            BOOT: __webpack_require__(867),
            DESTROY: __webpack_require__(868),
            REBIND: __webpack_require__(869),
            RESIZE: __webpack_require__(870)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var WEBGL_CONST = __webpack_require__(104);
          var WebGLShader = new Class({
            initialize: function WebGLShader2(pipeline, name, vertexShader, fragmentShader, attributes) {
              this.pipeline = pipeline;
              this.name = name;
              this.renderer = pipeline.renderer;
              this.gl = this.renderer.gl;
              this.program = this.renderer.createProgram(vertexShader, fragmentShader);
              this.attributes;
              this.vertexComponentCount = 0;
              this.vertexSize = 0;
              this.uniforms = {};
              this.createAttributes(attributes);
              this.createUniforms();
            },
            createAttributes: function(attributes) {
              var count = 0;
              var offset = 0;
              var result = [];
              this.vertexComponentCount = 0;
              for (var i = 0; i < attributes.length; i++) {
                var element = attributes[i];
                var name = element.name;
                var size = GetFastValue(element, "size", 1);
                var glType = GetFastValue(element, "type", WEBGL_CONST.FLOAT);
                var type = glType.enum;
                var typeSize = glType.size;
                var normalized = element.normalized ? true : false;
                result.push({
                  name,
                  size,
                  type,
                  normalized,
                  offset,
                  enabled: false,
                  location: -1
                });
                if (typeSize === 4) {
                  count += size;
                } else {
                  count++;
                }
                offset += size * typeSize;
              }
              this.vertexSize = offset;
              this.vertexComponentCount = count;
              this.attributes = result;
            },
            bind: function(setAttributes, flush) {
              if (setAttributes === void 0) {
                setAttributes = false;
              }
              if (flush === void 0) {
                flush = false;
              }
              if (flush) {
                this.pipeline.flush();
              }
              this.renderer.setProgram(this.program);
              if (setAttributes) {
                this.setAttribPointers();
              }
              return this;
            },
            rebind: function() {
              this.renderer.setProgram(this.program);
              this.setAttribPointers(true);
              return this;
            },
            setAttribPointers: function(reset) {
              if (reset === void 0) {
                reset = false;
              }
              var gl = this.gl;
              var vertexSize = this.vertexSize;
              var attributes = this.attributes;
              var program = this.program;
              for (var i = 0; i < attributes.length; i++) {
                var element = attributes[i];
                var size = element.size;
                var type = element.type;
                var offset = element.offset;
                var enabled = element.enabled;
                var location = element.location;
                var normalized = element.normalized ? true : false;
                if (reset) {
                  var attribLocation = gl.getAttribLocation(program, element.name);
                  if (attribLocation >= 0) {
                    gl.enableVertexAttribArray(attribLocation);
                    gl.vertexAttribPointer(attribLocation, size, type, normalized, vertexSize, offset);
                    element.enabled = true;
                    element.location = attribLocation;
                  } else if (attribLocation !== -1) {
                    gl.disableVertexAttribArray(attribLocation);
                  }
                } else if (enabled) {
                  gl.vertexAttribPointer(location, size, type, normalized, vertexSize, offset);
                } else if (!enabled && location > -1) {
                  gl.disableVertexAttribArray(location);
                  element.location = -1;
                }
              }
              return this;
            },
            createUniforms: function() {
              var gl = this.gl;
              var program = this.program;
              var uniforms = this.uniforms;
              var i;
              var name;
              var location;
              var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
              for (i = 0; i < totalUniforms; i++) {
                var info = gl.getActiveUniform(program, i);
                if (info) {
                  name = info.name;
                  location = gl.getUniformLocation(program, name);
                  if (location !== null) {
                    uniforms[name] = {
                      name,
                      location,
                      value1: null,
                      value2: null,
                      value3: null,
                      value4: null
                    };
                  }
                  var struct = name.indexOf("[");
                  if (struct > 0) {
                    name = name.substr(0, struct);
                    if (!uniforms.hasOwnProperty(name)) {
                      location = gl.getUniformLocation(program, name);
                      if (location !== null) {
                        uniforms[name] = {
                          name,
                          location,
                          value1: null,
                          value2: null,
                          value3: null,
                          value4: null
                        };
                      }
                    }
                  }
                }
              }
              return this;
            },
            hasUniform: function(name) {
              return this.uniforms.hasOwnProperty(name);
            },
            resetUniform: function(name) {
              var uniform = this.uniforms[name];
              if (uniform) {
                uniform.value1 = null;
                uniform.value2 = null;
                uniform.value3 = null;
                uniform.value4 = null;
              }
              return this;
            },
            setUniform1: function(setter, name, value1) {
              var uniform = this.uniforms[name];
              if (!uniform) {
                return this;
              }
              if (uniform.value1 !== value1) {
                uniform.value1 = value1;
                this.renderer.setProgram(this.program);
                setter.call(this.gl, uniform.location, value1);
                this.pipeline.currentShader = this;
              }
              return this;
            },
            setUniform2: function(setter, name, value1, value2) {
              var uniform = this.uniforms[name];
              if (!uniform) {
                return this;
              }
              if (uniform.value1 !== value1 || uniform.value2 !== value2) {
                uniform.value1 = value1;
                uniform.value2 = value2;
                this.renderer.setProgram(this.program);
                setter.call(this.gl, uniform.location, value1, value2);
                this.pipeline.currentShader = this;
              }
              return this;
            },
            setUniform3: function(setter, name, value1, value2, value3) {
              var uniform = this.uniforms[name];
              if (!uniform) {
                return this;
              }
              if (uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3) {
                uniform.value1 = value1;
                uniform.value2 = value2;
                uniform.value3 = value3;
                this.renderer.setProgram(this.program);
                setter.call(this.gl, uniform.location, value1, value2, value3);
                this.pipeline.currentShader = this;
              }
              return this;
            },
            setUniform4: function(setter, name, value1, value2, value3, value4) {
              var uniform = this.uniforms[name];
              if (!uniform) {
                return this;
              }
              if (uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3 || uniform.value4 !== value4) {
                uniform.value1 = value1;
                uniform.value2 = value2;
                uniform.value3 = value3;
                uniform.value4 = value4;
                this.renderer.setProgram(this.program);
                setter.call(this.gl, uniform.location, value1, value2, value3, value4);
                this.pipeline.currentShader = this;
              }
              return this;
            },
            set1f: function(name, x) {
              return this.setUniform1(this.gl.uniform1f, name, x);
            },
            set2f: function(name, x, y) {
              return this.setUniform2(this.gl.uniform2f, name, x, y);
            },
            set3f: function(name, x, y, z) {
              return this.setUniform3(this.gl.uniform3f, name, x, y, z);
            },
            set4f: function(name, x, y, z, w) {
              return this.setUniform4(this.gl.uniform4f, name, x, y, z, w);
            },
            set1fv: function(name, arr) {
              return this.setUniform1(this.gl.uniform1fv, name, arr);
            },
            set2fv: function(name, arr) {
              return this.setUniform1(this.gl.uniform2fv, name, arr);
            },
            set3fv: function(name, arr) {
              return this.setUniform1(this.gl.uniform3fv, name, arr);
            },
            set4fv: function(name, arr) {
              return this.setUniform1(this.gl.uniform4fv, name, arr);
            },
            set1iv: function(name, arr) {
              return this.setUniform1(this.gl.uniform1iv, name, arr);
            },
            set2iv: function(name, arr) {
              return this.setUniform1(this.gl.uniform2iv, name, arr);
            },
            set3iv: function(name, arr) {
              return this.setUniform1(this.gl.uniform3iv, name, arr);
            },
            set4iv: function(name, arr) {
              return this.setUniform1(this.gl.uniform4iv, name, arr);
            },
            set1i: function(name, x) {
              return this.setUniform1(this.gl.uniform1i, name, x);
            },
            set2i: function(name, x, y) {
              return this.setUniform2(this.gl.uniform2i, name, x, y);
            },
            set3i: function(name, x, y, z) {
              return this.setUniform3(this.gl.uniform3i, name, x, y, z);
            },
            set4i: function(name, x, y, z, w) {
              return this.setUniform4(this.gl.uniform4i, name, x, y, z, w);
            },
            setMatrix2fv: function(name, transpose, matrix) {
              return this.setUniform2(this.gl.uniformMatrix2fv, name, transpose, matrix);
            },
            setMatrix3fv: function(name, transpose, matrix) {
              return this.setUniform2(this.gl.uniformMatrix3fv, name, transpose, matrix);
            },
            setMatrix4fv: function(name, transpose, matrix) {
              return this.setUniform2(this.gl.uniformMatrix4fv, name, transpose, matrix);
            },
            destroy: function() {
              this.gl.deleteProgram(this.program);
              this.pipeline = null;
              this.renderer = null;
              this.gl = null;
              this.program = null;
              this.attributes = null;
              this.uniforms = null;
            }
          });
          module2.exports = WebGLShader;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Felipe Alfonso <@bitnenfer>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Earcut = __webpack_require__(68);
          var GetFastValue = __webpack_require__(2);
          var ShaderSourceFS = __webpack_require__(871);
          var ShaderSourceVS = __webpack_require__(872);
          var TransformMatrix = __webpack_require__(25);
          var WEBGL_CONST = __webpack_require__(104);
          var WebGLPipeline = __webpack_require__(57);
          var GraphicsPipeline = new Class({
            Extends: WebGLPipeline,
            initialize: function GraphicsPipeline2(config2) {
              config2.fragShader = GetFastValue(config2, "fragShader", ShaderSourceFS);
              config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS);
              config2.attributes = GetFastValue(config2, "attributes", [
                {
                  name: "inPosition",
                  size: 2
                },
                {
                  name: "inColor",
                  size: 4,
                  type: WEBGL_CONST.UNSIGNED_BYTE,
                  normalized: true
                }
              ]);
              WebGLPipeline.call(this, config2);
              this.calcMatrix = new TransformMatrix();
              this.tempTriangle = [
                {x: 0, y: 0, width: 0},
                {x: 0, y: 0, width: 0},
                {x: 0, y: 0, width: 0},
                {x: 0, y: 0, width: 0}
              ];
              this.strokeTint = {TL: 0, TR: 0, BL: 0, BR: 0};
              this.fillTint = {TL: 0, TR: 0, BL: 0, BR: 0};
              this.currentFrame = {u0: 0, v0: 0, u1: 1, v1: 1};
              this.firstQuad = [0, 0, 0, 0, 0];
              this.prevQuad = [0, 0, 0, 0, 0];
              this.polygonCache = [];
            },
            batchFillRect: function(x, y, width, height, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              var calcMatrix = this.calcMatrix;
              if (parentMatrix) {
                parentMatrix.multiply(currentMatrix, calcMatrix);
              }
              var xw = x + width;
              var yh = y + height;
              var x0 = calcMatrix.getX(x, y);
              var y0 = calcMatrix.getY(x, y);
              var x1 = calcMatrix.getX(x, yh);
              var y1 = calcMatrix.getY(x, yh);
              var x2 = calcMatrix.getX(xw, yh);
              var y2 = calcMatrix.getY(xw, yh);
              var x3 = calcMatrix.getX(xw, y);
              var y3 = calcMatrix.getY(xw, y);
              var tint = this.fillTint;
              this.batchQuad(x0, y0, x1, y1, x2, y2, x3, y3, tint.TL, tint.TR, tint.BL, tint.BR);
            },
            batchFillTriangle: function(x0, y0, x1, y1, x2, y2, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              var calcMatrix = this.calcMatrix;
              if (parentMatrix) {
                parentMatrix.multiply(currentMatrix, calcMatrix);
              }
              var tx0 = calcMatrix.getX(x0, y0);
              var ty0 = calcMatrix.getY(x0, y0);
              var tx1 = calcMatrix.getX(x1, y1);
              var ty1 = calcMatrix.getY(x1, y1);
              var tx2 = calcMatrix.getX(x2, y2);
              var ty2 = calcMatrix.getY(x2, y2);
              var tint = this.fillTint;
              this.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, tint.TL, tint.TR, tint.BL);
            },
            batchStrokeTriangle: function(x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix) {
              var tempTriangle = this.tempTriangle;
              tempTriangle[0].x = x0;
              tempTriangle[0].y = y0;
              tempTriangle[0].width = lineWidth;
              tempTriangle[1].x = x1;
              tempTriangle[1].y = y1;
              tempTriangle[1].width = lineWidth;
              tempTriangle[2].x = x2;
              tempTriangle[2].y = y2;
              tempTriangle[2].width = lineWidth;
              tempTriangle[3].x = x0;
              tempTriangle[3].y = y0;
              tempTriangle[3].width = lineWidth;
              this.batchStrokePath(tempTriangle, lineWidth, false, currentMatrix, parentMatrix);
            },
            batchFillPath: function(path, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              var calcMatrix = this.calcMatrix;
              if (parentMatrix) {
                parentMatrix.multiply(currentMatrix, calcMatrix);
              }
              var length = path.length;
              var polygonCache = this.polygonCache;
              var polygonIndexArray;
              var point;
              var tintTL = this.fillTint.TL;
              var tintTR = this.fillTint.TR;
              var tintBL = this.fillTint.BL;
              for (var pathIndex = 0; pathIndex < length; ++pathIndex) {
                point = path[pathIndex];
                polygonCache.push(point.x, point.y);
              }
              polygonIndexArray = Earcut(polygonCache);
              length = polygonIndexArray.length;
              for (var index = 0; index < length; index += 3) {
                var p0 = polygonIndexArray[index + 0] * 2;
                var p1 = polygonIndexArray[index + 1] * 2;
                var p2 = polygonIndexArray[index + 2] * 2;
                var x0 = polygonCache[p0 + 0];
                var y0 = polygonCache[p0 + 1];
                var x1 = polygonCache[p1 + 0];
                var y1 = polygonCache[p1 + 1];
                var x2 = polygonCache[p2 + 0];
                var y2 = polygonCache[p2 + 1];
                var tx0 = calcMatrix.getX(x0, y0);
                var ty0 = calcMatrix.getY(x0, y0);
                var tx1 = calcMatrix.getX(x1, y1);
                var ty1 = calcMatrix.getY(x1, y1);
                var tx2 = calcMatrix.getX(x2, y2);
                var ty2 = calcMatrix.getY(x2, y2);
                this.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, tintTL, tintTR, tintBL);
              }
              polygonCache.length = 0;
            },
            batchStrokePath: function(path, lineWidth, pathOpen, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              this.prevQuad[4] = 0;
              this.firstQuad[4] = 0;
              var pathLength = path.length - 1;
              for (var pathIndex = 0; pathIndex < pathLength; pathIndex++) {
                var point0 = path[pathIndex];
                var point1 = path[pathIndex + 1];
                this.batchLine(point0.x, point0.y, point1.x, point1.y, point0.width / 2, point1.width / 2, lineWidth, pathIndex, !pathOpen && pathIndex === pathLength - 1, currentMatrix, parentMatrix);
              }
            },
            batchLine: function(ax, ay, bx, by, aLineWidth, bLineWidth, lineWidth, index, closePath, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              var calcMatrix = this.calcMatrix;
              if (parentMatrix) {
                parentMatrix.multiply(currentMatrix, calcMatrix);
              }
              var dx = bx - ax;
              var dy = by - ay;
              var len = Math.sqrt(dx * dx + dy * dy);
              var al0 = aLineWidth * (by - ay) / len;
              var al1 = aLineWidth * (ax - bx) / len;
              var bl0 = bLineWidth * (by - ay) / len;
              var bl1 = bLineWidth * (ax - bx) / len;
              var lx0 = bx - bl0;
              var ly0 = by - bl1;
              var lx1 = ax - al0;
              var ly1 = ay - al1;
              var lx2 = bx + bl0;
              var ly2 = by + bl1;
              var lx3 = ax + al0;
              var ly3 = ay + al1;
              var brX = calcMatrix.getX(lx0, ly0);
              var brY = calcMatrix.getY(lx0, ly0);
              var blX = calcMatrix.getX(lx1, ly1);
              var blY = calcMatrix.getY(lx1, ly1);
              var trX = calcMatrix.getX(lx2, ly2);
              var trY = calcMatrix.getY(lx2, ly2);
              var tlX = calcMatrix.getX(lx3, ly3);
              var tlY = calcMatrix.getY(lx3, ly3);
              var tint = this.strokeTint;
              var tintTL = tint.TL;
              var tintTR = tint.TR;
              var tintBL = tint.BL;
              var tintBR = tint.BR;
              this.batchQuad(tlX, tlY, blX, blY, brX, brY, trX, trY, tintTL, tintTR, tintBL, tintBR);
              if (lineWidth <= 2) {
                return;
              }
              var prev = this.prevQuad;
              var first = this.firstQuad;
              if (index > 0 && prev[4]) {
                this.batchQuad(tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], tintTL, tintTR, tintBL, tintBR);
              } else {
                first[0] = tlX;
                first[1] = tlY;
                first[2] = blX;
                first[3] = blY;
                first[4] = 1;
              }
              if (closePath && first[4]) {
                this.batchQuad(brX, brY, trX, trY, first[0], first[1], first[2], first[3], tintTL, tintTR, tintBL, tintBR);
              } else {
                prev[0] = brX;
                prev[1] = brY;
                prev[2] = trX;
                prev[3] = trY;
                prev[4] = 1;
              }
            },
            batchVert: function(x, y, tint) {
              var vertexViewF32 = this.vertexViewF32;
              var vertexViewU32 = this.vertexViewU32;
              var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
              vertexViewF32[++vertexOffset] = x;
              vertexViewF32[++vertexOffset] = y;
              vertexViewU32[++vertexOffset] = tint;
              this.vertexCount++;
            },
            batchQuad: function(x0, y0, x1, y1, x2, y2, x3, y3, tintTL, tintTR, tintBL, tintBR) {
              var hasFlushed = false;
              if (this.shouldFlush(6)) {
                this.flush();
                hasFlushed = true;
              }
              this.batchVert(x0, y0, tintTL);
              this.batchVert(x1, y1, tintBL);
              this.batchVert(x2, y2, tintBR);
              this.batchVert(x0, y0, tintTL);
              this.batchVert(x2, y2, tintBR);
              this.batchVert(x3, y3, tintTR);
              return hasFlushed;
            },
            batchTri: function(x0, y0, x1, y1, x2, y2, tintTL, tintTR, tintBL) {
              var hasFlushed = false;
              if (this.shouldFlush(3)) {
                this.flush();
                hasFlushed = true;
              }
              this.batchVert(x0, y0, tintTL);
              this.batchVert(x1, y1, tintTR);
              this.batchVert(x2, y2, tintBL);
              return hasFlushed;
            },
            destroy: function() {
              WebGLPipeline.prototype.destroy.call(this);
              this.polygonCache = null;
              return this;
            }
          });
          module2.exports = GraphicsPipeline;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Felipe Alfonso <@bitnenfer>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var LightShaderSourceFS = __webpack_require__(873);
          var MultiPipeline = __webpack_require__(105);
          var Vec2 = __webpack_require__(3);
          var WebGLPipeline = __webpack_require__(57);
          var LIGHT_COUNT = 10;
          var tempVec2 = new Vec2();
          var LightPipeline = new Class({
            Extends: MultiPipeline,
            initialize: function LightPipeline2(config2) {
              LIGHT_COUNT = config2.game.renderer.config.maxLights;
              var fragShader = GetFastValue(config2, "fragShader", LightShaderSourceFS);
              var shaders = [];
              for (var i = 1; i <= LIGHT_COUNT; i++) {
                shaders.push({
                  name: "lights" + i,
                  fragShader: fragShader.replace("%LIGHT_COUNT%", i.toString())
                });
              }
              config2.shaders = shaders;
              MultiPipeline.call(this, config2);
              this.inverseRotationMatrix = new Float32Array([
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1
              ]);
              this.defaultNormalMap;
            },
            boot: function() {
              WebGLPipeline.prototype.boot.call(this);
              var gl = this.gl;
              var tempTexture = gl.createTexture();
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, tempTexture);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([127, 127, 255, 255]));
              this.defaultNormalMap = {glTexture: tempTexture};
              for (var i = 0; i < this.shaders.length; i++) {
                this["lightShader" + (i + 1)] = this.shaders[i];
              }
            },
            onRender: function(scene, camera) {
              var lightManager = scene.sys.lights;
              if (!lightManager || !lightManager.active) {
                return;
              }
              var lights = lightManager.getLights(camera);
              var lightsCount = lights.length;
              if (lightsCount === 0) {
                return;
              }
              this.setShader(this["lightShader" + lightsCount], true);
              var i;
              var renderer = this.renderer;
              var height = renderer.height;
              var cameraMatrix = camera.matrix;
              this.set1i("uMainSampler", 0);
              this.set1i("uNormSampler", 1);
              this.set2f("uResolution", this.width / 2, this.height / 2);
              this.set4f("uCamera", camera.x, camera.y, camera.rotation, camera.zoom);
              this.set3f("uAmbientLightColor", lightManager.ambientColor.r, lightManager.ambientColor.g, lightManager.ambientColor.b);
              for (i = 0; i < lightsCount; i++) {
                var light = lights[i].light;
                var color = light.color;
                var lightName = "uLights[" + i + "].";
                cameraMatrix.transformPoint(light.x, light.y, tempVec2);
                this.set2f(lightName + "position", tempVec2.x - camera.scrollX * light.scrollFactorX * camera.zoom, height - (tempVec2.y - camera.scrollY * light.scrollFactorY * camera.zoom));
                this.set3f(lightName + "color", color.r, color.g, color.b);
                this.set1f(lightName + "intensity", light.intensity);
                this.set1f(lightName + "radius", light.radius);
              }
              this.currentNormalMapRotation = null;
            },
            setNormalMapRotation: function(rotation) {
              if (rotation !== this.currentNormalMapRotation || this.vertexCount === 0) {
                if (this.vertexCount > 0) {
                  this.flush();
                }
                var inverseRotationMatrix = this.inverseRotationMatrix;
                if (rotation) {
                  var rot = -rotation;
                  var c = Math.cos(rot);
                  var s = Math.sin(rot);
                  inverseRotationMatrix[1] = s;
                  inverseRotationMatrix[3] = -s;
                  inverseRotationMatrix[0] = inverseRotationMatrix[4] = c;
                } else {
                  inverseRotationMatrix[0] = inverseRotationMatrix[4] = 1;
                  inverseRotationMatrix[1] = inverseRotationMatrix[3] = 0;
                }
                this.setMatrix3fv("uInverseRotationMatrix", false, inverseRotationMatrix);
                this.currentNormalMapRotation = rotation;
              }
            },
            setTexture2D: function(texture, gameObject) {
              var renderer = this.renderer;
              if (texture === void 0) {
                texture = renderer.tempTextures[0];
              }
              var normalTexture = this.getNormalMap(gameObject);
              if (renderer.isNewNormalMap(texture, normalTexture)) {
                this.flush();
                renderer.setTextureZero(texture);
                renderer.setNormalMap(normalTexture);
              }
              var rotation = gameObject ? gameObject.rotation : 0;
              this.setNormalMapRotation(rotation);
              this.currentUnit = 0;
              return 0;
            },
            setGameObject: function(gameObject, frame) {
              if (frame === void 0) {
                frame = gameObject.frame;
              }
              var renderer = this.renderer;
              var texture = frame.glTexture;
              var normalTexture = this.getNormalMap(gameObject);
              if (renderer.isNewNormalMap()) {
                this.flush();
                renderer.setTextureZero(texture);
                renderer.setNormalMap(normalTexture);
              }
              this.setNormalMapRotation(gameObject.rotation);
              this.currentUnit = 0;
              return 0;
            },
            getNormalMap: function(gameObject) {
              var normalTexture;
              if (!gameObject) {
                normalTexture = this.defaultNormalMap;
              } else if (gameObject.displayTexture) {
                normalTexture = gameObject.displayTexture.dataSource[gameObject.displayFrame.sourceIndex];
              } else if (gameObject.texture) {
                normalTexture = gameObject.texture.dataSource[gameObject.frame.sourceIndex];
              } else if (gameObject.tileset) {
                if (Array.isArray(gameObject.tileset)) {
                  normalTexture = gameObject.tileset[0].image.dataSource[0];
                } else {
                  normalTexture = gameObject.tileset.image.dataSource[0];
                }
              }
              if (!normalTexture) {
                normalTexture = this.defaultNormalMap;
              }
              return normalTexture.glTexture;
            }
          });
          LightPipeline.LIGHT_COUNT = LIGHT_COUNT;
          module2.exports = LightPipeline;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var PointLightShaderSourceFS = __webpack_require__(876);
          var PointLightShaderSourceVS = __webpack_require__(877);
          var WebGLPipeline = __webpack_require__(57);
          var PointLightPipeline = new Class({
            Extends: WebGLPipeline,
            initialize: function PointLightPipeline2(config2) {
              config2.vertShader = GetFastValue(config2, "vertShader", PointLightShaderSourceVS);
              config2.fragShader = GetFastValue(config2, "fragShader", PointLightShaderSourceFS);
              config2.attributes = GetFastValue(config2, "attributes", [
                {
                  name: "inPosition",
                  size: 2
                },
                {
                  name: "inLightPosition",
                  size: 2
                },
                {
                  name: "inLightRadius"
                },
                {
                  name: "inLightAttenuation"
                },
                {
                  name: "inLightColor",
                  size: 4
                }
              ]);
              WebGLPipeline.call(this, config2);
            },
            onRender: function(scene, camera) {
              this.set2f("uResolution", this.width, this.height);
              this.set1f("uCameraZoom", camera.zoom);
            },
            batchPointLight: function(light, camera, x0, y0, x1, y1, x2, y2, x3, y3, lightX, lightY) {
              var color = light.color;
              var intensity = light.intensity;
              var radius = light.radius;
              var attenuation = light.attenuation;
              var r = color.r * intensity;
              var g = color.g * intensity;
              var b = color.b * intensity;
              var a = camera.alpha * light.alpha;
              if (this.shouldFlush(6)) {
                this.flush();
              }
              this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a);
              this.batchLightVert(x1, y1, lightX, lightY, radius, attenuation, r, g, b, a);
              this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a);
              this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a);
              this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a);
              this.batchLightVert(x3, y3, lightX, lightY, radius, attenuation, r, g, b, a);
            },
            batchLightVert: function(x, y, lightX, lightY, radius, attenuation, r, g, b, a) {
              var vertexViewF32 = this.vertexViewF32;
              var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
              vertexViewF32[++vertexOffset] = x;
              vertexViewF32[++vertexOffset] = y;
              vertexViewF32[++vertexOffset] = lightX;
              vertexViewF32[++vertexOffset] = lightY;
              vertexViewF32[++vertexOffset] = radius;
              vertexViewF32[++vertexOffset] = attenuation;
              vertexViewF32[++vertexOffset] = r;
              vertexViewF32[++vertexOffset] = g;
              vertexViewF32[++vertexOffset] = b;
              vertexViewF32[++vertexOffset] = a;
              this.vertexCount++;
            }
          });
          module2.exports = PointLightPipeline;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var MultiPipeline = __webpack_require__(105);
          var RopePipeline = new Class({
            Extends: MultiPipeline,
            initialize: function RopePipeline2(config2) {
              config2.topology = 5;
              config2.batchSize = GetFastValue(config2, "batchSize", 256);
              MultiPipeline.call(this, config2);
            }
          });
          module2.exports = RopePipeline;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var MultiPipeline = __webpack_require__(105);
          var ShaderSourceFS = __webpack_require__(878);
          var ShaderSourceVS = __webpack_require__(879);
          var WebGLPipeline = __webpack_require__(57);
          var SinglePipeline = new Class({
            Extends: MultiPipeline,
            initialize: function SinglePipeline2(config2) {
              config2.fragShader = GetFastValue(config2, "fragShader", ShaderSourceFS), config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS), config2.forceZero = true;
              MultiPipeline.call(this, config2);
            },
            boot: function() {
              WebGLPipeline.prototype.boot.call(this);
              this.set1i("uMainSampler", 0);
            }
          });
          module2.exports = SinglePipeline;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AddBlendFS = __webpack_require__(880);
          var BlendModes = __webpack_require__(34);
          var Class = __webpack_require__(0);
          var ColorMatrix = __webpack_require__(195);
          var ColorMatrixFS = __webpack_require__(881);
          var CopyFS = __webpack_require__(882);
          var GetFastValue = __webpack_require__(2);
          var LinearBlendFS = __webpack_require__(883);
          var QuadVS = __webpack_require__(376);
          var WebGLPipeline = __webpack_require__(57);
          var UtilityPipeline = new Class({
            Extends: WebGLPipeline,
            initialize: function UtilityPipeline2(config2) {
              config2.renderTarget = GetFastValue(config2, "renderTarget", [
                {
                  scale: 1
                },
                {
                  scale: 1
                },
                {
                  scale: 0.5
                },
                {
                  scale: 0.5
                }
              ]);
              config2.vertShader = GetFastValue(config2, "vertShader", QuadVS);
              config2.shaders = GetFastValue(config2, "shaders", [
                {
                  name: "Copy",
                  fragShader: CopyFS
                },
                {
                  name: "AddBlend",
                  fragShader: AddBlendFS
                },
                {
                  name: "LinearBlend",
                  fragShader: LinearBlendFS
                },
                {
                  name: "ColorMatrix",
                  fragShader: ColorMatrixFS
                }
              ]);
              config2.attributes = GetFastValue(config2, "attributes", [
                {
                  name: "inPosition",
                  size: 2
                },
                {
                  name: "inTexCoord",
                  size: 2
                }
              ]);
              config2.vertices = [
                -1,
                -1,
                0,
                0,
                -1,
                1,
                0,
                1,
                1,
                1,
                1,
                1,
                -1,
                -1,
                0,
                0,
                1,
                1,
                1,
                1,
                1,
                -1,
                1,
                0
              ];
              config2.batchSize = 1;
              WebGLPipeline.call(this, config2);
              this.colorMatrix = new ColorMatrix();
              this.copyShader;
              this.addShader;
              this.linearShader;
              this.colorMatrixShader;
              this.fullFrame1;
              this.fullFrame2;
              this.halfFrame1;
              this.halfFrame2;
            },
            boot: function() {
              WebGLPipeline.prototype.boot.call(this);
              var shaders = this.shaders;
              var targets = this.renderTargets;
              this.copyShader = shaders[0];
              this.addShader = shaders[1];
              this.linearShader = shaders[2];
              this.colorMatrixShader = shaders[3];
              this.fullFrame1 = targets[0];
              this.fullFrame2 = targets[1];
              this.halfFrame1 = targets[2];
              this.halfFrame2 = targets[3];
            },
            copyFrame: function(source, target, brightness, clear, clearAlpha) {
              if (brightness === void 0) {
                brightness = 1;
              }
              if (clear === void 0) {
                clear = true;
              }
              if (clearAlpha === void 0) {
                clearAlpha = true;
              }
              var gl = this.gl;
              this.setShader(this.copyShader);
              this.set1i("uMainSampler", 0);
              this.set1f("uBrightness", brightness);
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, source.texture);
              if (target) {
                gl.viewport(0, 0, target.width, target.height);
                gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
              } else {
                gl.viewport(0, 0, source.width, source.height);
              }
              if (clear) {
                if (clearAlpha) {
                  gl.clearColor(0, 0, 0, 0);
                } else {
                  gl.clearColor(0, 0, 0, 1);
                }
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
              gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.bindTexture(gl.TEXTURE_2D, null);
            },
            blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode) {
              if (brightness === void 0) {
                brightness = 1;
              }
              if (clear === void 0) {
                clear = true;
              }
              if (clearAlpha === void 0) {
                clearAlpha = true;
              }
              if (eraseMode === void 0) {
                eraseMode = false;
              }
              var gl = this.gl;
              this.setShader(this.copyShader);
              this.set1i("uMainSampler", 0);
              this.set1f("uBrightness", brightness);
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, source.texture);
              if (source.height > target.height) {
                gl.viewport(0, 0, source.width, source.height);
                this.setTargetUVs(source, target);
              } else {
                var diff = target.height - source.height;
                gl.viewport(0, diff, source.width, source.height);
              }
              gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
              if (clear) {
                if (clearAlpha) {
                  gl.clearColor(0, 0, 0, 0);
                } else {
                  gl.clearColor(0, 0, 0, 1);
                }
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
              if (eraseMode) {
                var blendMode = this.renderer.currentBlendMode;
                this.renderer.setBlendMode(BlendModes.ERASE);
              }
              gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              if (eraseMode) {
                this.renderer.setBlendMode(blendMode);
              }
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.bindTexture(gl.TEXTURE_2D, null);
              this.resetUVs();
            },
            copyFrameRect: function(source, target, x, y, width, height, clear, clearAlpha) {
              if (clear === void 0) {
                clear = true;
              }
              if (clearAlpha === void 0) {
                clearAlpha = true;
              }
              var gl = this.gl;
              gl.bindFramebuffer(gl.FRAMEBUFFER, source.framebuffer);
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, source.texture, 0);
              if (clear) {
                if (clearAlpha) {
                  gl.clearColor(0, 0, 0, 0);
                } else {
                  gl.clearColor(0, 0, 0, 1);
                }
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, target.texture);
              gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, y, width, height);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.bindTexture(gl.TEXTURE_2D, null);
            },
            copyToGame: function(source) {
              var gl = this.gl;
              this.setShader(this.copyShader);
              this.set1i("uMainSampler", 0);
              this.set1f("uBrightness", 1);
              this.renderer.popFramebuffer();
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, source.texture);
              gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              this.renderer.resetTextures();
            },
            drawFrame: function(source, target, clearAlpha, colorMatrix) {
              if (clearAlpha === void 0) {
                clearAlpha = true;
              }
              if (colorMatrix === void 0) {
                colorMatrix = this.colorMatrix;
              }
              var gl = this.gl;
              this.setShader(this.colorMatrixShader);
              this.set1i("uMainSampler", 0);
              this.set1fv("uColorMatrix", colorMatrix.getData());
              this.set1f("uAlpha", colorMatrix.alpha);
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, source.texture);
              if (target) {
                gl.viewport(0, 0, target.width, target.height);
                gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
              } else {
                gl.viewport(0, 0, source.width, source.height);
              }
              if (clearAlpha) {
                gl.clearColor(0, 0, 0, 0);
              } else {
                gl.clearColor(0, 0, 0, 1);
              }
              gl.clear(gl.COLOR_BUFFER_BIT);
              gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.bindTexture(gl.TEXTURE_2D, null);
            },
            blendFrames: function(source1, source2, target, strength, clearAlpha, blendShader) {
              if (strength === void 0) {
                strength = 1;
              }
              if (clearAlpha === void 0) {
                clearAlpha = true;
              }
              if (blendShader === void 0) {
                blendShader = this.linearShader;
              }
              var gl = this.gl;
              this.setShader(blendShader);
              this.set1i("uMainSampler1", 0);
              this.set1i("uMainSampler2", 1);
              this.set1f("uStrength", strength);
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, source1.texture);
              gl.activeTexture(gl.TEXTURE1);
              gl.bindTexture(gl.TEXTURE_2D, source2.texture);
              if (target) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
                gl.viewport(0, 0, target.width, target.height);
              } else {
                gl.viewport(0, 0, source1.width, source1.height);
              }
              if (clearAlpha) {
                gl.clearColor(0, 0, 0, 0);
              } else {
                gl.clearColor(0, 0, 0, 1);
              }
              gl.clear(gl.COLOR_BUFFER_BIT);
              gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.bindTexture(gl.TEXTURE_2D, null);
            },
            blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
              this.blendFrames(source1, source2, target, strength, clearAlpha, this.addShader);
            },
            clearFrame: function(target, clearAlpha) {
              if (clearAlpha === void 0) {
                clearAlpha = true;
              }
              var gl = this.gl;
              gl.viewport(0, 0, target.width, target.height);
              gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
              if (clearAlpha) {
                gl.clearColor(0, 0, 0, 0);
              } else {
                gl.clearColor(0, 0, 0, 1);
              }
              gl.clear(gl.COLOR_BUFFER_BIT);
              var fbo = this.renderer.currentFramebuffer;
              gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            },
            setUVs: function(uA, vA, uB, vB, uC, vC, uD, vD) {
              var vertexViewF32 = this.vertexViewF32;
              vertexViewF32[2] = uA;
              vertexViewF32[3] = vA;
              vertexViewF32[6] = uB;
              vertexViewF32[7] = vB;
              vertexViewF32[10] = uC;
              vertexViewF32[11] = vC;
              vertexViewF32[14] = uA;
              vertexViewF32[15] = vA;
              vertexViewF32[18] = uC;
              vertexViewF32[19] = vC;
              vertexViewF32[22] = uD;
              vertexViewF32[23] = vD;
            },
            setTargetUVs: function(source, target) {
              var diff = target.height / source.height;
              if (diff > 0.5) {
                diff = 0.5 - (diff - 0.5);
              } else {
                diff = 0.5 + (0.5 - diff);
              }
              this.setUVs(0, diff, 0, 1 + diff, 1, 1 + diff, 1, diff);
            },
            flipX: function() {
              this.setUVs(1, 0, 1, 1, 0, 1, 0, 0);
            },
            flipY: function() {
              this.setUVs(0, 1, 0, 0, 1, 0, 1, 1);
            },
            resetUVs: function() {
              this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
            }
          });
          module2.exports = UtilityPipeline;
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_QUAD_VS",
            "",
            "precision mediump float;",
            "",
            "attribute vec2 inPosition;",
            "attribute vec2 inTexCoord;",
            "",
            "varying vec2 outFragCoord;",
            "varying vec2 outTexCoord;",
            "",
            "void main ()",
            "{",
            "    outFragCoord = inPosition.xy * 0.5 + 0.5;",
            "    outTexCoord = inTexCoord;",
            "",
            "    gl_Position = vec4(inPosition, 0, 1);",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CanvasPool = __webpack_require__(31);
          var Color = __webpack_require__(37);
          var GetFastValue = __webpack_require__(2);
          var WebGLSnapshot = function(sourceCanvas, config2) {
            var gl = sourceCanvas.getContext("experimental-webgl");
            var callback = GetFastValue(config2, "callback");
            var type = GetFastValue(config2, "type", "image/png");
            var encoderOptions = GetFastValue(config2, "encoder", 0.92);
            var x = GetFastValue(config2, "x", 0);
            var y = GetFastValue(config2, "y", 0);
            var getPixel = GetFastValue(config2, "getPixel", false);
            var isFramebuffer = GetFastValue(config2, "isFramebuffer", false);
            var bufferWidth = isFramebuffer ? GetFastValue(config2, "bufferWidth", 1) : gl.drawingBufferWidth;
            var bufferHeight = isFramebuffer ? GetFastValue(config2, "bufferHeight", 1) : gl.drawingBufferHeight;
            if (getPixel) {
              var pixel = new Uint8Array(4);
              var destY = isFramebuffer ? y : bufferHeight - y;
              gl.readPixels(x, destY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
              callback.call(null, new Color(pixel[0], pixel[1], pixel[2], pixel[3] / 255));
            } else {
              var width = GetFastValue(config2, "width", bufferWidth);
              var height = GetFastValue(config2, "height", bufferHeight);
              var total = width * height * 4;
              var pixels = new Uint8Array(total);
              gl.readPixels(x, bufferHeight - y - height, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
              var canvas = CanvasPool.createWebGL(this, width, height);
              var ctx = canvas.getContext("2d");
              var imageData = ctx.getImageData(0, 0, width, height);
              var data = imageData.data;
              for (var py = 0; py < height; py++) {
                for (var px = 0; px < width; px++) {
                  var sourceIndex = ((height - py - 1) * width + px) * 4;
                  var destIndex = (py * width + px) * 4;
                  data[destIndex + 0] = pixels[sourceIndex + 0];
                  data[destIndex + 1] = pixels[sourceIndex + 1];
                  data[destIndex + 2] = pixels[sourceIndex + 2];
                  data[destIndex + 3] = pixels[sourceIndex + 3];
                }
              }
              ctx.putImageData(imageData, 0, 0);
              var image = new Image();
              image.onerror = function() {
                callback.call(null);
                CanvasPool.remove(canvas);
              };
              image.onload = function() {
                callback.call(null, image);
                CanvasPool.remove(canvas);
              };
              image.src = canvas.toDataURL(type, encoderOptions);
            }
          };
          module2.exports = WebGLSnapshot;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(32);
          var DebugHeader = function(game) {
            var config2 = game.config;
            if (config2.hideBanner) {
              return;
            }
            var renderType = "WebGL";
            if (config2.renderType === CONST.CANVAS) {
              renderType = "Canvas";
            } else if (config2.renderType === CONST.HEADLESS) {
              renderType = "Headless";
            }
            var audioConfig = config2.audio;
            var deviceAudio = game.device.audio;
            var audioType;
            if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
              audioType = "Web Audio";
            } else if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
              audioType = "No Audio";
            } else {
              audioType = "HTML5 Audio";
            }
            if (!game.device.browser.ie) {
              var c = "";
              var args = [c];
              if (Array.isArray(config2.bannerBackgroundColor)) {
                var lastColor;
                config2.bannerBackgroundColor.forEach(function(color) {
                  c = c.concat("%c ");
                  args.push("background: " + color);
                  lastColor = color;
                });
                args[args.length - 1] = "color: " + config2.bannerTextColor + "; background: " + lastColor;
              } else {
                c = c.concat("%c ");
                args.push("color: " + config2.bannerTextColor + "; background: " + config2.bannerBackgroundColor);
              }
              args.push("background: transparent");
              if (config2.gameTitle) {
                c = c.concat(config2.gameTitle);
                if (config2.gameVersion) {
                  c = c.concat(" v" + config2.gameVersion);
                }
                if (!config2.hidePhaser) {
                  c = c.concat(" / ");
                }
              }
              var fb = false ? void 0 : "";
              if (!config2.hidePhaser) {
                c = c.concat("Phaser v" + CONST.VERSION + fb + " (" + renderType + " | " + audioType + ")");
              }
              c = c.concat(" %c " + config2.gameURL);
              args[0] = c;
              console.log.apply(console, args);
            } else if (window["console"]) {
              console.log("Phaser v" + CONST.VERSION + " / https://phaser.io");
            }
          };
          module2.exports = DebugHeader;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetValue = __webpack_require__(6);
          var NOOP = __webpack_require__(1);
          var RequestAnimationFrame = __webpack_require__(380);
          var TimeStep = new Class({
            initialize: function TimeStep2(game, config2) {
              this.game = game;
              this.raf = new RequestAnimationFrame();
              this.started = false;
              this.running = false;
              this.minFps = GetValue(config2, "min", 5);
              this.targetFps = GetValue(config2, "target", 60);
              this._min = 1e3 / this.minFps;
              this._target = 1e3 / this.targetFps;
              this.actualFps = this.targetFps;
              this.nextFpsUpdate = 0;
              this.framesThisSecond = 0;
              this.callback = NOOP;
              this.forceSetTimeOut = GetValue(config2, "forceSetTimeOut", false);
              this.time = 0;
              this.startTime = 0;
              this.lastTime = 0;
              this.frame = 0;
              this.inFocus = true;
              this._pauseTime = 0;
              this._coolDown = 0;
              this.delta = 0;
              this.deltaIndex = 0;
              this.deltaHistory = [];
              this.deltaSmoothingMax = GetValue(config2, "deltaHistory", 10);
              this.panicMax = GetValue(config2, "panicMax", 120);
              this.rawDelta = 0;
              this.now = 0;
              this.smoothStep = GetValue(config2, "smoothStep", true);
            },
            blur: function() {
              this.inFocus = false;
            },
            focus: function() {
              this.inFocus = true;
              this.resetDelta();
            },
            pause: function() {
              this._pauseTime = window.performance.now();
            },
            resume: function() {
              this.resetDelta();
              this.startTime += this.time - this._pauseTime;
            },
            resetDelta: function() {
              var now = window.performance.now();
              this.time = now;
              this.lastTime = now;
              this.nextFpsUpdate = now + 1e3;
              this.framesThisSecond = 0;
              for (var i = 0; i < this.deltaSmoothingMax; i++) {
                this.deltaHistory[i] = Math.min(this._target, this.deltaHistory[i]);
              }
              this.delta = 0;
              this.deltaIndex = 0;
              this._coolDown = this.panicMax;
            },
            start: function(callback) {
              if (this.started) {
                return this;
              }
              this.started = true;
              this.running = true;
              for (var i = 0; i < this.deltaSmoothingMax; i++) {
                this.deltaHistory[i] = this._target;
              }
              this.resetDelta();
              this.startTime = window.performance.now();
              this.callback = callback;
              this.raf.start(this.step.bind(this), this.forceSetTimeOut, this._target);
            },
            step: function() {
              var time = window.performance.now();
              this.now = time;
              var before = time - this.lastTime;
              if (before < 0) {
                before = 0;
              }
              this.rawDelta = before;
              var idx = this.deltaIndex;
              var history = this.deltaHistory;
              var max = this.deltaSmoothingMax;
              var dt = before;
              var avg = before;
              if (this.smoothStep) {
                if (this._coolDown > 0 || !this.inFocus) {
                  this._coolDown--;
                  dt = Math.min(dt, this._target);
                }
                if (dt > this._min) {
                  dt = history[idx];
                  dt = Math.min(dt, this._min);
                }
                history[idx] = dt;
                this.deltaIndex++;
                if (this.deltaIndex > max) {
                  this.deltaIndex = 0;
                }
                avg = 0;
                for (var i = 0; i < max; i++) {
                  avg += history[i];
                }
                avg /= max;
              }
              this.delta = avg;
              this.time += this.rawDelta;
              if (time > this.nextFpsUpdate) {
                this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps;
                this.nextFpsUpdate = time + 1e3;
                this.framesThisSecond = 0;
              }
              this.framesThisSecond++;
              var interpolation = avg / this._target;
              this.callback(time, avg, interpolation);
              this.lastTime = time;
              this.frame++;
            },
            tick: function() {
              this.step();
            },
            sleep: function() {
              if (this.running) {
                this.raf.stop();
                this.running = false;
              }
            },
            wake: function(seamless) {
              if (this.running) {
                return;
              } else if (seamless) {
                this.startTime += -this.lastTime + (this.lastTime + window.performance.now());
              }
              this.raf.start(this.step.bind(this), this.useRAF);
              this.running = true;
              this.step();
            },
            getDuration: function() {
              return Math.round(this.lastTime - this.startTime) / 1e3;
            },
            getDurationMS: function() {
              return Math.round(this.lastTime - this.startTime);
            },
            stop: function() {
              this.running = false;
              this.started = false;
              this.raf.stop();
              return this;
            },
            destroy: function() {
              this.stop();
              this.callback = NOOP;
              this.raf = null;
              this.game = null;
            }
          });
          module2.exports = TimeStep;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var NOOP = __webpack_require__(1);
          var RequestAnimationFrame = new Class({
            initialize: function RequestAnimationFrame2() {
              this.isRunning = false;
              this.callback = NOOP;
              this.tick = 0;
              this.isSetTimeOut = false;
              this.timeOutID = null;
              this.lastTime = 0;
              this.target = 0;
              var _this = this;
              this.step = function step() {
                var timestamp = window.performance.now();
                _this.lastTime = _this.tick;
                _this.tick = timestamp;
                _this.callback(timestamp);
                _this.timeOutID = window.requestAnimationFrame(step);
              };
              this.stepTimeout = function stepTimeout() {
                var d = Date.now();
                var delay = Math.min(Math.max(_this.target * 2 + _this.tick - d, 0), _this.target);
                _this.lastTime = _this.tick;
                _this.tick = d;
                _this.callback(d);
                _this.timeOutID = window.setTimeout(stepTimeout, delay);
              };
            },
            start: function(callback, forceSetTimeOut, targetFPS) {
              if (this.isRunning) {
                return;
              }
              this.callback = callback;
              this.isSetTimeOut = forceSetTimeOut;
              this.target = targetFPS;
              this.isRunning = true;
              this.timeOutID = forceSetTimeOut ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step);
            },
            stop: function() {
              this.isRunning = false;
              if (this.isSetTimeOut) {
                clearTimeout(this.timeOutID);
              } else {
                window.cancelAnimationFrame(this.timeOutID);
              }
            },
            destroy: function() {
              this.stop();
              this.callback = NOOP;
            }
          });
          module2.exports = RequestAnimationFrame;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Events = __webpack_require__(22);
          var VisibilityHandler = function(game) {
            var hiddenVar;
            var eventEmitter = game.events;
            if (document.hidden !== void 0) {
              hiddenVar = "visibilitychange";
            } else {
              var vendors = ["webkit", "moz", "ms"];
              vendors.forEach(function(prefix) {
                if (document[prefix + "Hidden"] !== void 0) {
                  document.hidden = function() {
                    return document[prefix + "Hidden"];
                  };
                  hiddenVar = prefix + "visibilitychange";
                }
              });
            }
            var onChange = function(event) {
              if (document.hidden || event.type === "pause") {
                eventEmitter.emit(Events.HIDDEN);
              } else {
                eventEmitter.emit(Events.VISIBLE);
              }
            };
            if (hiddenVar) {
              document.addEventListener(hiddenVar, onChange, false);
            }
            window.onblur = function() {
              eventEmitter.emit(Events.BLUR);
            };
            window.onfocus = function() {
              eventEmitter.emit(Events.FOCUS);
            };
            if (window.focus && game.config.autoFocus) {
              window.focus();
            }
          };
          module2.exports = VisibilityHandler;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Arne16 = __webpack_require__(383);
          var CanvasPool = __webpack_require__(31);
          var GetValue = __webpack_require__(6);
          var GenerateTexture = function(config2) {
            var data = GetValue(config2, "data", []);
            var canvas = GetValue(config2, "canvas", null);
            var palette = GetValue(config2, "palette", Arne16);
            var pixelWidth = GetValue(config2, "pixelWidth", 1);
            var pixelHeight = GetValue(config2, "pixelHeight", pixelWidth);
            var resizeCanvas = GetValue(config2, "resizeCanvas", true);
            var clearCanvas = GetValue(config2, "clearCanvas", true);
            var preRender = GetValue(config2, "preRender", null);
            var postRender = GetValue(config2, "postRender", null);
            var width = Math.floor(Math.abs(data[0].length * pixelWidth));
            var height = Math.floor(Math.abs(data.length * pixelHeight));
            if (!canvas) {
              canvas = CanvasPool.create2D(this, width, height);
              resizeCanvas = false;
              clearCanvas = false;
            }
            if (resizeCanvas) {
              canvas.width = width;
              canvas.height = height;
            }
            var ctx = canvas.getContext("2d");
            if (clearCanvas) {
              ctx.clearRect(0, 0, width, height);
            }
            if (preRender) {
              preRender(canvas, ctx);
            }
            for (var y = 0; y < data.length; y++) {
              var row = data[y];
              for (var x = 0; x < row.length; x++) {
                var d = row[x];
                if (d !== "." && d !== " ") {
                  ctx.fillStyle = palette[d];
                  ctx.fillRect(x * pixelWidth, y * pixelHeight, pixelWidth, pixelHeight);
                }
              }
            }
            if (postRender) {
              postRender(canvas, ctx);
            }
            return canvas;
          };
          module2.exports = GenerateTexture;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            0: "#000",
            1: "#9D9D9D",
            2: "#FFF",
            3: "#BE2633",
            4: "#E06F8B",
            5: "#493C2B",
            6: "#A46422",
            7: "#EB8931",
            8: "#F7E26B",
            9: "#2F484E",
            A: "#44891A",
            B: "#A3CE27",
            C: "#1B2632",
            D: "#005784",
            E: "#31A2F2",
            F: "#B2DCEF"
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CubicBezier = __webpack_require__(352);
          var Curve = __webpack_require__(90);
          var Vector29 = __webpack_require__(3);
          var CubicBezierCurve = new Class({
            Extends: Curve,
            initialize: function CubicBezierCurve2(p0, p1, p2, p3) {
              Curve.call(this, "CubicBezierCurve");
              if (Array.isArray(p0)) {
                p3 = new Vector29(p0[6], p0[7]);
                p2 = new Vector29(p0[4], p0[5]);
                p1 = new Vector29(p0[2], p0[3]);
                p0 = new Vector29(p0[0], p0[1]);
              }
              this.p0 = p0;
              this.p1 = p1;
              this.p2 = p2;
              this.p3 = p3;
            },
            getStartPoint: function(out) {
              if (out === void 0) {
                out = new Vector29();
              }
              return out.copy(this.p0);
            },
            getResolution: function(divisions) {
              return divisions;
            },
            getPoint: function(t, out) {
              if (out === void 0) {
                out = new Vector29();
              }
              var p0 = this.p0;
              var p1 = this.p1;
              var p2 = this.p2;
              var p3 = this.p3;
              return out.set(CubicBezier(t, p0.x, p1.x, p2.x, p3.x), CubicBezier(t, p0.y, p1.y, p2.y, p3.y));
            },
            draw: function(graphics, pointsTotal) {
              if (pointsTotal === void 0) {
                pointsTotal = 32;
              }
              var points = this.getPoints(pointsTotal);
              graphics.beginPath();
              graphics.moveTo(this.p0.x, this.p0.y);
              for (var i = 1; i < points.length; i++) {
                graphics.lineTo(points[i].x, points[i].y);
              }
              graphics.strokePath();
              return graphics;
            },
            toJSON: function() {
              return {
                type: this.type,
                points: [
                  this.p0.x,
                  this.p0.y,
                  this.p1.x,
                  this.p1.y,
                  this.p2.x,
                  this.p2.y,
                  this.p3.x,
                  this.p3.y
                ]
              };
            }
          });
          CubicBezierCurve.fromJSON = function(data) {
            var points = data.points;
            var p0 = new Vector29(points[0], points[1]);
            var p1 = new Vector29(points[2], points[3]);
            var p2 = new Vector29(points[4], points[5]);
            var p3 = new Vector29(points[6], points[7]);
            return new CubicBezierCurve(p0, p1, p2, p3);
          };
          module2.exports = CubicBezierCurve;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Curve = __webpack_require__(90);
          var DegToRad = __webpack_require__(35);
          var GetValue = __webpack_require__(6);
          var RadToDeg = __webpack_require__(193);
          var Vector29 = __webpack_require__(3);
          var EllipseCurve = new Class({
            Extends: Curve,
            initialize: function EllipseCurve2(x, y, xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {
              if (typeof x === "object") {
                var config2 = x;
                x = GetValue(config2, "x", 0);
                y = GetValue(config2, "y", 0);
                xRadius = GetValue(config2, "xRadius", 0);
                yRadius = GetValue(config2, "yRadius", xRadius);
                startAngle = GetValue(config2, "startAngle", 0);
                endAngle = GetValue(config2, "endAngle", 360);
                clockwise = GetValue(config2, "clockwise", false);
                rotation = GetValue(config2, "rotation", 0);
              } else {
                if (yRadius === void 0) {
                  yRadius = xRadius;
                }
                if (startAngle === void 0) {
                  startAngle = 0;
                }
                if (endAngle === void 0) {
                  endAngle = 360;
                }
                if (clockwise === void 0) {
                  clockwise = false;
                }
                if (rotation === void 0) {
                  rotation = 0;
                }
              }
              Curve.call(this, "EllipseCurve");
              this.p0 = new Vector29(x, y);
              this._xRadius = xRadius;
              this._yRadius = yRadius;
              this._startAngle = DegToRad(startAngle);
              this._endAngle = DegToRad(endAngle);
              this._clockwise = clockwise;
              this._rotation = DegToRad(rotation);
            },
            getStartPoint: function(out) {
              if (out === void 0) {
                out = new Vector29();
              }
              return this.getPoint(0, out);
            },
            getResolution: function(divisions) {
              return divisions * 2;
            },
            getPoint: function(t, out) {
              if (out === void 0) {
                out = new Vector29();
              }
              var twoPi = Math.PI * 2;
              var deltaAngle = this._endAngle - this._startAngle;
              var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
              while (deltaAngle < 0) {
                deltaAngle += twoPi;
              }
              while (deltaAngle > twoPi) {
                deltaAngle -= twoPi;
              }
              if (deltaAngle < Number.EPSILON) {
                if (samePoints) {
                  deltaAngle = 0;
                } else {
                  deltaAngle = twoPi;
                }
              }
              if (this._clockwise && !samePoints) {
                if (deltaAngle === twoPi) {
                  deltaAngle = -twoPi;
                } else {
                  deltaAngle = deltaAngle - twoPi;
                }
              }
              var angle = this._startAngle + t * deltaAngle;
              var x = this.p0.x + this._xRadius * Math.cos(angle);
              var y = this.p0.y + this._yRadius * Math.sin(angle);
              if (this._rotation !== 0) {
                var cos = Math.cos(this._rotation);
                var sin = Math.sin(this._rotation);
                var tx = x - this.p0.x;
                var ty = y - this.p0.y;
                x = tx * cos - ty * sin + this.p0.x;
                y = tx * sin + ty * cos + this.p0.y;
              }
              return out.set(x, y);
            },
            setXRadius: function(value) {
              this.xRadius = value;
              return this;
            },
            setYRadius: function(value) {
              this.yRadius = value;
              return this;
            },
            setWidth: function(value) {
              this.xRadius = value / 2;
              return this;
            },
            setHeight: function(value) {
              this.yRadius = value / 2;
              return this;
            },
            setStartAngle: function(value) {
              this.startAngle = value;
              return this;
            },
            setEndAngle: function(value) {
              this.endAngle = value;
              return this;
            },
            setClockwise: function(value) {
              this.clockwise = value;
              return this;
            },
            setRotation: function(value) {
              this.rotation = value;
              return this;
            },
            x: {
              get: function() {
                return this.p0.x;
              },
              set: function(value) {
                this.p0.x = value;
              }
            },
            y: {
              get: function() {
                return this.p0.y;
              },
              set: function(value) {
                this.p0.y = value;
              }
            },
            xRadius: {
              get: function() {
                return this._xRadius;
              },
              set: function(value) {
                this._xRadius = value;
              }
            },
            yRadius: {
              get: function() {
                return this._yRadius;
              },
              set: function(value) {
                this._yRadius = value;
              }
            },
            startAngle: {
              get: function() {
                return RadToDeg(this._startAngle);
              },
              set: function(value) {
                this._startAngle = DegToRad(value);
              }
            },
            endAngle: {
              get: function() {
                return RadToDeg(this._endAngle);
              },
              set: function(value) {
                this._endAngle = DegToRad(value);
              }
            },
            clockwise: {
              get: function() {
                return this._clockwise;
              },
              set: function(value) {
                this._clockwise = value;
              }
            },
            angle: {
              get: function() {
                return RadToDeg(this._rotation);
              },
              set: function(value) {
                this._rotation = DegToRad(value);
              }
            },
            rotation: {
              get: function() {
                return this._rotation;
              },
              set: function(value) {
                this._rotation = value;
              }
            },
            toJSON: function() {
              return {
                type: this.type,
                x: this.p0.x,
                y: this.p0.y,
                xRadius: this._xRadius,
                yRadius: this._yRadius,
                startAngle: RadToDeg(this._startAngle),
                endAngle: RadToDeg(this._endAngle),
                clockwise: this._clockwise,
                rotation: RadToDeg(this._rotation)
              };
            }
          });
          EllipseCurve.fromJSON = function(data) {
            return new EllipseCurve(data);
          };
          module2.exports = EllipseCurve;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Curve = __webpack_require__(90);
          var FromPoints = __webpack_require__(196);
          var Rectangle = __webpack_require__(10);
          var Vector29 = __webpack_require__(3);
          var tmpVec2 = new Vector29();
          var LineCurve = new Class({
            Extends: Curve,
            initialize: function LineCurve2(p0, p1) {
              Curve.call(this, "LineCurve");
              if (Array.isArray(p0)) {
                p1 = new Vector29(p0[2], p0[3]);
                p0 = new Vector29(p0[0], p0[1]);
              }
              this.p0 = p0;
              this.p1 = p1;
              this.arcLengthDivisions = 1;
            },
            getBounds: function(out) {
              if (out === void 0) {
                out = new Rectangle();
              }
              return FromPoints([this.p0, this.p1], out);
            },
            getStartPoint: function(out) {
              if (out === void 0) {
                out = new Vector29();
              }
              return out.copy(this.p0);
            },
            getResolution: function(divisions) {
              if (divisions === void 0) {
                divisions = 1;
              }
              return divisions;
            },
            getPoint: function(t, out) {
              if (out === void 0) {
                out = new Vector29();
              }
              if (t === 1) {
                return out.copy(this.p1);
              }
              out.copy(this.p1).subtract(this.p0).scale(t).add(this.p0);
              return out;
            },
            getPointAt: function(u, out) {
              return this.getPoint(u, out);
            },
            getTangent: function() {
              var tangent = tmpVec2.copy(this.p1).subtract(this.p0);
              return tangent.normalize();
            },
            getUtoTmapping: function(u, distance, divisions) {
              var t;
              if (distance) {
                var arcLengths = this.getLengths(divisions);
                var lineLength = arcLengths[arcLengths.length - 1];
                var targetLineLength = Math.min(distance, lineLength);
                t = targetLineLength / lineLength;
              } else {
                t = u;
              }
              return t;
            },
            draw: function(graphics) {
              graphics.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y);
              return graphics;
            },
            toJSON: function() {
              return {
                type: this.type,
                points: [
                  this.p0.x,
                  this.p0.y,
                  this.p1.x,
                  this.p1.y
                ]
              };
            }
          });
          LineCurve.fromJSON = function(data) {
            var points = data.points;
            var p0 = new Vector29(points[0], points[1]);
            var p1 = new Vector29(points[2], points[3]);
            return new LineCurve(p0, p1);
          };
          module2.exports = LineCurve;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Vector29 = __webpack_require__(3);
          var MoveTo = new Class({
            initialize: function MoveTo2(x, y) {
              this.active = false;
              this.p0 = new Vector29(x, y);
            },
            getPoint: function(t, out) {
              if (out === void 0) {
                out = new Vector29();
              }
              return out.copy(this.p0);
            },
            getPointAt: function(u, out) {
              return this.getPoint(u, out);
            },
            getResolution: function() {
              return 1;
            },
            getLength: function() {
              return 0;
            },
            toJSON: function() {
              return {
                type: "MoveTo",
                points: [
                  this.p0.x,
                  this.p0.y
                ]
              };
            }
          });
          module2.exports = MoveTo;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Curve = __webpack_require__(90);
          var QuadraticBezierInterpolation = __webpack_require__(353);
          var Vector29 = __webpack_require__(3);
          var QuadraticBezier = new Class({
            Extends: Curve,
            initialize: function QuadraticBezier2(p0, p1, p2) {
              Curve.call(this, "QuadraticBezier");
              if (Array.isArray(p0)) {
                p2 = new Vector29(p0[4], p0[5]);
                p1 = new Vector29(p0[2], p0[3]);
                p0 = new Vector29(p0[0], p0[1]);
              }
              this.p0 = p0;
              this.p1 = p1;
              this.p2 = p2;
            },
            getStartPoint: function(out) {
              if (out === void 0) {
                out = new Vector29();
              }
              return out.copy(this.p0);
            },
            getResolution: function(divisions) {
              return divisions;
            },
            getPoint: function(t, out) {
              if (out === void 0) {
                out = new Vector29();
              }
              var p0 = this.p0;
              var p1 = this.p1;
              var p2 = this.p2;
              return out.set(QuadraticBezierInterpolation(t, p0.x, p1.x, p2.x), QuadraticBezierInterpolation(t, p0.y, p1.y, p2.y));
            },
            draw: function(graphics, pointsTotal) {
              if (pointsTotal === void 0) {
                pointsTotal = 32;
              }
              var points = this.getPoints(pointsTotal);
              graphics.beginPath();
              graphics.moveTo(this.p0.x, this.p0.y);
              for (var i = 1; i < points.length; i++) {
                graphics.lineTo(points[i].x, points[i].y);
              }
              graphics.strokePath();
              return graphics;
            },
            toJSON: function() {
              return {
                type: this.type,
                points: [
                  this.p0.x,
                  this.p0.y,
                  this.p1.x,
                  this.p1.y,
                  this.p2.x,
                  this.p2.y
                ]
              };
            }
          });
          QuadraticBezier.fromJSON = function(data) {
            var points = data.points;
            var p0 = new Vector29(points[0], points[1]);
            var p1 = new Vector29(points[2], points[3]);
            var p2 = new Vector29(points[4], points[5]);
            return new QuadraticBezier(p0, p1, p2);
          };
          module2.exports = QuadraticBezier;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CatmullRom = __webpack_require__(191);
          var Class = __webpack_require__(0);
          var Curve = __webpack_require__(90);
          var Vector29 = __webpack_require__(3);
          var SplineCurve = new Class({
            Extends: Curve,
            initialize: function SplineCurve2(points) {
              if (points === void 0) {
                points = [];
              }
              Curve.call(this, "SplineCurve");
              this.points = [];
              this.addPoints(points);
            },
            addPoints: function(points) {
              for (var i = 0; i < points.length; i++) {
                var p = new Vector29();
                if (typeof points[i] === "number") {
                  p.x = points[i];
                  p.y = points[i + 1];
                  i++;
                } else if (Array.isArray(points[i])) {
                  p.x = points[i][0];
                  p.y = points[i][1];
                } else {
                  p.x = points[i].x;
                  p.y = points[i].y;
                }
                this.points.push(p);
              }
              return this;
            },
            addPoint: function(x, y) {
              var vec = new Vector29(x, y);
              this.points.push(vec);
              return vec;
            },
            getStartPoint: function(out) {
              if (out === void 0) {
                out = new Vector29();
              }
              return out.copy(this.points[0]);
            },
            getResolution: function(divisions) {
              return divisions * this.points.length;
            },
            getPoint: function(t, out) {
              if (out === void 0) {
                out = new Vector29();
              }
              var points = this.points;
              var point = (points.length - 1) * t;
              var intPoint = Math.floor(point);
              var weight = point - intPoint;
              var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
              var p1 = points[intPoint];
              var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
              var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
              return out.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
            },
            toJSON: function() {
              var points = [];
              for (var i = 0; i < this.points.length; i++) {
                points.push(this.points[i].x);
                points.push(this.points[i].y);
              }
              return {
                type: this.type,
                points
              };
            }
          });
          SplineCurve.fromJSON = function(data) {
            return new SplineCurve(data.points);
          };
          module2.exports = SplineCurve;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var BaseShader = new Class({
            initialize: function BaseShader2(key, fragmentSrc, vertexSrc, uniforms) {
              if (!fragmentSrc || fragmentSrc === "") {
                fragmentSrc = [
                  "precision mediump float;",
                  "uniform vec2 resolution;",
                  "varying vec2 fragCoord;",
                  "void main () {",
                  "    vec2 uv = fragCoord / resolution.xy;",
                  "    gl_FragColor = vec4(uv.xyx, 1.0);",
                  "}"
                ].join("\n");
              }
              if (!vertexSrc || vertexSrc === "") {
                vertexSrc = [
                  "precision mediump float;",
                  "uniform mat4 uProjectionMatrix;",
                  "uniform mat4 uViewMatrix;",
                  "uniform vec2 uResolution;",
                  "attribute vec2 inPosition;",
                  "varying vec2 fragCoord;",
                  "varying vec2 outTexCoord;",
                  "void main () {",
                  "   gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);",
                  "   fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);",
                  "   outTexCoord = vec2(inPosition.x / uResolution.x, fragCoord.y / uResolution.y);",
                  "}"
                ].join("\n");
              }
              if (uniforms === void 0) {
                uniforms = null;
              }
              this.key = key;
              this.fragmentSrc = fragmentSrc;
              this.vertexSrc = vertexSrc;
              this.uniforms = uniforms;
            }
          });
          module2.exports = BaseShader;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Color = __webpack_require__(37);
          Color.ColorSpectrum = __webpack_require__(905);
          Color.ColorToRGBA = __webpack_require__(906);
          Color.ComponentToHex = __webpack_require__(392);
          Color.GetColor = __webpack_require__(100);
          Color.GetColor32 = __webpack_require__(322);
          Color.HexStringToColor = __webpack_require__(321);
          Color.HSLToColor = __webpack_require__(907);
          Color.HSVColorWheel = __webpack_require__(908);
          Color.HSVToRGB = __webpack_require__(185);
          Color.HueToComponent = __webpack_require__(393);
          Color.IntegerToColor = __webpack_require__(186);
          Color.IntegerToRGB = __webpack_require__(324);
          Color.Interpolate = __webpack_require__(909);
          Color.ObjectToColor = __webpack_require__(325);
          Color.RandomRGB = __webpack_require__(910);
          Color.RGBStringToColor = __webpack_require__(326);
          Color.RGBToHSV = __webpack_require__(323);
          Color.RGBToString = __webpack_require__(911);
          Color.ValueToColor = __webpack_require__(184);
          module2.exports = Color;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ComponentToHex = function(color) {
            var hex = color.toString(16);
            return hex.length === 1 ? "0" + hex : hex;
          };
          module2.exports = ComponentToHex;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var HueToComponent = function(p, q, t) {
            if (t < 0) {
              t += 1;
            }
            if (t > 1) {
              t -= 1;
            }
            if (t < 1 / 6) {
              return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
              return q;
            }
            if (t < 2 / 3) {
              return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
          };
          module2.exports = HueToComponent;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var OS = __webpack_require__(102);
          var DOMContentLoaded = function(callback) {
            if (document.readyState === "complete" || document.readyState === "interactive") {
              callback();
              return;
            }
            var check = function() {
              document.removeEventListener("deviceready", check, true);
              document.removeEventListener("DOMContentLoaded", check, true);
              window.removeEventListener("load", check, true);
              callback();
            };
            if (!document.body) {
              window.setTimeout(check, 20);
            } else if (OS.cordova) {
              document.addEventListener("deviceready", check, false);
            } else {
              document.addEventListener("DOMContentLoaded", check, true);
              window.addEventListener("load", check, true);
            }
          };
          module2.exports = DOMContentLoaded;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetInnerHeight = function(iOS) {
            if (!iOS) {
              return window.innerHeight;
            }
            var axis = Math.abs(window.orientation);
            var size = {w: 0, h: 0};
            var ruler = document.createElement("div");
            ruler.setAttribute("style", "position: fixed; height: 100vh; width: 0; top: 0");
            document.documentElement.appendChild(ruler);
            size.w = axis === 90 ? ruler.offsetHeight : window.innerWidth;
            size.h = axis === 90 ? window.innerWidth : ruler.offsetHeight;
            document.documentElement.removeChild(ruler);
            ruler = null;
            if (Math.abs(window.orientation) !== 90) {
              return size.h;
            } else {
              return size.w;
            }
          };
          module2.exports = GetInnerHeight;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(198);
          var GetScreenOrientation = function(width, height) {
            var screen2 = window.screen;
            var orientation = screen2 ? screen2.orientation || screen2.mozOrientation || screen2.msOrientation : false;
            if (orientation && typeof orientation.type === "string") {
              return orientation.type;
            } else if (typeof orientation === "string") {
              return orientation;
            }
            if (typeof window.orientation === "number") {
              return window.orientation === 0 || window.orientation === 180 ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
            } else if (window.matchMedia) {
              if (window.matchMedia("(orientation: portrait)").matches) {
                return CONST.ORIENTATION.PORTRAIT;
              } else if (window.matchMedia("(orientation: landscape)").matches) {
                return CONST.ORIENTATION.LANDSCAPE;
              }
            } else {
              return height > width ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
            }
          };
          module2.exports = GetScreenOrientation;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            NO_CENTER: 0,
            CENTER_BOTH: 1,
            CENTER_HORIZONTALLY: 2,
            CENTER_VERTICALLY: 3
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            LANDSCAPE: "landscape-primary",
            PORTRAIT: "portrait-primary"
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            NONE: 0,
            WIDTH_CONTROLS_HEIGHT: 1,
            HEIGHT_CONTROLS_WIDTH: 2,
            FIT: 3,
            ENVELOP: 4,
            RESIZE: 5
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            NO_ZOOM: 1,
            ZOOM_2X: 2,
            ZOOM_4X: 4,
            MAX_ZOOM: -1
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTarget = function(element) {
            var target;
            if (element !== "") {
              if (typeof element === "string") {
                target = document.getElementById(element);
              } else if (element && element.nodeType === 1) {
                target = element;
              }
            }
            if (!target) {
              target = document.body;
            }
            return target;
          };
          module2.exports = GetTarget;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ParseXML = function(data) {
            var xml = "";
            try {
              if (window["DOMParser"]) {
                var domparser = new DOMParser();
                xml = domparser.parseFromString(data, "text/xml");
              } else {
                xml = new ActiveXObject("Microsoft.XMLDOM");
                xml.loadXML(data);
              }
            } catch (e) {
              xml = null;
            }
            if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
              return null;
            } else {
              return xml;
            }
          };
          module2.exports = ParseXML;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(200);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(49);
          var GameEvents = __webpack_require__(22);
          var Keyboard = __webpack_require__(404);
          var Mouse = __webpack_require__(405);
          var Pointer = __webpack_require__(406);
          var Touch = __webpack_require__(407);
          var TransformMatrix = __webpack_require__(25);
          var TransformXY = __webpack_require__(174);
          var InputManager = new Class({
            initialize: function InputManager2(game, config2) {
              this.game = game;
              this.scaleManager;
              this.canvas;
              this.config = config2;
              this.enabled = true;
              this.events = new EventEmitter();
              this.isOver = true;
              this.defaultCursor = "";
              this.keyboard = config2.inputKeyboard ? new Keyboard(this) : null;
              this.mouse = config2.inputMouse ? new Mouse(this) : null;
              this.touch = config2.inputTouch ? new Touch(this) : null;
              this.pointers = [];
              this.pointersTotal = config2.inputActivePointers;
              if (config2.inputTouch && this.pointersTotal === 1) {
                this.pointersTotal = 2;
              }
              for (var i = 0; i <= this.pointersTotal; i++) {
                var pointer = new Pointer(this, i);
                pointer.smoothFactor = config2.inputSmoothFactor;
                this.pointers.push(pointer);
              }
              this.mousePointer = config2.inputMouse ? this.pointers[0] : null;
              this.activePointer = this.pointers[0];
              this.globalTopOnly = true;
              this.time = 0;
              this._tempPoint = {x: 0, y: 0};
              this._tempHitTest = [];
              this._tempMatrix = new TransformMatrix();
              this._tempMatrix2 = new TransformMatrix();
              this._tempSkip = false;
              this.mousePointerContainer = [this.mousePointer];
              game.events.once(GameEvents.BOOT, this.boot, this);
            },
            boot: function() {
              this.canvas = this.game.canvas;
              this.scaleManager = this.game.scale;
              this.events.emit(Events.MANAGER_BOOT);
              this.game.events.on(GameEvents.PRE_RENDER, this.preRender, this);
              this.game.events.once(GameEvents.DESTROY, this.destroy, this);
            },
            setCanvasOver: function(event) {
              this.isOver = true;
              this.events.emit(Events.GAME_OVER, event);
            },
            setCanvasOut: function(event) {
              this.isOver = false;
              this.events.emit(Events.GAME_OUT, event);
            },
            preRender: function() {
              var time = this.game.loop.now;
              var delta = this.game.loop.delta;
              var scenes = this.game.scene.getScenes(true, true);
              this.time = time;
              this.events.emit(Events.MANAGER_UPDATE);
              for (var i = 0; i < scenes.length; i++) {
                var scene = scenes[i];
                if (scene.sys.input && scene.sys.input.updatePoll(time, delta) && this.globalTopOnly) {
                  return;
                }
              }
            },
            setDefaultCursor: function(cursor) {
              this.defaultCursor = cursor;
              if (this.canvas.style.cursor !== cursor) {
                this.canvas.style.cursor = cursor;
              }
            },
            setCursor: function(interactiveObject) {
              if (interactiveObject.cursor) {
                this.canvas.style.cursor = interactiveObject.cursor;
              }
            },
            resetCursor: function(interactiveObject) {
              if (interactiveObject.cursor && this.canvas) {
                this.canvas.style.cursor = this.defaultCursor;
              }
            },
            addPointer: function(quantity) {
              if (quantity === void 0) {
                quantity = 1;
              }
              var output = [];
              if (this.pointersTotal + quantity > 10) {
                quantity = 10 - this.pointersTotal;
              }
              for (var i = 0; i < quantity; i++) {
                var id = this.pointers.length;
                var pointer = new Pointer(this, id);
                pointer.smoothFactor = this.config.inputSmoothFactor;
                this.pointers.push(pointer);
                this.pointersTotal++;
                output.push(pointer);
              }
              return output;
            },
            updateInputPlugins: function(type, pointers) {
              var scenes = this.game.scene.getScenes(true, true);
              this._tempSkip = false;
              for (var i = 0; i < scenes.length; i++) {
                var scene = scenes[i];
                if (scene.sys.input) {
                  var capture = scene.sys.input.update(type, pointers);
                  if (capture && this.globalTopOnly || this._tempSkip) {
                    return;
                  }
                }
              }
            },
            onTouchStart: function(event) {
              var pointers = this.pointers;
              var changed = [];
              for (var c = 0; c < event.changedTouches.length; c++) {
                var changedTouch = event.changedTouches[c];
                for (var i = 1; i < this.pointersTotal; i++) {
                  var pointer = pointers[i];
                  if (!pointer.active) {
                    pointer.touchstart(changedTouch, event);
                    this.activePointer = pointer;
                    changed.push(pointer);
                    break;
                  }
                }
              }
              this.updateInputPlugins(CONST.TOUCH_START, changed);
            },
            onTouchMove: function(event) {
              var pointers = this.pointers;
              var changed = [];
              for (var c = 0; c < event.changedTouches.length; c++) {
                var changedTouch = event.changedTouches[c];
                for (var i = 1; i < this.pointersTotal; i++) {
                  var pointer = pointers[i];
                  if (pointer.active && pointer.identifier === changedTouch.identifier) {
                    pointer.touchmove(changedTouch, event);
                    this.activePointer = pointer;
                    changed.push(pointer);
                    break;
                  }
                }
              }
              this.updateInputPlugins(CONST.TOUCH_MOVE, changed);
            },
            onTouchEnd: function(event) {
              var pointers = this.pointers;
              var changed = [];
              for (var c = 0; c < event.changedTouches.length; c++) {
                var changedTouch = event.changedTouches[c];
                for (var i = 1; i < this.pointersTotal; i++) {
                  var pointer = pointers[i];
                  if (pointer.active && pointer.identifier === changedTouch.identifier) {
                    pointer.touchend(changedTouch, event);
                    changed.push(pointer);
                    break;
                  }
                }
              }
              this.updateInputPlugins(CONST.TOUCH_END, changed);
            },
            onTouchCancel: function(event) {
              var pointers = this.pointers;
              var changed = [];
              for (var c = 0; c < event.changedTouches.length; c++) {
                var changedTouch = event.changedTouches[c];
                for (var i = 1; i < this.pointersTotal; i++) {
                  var pointer = pointers[i];
                  if (pointer.active && pointer.identifier === changedTouch.identifier) {
                    pointer.touchcancel(changedTouch, event);
                    changed.push(pointer);
                    break;
                  }
                }
              }
              this.updateInputPlugins(CONST.TOUCH_CANCEL, changed);
            },
            onMouseDown: function(event) {
              var mousePointer = this.mousePointer;
              mousePointer.down(event);
              mousePointer.updateMotion();
              this.activePointer = mousePointer;
              this.updateInputPlugins(CONST.MOUSE_DOWN, this.mousePointerContainer);
            },
            onMouseMove: function(event) {
              var mousePointer = this.mousePointer;
              mousePointer.move(event);
              mousePointer.updateMotion();
              this.activePointer = mousePointer;
              this.updateInputPlugins(CONST.MOUSE_MOVE, this.mousePointerContainer);
            },
            onMouseUp: function(event) {
              var mousePointer = this.mousePointer;
              mousePointer.up(event);
              mousePointer.updateMotion();
              this.activePointer = mousePointer;
              this.updateInputPlugins(CONST.MOUSE_UP, this.mousePointerContainer);
            },
            onMouseWheel: function(event) {
              var mousePointer = this.mousePointer;
              mousePointer.wheel(event);
              this.activePointer = mousePointer;
              this.updateInputPlugins(CONST.MOUSE_WHEEL, this.mousePointerContainer);
            },
            onPointerLockChange: function(event) {
              var isLocked = this.mouse.locked;
              this.mousePointer.locked = isLocked;
              this.events.emit(Events.POINTERLOCK_CHANGE, event, isLocked);
            },
            inputCandidate: function(gameObject, camera) {
              var input = gameObject.input;
              if (!input || !input.enabled || !input.alwaysEnabled && !gameObject.willRender(camera)) {
                return false;
              }
              var visible = true;
              var parent = gameObject.parentContainer;
              if (parent) {
                do {
                  if (!parent.willRender(camera)) {
                    visible = false;
                    break;
                  }
                  parent = parent.parentContainer;
                } while (parent);
              }
              return visible;
            },
            hitTest: function(pointer, gameObjects, camera, output) {
              if (output === void 0) {
                output = this._tempHitTest;
              }
              var tempPoint = this._tempPoint;
              var csx = camera.scrollX;
              var csy = camera.scrollY;
              output.length = 0;
              var x = pointer.x;
              var y = pointer.y;
              camera.getWorldPoint(x, y, tempPoint);
              pointer.worldX = tempPoint.x;
              pointer.worldY = tempPoint.y;
              var point = {x: 0, y: 0};
              var matrix = this._tempMatrix;
              var parentMatrix = this._tempMatrix2;
              for (var i = 0; i < gameObjects.length; i++) {
                var gameObject = gameObjects[i];
                if (!this.inputCandidate(gameObject, camera)) {
                  continue;
                }
                var px = tempPoint.x + csx * gameObject.scrollFactorX - csx;
                var py = tempPoint.y + csy * gameObject.scrollFactorY - csy;
                if (gameObject.parentContainer) {
                  gameObject.getWorldTransformMatrix(matrix, parentMatrix);
                  matrix.applyInverse(px, py, point);
                } else {
                  TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, point);
                }
                if (this.pointWithinHitArea(gameObject, point.x, point.y)) {
                  output.push(gameObject);
                }
              }
              return output;
            },
            pointWithinHitArea: function(gameObject, x, y) {
              x += gameObject.displayOriginX;
              y += gameObject.displayOriginY;
              var input = gameObject.input;
              if (input && input.hitAreaCallback(input.hitArea, x, y, gameObject)) {
                input.localX = x;
                input.localY = y;
                return true;
              } else {
                return false;
              }
            },
            pointWithinInteractiveObject: function(object, x, y) {
              if (!object.hitArea) {
                return false;
              }
              x += object.gameObject.displayOriginX;
              y += object.gameObject.displayOriginY;
              object.localX = x;
              object.localY = y;
              return object.hitAreaCallback(object.hitArea, x, y, object);
            },
            transformPointer: function(pointer, pageX, pageY, wasMove) {
              var p0 = pointer.position;
              var p1 = pointer.prevPosition;
              p1.x = p0.x;
              p1.y = p0.y;
              var x = this.scaleManager.transformX(pageX);
              var y = this.scaleManager.transformY(pageY);
              var a = pointer.smoothFactor;
              if (!wasMove || a === 0) {
                p0.x = x;
                p0.y = y;
              } else {
                p0.x = x * a + p1.x * (1 - a);
                p0.y = y * a + p1.y * (1 - a);
              }
            },
            destroy: function() {
              this.events.removeAllListeners();
              this.game.events.off(GameEvents.PRE_RENDER);
              if (this.keyboard) {
                this.keyboard.destroy();
              }
              if (this.mouse) {
                this.mouse.destroy();
              }
              if (this.touch) {
                this.touch.destroy();
              }
              for (var i = 0; i < this.pointers.length; i++) {
                this.pointers[i].destroy();
              }
              this.pointers = [];
              this._tempHitTest = [];
              this._tempMatrix.destroy();
              this.canvas = null;
              this.game = null;
            }
          });
          module2.exports = InputManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ArrayRemove = __webpack_require__(89);
          var Class = __webpack_require__(0);
          var GameEvents = __webpack_require__(22);
          var InputEvents = __webpack_require__(49);
          var KeyCodes = __webpack_require__(141);
          var NOOP = __webpack_require__(1);
          var KeyboardManager = new Class({
            initialize: function KeyboardManager2(inputManager) {
              this.manager = inputManager;
              this.queue = [];
              this.preventDefault = true;
              this.captures = [];
              this.enabled = false;
              this.target;
              this.onKeyDown = NOOP;
              this.onKeyUp = NOOP;
              inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
            },
            boot: function() {
              var config2 = this.manager.config;
              this.enabled = config2.inputKeyboard;
              this.target = config2.inputKeyboardEventTarget;
              this.addCapture(config2.inputKeyboardCapture);
              if (!this.target && window) {
                this.target = window;
              }
              if (this.enabled && this.target) {
                this.startListeners();
              }
              this.manager.game.events.on(GameEvents.POST_STEP, this.postUpdate, this);
            },
            startListeners: function() {
              var _this = this;
              this.onKeyDown = function(event) {
                if (event.defaultPrevented || !_this.enabled || !_this.manager) {
                  return;
                }
                _this.queue.push(event);
                _this.manager.events.emit(InputEvents.MANAGER_PROCESS);
                var modified = event.altKey || event.ctrlKey || event.shiftKey || event.metaKey;
                if (_this.preventDefault && !modified && _this.captures.indexOf(event.keyCode) > -1) {
                  event.preventDefault();
                }
              };
              this.onKeyUp = function(event) {
                if (event.defaultPrevented || !_this.enabled || !_this.manager) {
                  return;
                }
                _this.queue.push(event);
                _this.manager.events.emit(InputEvents.MANAGER_PROCESS);
                var modified = event.altKey || event.ctrlKey || event.shiftKey || event.metaKey;
                if (_this.preventDefault && !modified && _this.captures.indexOf(event.keyCode) > -1) {
                  event.preventDefault();
                }
              };
              var target = this.target;
              if (target) {
                target.addEventListener("keydown", this.onKeyDown, false);
                target.addEventListener("keyup", this.onKeyUp, false);
                this.enabled = true;
              }
            },
            stopListeners: function() {
              var target = this.target;
              target.removeEventListener("keydown", this.onKeyDown, false);
              target.removeEventListener("keyup", this.onKeyUp, false);
              this.enabled = false;
            },
            postUpdate: function() {
              this.queue = [];
            },
            addCapture: function(keycode) {
              if (typeof keycode === "string") {
                keycode = keycode.split(",");
              }
              if (!Array.isArray(keycode)) {
                keycode = [keycode];
              }
              var captures = this.captures;
              for (var i = 0; i < keycode.length; i++) {
                var code = keycode[i];
                if (typeof code === "string") {
                  code = KeyCodes[code.trim().toUpperCase()];
                }
                if (captures.indexOf(code) === -1) {
                  captures.push(code);
                }
              }
              this.preventDefault = captures.length > 0;
            },
            removeCapture: function(keycode) {
              if (typeof keycode === "string") {
                keycode = keycode.split(",");
              }
              if (!Array.isArray(keycode)) {
                keycode = [keycode];
              }
              var captures = this.captures;
              for (var i = 0; i < keycode.length; i++) {
                var code = keycode[i];
                if (typeof code === "string") {
                  code = KeyCodes[code.toUpperCase()];
                }
                ArrayRemove(captures, code);
              }
              this.preventDefault = captures.length > 0;
            },
            clearCaptures: function() {
              this.captures = [];
              this.preventDefault = false;
            },
            destroy: function() {
              this.stopListeners();
              this.clearCaptures();
              this.queue = [];
              this.manager.game.events.off(GameEvents.POST_RENDER, this.postUpdate, this);
              this.target = null;
              this.enabled = false;
              this.manager = null;
            }
          });
          module2.exports = KeyboardManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Features = __webpack_require__(188);
          var InputEvents = __webpack_require__(49);
          var NOOP = __webpack_require__(1);
          var MouseManager = new Class({
            initialize: function MouseManager2(inputManager) {
              this.manager = inputManager;
              this.preventDefaultDown = true;
              this.preventDefaultUp = true;
              this.preventDefaultMove = true;
              this.preventDefaultWheel = false;
              this.enabled = false;
              this.target;
              this.locked = false;
              this.onMouseMove = NOOP;
              this.onMouseDown = NOOP;
              this.onMouseUp = NOOP;
              this.onMouseDownWindow = NOOP;
              this.onMouseUpWindow = NOOP;
              this.onMouseOver = NOOP;
              this.onMouseOut = NOOP;
              this.onMouseWheel = NOOP;
              this.pointerLockChange = NOOP;
              this.isTop = true;
              inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
            },
            boot: function() {
              var config2 = this.manager.config;
              this.enabled = config2.inputMouse;
              this.target = config2.inputMouseEventTarget;
              this.passive = config2.inputMousePassive;
              this.preventDefaultDown = config2.inputMousePreventDefaultDown;
              this.preventDefaultUp = config2.inputMousePreventDefaultUp;
              this.preventDefaultMove = config2.inputMousePreventDefaultMove;
              this.preventDefaultWheel = config2.inputMousePreventDefaultWheel;
              if (!this.target) {
                this.target = this.manager.game.canvas;
              } else if (typeof this.target === "string") {
                this.target = document.getElementById(this.target);
              }
              if (config2.disableContextMenu) {
                this.disableContextMenu();
              }
              if (this.enabled && this.target) {
                this.startListeners();
              }
            },
            disableContextMenu: function() {
              document.body.addEventListener("contextmenu", function(event) {
                event.preventDefault();
                return false;
              });
              return this;
            },
            requestPointerLock: function() {
              if (Features.pointerLock) {
                var element = this.target;
                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                element.requestPointerLock();
              }
            },
            releasePointerLock: function() {
              if (Features.pointerLock) {
                document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
                document.exitPointerLock();
              }
            },
            startListeners: function() {
              var target = this.target;
              if (!target) {
                return;
              }
              var _this = this;
              var manager = this.manager;
              var canvas = manager.canvas;
              var autoFocus = window && window.focus && manager.game.config.autoFocus;
              this.onMouseMove = function(event) {
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                  manager.onMouseMove(event);
                  if (_this.preventDefaultMove) {
                    event.preventDefault();
                  }
                }
              };
              this.onMouseDown = function(event) {
                if (autoFocus) {
                  window.focus();
                }
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                  manager.onMouseDown(event);
                  if (_this.preventDefaultDown && event.target === canvas) {
                    event.preventDefault();
                  }
                }
              };
              this.onMouseDownWindow = function(event) {
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
                  manager.onMouseDown(event);
                }
              };
              this.onMouseUp = function(event) {
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                  manager.onMouseUp(event);
                  if (_this.preventDefaultUp && event.target === canvas) {
                    event.preventDefault();
                  }
                }
              };
              this.onMouseUpWindow = function(event) {
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
                  manager.onMouseUp(event);
                }
              };
              this.onMouseOver = function(event) {
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                  manager.setCanvasOver(event);
                }
              };
              this.onMouseOut = function(event) {
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                  manager.setCanvasOut(event);
                }
              };
              this.onMouseWheel = function(event) {
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                  manager.onMouseWheel(event);
                }
                if (_this.preventDefaultWheel && event.target === canvas) {
                  event.preventDefault();
                }
              };
              var passive = {passive: true};
              target.addEventListener("mousemove", this.onMouseMove);
              target.addEventListener("mousedown", this.onMouseDown);
              target.addEventListener("mouseup", this.onMouseUp);
              target.addEventListener("mouseover", this.onMouseOver, passive);
              target.addEventListener("mouseout", this.onMouseOut, passive);
              if (this.preventDefaultWheel) {
                target.addEventListener("wheel", this.onMouseWheel, {passive: false});
              } else {
                target.addEventListener("wheel", this.onMouseWheel, passive);
              }
              if (window && manager.game.config.inputWindowEvents) {
                try {
                  window.top.addEventListener("mousedown", this.onMouseDownWindow, passive);
                  window.top.addEventListener("mouseup", this.onMouseUpWindow, passive);
                } catch (exception) {
                  window.addEventListener("mousedown", this.onMouseDownWindow, passive);
                  window.addEventListener("mouseup", this.onMouseUpWindow, passive);
                  this.isTop = false;
                }
              }
              if (Features.pointerLock) {
                this.pointerLockChange = function(event) {
                  var element = _this.target;
                  _this.locked = document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ? true : false;
                  manager.onPointerLockChange(event);
                };
                document.addEventListener("pointerlockchange", this.pointerLockChange, true);
                document.addEventListener("mozpointerlockchange", this.pointerLockChange, true);
                document.addEventListener("webkitpointerlockchange", this.pointerLockChange, true);
              }
              this.enabled = true;
            },
            stopListeners: function() {
              var target = this.target;
              target.removeEventListener("mousemove", this.onMouseMove);
              target.removeEventListener("mousedown", this.onMouseDown);
              target.removeEventListener("mouseup", this.onMouseUp);
              target.removeEventListener("mouseover", this.onMouseOver);
              target.removeEventListener("mouseout", this.onMouseOut);
              if (window) {
                target = this.isTop ? window.top : window;
                target.removeEventListener("mousedown", this.onMouseDownWindow);
                target.removeEventListener("mouseup", this.onMouseUpWindow);
              }
              if (Features.pointerLock) {
                document.removeEventListener("pointerlockchange", this.pointerLockChange, true);
                document.removeEventListener("mozpointerlockchange", this.pointerLockChange, true);
                document.removeEventListener("webkitpointerlockchange", this.pointerLockChange, true);
              }
            },
            destroy: function() {
              this.stopListeners();
              this.target = null;
              this.enabled = false;
              this.manager = null;
            }
          });
          module2.exports = MouseManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Angle = __webpack_require__(343);
          var Class = __webpack_require__(0);
          var Distance = __webpack_require__(48);
          var FuzzyEqual = __webpack_require__(123);
          var SmoothStepInterpolation = __webpack_require__(354);
          var Vector29 = __webpack_require__(3);
          var OS = __webpack_require__(102);
          var Pointer = new Class({
            initialize: function Pointer2(manager, id) {
              this.manager = manager;
              this.id = id;
              this.event;
              this.downElement;
              this.upElement;
              this.camera = null;
              this.button = 0;
              this.buttons = 0;
              this.position = new Vector29();
              this.prevPosition = new Vector29();
              this.midPoint = new Vector29(-1, -1);
              this.velocity = new Vector29();
              this.angle = 0;
              this.distance = 0;
              this.smoothFactor = 0;
              this.motionFactor = 0.2;
              this.worldX = 0;
              this.worldY = 0;
              this.moveTime = 0;
              this.downX = 0;
              this.downY = 0;
              this.downTime = 0;
              this.upX = 0;
              this.upY = 0;
              this.upTime = 0;
              this.primaryDown = false;
              this.isDown = false;
              this.wasTouch = false;
              this.wasCanceled = false;
              this.movementX = 0;
              this.movementY = 0;
              this.identifier = 0;
              this.pointerId = null;
              this.active = id === 0 ? true : false;
              this.locked = false;
              this.deltaX = 0;
              this.deltaY = 0;
              this.deltaZ = 0;
            },
            updateWorldPoint: function(camera) {
              var temp = camera.getWorldPoint(this.x, this.y);
              this.worldX = temp.x;
              this.worldY = temp.y;
              return this;
            },
            positionToCamera: function(camera, output) {
              return camera.getWorldPoint(this.x, this.y, output);
            },
            updateMotion: function() {
              var cx = this.position.x;
              var cy = this.position.y;
              var mx = this.midPoint.x;
              var my = this.midPoint.y;
              if (cx === mx && cy === my) {
                return;
              }
              var vx = SmoothStepInterpolation(this.motionFactor, mx, cx);
              var vy = SmoothStepInterpolation(this.motionFactor, my, cy);
              if (FuzzyEqual(vx, cx, 0.1)) {
                vx = cx;
              }
              if (FuzzyEqual(vy, cy, 0.1)) {
                vy = cy;
              }
              this.midPoint.set(vx, vy);
              var dx = cx - vx;
              var dy = cy - vy;
              this.velocity.set(dx, dy);
              this.angle = Angle(vx, vy, cx, cy);
              this.distance = Math.sqrt(dx * dx + dy * dy);
            },
            up: function(event) {
              if ("buttons" in event) {
                this.buttons = event.buttons;
              }
              this.event = event;
              this.button = event.button;
              this.upElement = event.target;
              this.manager.transformPointer(this, event.pageX, event.pageY, false);
              if (event.button === 0) {
                this.primaryDown = false;
                this.upX = this.x;
                this.upY = this.y;
              }
              if (this.buttons === 0) {
                this.isDown = false;
                this.upTime = event.timeStamp;
                this.wasTouch = false;
              }
            },
            down: function(event) {
              if ("buttons" in event) {
                this.buttons = event.buttons;
              }
              this.event = event;
              this.button = event.button;
              this.downElement = event.target;
              this.manager.transformPointer(this, event.pageX, event.pageY, false);
              if (event.button === 0) {
                this.primaryDown = true;
                this.downX = this.x;
                this.downY = this.y;
              }
              if (OS.macOS && event.ctrlKey) {
                this.buttons = 2;
                this.primaryDown = false;
              }
              if (!this.isDown) {
                this.isDown = true;
                this.downTime = event.timeStamp;
              }
              this.wasTouch = false;
            },
            move: function(event) {
              if ("buttons" in event) {
                this.buttons = event.buttons;
              }
              this.event = event;
              this.manager.transformPointer(this, event.pageX, event.pageY, true);
              if (this.locked) {
                this.movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                this.movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
              }
              this.moveTime = event.timeStamp;
              this.wasTouch = false;
            },
            wheel: function(event) {
              if ("buttons" in event) {
                this.buttons = event.buttons;
              }
              this.event = event;
              this.manager.transformPointer(this, event.pageX, event.pageY, false);
              this.deltaX = event.deltaX;
              this.deltaY = event.deltaY;
              this.deltaZ = event.deltaZ;
              this.wasTouch = false;
            },
            touchstart: function(touch, event) {
              if (touch["pointerId"]) {
                this.pointerId = touch.pointerId;
              }
              this.identifier = touch.identifier;
              this.target = touch.target;
              this.active = true;
              this.buttons = 1;
              this.event = event;
              this.downElement = touch.target;
              this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
              this.primaryDown = true;
              this.downX = this.x;
              this.downY = this.y;
              this.downTime = event.timeStamp;
              this.isDown = true;
              this.wasTouch = true;
              this.wasCanceled = false;
              this.updateMotion();
            },
            touchmove: function(touch, event) {
              this.event = event;
              this.manager.transformPointer(this, touch.pageX, touch.pageY, true);
              this.moveTime = event.timeStamp;
              this.wasTouch = true;
              this.updateMotion();
            },
            touchend: function(touch, event) {
              this.buttons = 0;
              this.event = event;
              this.upElement = touch.target;
              this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
              this.primaryDown = false;
              this.upX = this.x;
              this.upY = this.y;
              this.upTime = event.timeStamp;
              this.isDown = false;
              this.wasTouch = true;
              this.wasCanceled = false;
              this.active = false;
              this.updateMotion();
            },
            touchcancel: function(touch, event) {
              this.buttons = 0;
              this.event = event;
              this.upElement = touch.target;
              this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
              this.primaryDown = false;
              this.upX = this.x;
              this.upY = this.y;
              this.upTime = event.timeStamp;
              this.isDown = false;
              this.wasTouch = true;
              this.wasCanceled = true;
              this.active = false;
            },
            noButtonDown: function() {
              return this.buttons === 0;
            },
            leftButtonDown: function() {
              return this.buttons & 1 ? true : false;
            },
            rightButtonDown: function() {
              return this.buttons & 2 ? true : false;
            },
            middleButtonDown: function() {
              return this.buttons & 4 ? true : false;
            },
            backButtonDown: function() {
              return this.buttons & 8 ? true : false;
            },
            forwardButtonDown: function() {
              return this.buttons & 16 ? true : false;
            },
            leftButtonReleased: function() {
              return this.button === 0 && !this.isDown;
            },
            rightButtonReleased: function() {
              return this.button === 2 && !this.isDown;
            },
            middleButtonReleased: function() {
              return this.button === 1 && !this.isDown;
            },
            backButtonReleased: function() {
              return this.button === 3 && !this.isDown;
            },
            forwardButtonReleased: function() {
              return this.button === 4 && !this.isDown;
            },
            getDistance: function() {
              if (this.isDown) {
                return Distance(this.downX, this.downY, this.x, this.y);
              } else {
                return Distance(this.downX, this.downY, this.upX, this.upY);
              }
            },
            getDistanceX: function() {
              if (this.isDown) {
                return Math.abs(this.downX - this.x);
              } else {
                return Math.abs(this.downX - this.upX);
              }
            },
            getDistanceY: function() {
              if (this.isDown) {
                return Math.abs(this.downY - this.y);
              } else {
                return Math.abs(this.downY - this.upY);
              }
            },
            getDuration: function() {
              if (this.isDown) {
                return this.manager.time - this.downTime;
              } else {
                return this.upTime - this.downTime;
              }
            },
            getAngle: function() {
              if (this.isDown) {
                return Angle(this.downX, this.downY, this.x, this.y);
              } else {
                return Angle(this.downX, this.downY, this.upX, this.upY);
              }
            },
            getInterpolatedPosition: function(steps, out) {
              if (steps === void 0) {
                steps = 10;
              }
              if (out === void 0) {
                out = [];
              }
              var prevX = this.prevPosition.x;
              var prevY = this.prevPosition.y;
              var curX = this.position.x;
              var curY = this.position.y;
              for (var i = 0; i < steps; i++) {
                var t = 1 / steps * i;
                out[i] = {x: SmoothStepInterpolation(t, prevX, curX), y: SmoothStepInterpolation(t, prevY, curY)};
              }
              return out;
            },
            destroy: function() {
              this.camera = null;
              this.manager = null;
              this.position = null;
            },
            x: {
              get: function() {
                return this.position.x;
              },
              set: function(value) {
                this.position.x = value;
              }
            },
            y: {
              get: function() {
                return this.position.y;
              },
              set: function(value) {
                this.position.y = value;
              }
            },
            time: {
              get: function() {
                return this.event ? this.event.timeStamp : 0;
              }
            }
          });
          module2.exports = Pointer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var InputEvents = __webpack_require__(49);
          var NOOP = __webpack_require__(1);
          var TouchManager = new Class({
            initialize: function TouchManager2(inputManager) {
              this.manager = inputManager;
              this.capture = true;
              this.enabled = false;
              this.target;
              this.onTouchStart = NOOP;
              this.onTouchStartWindow = NOOP;
              this.onTouchMove = NOOP;
              this.onTouchEnd = NOOP;
              this.onTouchEndWindow = NOOP;
              this.onTouchCancel = NOOP;
              this.onTouchCancelWindow = NOOP;
              this.onTouchOver = NOOP;
              this.onTouchOut = NOOP;
              inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
            },
            boot: function() {
              var config2 = this.manager.config;
              this.enabled = config2.inputTouch;
              this.target = config2.inputTouchEventTarget;
              this.capture = config2.inputTouchCapture;
              if (!this.target) {
                this.target = this.manager.game.canvas;
              }
              if (config2.disableContextMenu) {
                this.disableContextMenu();
              }
              if (this.enabled && this.target) {
                this.startListeners();
              }
            },
            disableContextMenu: function() {
              document.body.addEventListener("contextmenu", function(event) {
                event.preventDefault();
                return false;
              });
              return this;
            },
            startListeners: function() {
              var _this = this;
              var canvas = this.manager.canvas;
              var autoFocus = window && window.focus && this.manager.game.config.autoFocus;
              this.onTouchStart = function(event) {
                if (autoFocus) {
                  window.focus();
                }
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                  _this.manager.onTouchStart(event);
                  if (_this.capture && event.cancelable && event.target === canvas) {
                    event.preventDefault();
                  }
                }
              };
              this.onTouchStartWindow = function(event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && event.target !== canvas) {
                  _this.manager.onTouchStart(event);
                }
              };
              this.onTouchMove = function(event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                  _this.manager.onTouchMove(event);
                  if (_this.capture && event.cancelable) {
                    event.preventDefault();
                  }
                }
              };
              this.onTouchEnd = function(event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                  _this.manager.onTouchEnd(event);
                  if (_this.capture && event.cancelable && event.target === canvas) {
                    event.preventDefault();
                  }
                }
              };
              this.onTouchEndWindow = function(event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && event.target !== canvas) {
                  _this.manager.onTouchEnd(event);
                }
              };
              this.onTouchCancel = function(event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                  _this.manager.onTouchCancel(event);
                  if (_this.capture) {
                    event.preventDefault();
                  }
                }
              };
              this.onTouchCancelWindow = function(event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                  _this.manager.onTouchCancel(event);
                }
              };
              this.onTouchOver = function(event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                  _this.manager.setCanvasOver(event);
                }
              };
              this.onTouchOut = function(event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                  _this.manager.setCanvasOut(event);
                }
              };
              var target = this.target;
              if (!target) {
                return;
              }
              var passive = {passive: true};
              var nonPassive = {passive: false};
              target.addEventListener("touchstart", this.onTouchStart, this.capture ? nonPassive : passive);
              target.addEventListener("touchmove", this.onTouchMove, this.capture ? nonPassive : passive);
              target.addEventListener("touchend", this.onTouchEnd, this.capture ? nonPassive : passive);
              target.addEventListener("touchcancel", this.onTouchCancel, this.capture ? nonPassive : passive);
              target.addEventListener("touchover", this.onTouchOver, this.capture ? nonPassive : passive);
              target.addEventListener("touchout", this.onTouchOut, this.capture ? nonPassive : passive);
              if (window && this.manager.game.config.inputWindowEvents) {
                window.addEventListener("touchstart", this.onTouchStartWindow, nonPassive);
                window.addEventListener("touchend", this.onTouchEndWindow, nonPassive);
                window.addEventListener("touchcancel", this.onTouchCancelWindow, nonPassive);
              }
              this.enabled = true;
            },
            stopListeners: function() {
              var target = this.target;
              target.removeEventListener("touchstart", this.onTouchStart);
              target.removeEventListener("touchmove", this.onTouchMove);
              target.removeEventListener("touchend", this.onTouchEnd);
              target.removeEventListener("touchcancel", this.onTouchCancel);
              target.removeEventListener("touchover", this.onTouchOver);
              target.removeEventListener("touchout", this.onTouchOut);
              if (window) {
                window.removeEventListener("touchstart", this.onTouchStartWindow);
                window.removeEventListener("touchend", this.onTouchEndWindow);
              }
            },
            destroy: function() {
              this.stopListeners();
              this.target = null;
              this.enabled = false;
              this.manager = null;
            }
          });
          module2.exports = TouchManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GameEvents = __webpack_require__(22);
          var EventEmitter = __webpack_require__(9);
          var FileTypesManager = __webpack_require__(8);
          var GameObjectCreator = __webpack_require__(16);
          var GameObjectFactory = __webpack_require__(5);
          var GetFastValue = __webpack_require__(2);
          var PluginCache = __webpack_require__(24);
          var Remove = __webpack_require__(89);
          var PluginManager = new Class({
            Extends: EventEmitter,
            initialize: function PluginManager2(game) {
              EventEmitter.call(this);
              this.game = game;
              this.plugins = [];
              this.scenePlugins = [];
              this._pendingGlobal = [];
              this._pendingScene = [];
              if (game.isBooted) {
                this.boot();
              } else {
                game.events.once(GameEvents.BOOT, this.boot, this);
              }
            },
            boot: function() {
              var i;
              var entry;
              var key;
              var plugin;
              var start;
              var mapping;
              var data;
              var config2 = this.game.config;
              var list = config2.installGlobalPlugins;
              list = list.concat(this._pendingGlobal);
              for (i = 0; i < list.length; i++) {
                entry = list[i];
                key = GetFastValue(entry, "key", null);
                plugin = GetFastValue(entry, "plugin", null);
                start = GetFastValue(entry, "start", false);
                mapping = GetFastValue(entry, "mapping", null);
                data = GetFastValue(entry, "data", null);
                if (key) {
                  if (plugin) {
                    this.install(key, plugin, start, mapping, data);
                  } else {
                    console.warn("Missing `plugin` for key: " + key);
                  }
                }
              }
              list = config2.installScenePlugins;
              list = list.concat(this._pendingScene);
              for (i = 0; i < list.length; i++) {
                entry = list[i];
                key = GetFastValue(entry, "key", null);
                plugin = GetFastValue(entry, "plugin", null);
                mapping = GetFastValue(entry, "mapping", null);
                if (key) {
                  if (plugin) {
                    this.installScenePlugin(key, plugin, mapping);
                  } else {
                    console.warn("Missing `plugin` for key: " + key);
                  }
                }
              }
              this._pendingGlobal = [];
              this._pendingScene = [];
              this.game.events.once(GameEvents.DESTROY, this.destroy, this);
            },
            addToScene: function(sys, globalPlugins, scenePlugins) {
              var i;
              var pluginKey;
              var pluginList;
              var game = this.game;
              var scene = sys.scene;
              var map = sys.settings.map;
              var isBooted = sys.settings.isBooted;
              for (i = 0; i < globalPlugins.length; i++) {
                pluginKey = globalPlugins[i];
                if (game[pluginKey]) {
                  sys[pluginKey] = game[pluginKey];
                  if (map.hasOwnProperty(pluginKey)) {
                    scene[map[pluginKey]] = sys[pluginKey];
                  }
                } else if (pluginKey === "game" && map.hasOwnProperty(pluginKey)) {
                  scene[map[pluginKey]] = game;
                }
              }
              for (var s = 0; s < scenePlugins.length; s++) {
                pluginList = scenePlugins[s];
                for (i = 0; i < pluginList.length; i++) {
                  pluginKey = pluginList[i];
                  if (!PluginCache.hasCore(pluginKey)) {
                    continue;
                  }
                  var source = PluginCache.getCore(pluginKey);
                  var plugin = new source.plugin(scene, this);
                  sys[source.mapping] = plugin;
                  if (source.custom) {
                    scene[source.mapping] = plugin;
                  } else if (map.hasOwnProperty(source.mapping)) {
                    scene[map[source.mapping]] = plugin;
                  }
                  if (isBooted) {
                    plugin.boot();
                  }
                }
              }
              pluginList = this.plugins;
              for (i = 0; i < pluginList.length; i++) {
                var entry = pluginList[i];
                if (entry.mapping) {
                  scene[entry.mapping] = entry.plugin;
                }
              }
            },
            getDefaultScenePlugins: function() {
              var list = this.game.config.defaultPlugins;
              list = list.concat(this.scenePlugins);
              return list;
            },
            installScenePlugin: function(key, plugin, mapping, addToScene, fromLoader) {
              if (fromLoader === void 0) {
                fromLoader = false;
              }
              if (typeof plugin !== "function") {
                console.warn("Invalid Scene Plugin: " + key);
                return;
              }
              if (!PluginCache.hasCore(key)) {
                PluginCache.register(key, plugin, mapping, true);
                this.scenePlugins.push(key);
              } else if (!fromLoader && PluginCache.hasCore(key)) {
                console.warn("Scene Plugin key in use: " + key);
                return;
              }
              if (addToScene) {
                var instance = new plugin(addToScene, this);
                addToScene.sys[key] = instance;
                if (mapping && mapping !== "") {
                  addToScene[mapping] = instance;
                }
                instance.boot();
              }
            },
            install: function(key, plugin, start, mapping, data) {
              if (start === void 0) {
                start = false;
              }
              if (mapping === void 0) {
                mapping = null;
              }
              if (data === void 0) {
                data = null;
              }
              if (typeof plugin !== "function") {
                console.warn("Invalid Plugin: " + key);
                return null;
              }
              if (PluginCache.hasCustom(key)) {
                console.warn("Plugin key in use: " + key);
                return null;
              }
              if (mapping !== null) {
                start = true;
              }
              if (!this.game.isBooted) {
                this._pendingGlobal.push({key, plugin, start, mapping, data});
              } else {
                PluginCache.registerCustom(key, plugin, mapping, data);
                if (start) {
                  return this.start(key);
                }
              }
              return null;
            },
            getIndex: function(key) {
              var list = this.plugins;
              for (var i = 0; i < list.length; i++) {
                var entry = list[i];
                if (entry.key === key) {
                  return i;
                }
              }
              return -1;
            },
            getEntry: function(key) {
              var idx = this.getIndex(key);
              if (idx !== -1) {
                return this.plugins[idx];
              }
            },
            isActive: function(key) {
              var entry = this.getEntry(key);
              return entry && entry.active;
            },
            start: function(key, runAs) {
              if (runAs === void 0) {
                runAs = key;
              }
              var entry = this.getEntry(runAs);
              if (entry && !entry.active) {
                entry.active = true;
                entry.plugin.start();
              } else if (!entry) {
                entry = this.createEntry(key, runAs);
              }
              return entry ? entry.plugin : null;
            },
            createEntry: function(key, runAs) {
              var entry = PluginCache.getCustom(key);
              if (entry) {
                var instance = new entry.plugin(this);
                entry = {
                  key: runAs,
                  plugin: instance,
                  active: true,
                  mapping: entry.mapping,
                  data: entry.data
                };
                this.plugins.push(entry);
                instance.init(entry.data);
                instance.start();
              }
              return entry;
            },
            stop: function(key) {
              var entry = this.getEntry(key);
              if (entry && entry.active) {
                entry.active = false;
                entry.plugin.stop();
              }
              return this;
            },
            get: function(key, autoStart) {
              if (autoStart === void 0) {
                autoStart = true;
              }
              var entry = this.getEntry(key);
              if (entry) {
                return entry.plugin;
              } else {
                var plugin = this.getClass(key);
                if (plugin && autoStart) {
                  entry = this.createEntry(key, key);
                  return entry ? entry.plugin : null;
                } else if (plugin) {
                  return plugin;
                }
              }
              return null;
            },
            getClass: function(key) {
              return PluginCache.getCustomClass(key);
            },
            removeGlobalPlugin: function(key) {
              var entry = this.getEntry(key);
              if (entry) {
                Remove(this.plugins, entry);
              }
              PluginCache.removeCustom(key);
            },
            removeScenePlugin: function(key) {
              Remove(this.scenePlugins, key);
              PluginCache.remove(key);
            },
            registerGameObject: function(key, factoryCallback, creatorCallback) {
              if (factoryCallback) {
                GameObjectFactory.register(key, factoryCallback);
              }
              if (creatorCallback) {
                GameObjectCreator.register(key, creatorCallback);
              }
              return this;
            },
            removeGameObject: function(key, removeFromFactory, removeFromCreator) {
              if (removeFromFactory === void 0) {
                removeFromFactory = true;
              }
              if (removeFromCreator === void 0) {
                removeFromCreator = true;
              }
              if (removeFromFactory) {
                GameObjectFactory.remove(key);
              }
              if (removeFromCreator) {
                GameObjectCreator.remove(key);
              }
              return this;
            },
            registerFileType: function(key, callback, addToScene) {
              FileTypesManager.register(key, callback);
              if (addToScene && addToScene.sys.load) {
                addToScene.sys.load[key] = callback;
              }
            },
            destroy: function() {
              for (var i = 0; i < this.plugins.length; i++) {
                this.plugins[i].plugin.destroy();
              }
              PluginCache.destroyCustomPlugins();
              if (this.game.noReturn) {
                PluginCache.destroyCorePlugins();
              }
              this.game = null;
              this.plugins = [];
              this.scenePlugins = [];
            }
          });
          module2.exports = PluginManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(198);
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(101);
          var GameEvents = __webpack_require__(22);
          var GetInnerHeight = __webpack_require__(395);
          var GetTarget = __webpack_require__(401);
          var GetScreenOrientation = __webpack_require__(396);
          var NOOP = __webpack_require__(1);
          var Rectangle = __webpack_require__(10);
          var Size = __webpack_require__(410);
          var SnapFloor = __webpack_require__(76);
          var Vector29 = __webpack_require__(3);
          var ScaleManager = new Class({
            Extends: EventEmitter,
            initialize: function ScaleManager2(game) {
              EventEmitter.call(this);
              this.game = game;
              this.canvas;
              this.canvasBounds = new Rectangle();
              this.parent = null;
              this.parentIsWindow = false;
              this.parentSize = new Size();
              this.gameSize = new Size();
              this.baseSize = new Size();
              this.displaySize = new Size();
              this.scaleMode = CONST.SCALE_MODE.NONE;
              this.zoom = 1;
              this._resetZoom = false;
              this.displayScale = new Vector29(1, 1);
              this.autoRound = false;
              this.autoCenter = CONST.CENTER.NO_CENTER;
              this.orientation = CONST.ORIENTATION.LANDSCAPE;
              this.fullscreen;
              this.fullscreenTarget = null;
              this._createdFullscreenTarget = false;
              this.dirty = false;
              this.resizeInterval = 500;
              this._lastCheck = 0;
              this._checkOrientation = false;
              this.listeners = {
                orientationChange: NOOP,
                windowResize: NOOP,
                fullScreenChange: NOOP,
                fullScreenError: NOOP
              };
            },
            preBoot: function() {
              this.parseConfig(this.game.config);
              this.game.events.once(GameEvents.BOOT, this.boot, this);
            },
            boot: function() {
              var game = this.game;
              this.canvas = game.canvas;
              this.fullscreen = game.device.fullscreen;
              if (this.scaleMode !== CONST.SCALE_MODE.RESIZE) {
                this.displaySize.setAspectMode(this.scaleMode);
              }
              if (this.scaleMode === CONST.SCALE_MODE.NONE) {
                this.resize(this.width, this.height);
              } else {
                this.getParentBounds();
                if (this.parentSize.width > 0 && this.parentSize.height > 0) {
                  this.displaySize.setParent(this.parentSize);
                }
                this.refresh();
              }
              game.events.on(GameEvents.PRE_STEP, this.step, this);
              game.events.once(GameEvents.READY, this.refresh, this);
              game.events.once(GameEvents.DESTROY, this.destroy, this);
              this.startListeners();
            },
            parseConfig: function(config2) {
              this.getParent(config2);
              this.getParentBounds();
              var width = config2.width;
              var height = config2.height;
              var scaleMode = config2.scaleMode;
              var zoom = config2.zoom;
              var autoRound = config2.autoRound;
              if (typeof width === "string") {
                var parentWidth = this.parentSize.width;
                if (parentWidth === 0) {
                  parentWidth = window.innerWidth;
                }
                var parentScaleX = parseInt(width, 10) / 100;
                width = Math.floor(parentWidth * parentScaleX);
              }
              if (typeof height === "string") {
                var parentHeight = this.parentSize.height;
                if (parentHeight === 0) {
                  parentHeight = window.innerHeight;
                }
                var parentScaleY = parseInt(height, 10) / 100;
                height = Math.floor(parentHeight * parentScaleY);
              }
              this.scaleMode = scaleMode;
              this.autoRound = autoRound;
              this.autoCenter = config2.autoCenter;
              this.resizeInterval = config2.resizeInterval;
              if (autoRound) {
                width = Math.floor(width);
                height = Math.floor(height);
              }
              this.gameSize.setSize(width, height);
              if (zoom === CONST.ZOOM.MAX_ZOOM) {
                zoom = this.getMaxZoom();
              }
              this.zoom = zoom;
              if (zoom !== 1) {
                this._resetZoom = true;
              }
              this.baseSize.setSize(width, height);
              if (autoRound) {
                this.baseSize.width = Math.floor(this.baseSize.width);
                this.baseSize.height = Math.floor(this.baseSize.height);
              }
              if (config2.minWidth > 0) {
                this.displaySize.setMin(config2.minWidth * zoom, config2.minHeight * zoom);
              }
              if (config2.maxWidth > 0) {
                this.displaySize.setMax(config2.maxWidth * zoom, config2.maxHeight * zoom);
              }
              this.displaySize.setSize(width, height);
              this.orientation = GetScreenOrientation(width, height);
            },
            getParent: function(config2) {
              var parent = config2.parent;
              if (parent === null) {
                return;
              }
              this.parent = GetTarget(parent);
              this.parentIsWindow = this.parent === document.body;
              if (config2.expandParent && config2.scaleMode !== CONST.SCALE_MODE.NONE) {
                var DOMRect = this.parent.getBoundingClientRect();
                if (this.parentIsWindow || DOMRect.height === 0) {
                  document.documentElement.style.height = "100%";
                  document.body.style.height = "100%";
                  DOMRect = this.parent.getBoundingClientRect();
                  if (!this.parentIsWindow && DOMRect.height === 0) {
                    this.parent.style.overflow = "hidden";
                    this.parent.style.width = "100%";
                    this.parent.style.height = "100%";
                  }
                }
              }
              if (config2.fullscreenTarget && !this.fullscreenTarget) {
                this.fullscreenTarget = GetTarget(config2.fullscreenTarget);
              }
            },
            getParentBounds: function() {
              if (!this.parent) {
                return false;
              }
              var parentSize = this.parentSize;
              var DOMRect = this.parent.getBoundingClientRect();
              if (this.parentIsWindow && this.game.device.os.iOS) {
                DOMRect.height = GetInnerHeight(true);
              }
              var newWidth = DOMRect.width;
              var newHeight = DOMRect.height;
              if (parentSize.width !== newWidth || parentSize.height !== newHeight) {
                parentSize.setSize(newWidth, newHeight);
                return true;
              } else {
                return false;
              }
            },
            lockOrientation: function(orientation) {
              var lock = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;
              if (lock) {
                return lock.call(screen, orientation);
              }
              return false;
            },
            setParentSize: function(width, height) {
              this.parentSize.setSize(width, height);
              return this.refresh();
            },
            setGameSize: function(width, height) {
              var autoRound = this.autoRound;
              if (autoRound) {
                width = Math.floor(width);
                height = Math.floor(height);
              }
              var previousWidth = this.width;
              var previousHeight = this.height;
              this.gameSize.resize(width, height);
              this.baseSize.resize(width, height);
              if (autoRound) {
                this.baseSize.width = Math.floor(this.baseSize.width);
                this.baseSize.height = Math.floor(this.baseSize.height);
              }
              this.displaySize.setAspectRatio(width / height);
              this.canvas.width = this.baseSize.width;
              this.canvas.height = this.baseSize.height;
              return this.refresh(previousWidth, previousHeight);
            },
            resize: function(width, height) {
              var zoom = this.zoom;
              var autoRound = this.autoRound;
              if (autoRound) {
                width = Math.floor(width);
                height = Math.floor(height);
              }
              var previousWidth = this.width;
              var previousHeight = this.height;
              this.gameSize.resize(width, height);
              this.baseSize.resize(width, height);
              if (autoRound) {
                this.baseSize.width = Math.floor(this.baseSize.width);
                this.baseSize.height = Math.floor(this.baseSize.height);
              }
              this.displaySize.setSize(width * zoom, height * zoom);
              this.canvas.width = this.baseSize.width;
              this.canvas.height = this.baseSize.height;
              var style = this.canvas.style;
              var styleWidth = width * zoom;
              var styleHeight = height * zoom;
              if (autoRound) {
                styleWidth = Math.floor(styleWidth);
                styleHeight = Math.floor(styleHeight);
              }
              if (styleWidth !== width || styleHeight !== height) {
                style.width = styleWidth + "px";
                style.height = styleHeight + "px";
              }
              return this.refresh(previousWidth, previousHeight);
            },
            setZoom: function(value) {
              this.zoom = value;
              this._resetZoom = true;
              return this.refresh();
            },
            setMaxZoom: function() {
              this.zoom = this.getMaxZoom();
              this._resetZoom = true;
              return this.refresh();
            },
            refresh: function(previousWidth, previousHeight) {
              if (previousWidth === void 0) {
                previousWidth = this.width;
              }
              if (previousHeight === void 0) {
                previousHeight = this.height;
              }
              this.updateScale();
              this.updateBounds();
              this.updateOrientation();
              this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);
              var domContainer = this.game.domContainer;
              if (domContainer) {
                this.baseSize.setCSS(domContainer);
                var canvasStyle = this.canvas.style;
                var domStyle = domContainer.style;
                domStyle.transform = "scale(" + this.displaySize.width / this.baseSize.width + "," + this.displaySize.height / this.baseSize.height + ")";
                domStyle.marginLeft = canvasStyle.marginLeft;
                domStyle.marginTop = canvasStyle.marginTop;
              }
              this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, previousWidth, previousHeight);
              return this;
            },
            updateOrientation: function() {
              if (this._checkOrientation) {
                this._checkOrientation = false;
                var newOrientation = GetScreenOrientation(this.width, this.height);
                if (newOrientation !== this.orientation) {
                  this.orientation = newOrientation;
                  this.emit(Events.ORIENTATION_CHANGE, newOrientation);
                }
              }
            },
            updateScale: function() {
              var style = this.canvas.style;
              var width = this.gameSize.width;
              var height = this.gameSize.height;
              var styleWidth;
              var styleHeight;
              var zoom = this.zoom;
              var autoRound = this.autoRound;
              if (this.scaleMode === CONST.SCALE_MODE.NONE) {
                this.displaySize.setSize(width * zoom, height * zoom);
                styleWidth = this.displaySize.width;
                styleHeight = this.displaySize.height;
                if (autoRound) {
                  styleWidth = Math.floor(styleWidth);
                  styleHeight = Math.floor(styleHeight);
                }
                if (this._resetZoom) {
                  style.width = styleWidth + "px";
                  style.height = styleHeight + "px";
                  this._resetZoom = false;
                }
              } else if (this.scaleMode === CONST.SCALE_MODE.RESIZE) {
                this.displaySize.setSize(this.parentSize.width, this.parentSize.height);
                this.gameSize.setSize(this.displaySize.width, this.displaySize.height);
                this.baseSize.setSize(this.displaySize.width, this.displaySize.height);
                styleWidth = this.displaySize.width;
                styleHeight = this.displaySize.height;
                if (autoRound) {
                  styleWidth = Math.floor(styleWidth);
                  styleHeight = Math.floor(styleHeight);
                }
                this.canvas.width = styleWidth;
                this.canvas.height = styleHeight;
              } else {
                this.displaySize.setSize(this.parentSize.width, this.parentSize.height);
                styleWidth = this.displaySize.width;
                styleHeight = this.displaySize.height;
                if (autoRound) {
                  styleWidth = Math.floor(styleWidth);
                  styleHeight = Math.floor(styleHeight);
                }
                style.width = styleWidth + "px";
                style.height = styleHeight + "px";
              }
              this.getParentBounds();
              this.updateCenter();
            },
            getMaxZoom: function() {
              var zoomH = SnapFloor(this.parentSize.width, this.gameSize.width, 0, true);
              var zoomV = SnapFloor(this.parentSize.height, this.gameSize.height, 0, true);
              return Math.max(Math.min(zoomH, zoomV), 1);
            },
            updateCenter: function() {
              var autoCenter = this.autoCenter;
              if (autoCenter === CONST.CENTER.NO_CENTER) {
                return;
              }
              var canvas = this.canvas;
              var style = canvas.style;
              var bounds = canvas.getBoundingClientRect();
              var width = bounds.width;
              var height = bounds.height;
              var offsetX = Math.floor((this.parentSize.width - width) / 2);
              var offsetY = Math.floor((this.parentSize.height - height) / 2);
              if (autoCenter === CONST.CENTER.CENTER_HORIZONTALLY) {
                offsetY = 0;
              } else if (autoCenter === CONST.CENTER.CENTER_VERTICALLY) {
                offsetX = 0;
              }
              style.marginLeft = offsetX + "px";
              style.marginTop = offsetY + "px";
            },
            updateBounds: function() {
              var bounds = this.canvasBounds;
              var clientRect = this.canvas.getBoundingClientRect();
              bounds.x = clientRect.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0);
              bounds.y = clientRect.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0);
              bounds.width = clientRect.width;
              bounds.height = clientRect.height;
            },
            transformX: function(pageX) {
              return (pageX - this.canvasBounds.left) * this.displayScale.x;
            },
            transformY: function(pageY) {
              return (pageY - this.canvasBounds.top) * this.displayScale.y;
            },
            startFullscreen: function(fullscreenOptions) {
              if (fullscreenOptions === void 0) {
                fullscreenOptions = {navigationUI: "hide"};
              }
              var fullscreen = this.fullscreen;
              if (!fullscreen.available) {
                this.emit(Events.FULLSCREEN_UNSUPPORTED);
                return;
              }
              if (!fullscreen.active) {
                var fsTarget = this.getFullscreenTarget();
                if (fullscreen.keyboard) {
                  fsTarget[fullscreen.request](Element.ALLOW_KEYBOARD_INPUT);
                } else {
                  fsTarget[fullscreen.request](fullscreenOptions);
                }
              }
            },
            fullscreenSuccessHandler: function() {
              this.getParentBounds();
              this.refresh();
              this.emit(Events.ENTER_FULLSCREEN);
            },
            fullscreenErrorHandler: function(error) {
              this.removeFullscreenTarget();
              this.emit(Events.FULLSCREEN_FAILED, error);
            },
            getFullscreenTarget: function() {
              if (!this.fullscreenTarget) {
                var fsTarget = document.createElement("div");
                fsTarget.style.margin = "0";
                fsTarget.style.padding = "0";
                fsTarget.style.width = "100%";
                fsTarget.style.height = "100%";
                this.fullscreenTarget = fsTarget;
                this._createdFullscreenTarget = true;
              }
              if (this._createdFullscreenTarget) {
                var canvasParent = this.canvas.parentNode;
                canvasParent.insertBefore(this.fullscreenTarget, this.canvas);
                this.fullscreenTarget.appendChild(this.canvas);
              }
              return this.fullscreenTarget;
            },
            removeFullscreenTarget: function() {
              if (this._createdFullscreenTarget) {
                var fsTarget = this.fullscreenTarget;
                if (fsTarget && fsTarget.parentNode) {
                  var parent = fsTarget.parentNode;
                  parent.insertBefore(this.canvas, fsTarget);
                  parent.removeChild(fsTarget);
                }
              }
            },
            stopFullscreen: function() {
              var fullscreen = this.fullscreen;
              if (!fullscreen.available) {
                this.emit(Events.FULLSCREEN_UNSUPPORTED);
                return false;
              }
              if (fullscreen.active) {
                document[fullscreen.cancel]();
              }
              this.removeFullscreenTarget();
              this.getParentBounds();
              this.emit(Events.LEAVE_FULLSCREEN);
              this.refresh();
            },
            toggleFullscreen: function(fullscreenOptions) {
              if (this.fullscreen.active) {
                this.stopFullscreen();
              } else {
                this.startFullscreen(fullscreenOptions);
              }
            },
            startListeners: function() {
              var _this = this;
              var listeners = this.listeners;
              listeners.orientationChange = function() {
                _this.updateBounds();
                _this._checkOrientation = true;
                _this.dirty = true;
              };
              listeners.windowResize = function() {
                _this.updateBounds();
                _this.dirty = true;
              };
              window.addEventListener("orientationchange", listeners.orientationChange, false);
              window.addEventListener("resize", listeners.windowResize, false);
              if (this.fullscreen.available) {
                listeners.fullScreenChange = function(event) {
                  return _this.onFullScreenChange(event);
                };
                listeners.fullScreenError = function(event) {
                  return _this.onFullScreenError(event);
                };
                var vendors = ["webkit", "moz", ""];
                vendors.forEach(function(prefix) {
                  document.addEventListener(prefix + "fullscreenchange", listeners.fullScreenChange, false);
                  document.addEventListener(prefix + "fullscreenerror", listeners.fullScreenError, false);
                });
                document.addEventListener("MSFullscreenChange", listeners.fullScreenChange, false);
                document.addEventListener("MSFullscreenError", listeners.fullScreenError, false);
              }
            },
            onFullScreenChange: function() {
              if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement) {
                this.fullscreenSuccessHandler();
              } else {
                this.stopFullscreen();
              }
            },
            onFullScreenError: function() {
              this.removeFullscreenTarget();
            },
            step: function(time, delta) {
              if (!this.parent) {
                return;
              }
              this._lastCheck += delta;
              if (this.dirty || this._lastCheck > this.resizeInterval) {
                if (this.getParentBounds()) {
                  this.refresh();
                }
                this.dirty = false;
                this._lastCheck = 0;
              }
            },
            stopListeners: function() {
              var listeners = this.listeners;
              window.removeEventListener("orientationchange", listeners.orientationChange, false);
              window.removeEventListener("resize", listeners.windowResize, false);
              var vendors = ["webkit", "moz", ""];
              vendors.forEach(function(prefix) {
                document.removeEventListener(prefix + "fullscreenchange", listeners.fullScreenChange, false);
                document.removeEventListener(prefix + "fullscreenerror", listeners.fullScreenError, false);
              });
              document.removeEventListener("MSFullscreenChange", listeners.fullScreenChange, false);
              document.removeEventListener("MSFullscreenError", listeners.fullScreenError, false);
            },
            destroy: function() {
              this.removeAllListeners();
              this.stopListeners();
              this.game = null;
              this.canvas = null;
              this.canvasBounds = null;
              this.parent = null;
              this.fullscreenTarget = null;
              this.parentSize.destroy();
              this.gameSize.destroy();
              this.baseSize.destroy();
              this.displaySize.destroy();
            },
            isFullscreen: {
              get: function() {
                return this.fullscreen.active;
              }
            },
            width: {
              get: function() {
                return this.gameSize.width;
              }
            },
            height: {
              get: function() {
                return this.gameSize.height;
              }
            },
            isPortrait: {
              get: function() {
                return this.orientation === CONST.ORIENTATION.PORTRAIT;
              }
            },
            isLandscape: {
              get: function() {
                return this.orientation === CONST.ORIENTATION.LANDSCAPE;
              }
            },
            isGamePortrait: {
              get: function() {
                return this.height > this.width;
              }
            },
            isGameLandscape: {
              get: function() {
                return this.width > this.height;
              }
            }
          });
          module2.exports = ScaleManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var SnapFloor = __webpack_require__(76);
          var Vector29 = __webpack_require__(3);
          var Size = new Class({
            initialize: function Size2(width, height, aspectMode, parent) {
              if (width === void 0) {
                width = 0;
              }
              if (height === void 0) {
                height = width;
              }
              if (aspectMode === void 0) {
                aspectMode = 0;
              }
              if (parent === void 0) {
                parent = null;
              }
              this._width = width;
              this._height = height;
              this._parent = parent;
              this.aspectMode = aspectMode;
              this.aspectRatio = height === 0 ? 1 : width / height;
              this.minWidth = 0;
              this.minHeight = 0;
              this.maxWidth = Number.MAX_VALUE;
              this.maxHeight = Number.MAX_VALUE;
              this.snapTo = new Vector29();
            },
            setAspectMode: function(value) {
              if (value === void 0) {
                value = 0;
              }
              this.aspectMode = value;
              return this.setSize(this._width, this._height);
            },
            setSnap: function(snapWidth, snapHeight) {
              if (snapWidth === void 0) {
                snapWidth = 0;
              }
              if (snapHeight === void 0) {
                snapHeight = snapWidth;
              }
              this.snapTo.set(snapWidth, snapHeight);
              return this.setSize(this._width, this._height);
            },
            setParent: function(parent) {
              this._parent = parent;
              return this.setSize(this._width, this._height);
            },
            setMin: function(width, height) {
              if (width === void 0) {
                width = 0;
              }
              if (height === void 0) {
                height = width;
              }
              this.minWidth = Clamp(width, 0, this.maxWidth);
              this.minHeight = Clamp(height, 0, this.maxHeight);
              return this.setSize(this._width, this._height);
            },
            setMax: function(width, height) {
              if (width === void 0) {
                width = Number.MAX_VALUE;
              }
              if (height === void 0) {
                height = width;
              }
              this.maxWidth = Clamp(width, this.minWidth, Number.MAX_VALUE);
              this.maxHeight = Clamp(height, this.minHeight, Number.MAX_VALUE);
              return this.setSize(this._width, this._height);
            },
            setSize: function(width, height) {
              if (width === void 0) {
                width = 0;
              }
              if (height === void 0) {
                height = width;
              }
              switch (this.aspectMode) {
                case Size.NONE:
                  this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
                  this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
                  this.aspectRatio = this._height === 0 ? 1 : this._width / this._height;
                  break;
                case Size.WIDTH_CONTROLS_HEIGHT:
                  this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
                  this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), false);
                  break;
                case Size.HEIGHT_CONTROLS_WIDTH:
                  this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
                  this._width = this.getNewWidth(this._height * this.aspectRatio, false);
                  break;
                case Size.FIT:
                  this.constrain(width, height, true);
                  break;
                case Size.ENVELOP:
                  this.constrain(width, height, false);
                  break;
              }
              return this;
            },
            setAspectRatio: function(ratio) {
              this.aspectRatio = ratio;
              return this.setSize(this._width, this._height);
            },
            resize: function(width, height) {
              this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
              this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
              this.aspectRatio = this._height === 0 ? 1 : this._width / this._height;
              return this;
            },
            getNewWidth: function(value, checkParent) {
              if (checkParent === void 0) {
                checkParent = true;
              }
              value = Clamp(value, this.minWidth, this.maxWidth);
              if (checkParent && this._parent && value > this._parent.width) {
                value = Math.max(this.minWidth, this._parent.width);
              }
              return value;
            },
            getNewHeight: function(value, checkParent) {
              if (checkParent === void 0) {
                checkParent = true;
              }
              value = Clamp(value, this.minHeight, this.maxHeight);
              if (checkParent && this._parent && value > this._parent.height) {
                value = Math.max(this.minHeight, this._parent.height);
              }
              return value;
            },
            constrain: function(width, height, fit) {
              if (width === void 0) {
                width = 0;
              }
              if (height === void 0) {
                height = width;
              }
              if (fit === void 0) {
                fit = true;
              }
              width = this.getNewWidth(width);
              height = this.getNewHeight(height);
              var snap = this.snapTo;
              var newRatio = height === 0 ? 1 : width / height;
              if (fit && this.aspectRatio > newRatio || !fit && this.aspectRatio < newRatio) {
                width = SnapFloor(width, snap.x);
                height = width / this.aspectRatio;
                if (snap.y > 0) {
                  height = SnapFloor(height, snap.y);
                  width = height * this.aspectRatio;
                }
              } else if (fit && this.aspectRatio < newRatio || !fit && this.aspectRatio > newRatio) {
                height = SnapFloor(height, snap.y);
                width = height * this.aspectRatio;
                if (snap.x > 0) {
                  width = SnapFloor(width, snap.x);
                  height = width * (1 / this.aspectRatio);
                }
              }
              this._width = width;
              this._height = height;
              return this;
            },
            fitTo: function(width, height) {
              return this.constrain(width, height, true);
            },
            envelop: function(width, height) {
              return this.constrain(width, height, false);
            },
            setWidth: function(value) {
              return this.setSize(value, this._height);
            },
            setHeight: function(value) {
              return this.setSize(this._width, value);
            },
            toString: function() {
              return "[{ Size (width=" + this._width + " height=" + this._height + " aspectRatio=" + this.aspectRatio + " aspectMode=" + this.aspectMode + ") }]";
            },
            setCSS: function(element) {
              if (element && element.style) {
                element.style.width = this._width + "px";
                element.style.height = this._height + "px";
              }
            },
            copy: function(destination) {
              destination.setAspectMode(this.aspectMode);
              destination.aspectRatio = this.aspectRatio;
              return destination.setSize(this.width, this.height);
            },
            destroy: function() {
              this._parent = null;
              this.snapTo = null;
            },
            width: {
              get: function() {
                return this._width;
              },
              set: function(value) {
                this.setSize(value, this._height);
              }
            },
            height: {
              get: function() {
                return this._height;
              },
              set: function(value) {
                this.setSize(this._width, value);
              }
            }
          });
          Size.NONE = 0;
          Size.WIDTH_CONTROLS_HEIGHT = 1;
          Size.HEIGHT_CONTROLS_WIDTH = 2;
          Size.FIT = 3;
          Size.ENVELOP = 4;
          module2.exports = Size;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(142);
          var Events = __webpack_require__(21);
          var GameEvents = __webpack_require__(22);
          var GetValue = __webpack_require__(6);
          var LoaderEvents = __webpack_require__(91);
          var NOOP = __webpack_require__(1);
          var Scene = __webpack_require__(412);
          var Systems = __webpack_require__(201);
          var SceneManager = new Class({
            initialize: function SceneManager2(game, sceneConfig) {
              this.game = game;
              this.keys = {};
              this.scenes = [];
              this._pending = [];
              this._start = [];
              this._queue = [];
              this._data = {};
              this.isProcessing = false;
              this.isBooted = false;
              this.customViewports = 0;
              if (sceneConfig) {
                if (!Array.isArray(sceneConfig)) {
                  sceneConfig = [sceneConfig];
                }
                for (var i = 0; i < sceneConfig.length; i++) {
                  this._pending.push({
                    key: "default",
                    scene: sceneConfig[i],
                    autoStart: i === 0,
                    data: {}
                  });
                }
              }
              game.events.once(GameEvents.READY, this.bootQueue, this);
            },
            bootQueue: function() {
              if (this.isBooted) {
                return;
              }
              var i;
              var entry;
              var key;
              var sceneConfig;
              for (i = 0; i < this._pending.length; i++) {
                entry = this._pending[i];
                key = entry.key;
                sceneConfig = entry.scene;
                var newScene;
                if (sceneConfig instanceof Scene) {
                  newScene = this.createSceneFromInstance(key, sceneConfig);
                } else if (typeof sceneConfig === "object") {
                  newScene = this.createSceneFromObject(key, sceneConfig);
                } else if (typeof sceneConfig === "function") {
                  newScene = this.createSceneFromFunction(key, sceneConfig);
                }
                key = newScene.sys.settings.key;
                this.keys[key] = newScene;
                this.scenes.push(newScene);
                if (this._data[key]) {
                  newScene.sys.settings.data = this._data[key].data;
                  if (this._data[key].autoStart) {
                    entry.autoStart = true;
                  }
                }
                if (entry.autoStart || newScene.sys.settings.active) {
                  this._start.push(key);
                }
              }
              this._pending.length = 0;
              this._data = {};
              this.isBooted = true;
              for (i = 0; i < this._start.length; i++) {
                entry = this._start[i];
                this.start(entry);
              }
              this._start.length = 0;
            },
            processQueue: function() {
              var pendingLength = this._pending.length;
              var queueLength = this._queue.length;
              if (pendingLength === 0 && queueLength === 0) {
                return;
              }
              var i;
              var entry;
              if (pendingLength) {
                for (i = 0; i < pendingLength; i++) {
                  entry = this._pending[i];
                  this.add(entry.key, entry.scene, entry.autoStart, entry.data);
                }
                for (i = 0; i < this._start.length; i++) {
                  entry = this._start[i];
                  this.start(entry);
                }
                this._start.length = 0;
                this._pending.length = 0;
                return;
              }
              for (i = 0; i < this._queue.length; i++) {
                entry = this._queue[i];
                this[entry.op](entry.keyA, entry.keyB);
              }
              this._queue.length = 0;
            },
            add: function(key, sceneConfig, autoStart, data) {
              if (autoStart === void 0) {
                autoStart = false;
              }
              if (data === void 0) {
                data = {};
              }
              if (this.isProcessing || !this.isBooted) {
                this._pending.push({
                  key,
                  scene: sceneConfig,
                  autoStart,
                  data
                });
                if (!this.isBooted) {
                  this._data[key] = {data};
                }
                return null;
              }
              key = this.getKey(key, sceneConfig);
              var newScene;
              if (sceneConfig instanceof Scene) {
                newScene = this.createSceneFromInstance(key, sceneConfig);
              } else if (typeof sceneConfig === "object") {
                sceneConfig.key = key;
                newScene = this.createSceneFromObject(key, sceneConfig);
              } else if (typeof sceneConfig === "function") {
                newScene = this.createSceneFromFunction(key, sceneConfig);
              }
              newScene.sys.settings.data = data;
              key = newScene.sys.settings.key;
              this.keys[key] = newScene;
              this.scenes.push(newScene);
              if (autoStart || newScene.sys.settings.active) {
                if (this._pending.length) {
                  this._start.push(key);
                } else {
                  this.start(key);
                }
              }
              return newScene;
            },
            remove: function(key) {
              if (this.isProcessing) {
                this._queue.push({op: "remove", keyA: key, keyB: null});
              } else {
                var sceneToRemove = this.getScene(key);
                if (!sceneToRemove || sceneToRemove.sys.isTransitioning()) {
                  return this;
                }
                var index = this.scenes.indexOf(sceneToRemove);
                var sceneKey = sceneToRemove.sys.settings.key;
                if (index > -1) {
                  delete this.keys[sceneKey];
                  this.scenes.splice(index, 1);
                  if (this._start.indexOf(sceneKey) > -1) {
                    index = this._start.indexOf(sceneKey);
                    this._start.splice(index, 1);
                  }
                  sceneToRemove.sys.destroy();
                }
              }
              return this;
            },
            bootScene: function(scene) {
              var sys = scene.sys;
              var settings = sys.settings;
              sys.sceneUpdate = NOOP;
              if (scene.init) {
                scene.init.call(scene, settings.data);
                settings.status = CONST.INIT;
                if (settings.isTransition) {
                  sys.events.emit(Events.TRANSITION_INIT, settings.transitionFrom, settings.transitionDuration);
                }
              }
              var loader;
              if (sys.load) {
                loader = sys.load;
                loader.reset();
              }
              if (loader && scene.preload) {
                scene.preload.call(scene);
                if (loader.list.size === 0) {
                  this.create(scene);
                } else {
                  settings.status = CONST.LOADING;
                  loader.once(LoaderEvents.COMPLETE, this.loadComplete, this);
                  loader.start();
                }
              } else {
                this.create(scene);
              }
            },
            loadComplete: function(loader) {
              var scene = loader.scene;
              if (this.game.sound && this.game.sound.onBlurPausedSounds) {
                this.game.sound.unlock();
              }
              this.create(scene);
            },
            payloadComplete: function(loader) {
              this.bootScene(loader.scene);
            },
            update: function(time, delta) {
              this.processQueue();
              this.isProcessing = true;
              for (var i = this.scenes.length - 1; i >= 0; i--) {
                var sys = this.scenes[i].sys;
                if (sys.settings.status > CONST.START && sys.settings.status <= CONST.RUNNING) {
                  sys.step(time, delta);
                }
              }
            },
            render: function(renderer) {
              for (var i = 0; i < this.scenes.length; i++) {
                var sys = this.scenes[i].sys;
                if (sys.settings.visible && sys.settings.status >= CONST.LOADING && sys.settings.status < CONST.SLEEPING) {
                  sys.render(renderer);
                }
              }
              this.isProcessing = false;
            },
            create: function(scene) {
              var sys = scene.sys;
              var settings = sys.settings;
              if (scene.create) {
                settings.status = CONST.CREATING;
                scene.create.call(scene, settings.data);
                if (settings.status === CONST.DESTROYED) {
                  return;
                }
              }
              if (settings.isTransition) {
                sys.events.emit(Events.TRANSITION_START, settings.transitionFrom, settings.transitionDuration);
              }
              if (scene.update) {
                sys.sceneUpdate = scene.update;
              }
              settings.status = CONST.RUNNING;
              sys.events.emit(Events.CREATE, scene);
            },
            createSceneFromFunction: function(key, scene) {
              var newScene = new scene();
              if (newScene instanceof Scene) {
                var configKey = newScene.sys.settings.key;
                if (configKey !== "") {
                  key = configKey;
                }
                if (this.keys.hasOwnProperty(key)) {
                  throw new Error("Cannot add a Scene with duplicate key: " + key);
                }
                return this.createSceneFromInstance(key, newScene);
              } else {
                newScene.sys = new Systems(newScene);
                newScene.sys.settings.key = key;
                newScene.sys.init(this.game);
                return newScene;
              }
            },
            createSceneFromInstance: function(key, newScene) {
              var configKey = newScene.sys.settings.key;
              if (configKey === "") {
                newScene.sys.settings.key = key;
              }
              newScene.sys.init(this.game);
              return newScene;
            },
            createSceneFromObject: function(key, sceneConfig) {
              var newScene = new Scene(sceneConfig);
              var configKey = newScene.sys.settings.key;
              if (configKey !== "") {
                key = configKey;
              } else {
                newScene.sys.settings.key = key;
              }
              newScene.sys.init(this.game);
              var defaults = ["init", "preload", "create", "update", "render"];
              for (var i = 0; i < defaults.length; i++) {
                var sceneCallback = GetValue(sceneConfig, defaults[i], null);
                if (sceneCallback) {
                  newScene[defaults[i]] = sceneCallback;
                }
              }
              if (sceneConfig.hasOwnProperty("extend")) {
                for (var propertyKey in sceneConfig.extend) {
                  if (!sceneConfig.extend.hasOwnProperty(propertyKey)) {
                    continue;
                  }
                  var value = sceneConfig.extend[propertyKey];
                  if (propertyKey === "data" && newScene.hasOwnProperty("data") && typeof value === "object") {
                    newScene.data.merge(value);
                  } else if (propertyKey !== "sys") {
                    newScene[propertyKey] = value;
                  }
                }
              }
              return newScene;
            },
            getKey: function(key, sceneConfig) {
              if (!key) {
                key = "default";
              }
              if (typeof sceneConfig === "function") {
                return key;
              } else if (sceneConfig instanceof Scene) {
                key = sceneConfig.sys.settings.key;
              } else if (typeof sceneConfig === "object" && sceneConfig.hasOwnProperty("key")) {
                key = sceneConfig.key;
              }
              if (this.keys.hasOwnProperty(key)) {
                throw new Error("Cannot add a Scene with duplicate key: " + key);
              } else {
                return key;
              }
            },
            getScenes: function(isActive, inReverse) {
              if (isActive === void 0) {
                isActive = true;
              }
              if (inReverse === void 0) {
                inReverse = false;
              }
              var out = [];
              var scenes = this.scenes;
              for (var i = 0; i < scenes.length; i++) {
                var scene = scenes[i];
                if (scene && (!isActive || isActive && scene.sys.isActive())) {
                  out.push(scene);
                }
              }
              return inReverse ? out.reverse() : out;
            },
            getScene: function(key) {
              if (typeof key === "string") {
                if (this.keys[key]) {
                  return this.keys[key];
                }
              } else {
                for (var i = 0; i < this.scenes.length; i++) {
                  if (key === this.scenes[i]) {
                    return key;
                  }
                }
              }
              return null;
            },
            isActive: function(key) {
              var scene = this.getScene(key);
              if (scene) {
                return scene.sys.isActive();
              }
              return null;
            },
            isPaused: function(key) {
              var scene = this.getScene(key);
              if (scene) {
                return scene.sys.isPaused();
              }
              return null;
            },
            isVisible: function(key) {
              var scene = this.getScene(key);
              if (scene) {
                return scene.sys.isVisible();
              }
              return null;
            },
            isSleeping: function(key) {
              var scene = this.getScene(key);
              if (scene) {
                return scene.sys.isSleeping();
              }
              return null;
            },
            pause: function(key, data) {
              var scene = this.getScene(key);
              if (scene) {
                scene.sys.pause(data);
              }
              return this;
            },
            resume: function(key, data) {
              var scene = this.getScene(key);
              if (scene) {
                scene.sys.resume(data);
              }
              return this;
            },
            sleep: function(key, data) {
              var scene = this.getScene(key);
              if (scene && !scene.sys.isTransitioning()) {
                scene.sys.sleep(data);
              }
              return this;
            },
            wake: function(key, data) {
              var scene = this.getScene(key);
              if (scene) {
                scene.sys.wake(data);
              }
              return this;
            },
            run: function(key, data) {
              var scene = this.getScene(key);
              if (!scene) {
                for (var i = 0; i < this._pending.length; i++) {
                  if (this._pending[i].key === key) {
                    this.queueOp("start", key, data);
                    break;
                  }
                }
                return this;
              }
              if (scene.sys.isSleeping()) {
                scene.sys.wake(data);
              } else if (scene.sys.isPaused()) {
                scene.sys.resume(data);
              } else {
                this.start(key, data);
              }
            },
            start: function(key, data) {
              if (!this.isBooted) {
                this._data[key] = {
                  autoStart: true,
                  data
                };
                return this;
              }
              var scene = this.getScene(key);
              if (scene) {
                var sys = scene.sys;
                if (sys.isActive() || sys.isPaused()) {
                  sys.shutdown();
                  sys.sceneUpdate = NOOP;
                  sys.start(data);
                } else {
                  sys.sceneUpdate = NOOP;
                  sys.start(data);
                  var loader;
                  if (sys.load) {
                    loader = sys.load;
                  }
                  if (loader && sys.settings.hasOwnProperty("pack")) {
                    loader.reset();
                    if (loader.addPack({payload: sys.settings.pack})) {
                      sys.settings.status = CONST.LOADING;
                      loader.once(LoaderEvents.COMPLETE, this.payloadComplete, this);
                      loader.start();
                      return this;
                    }
                  }
                }
                this.bootScene(scene);
              }
              return this;
            },
            stop: function(key, data) {
              var scene = this.getScene(key);
              if (scene && !scene.sys.isTransitioning()) {
                scene.sys.shutdown(data);
              }
              return this;
            },
            switch: function(from, to) {
              var sceneA = this.getScene(from);
              var sceneB = this.getScene(to);
              if (sceneA && sceneB && sceneA !== sceneB) {
                this.sleep(from);
                if (this.isSleeping(to)) {
                  this.wake(to);
                } else {
                  this.start(to);
                }
              }
              return this;
            },
            getAt: function(index) {
              return this.scenes[index];
            },
            getIndex: function(key) {
              var scene = this.getScene(key);
              return this.scenes.indexOf(scene);
            },
            bringToTop: function(key) {
              if (this.isProcessing) {
                this._queue.push({op: "bringToTop", keyA: key, keyB: null});
              } else {
                var index = this.getIndex(key);
                if (index !== -1 && index < this.scenes.length) {
                  var scene = this.getScene(key);
                  this.scenes.splice(index, 1);
                  this.scenes.push(scene);
                }
              }
              return this;
            },
            sendToBack: function(key) {
              if (this.isProcessing) {
                this._queue.push({op: "sendToBack", keyA: key, keyB: null});
              } else {
                var index = this.getIndex(key);
                if (index !== -1 && index > 0) {
                  var scene = this.getScene(key);
                  this.scenes.splice(index, 1);
                  this.scenes.unshift(scene);
                }
              }
              return this;
            },
            moveDown: function(key) {
              if (this.isProcessing) {
                this._queue.push({op: "moveDown", keyA: key, keyB: null});
              } else {
                var indexA = this.getIndex(key);
                if (indexA > 0) {
                  var indexB = indexA - 1;
                  var sceneA = this.getScene(key);
                  var sceneB = this.getAt(indexB);
                  this.scenes[indexA] = sceneB;
                  this.scenes[indexB] = sceneA;
                }
              }
              return this;
            },
            moveUp: function(key) {
              if (this.isProcessing) {
                this._queue.push({op: "moveUp", keyA: key, keyB: null});
              } else {
                var indexA = this.getIndex(key);
                if (indexA < this.scenes.length - 1) {
                  var indexB = indexA + 1;
                  var sceneA = this.getScene(key);
                  var sceneB = this.getAt(indexB);
                  this.scenes[indexA] = sceneB;
                  this.scenes[indexB] = sceneA;
                }
              }
              return this;
            },
            moveAbove: function(keyA, keyB) {
              if (keyA === keyB) {
                return this;
              }
              if (this.isProcessing) {
                this._queue.push({op: "moveAbove", keyA, keyB});
              } else {
                var indexA = this.getIndex(keyA);
                var indexB = this.getIndex(keyB);
                if (indexA !== -1 && indexB !== -1) {
                  var tempScene = this.getAt(indexB);
                  this.scenes.splice(indexB, 1);
                  this.scenes.splice(indexA + 1, 0, tempScene);
                }
              }
              return this;
            },
            moveBelow: function(keyA, keyB) {
              if (keyA === keyB) {
                return this;
              }
              if (this.isProcessing) {
                this._queue.push({op: "moveBelow", keyA, keyB});
              } else {
                var indexA = this.getIndex(keyA);
                var indexB = this.getIndex(keyB);
                if (indexA !== -1 && indexB !== -1) {
                  var tempScene = this.getAt(indexB);
                  this.scenes.splice(indexB, 1);
                  if (indexA === 0) {
                    this.scenes.unshift(tempScene);
                  } else {
                    this.scenes.splice(indexA, 0, tempScene);
                  }
                }
              }
              return this;
            },
            queueOp: function(op, keyA, keyB) {
              this._queue.push({op, keyA, keyB});
              return this;
            },
            swapPosition: function(keyA, keyB) {
              if (keyA === keyB) {
                return this;
              }
              if (this.isProcessing) {
                this._queue.push({op: "swapPosition", keyA, keyB});
              } else {
                var indexA = this.getIndex(keyA);
                var indexB = this.getIndex(keyB);
                if (indexA !== indexB && indexA !== -1 && indexB !== -1) {
                  var tempScene = this.getAt(indexA);
                  this.scenes[indexA] = this.scenes[indexB];
                  this.scenes[indexB] = tempScene;
                }
              }
              return this;
            },
            dump: function() {
              var out = [];
              var map = ["pending", "init", "start", "loading", "creating", "running", "paused", "sleeping", "shutdown", "destroyed"];
              for (var i = 0; i < this.scenes.length; i++) {
                var sys = this.scenes[i].sys;
                var key = sys.settings.visible && (sys.settings.status === CONST.RUNNING || sys.settings.status === CONST.PAUSED) ? "[*] " : "[-] ";
                key += sys.settings.key + " (" + map[sys.settings.status] + ")";
                out.push(key);
              }
              console.log(out.join("\n"));
            },
            destroy: function() {
              for (var i = 0; i < this.scenes.length; i++) {
                var sys = this.scenes[i].sys;
                sys.destroy();
              }
              this.update = NOOP;
              this.scenes = [];
              this._pending = [];
              this._start = [];
              this._queue = [];
              this.game = null;
            }
          });
          module2.exports = SceneManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Systems = __webpack_require__(201);
          var Scene = new Class({
            initialize: function Scene2(config2) {
              this.sys = new Systems(this, config2);
              this.game;
              this.anims;
              this.cache;
              this.registry;
              this.sound;
              this.textures;
              this.events;
              this.cameras;
              this.add;
              this.make;
              this.scene;
              this.children;
              this.lights;
              this.data;
              this.input;
              this.load;
              this.time;
              this.tweens;
              this.physics;
              this.matter;
              if (false) {
              }
              this.scale;
              this.plugins;
              this.renderer;
            },
            update: function() {
            }
          });
          module2.exports = Scene;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetFastValue = __webpack_require__(2);
          var UppercaseFirst = __webpack_require__(202);
          var GetPhysicsPlugins = function(sys) {
            var defaultSystem = sys.game.config.defaultPhysicsSystem;
            var sceneSystems = GetFastValue(sys.settings, "physics", false);
            if (!defaultSystem && !sceneSystems) {
              return;
            }
            var output = [];
            if (defaultSystem) {
              output.push(UppercaseFirst(defaultSystem + "Physics"));
            }
            if (sceneSystems) {
              for (var key in sceneSystems) {
                key = UppercaseFirst(key.concat("Physics"));
                if (output.indexOf(key) === -1) {
                  output.push(key);
                }
              }
            }
            return output;
          };
          module2.exports = GetPhysicsPlugins;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetFastValue = __webpack_require__(2);
          var GetScenePlugins = function(sys) {
            var defaultPlugins = sys.plugins.getDefaultScenePlugins();
            var scenePlugins = GetFastValue(sys.settings, "plugins", false);
            if (Array.isArray(scenePlugins)) {
              return scenePlugins;
            } else if (defaultPlugins) {
              return defaultPlugins;
            } else {
              return [];
            }
          };
          module2.exports = GetScenePlugins;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(142);
          var GetValue = __webpack_require__(6);
          var Merge = __webpack_require__(143);
          var InjectionMap = __webpack_require__(974);
          var Settings = {
            create: function(config2) {
              if (typeof config2 === "string") {
                config2 = {key: config2};
              } else if (config2 === void 0) {
                config2 = {};
              }
              return {
                status: CONST.PENDING,
                key: GetValue(config2, "key", ""),
                active: GetValue(config2, "active", false),
                visible: GetValue(config2, "visible", true),
                isBooted: false,
                isTransition: false,
                transitionFrom: null,
                transitionDuration: 0,
                transitionAllowInput: true,
                data: {},
                pack: GetValue(config2, "pack", false),
                cameras: GetValue(config2, "cameras", null),
                map: GetValue(config2, "map", Merge(InjectionMap, GetValue(config2, "mapAdd", {}))),
                physics: GetValue(config2, "physics", {}),
                loader: GetValue(config2, "loader", {}),
                plugins: GetValue(config2, "plugins", false),
                input: GetValue(config2, "input", {})
              };
            }
          };
          module2.exports = Settings;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CanvasPool = __webpack_require__(31);
          var CanvasTexture = __webpack_require__(417);
          var Class = __webpack_require__(0);
          var Color = __webpack_require__(37);
          var CONST = __webpack_require__(32);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(103);
          var GameEvents = __webpack_require__(22);
          var GenerateTexture = __webpack_require__(382);
          var GetValue = __webpack_require__(6);
          var Parser = __webpack_require__(419);
          var Texture = __webpack_require__(203);
          var TextureManager = new Class({
            Extends: EventEmitter,
            initialize: function TextureManager2(game) {
              EventEmitter.call(this);
              this.game = game;
              this.name = "TextureManager";
              this.list = {};
              this._tempCanvas = CanvasPool.create2D(this, 1, 1);
              this._tempContext = this._tempCanvas.getContext("2d");
              this._pending = 0;
              game.events.once(GameEvents.BOOT, this.boot, this);
            },
            boot: function() {
              this.on(Events.LOAD, this.updatePending, this);
              this.on(Events.ERROR, this.updatePending, this);
              var config2 = this.game.config;
              this.addBase64("__DEFAULT", config2.defaultImage);
              this.addBase64("__MISSING", config2.missingImage);
              this.addBase64("__WHITE", config2.whiteImage);
              this._pending = 3;
              this.game.events.once(GameEvents.DESTROY, this.destroy, this);
            },
            updatePending: function() {
              this._pending--;
              if (this._pending === 0) {
                this.off(Events.LOAD);
                this.off(Events.ERROR);
                this.emit(Events.READY);
              }
            },
            checkKey: function(key) {
              if (this.exists(key)) {
                console.error("Texture key already in use: " + key);
                return false;
              }
              return true;
            },
            remove: function(key) {
              if (typeof key === "string") {
                if (this.exists(key)) {
                  key = this.get(key);
                } else {
                  console.warn("No texture found matching key: " + key);
                  return this;
                }
              }
              if (this.list.hasOwnProperty(key.key)) {
                key.destroy();
                this.emit(Events.REMOVE, key.key);
              }
              return this;
            },
            removeKey: function(key) {
              if (this.list.hasOwnProperty(key)) {
                delete this.list[key];
              }
              return this;
            },
            addBase64: function(key, data) {
              if (this.checkKey(key)) {
                var _this = this;
                var image = new Image();
                image.onerror = function() {
                  _this.emit(Events.ERROR, key);
                };
                image.onload = function() {
                  var texture = _this.create(key, image);
                  Parser.Image(texture, 0);
                  _this.emit(Events.ADD, key, texture);
                  _this.emit(Events.LOAD, key, texture);
                };
                image.src = data;
              }
              return this;
            },
            getBase64: function(key, frame, type, encoderOptions) {
              if (type === void 0) {
                type = "image/png";
              }
              if (encoderOptions === void 0) {
                encoderOptions = 0.92;
              }
              var data = "";
              var textureFrame = this.getFrame(key, frame);
              if (textureFrame && (textureFrame.source.isRenderTexture || textureFrame.source.isGLTexture)) {
                console.warn("Cannot getBase64 from WebGL Texture");
              } else if (textureFrame) {
                var cd = textureFrame.canvasData;
                var canvas = CanvasPool.create2D(this, cd.width, cd.height);
                var ctx = canvas.getContext("2d");
                ctx.drawImage(textureFrame.source.image, cd.x, cd.y, cd.width, cd.height, 0, 0, cd.width, cd.height);
                data = canvas.toDataURL(type, encoderOptions);
                CanvasPool.remove(canvas);
              }
              return data;
            },
            addImage: function(key, source, dataSource) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = this.create(key, source);
                Parser.Image(texture, 0);
                if (dataSource) {
                  texture.setDataSource(dataSource);
                }
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addGLTexture: function(key, glTexture, width, height) {
              var texture = null;
              if (this.checkKey(key)) {
                if (width === void 0) {
                  width = glTexture.width;
                }
                if (height === void 0) {
                  height = glTexture.height;
                }
                texture = this.create(key, glTexture, width, height);
                texture.add("__BASE", 0, 0, 0, width, height);
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addRenderTexture: function(key, renderTexture) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = this.create(key, renderTexture);
                texture.add("__BASE", 0, 0, 0, renderTexture.width, renderTexture.height);
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            generate: function(key, config2) {
              if (this.checkKey(key)) {
                var canvas = CanvasPool.create(this, 1, 1);
                config2.canvas = canvas;
                GenerateTexture(config2);
                return this.addCanvas(key, canvas);
              } else {
                return null;
              }
            },
            createCanvas: function(key, width, height) {
              if (width === void 0) {
                width = 256;
              }
              if (height === void 0) {
                height = 256;
              }
              if (this.checkKey(key)) {
                var canvas = CanvasPool.create(this, width, height, CONST.CANVAS, true);
                return this.addCanvas(key, canvas);
              }
              return null;
            },
            addCanvas: function(key, source, skipCache) {
              if (skipCache === void 0) {
                skipCache = false;
              }
              var texture = null;
              if (skipCache) {
                texture = new CanvasTexture(this, key, source, source.width, source.height);
              } else if (this.checkKey(key)) {
                texture = new CanvasTexture(this, key, source, source.width, source.height);
                this.list[key] = texture;
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addAtlas: function(key, source, data, dataSource) {
              if (Array.isArray(data.textures) || Array.isArray(data.frames)) {
                return this.addAtlasJSONArray(key, source, data, dataSource);
              } else {
                return this.addAtlasJSONHash(key, source, data, dataSource);
              }
            },
            addAtlasJSONArray: function(key, source, data, dataSource) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = this.create(key, source);
                if (Array.isArray(data)) {
                  var singleAtlasFile = data.length === 1;
                  for (var i = 0; i < texture.source.length; i++) {
                    var atlasData = singleAtlasFile ? data[0] : data[i];
                    Parser.JSONArray(texture, i, atlasData);
                  }
                } else {
                  Parser.JSONArray(texture, 0, data);
                }
                if (dataSource) {
                  texture.setDataSource(dataSource);
                }
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addAtlasJSONHash: function(key, source, data, dataSource) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = this.create(key, source);
                if (Array.isArray(data)) {
                  for (var i = 0; i < data.length; i++) {
                    Parser.JSONHash(texture, i, data[i]);
                  }
                } else {
                  Parser.JSONHash(texture, 0, data);
                }
                if (dataSource) {
                  texture.setDataSource(dataSource);
                }
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addAtlasXML: function(key, source, data, dataSource) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = this.create(key, source);
                Parser.AtlasXML(texture, 0, data);
                if (dataSource) {
                  texture.setDataSource(dataSource);
                }
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addUnityAtlas: function(key, source, data, dataSource) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = this.create(key, source);
                Parser.UnityYAML(texture, 0, data);
                if (dataSource) {
                  texture.setDataSource(dataSource);
                }
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addSpriteSheet: function(key, source, config2) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = this.create(key, source);
                var width = texture.source[0].width;
                var height = texture.source[0].height;
                Parser.SpriteSheet(texture, 0, 0, 0, width, height, config2);
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addSpriteSheetFromAtlas: function(key, config2) {
              if (!this.checkKey(key)) {
                return null;
              }
              var atlasKey = GetValue(config2, "atlas", null);
              var atlasFrame = GetValue(config2, "frame", null);
              if (!atlasKey || !atlasFrame) {
                return;
              }
              var atlas = this.get(atlasKey);
              var sheet = atlas.get(atlasFrame);
              if (sheet) {
                var texture = this.create(key, sheet.source.image);
                if (sheet.trimmed) {
                  Parser.SpriteSheetFromAtlas(texture, sheet, config2);
                } else {
                  Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config2);
                }
                this.emit(Events.ADD, key, texture);
                return texture;
              }
            },
            create: function(key, source, width, height) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = new Texture(this, key, source, width, height);
                this.list[key] = texture;
              }
              return texture;
            },
            exists: function(key) {
              return this.list.hasOwnProperty(key);
            },
            get: function(key) {
              if (key === void 0) {
                key = "__DEFAULT";
              }
              if (this.list[key]) {
                return this.list[key];
              } else if (key instanceof Texture) {
                return key;
              } else {
                return this.list["__MISSING"];
              }
            },
            cloneFrame: function(key, frame) {
              if (this.list[key]) {
                return this.list[key].get(frame).clone();
              }
            },
            getFrame: function(key, frame) {
              if (this.list[key]) {
                return this.list[key].get(frame);
              }
            },
            getTextureKeys: function() {
              var output = [];
              for (var key in this.list) {
                if (key !== "__DEFAULT" && key !== "__MISSING") {
                  output.push(key);
                }
              }
              return output;
            },
            getPixel: function(x, y, key, frame) {
              var textureFrame = this.getFrame(key, frame);
              if (textureFrame) {
                x -= textureFrame.x;
                y -= textureFrame.y;
                var data = textureFrame.data.cut;
                x += data.x;
                y += data.y;
                if (x >= data.x && x < data.r && y >= data.y && y < data.b) {
                  var ctx = this._tempContext;
                  ctx.clearRect(0, 0, 1, 1);
                  ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);
                  var rgb = ctx.getImageData(0, 0, 1, 1);
                  return new Color(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
                }
              }
              return null;
            },
            getPixelAlpha: function(x, y, key, frame) {
              var textureFrame = this.getFrame(key, frame);
              if (textureFrame) {
                x -= textureFrame.x;
                y -= textureFrame.y;
                var data = textureFrame.data.cut;
                x += data.x;
                y += data.y;
                if (x >= data.x && x < data.r && y >= data.y && y < data.b) {
                  var ctx = this._tempContext;
                  ctx.clearRect(0, 0, 1, 1);
                  ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);
                  var rgb = ctx.getImageData(0, 0, 1, 1);
                  return rgb.data[3];
                }
              }
              return null;
            },
            setTexture: function(gameObject, key, frame) {
              if (this.list[key]) {
                gameObject.texture = this.list[key];
                gameObject.frame = gameObject.texture.get(frame);
              }
              return gameObject;
            },
            renameTexture: function(currentKey, newKey) {
              var texture = this.get(currentKey);
              if (texture && currentKey !== newKey) {
                texture.key = newKey;
                this.list[newKey] = texture;
                delete this.list[currentKey];
                return true;
              }
              return false;
            },
            each: function(callback, scope) {
              var args = [null];
              for (var i = 1; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (var texture in this.list) {
                args[0] = this.list[texture];
                callback.apply(scope, args);
              }
            },
            destroy: function() {
              for (var texture in this.list) {
                this.list[texture].destroy();
              }
              this.list = {};
              this.game = null;
              CanvasPool.remove(this._tempCanvas);
            }
          });
          module2.exports = TextureManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Clamp = __webpack_require__(18);
          var Color = __webpack_require__(37);
          var CONST = __webpack_require__(32);
          var IsSizePowerOfTwo = __webpack_require__(136);
          var Texture = __webpack_require__(203);
          var CanvasTexture = new Class({
            Extends: Texture,
            initialize: function CanvasTexture2(manager, key, source, width, height) {
              Texture.call(this, manager, key, source, width, height);
              this.add("__BASE", 0, 0, 0, width, height);
              this._source = this.frames["__BASE"].source;
              this.canvas = this._source.image;
              this.context = this.canvas.getContext("2d");
              this.width = width;
              this.height = height;
              this.imageData = this.context.getImageData(0, 0, width, height);
              this.data = null;
              if (this.imageData) {
                this.data = this.imageData.data;
              }
              this.pixels = null;
              this.buffer;
              if (this.data) {
                if (this.imageData.data.buffer) {
                  this.buffer = this.imageData.data.buffer;
                  this.pixels = new Uint32Array(this.buffer);
                } else if (window.ArrayBuffer) {
                  this.buffer = new ArrayBuffer(this.imageData.data.length);
                  this.pixels = new Uint32Array(this.buffer);
                } else {
                  this.pixels = this.imageData.data;
                }
              }
            },
            update: function() {
              this.imageData = this.context.getImageData(0, 0, this.width, this.height);
              this.data = this.imageData.data;
              if (this.imageData.data.buffer) {
                this.buffer = this.imageData.data.buffer;
                this.pixels = new Uint32Array(this.buffer);
              } else if (window.ArrayBuffer) {
                this.buffer = new ArrayBuffer(this.imageData.data.length);
                this.pixels = new Uint32Array(this.buffer);
              } else {
                this.pixels = this.imageData.data;
              }
              if (this.manager.game.config.renderType === CONST.WEBGL) {
                this.refresh();
              }
              return this;
            },
            draw: function(x, y, source) {
              this.context.drawImage(source, x, y);
              return this.update();
            },
            drawFrame: function(key, frame, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              var textureFrame = this.manager.getFrame(key, frame);
              if (textureFrame) {
                var cd = textureFrame.canvasData;
                var width = textureFrame.cutWidth;
                var height = textureFrame.cutHeight;
                var res = textureFrame.source.resolution;
                this.context.drawImage(textureFrame.source.image, cd.x, cd.y, width, height, x, y, width / res, height / res);
                return this.update();
              } else {
                return this;
              }
            },
            setPixel: function(x, y, red, green, blue, alpha) {
              if (alpha === void 0) {
                alpha = 255;
              }
              x = Math.abs(Math.floor(x));
              y = Math.abs(Math.floor(y));
              var index = this.getIndex(x, y);
              if (index > -1) {
                var imageData = this.context.getImageData(x, y, 1, 1);
                imageData.data[0] = red;
                imageData.data[1] = green;
                imageData.data[2] = blue;
                imageData.data[3] = alpha;
                this.context.putImageData(imageData, x, y);
              }
              return this;
            },
            putData: function(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
              if (dirtyX === void 0) {
                dirtyX = 0;
              }
              if (dirtyY === void 0) {
                dirtyY = 0;
              }
              if (dirtyWidth === void 0) {
                dirtyWidth = imageData.width;
              }
              if (dirtyHeight === void 0) {
                dirtyHeight = imageData.height;
              }
              this.context.putImageData(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
              return this;
            },
            getData: function(x, y, width, height) {
              x = Clamp(Math.floor(x), 0, this.width - 1);
              y = Clamp(Math.floor(y), 0, this.height - 1);
              width = Clamp(width, 1, this.width - x);
              height = Clamp(height, 1, this.height - y);
              var imageData = this.context.getImageData(x, y, width, height);
              return imageData;
            },
            getPixel: function(x, y, out) {
              if (!out) {
                out = new Color();
              }
              var index = this.getIndex(x, y);
              if (index > -1) {
                var data = this.data;
                var r = data[index + 0];
                var g = data[index + 1];
                var b = data[index + 2];
                var a = data[index + 3];
                out.setTo(r, g, b, a);
              }
              return out;
            },
            getPixels: function(x, y, width, height) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = this.width;
              }
              if (height === void 0) {
                height = width;
              }
              x = Math.abs(Math.round(x));
              y = Math.abs(Math.round(y));
              var left = Clamp(x, 0, this.width);
              var right = Clamp(x + width, 0, this.width);
              var top = Clamp(y, 0, this.height);
              var bottom = Clamp(y + height, 0, this.height);
              var pixel = new Color();
              var out = [];
              for (var py = top; py < bottom; py++) {
                var row = [];
                for (var px = left; px < right; px++) {
                  pixel = this.getPixel(px, py, pixel);
                  row.push({x: px, y: py, color: pixel.color, alpha: pixel.alphaGL});
                }
                out.push(row);
              }
              return out;
            },
            getIndex: function(x, y) {
              x = Math.abs(Math.round(x));
              y = Math.abs(Math.round(y));
              if (x < this.width && y < this.height) {
                return (x + y * this.width) * 4;
              } else {
                return -1;
              }
            },
            refresh: function() {
              this._source.update();
              return this;
            },
            getCanvas: function() {
              return this.canvas;
            },
            getContext: function() {
              return this.context;
            },
            clear: function(x, y, width, height) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = this.width;
              }
              if (height === void 0) {
                height = this.height;
              }
              this.context.clearRect(x, y, width, height);
              return this.update();
            },
            setSize: function(width, height) {
              if (height === void 0) {
                height = width;
              }
              if (width !== this.width || height !== this.height) {
                this.canvas.width = width;
                this.canvas.height = height;
                this._source.width = width;
                this._source.height = height;
                this._source.isPowerOf2 = IsSizePowerOfTwo(width, height);
                this.frames["__BASE"].setSize(width, height, 0, 0);
                this.width = width;
                this.height = height;
                this.refresh();
              }
              return this;
            },
            destroy: function() {
              Texture.prototype.destroy.call(this);
              this._source = null;
              this.canvas = null;
              this.context = null;
              this.imageData = null;
              this.data = null;
              this.pixels = null;
              this.buffer = null;
            }
          });
          module2.exports = CanvasTexture;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CanvasPool = __webpack_require__(31);
          var Class = __webpack_require__(0);
          var IsSizePowerOfTwo = __webpack_require__(136);
          var ScaleModes = __webpack_require__(164);
          var TextureSource = new Class({
            initialize: function TextureSource2(texture, source, width, height, flipY) {
              if (flipY === void 0) {
                flipY = false;
              }
              var game = texture.manager.game;
              this.renderer = game.renderer;
              this.texture = texture;
              this.source = source;
              this.image = source;
              this.compressionAlgorithm = null;
              this.resolution = 1;
              this.width = width || source.naturalWidth || source.videoWidth || source.width || 0;
              this.height = height || source.naturalHeight || source.videoHeight || source.height || 0;
              this.scaleMode = ScaleModes.DEFAULT;
              this.isCanvas = source instanceof HTMLCanvasElement;
              this.isVideo = window.hasOwnProperty("HTMLVideoElement") && source instanceof HTMLVideoElement;
              this.isRenderTexture = source.type === "RenderTexture";
              this.isGLTexture = window.hasOwnProperty("WebGLTexture") && source instanceof WebGLTexture;
              this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);
              this.glTexture = null;
              this.glIndex = 0;
              this.glIndexCounter = -1;
              this.flipY = flipY;
              this.init(game);
            },
            init: function(game) {
              var renderer = this.renderer;
              if (renderer) {
                if (renderer.gl) {
                  if (this.isCanvas) {
                    this.glTexture = renderer.createCanvasTexture(this.image, false, this.flipY);
                  } else if (this.isVideo) {
                    this.glTexture = renderer.createVideoTexture(this.image, false, this.flipY);
                  } else if (this.isRenderTexture) {
                    this.image = this.source.canvas;
                    this.glTexture = renderer.createTextureFromSource(null, this.width, this.height, this.scaleMode);
                  } else if (this.isGLTexture) {
                    this.glTexture = this.source;
                  } else {
                    this.glTexture = renderer.createTextureFromSource(this.image, this.width, this.height, this.scaleMode);
                  }
                } else if (this.isRenderTexture) {
                  this.image = this.source.canvas;
                }
              }
              if (!game.config.antialias) {
                this.setFilter(1);
              }
            },
            setFilter: function(filterMode) {
              if (this.renderer.gl) {
                this.renderer.setTextureFilter(this.glTexture, filterMode);
              }
              this.scaleMode = filterMode;
            },
            setFlipY: function(value) {
              if (value === void 0) {
                value = true;
              }
              this.flipY = value;
              return this;
            },
            update: function() {
              var gl = this.renderer.gl;
              if (gl && this.isCanvas) {
                this.glTexture = this.renderer.updateCanvasTexture(this.image, this.glTexture, this.flipY);
              } else if (gl && this.isVideo) {
                this.glTexture = this.renderer.updateVideoTexture(this.image, this.glTexture, this.flipY);
              }
            },
            destroy: function() {
              if (this.glTexture) {
                this.renderer.deleteTexture(this.glTexture, false);
              }
              if (this.isCanvas) {
                CanvasPool.remove(this.image);
              }
              this.renderer = null;
              this.texture = null;
              this.source = null;
              this.image = null;
              this.glTexture = null;
            }
          });
          module2.exports = TextureSource;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            AtlasXML: __webpack_require__(975),
            Canvas: __webpack_require__(976),
            Image: __webpack_require__(977),
            JSONArray: __webpack_require__(978),
            JSONHash: __webpack_require__(979),
            SpriteSheet: __webpack_require__(980),
            SpriteSheetFromAtlas: __webpack_require__(981),
            UnityYAML: __webpack_require__(982)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var HTML5AudioSoundManager = __webpack_require__(421);
          var NoAudioSoundManager = __webpack_require__(424);
          var WebAudioSoundManager = __webpack_require__(426);
          var SoundManagerCreator = {
            create: function(game) {
              var audioConfig = game.config.audio;
              var deviceAudio = game.device.audio;
              if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
                return new NoAudioSoundManager(game);
              }
              if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
                return new WebAudioSoundManager(game);
              }
              return new HTML5AudioSoundManager(game);
            }
          };
          module2.exports = SoundManagerCreator;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BaseSoundManager = __webpack_require__(144);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(69);
          var HTML5AudioSound = __webpack_require__(423);
          var HTML5AudioSoundManager = new Class({
            Extends: BaseSoundManager,
            initialize: function HTML5AudioSoundManager2(game) {
              this.override = true;
              this.audioPlayDelay = 0.1;
              this.loopEndOffset = 0.05;
              this.onBlurPausedSounds = [];
              this.locked = "ontouchstart" in window;
              this.lockedActionsQueue = this.locked ? [] : null;
              this._mute = false;
              this._volume = 1;
              BaseSoundManager.call(this, game);
            },
            add: function(key, config2) {
              var sound = new HTML5AudioSound(this, key, config2);
              this.sounds.push(sound);
              return sound;
            },
            unlock: function() {
              this.locked = false;
              var _this = this;
              this.game.cache.audio.entries.each(function(key, tags) {
                for (var i = 0; i < tags.length; i++) {
                  if (tags[i].dataset.locked === "true") {
                    _this.locked = true;
                    return false;
                  }
                }
                return true;
              });
              if (!this.locked) {
                return;
              }
              var moved = false;
              var detectMove = function() {
                moved = true;
              };
              var unlock = function() {
                if (moved) {
                  moved = false;
                  return;
                }
                document.body.removeEventListener("touchmove", detectMove);
                document.body.removeEventListener("touchend", unlock);
                var lockedTags = [];
                _this.game.cache.audio.entries.each(function(key, tags) {
                  for (var i = 0; i < tags.length; i++) {
                    var tag = tags[i];
                    if (tag.dataset.locked === "true") {
                      lockedTags.push(tag);
                    }
                  }
                  return true;
                });
                if (lockedTags.length === 0) {
                  return;
                }
                var lastTag = lockedTags[lockedTags.length - 1];
                lastTag.oncanplaythrough = function() {
                  lastTag.oncanplaythrough = null;
                  lockedTags.forEach(function(tag) {
                    tag.dataset.locked = "false";
                  });
                  _this.unlocked = true;
                };
                lockedTags.forEach(function(tag) {
                  tag.load();
                });
              };
              this.once(Events.UNLOCKED, function() {
                this.forEachActiveSound(function(sound) {
                  if (sound.currentMarker === null && sound.duration === 0) {
                    sound.duration = sound.tags[0].duration;
                  }
                  sound.totalDuration = sound.tags[0].duration;
                });
                while (this.lockedActionsQueue.length) {
                  var lockedAction = this.lockedActionsQueue.shift();
                  if (lockedAction.sound[lockedAction.prop].apply) {
                    lockedAction.sound[lockedAction.prop].apply(lockedAction.sound, lockedAction.value || []);
                  } else {
                    lockedAction.sound[lockedAction.prop] = lockedAction.value;
                  }
                }
              }, this);
              document.body.addEventListener("touchmove", detectMove, false);
              document.body.addEventListener("touchend", unlock, false);
            },
            onBlur: function() {
              this.forEachActiveSound(function(sound) {
                if (sound.isPlaying) {
                  this.onBlurPausedSounds.push(sound);
                  sound.onBlur();
                }
              });
            },
            onFocus: function() {
              this.onBlurPausedSounds.forEach(function(sound) {
                sound.onFocus();
              });
              this.onBlurPausedSounds.length = 0;
            },
            destroy: function() {
              BaseSoundManager.prototype.destroy.call(this);
              this.onBlurPausedSounds.length = 0;
              this.onBlurPausedSounds = null;
            },
            isLocked: function(sound, prop, value) {
              if (sound.tags[0].dataset.locked === "true") {
                this.lockedActionsQueue.push({
                  sound,
                  prop,
                  value
                });
                return true;
              }
              return false;
            },
            setMute: function(value) {
              this.mute = value;
              return this;
            },
            mute: {
              get: function() {
                return this._mute;
              },
              set: function(value) {
                this._mute = value;
                this.forEachActiveSound(function(sound) {
                  sound.updateMute();
                });
                this.emit(Events.GLOBAL_MUTE, this, value);
              }
            },
            setVolume: function(value) {
              this.volume = value;
              return this;
            },
            volume: {
              get: function() {
                return this._volume;
              },
              set: function(value) {
                this._volume = value;
                this.forEachActiveSound(function(sound) {
                  sound.updateVolume();
                });
                this.emit(Events.GLOBAL_VOLUME, this, value);
              }
            }
          });
          module2.exports = HTML5AudioSoundManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SafeRange = __webpack_require__(78);
          var GetFirst = function(array, property, value, startIndex, endIndex) {
            if (startIndex === void 0) {
              startIndex = 0;
            }
            if (endIndex === void 0) {
              endIndex = array.length;
            }
            if (SafeRange(array, startIndex, endIndex)) {
              for (var i = startIndex; i < endIndex; i++) {
                var child = array[i];
                if (!property || property && value === void 0 && child.hasOwnProperty(property) || property && value !== void 0 && child[property] === value) {
                  return child;
                }
              }
            }
            return null;
          };
          module2.exports = GetFirst;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BaseSound = __webpack_require__(145);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(69);
          var Clamp = __webpack_require__(18);
          var HTML5AudioSound = new Class({
            Extends: BaseSound,
            initialize: function HTML5AudioSound2(manager, key, config2) {
              if (config2 === void 0) {
                config2 = {};
              }
              this.tags = manager.game.cache.audio.get(key);
              if (!this.tags) {
                throw new Error('There is no audio asset with key "' + key + '" in the audio cache');
              }
              this.audio = null;
              this.startTime = 0;
              this.previousTime = 0;
              this.duration = this.tags[0].duration;
              this.totalDuration = this.tags[0].duration;
              BaseSound.call(this, manager, key, config2);
            },
            play: function(markerName, config2) {
              if (this.manager.isLocked(this, "play", [markerName, config2])) {
                return false;
              }
              if (!BaseSound.prototype.play.call(this, markerName, config2)) {
                return false;
              }
              if (!this.pickAndPlayAudioTag()) {
                return false;
              }
              this.emit(Events.PLAY, this);
              return true;
            },
            pause: function() {
              if (this.manager.isLocked(this, "pause")) {
                return false;
              }
              if (this.startTime > 0) {
                return false;
              }
              if (!BaseSound.prototype.pause.call(this)) {
                return false;
              }
              this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
              this.stopAndReleaseAudioTag();
              this.emit(Events.PAUSE, this);
              return true;
            },
            resume: function() {
              if (this.manager.isLocked(this, "resume")) {
                return false;
              }
              if (this.startTime > 0) {
                return false;
              }
              if (!BaseSound.prototype.resume.call(this)) {
                return false;
              }
              if (!this.pickAndPlayAudioTag()) {
                return false;
              }
              this.emit(Events.RESUME, this);
              return true;
            },
            stop: function() {
              if (this.manager.isLocked(this, "stop")) {
                return false;
              }
              if (!BaseSound.prototype.stop.call(this)) {
                return false;
              }
              this.stopAndReleaseAudioTag();
              this.emit(Events.STOP, this);
              return true;
            },
            pickAndPlayAudioTag: function() {
              if (!this.pickAudioTag()) {
                this.reset();
                return false;
              }
              var seek = this.currentConfig.seek;
              var delay = this.currentConfig.delay;
              var offset = (this.currentMarker ? this.currentMarker.start : 0) + seek;
              this.previousTime = offset;
              this.audio.currentTime = offset;
              this.applyConfig();
              if (delay === 0) {
                this.startTime = 0;
                if (this.audio.paused) {
                  this.playCatchPromise();
                }
              } else {
                this.startTime = window.performance.now() + delay * 1e3;
                if (!this.audio.paused) {
                  this.audio.pause();
                }
              }
              this.resetConfig();
              return true;
            },
            pickAudioTag: function() {
              if (this.audio) {
                return true;
              }
              for (var i = 0; i < this.tags.length; i++) {
                var audio = this.tags[i];
                if (audio.dataset.used === "false") {
                  audio.dataset.used = "true";
                  this.audio = audio;
                  return true;
                }
              }
              if (!this.manager.override) {
                return false;
              }
              var otherSounds = [];
              this.manager.forEachActiveSound(function(sound) {
                if (sound.key === this.key && sound.audio) {
                  otherSounds.push(sound);
                }
              }, this);
              otherSounds.sort(function(a1, a2) {
                if (a1.loop === a2.loop) {
                  return a2.seek / a2.duration - a1.seek / a1.duration;
                }
                return a1.loop ? 1 : -1;
              });
              var selectedSound = otherSounds[0];
              this.audio = selectedSound.audio;
              selectedSound.reset();
              selectedSound.audio = null;
              selectedSound.startTime = 0;
              selectedSound.previousTime = 0;
              return true;
            },
            playCatchPromise: function() {
              var playPromise = this.audio.play();
              if (playPromise) {
                playPromise.catch(function(reason) {
                  console.warn(reason);
                });
              }
            },
            stopAndReleaseAudioTag: function() {
              this.startTime = 0;
              this.previousTime = 0;
              if (this.audio) {
                this.audio.pause();
                this.audio.dataset.used = "false";
                this.audio = null;
              }
            },
            reset: function() {
              BaseSound.prototype.stop.call(this);
            },
            onBlur: function() {
              this.isPlaying = false;
              this.isPaused = true;
              this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
              this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3);
              this.stopAndReleaseAudioTag();
            },
            onFocus: function() {
              this.isPlaying = true;
              this.isPaused = false;
              this.pickAndPlayAudioTag();
            },
            update: function(time) {
              if (!this.isPlaying) {
                return;
              }
              if (this.startTime > 0) {
                if (this.startTime < time - this.manager.audioPlayDelay) {
                  this.audio.currentTime += Math.max(0, time - this.startTime) / 1e3;
                  this.startTime = 0;
                  this.previousTime = this.audio.currentTime;
                  this.playCatchPromise();
                }
                return;
              }
              var startTime = this.currentMarker ? this.currentMarker.start : 0;
              var endTime = startTime + this.duration;
              var currentTime = this.audio.currentTime;
              if (this.currentConfig.loop) {
                if (currentTime >= endTime - this.manager.loopEndOffset) {
                  this.audio.currentTime = startTime + Math.max(0, currentTime - endTime);
                  currentTime = this.audio.currentTime;
                } else if (currentTime < startTime) {
                  this.audio.currentTime += startTime;
                  currentTime = this.audio.currentTime;
                }
                if (currentTime < this.previousTime) {
                  this.emit(Events.LOOPED, this);
                }
              } else if (currentTime >= endTime) {
                this.reset();
                this.stopAndReleaseAudioTag();
                this.emit(Events.COMPLETE, this);
                return;
              }
              this.previousTime = currentTime;
            },
            destroy: function() {
              BaseSound.prototype.destroy.call(this);
              this.tags = null;
              if (this.audio) {
                this.stopAndReleaseAudioTag();
              }
            },
            updateMute: function() {
              if (this.audio) {
                this.audio.muted = this.currentConfig.mute || this.manager.mute;
              }
            },
            updateVolume: function() {
              if (this.audio) {
                this.audio.volume = Clamp(this.currentConfig.volume * this.manager.volume, 0, 1);
              }
            },
            calculateRate: function() {
              BaseSound.prototype.calculateRate.call(this);
              if (this.audio) {
                this.audio.playbackRate = this.totalRate;
              }
            },
            mute: {
              get: function() {
                return this.currentConfig.mute;
              },
              set: function(value) {
                this.currentConfig.mute = value;
                if (this.manager.isLocked(this, "mute", value)) {
                  return;
                }
                this.updateMute();
                this.emit(Events.MUTE, this, value);
              }
            },
            setMute: function(value) {
              this.mute = value;
              return this;
            },
            volume: {
              get: function() {
                return this.currentConfig.volume;
              },
              set: function(value) {
                this.currentConfig.volume = value;
                if (this.manager.isLocked(this, "volume", value)) {
                  return;
                }
                this.updateVolume();
                this.emit(Events.VOLUME, this, value);
              }
            },
            setVolume: function(value) {
              this.volume = value;
              return this;
            },
            rate: {
              get: function() {
                return this.currentConfig.rate;
              },
              set: function(value) {
                this.currentConfig.rate = value;
                if (this.manager.isLocked(this, Events.RATE, value)) {
                  return;
                } else {
                  this.calculateRate();
                  this.emit(Events.RATE, this, value);
                }
              }
            },
            setRate: function(value) {
              this.rate = value;
              return this;
            },
            detune: {
              get: function() {
                return this.currentConfig.detune;
              },
              set: function(value) {
                this.currentConfig.detune = value;
                if (this.manager.isLocked(this, Events.DETUNE, value)) {
                  return;
                } else {
                  this.calculateRate();
                  this.emit(Events.DETUNE, this, value);
                }
              }
            },
            setDetune: function(value) {
              this.detune = value;
              return this;
            },
            seek: {
              get: function() {
                if (this.isPlaying) {
                  return this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
                } else if (this.isPaused) {
                  return this.currentConfig.seek;
                } else {
                  return 0;
                }
              },
              set: function(value) {
                if (this.manager.isLocked(this, "seek", value)) {
                  return;
                }
                if (this.startTime > 0) {
                  return;
                }
                if (this.isPlaying || this.isPaused) {
                  value = Math.min(Math.max(0, value), this.duration);
                  if (this.isPlaying) {
                    this.previousTime = value;
                    this.audio.currentTime = value;
                  } else if (this.isPaused) {
                    this.currentConfig.seek = value;
                  }
                  this.emit(Events.SEEK, this, value);
                }
              }
            },
            setSeek: function(value) {
              this.seek = value;
              return this;
            },
            loop: {
              get: function() {
                return this.currentConfig.loop;
              },
              set: function(value) {
                this.currentConfig.loop = value;
                if (this.manager.isLocked(this, "loop", value)) {
                  return;
                }
                if (this.audio) {
                  this.audio.loop = value;
                }
                this.emit(Events.LOOP, this, value);
              }
            },
            setLoop: function(value) {
              this.loop = value;
              return this;
            },
            pan: {
              get: function() {
                return this.currentConfig.pan;
              },
              set: function(value) {
                this.currentConfig.pan = value;
                this.emit(Events.PAN, this, value);
              }
            },
            setPan: function(value) {
              this.pan = value;
              return this;
            }
          });
          module2.exports = HTML5AudioSound;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BaseSoundManager = __webpack_require__(144);
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var NoAudioSound = __webpack_require__(425);
          var NOOP = __webpack_require__(1);
          var NoAudioSoundManager = new Class({
            Extends: EventEmitter,
            initialize: function NoAudioSoundManager2(game) {
              EventEmitter.call(this);
              this.game = game;
              this.sounds = [];
              this.mute = false;
              this.volume = 1;
              this.rate = 1;
              this.detune = 0;
              this.pauseOnBlur = true;
              this.locked = false;
            },
            add: function(key, config2) {
              var sound = new NoAudioSound(this, key, config2);
              this.sounds.push(sound);
              return sound;
            },
            addAudioSprite: function(key, config2) {
              var sound = this.add(key, config2);
              sound.spritemap = {};
              return sound;
            },
            play: function(key, extra) {
              return false;
            },
            playAudioSprite: function(key, spriteName, config2) {
              return false;
            },
            remove: function(sound) {
              return BaseSoundManager.prototype.remove.call(this, sound);
            },
            removeByKey: function(key) {
              return BaseSoundManager.prototype.removeByKey.call(this, key);
            },
            pauseAll: NOOP,
            resumeAll: NOOP,
            stopAll: NOOP,
            update: NOOP,
            setRate: NOOP,
            setDetune: NOOP,
            setMute: NOOP,
            setVolume: NOOP,
            forEachActiveSound: function(callbackfn, scope) {
              BaseSoundManager.prototype.forEachActiveSound.call(this, callbackfn, scope);
            },
            destroy: function() {
              BaseSoundManager.prototype.destroy.call(this);
            }
          });
          module2.exports = NoAudioSoundManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BaseSound = __webpack_require__(145);
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Extend = __webpack_require__(17);
          var returnFalse = function() {
            return false;
          };
          var returnNull = function() {
            return null;
          };
          var returnThis = function() {
            return this;
          };
          var NoAudioSound = new Class({
            Extends: EventEmitter,
            initialize: function NoAudioSound2(manager, key, config2) {
              if (config2 === void 0) {
                config2 = {};
              }
              EventEmitter.call(this);
              this.manager = manager;
              this.key = key;
              this.isPlaying = false;
              this.isPaused = false;
              this.totalRate = 1;
              this.duration = 0;
              this.totalDuration = 0;
              this.config = Extend({
                mute: false,
                volume: 1,
                rate: 1,
                detune: 0,
                seek: 0,
                loop: false,
                delay: 0,
                pan: 0
              }, config2);
              this.currentConfig = this.config;
              this.mute = false;
              this.volume = 1;
              this.rate = 1;
              this.detune = 0;
              this.seek = 0;
              this.loop = false;
              this.pan = 0;
              this.markers = {};
              this.currentMarker = null;
              this.pendingRemove = false;
            },
            addMarker: returnFalse,
            updateMarker: returnFalse,
            removeMarker: returnNull,
            play: returnFalse,
            pause: returnFalse,
            resume: returnFalse,
            stop: returnFalse,
            destroy: function() {
              BaseSound.prototype.destroy.call(this);
            },
            setMute: returnThis,
            setVolume: returnThis,
            setRate: returnThis,
            setDetune: returnThis,
            setSeek: returnThis,
            setLoop: returnThis,
            setPan: returnThis
          });
          module2.exports = NoAudioSound;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Base64ToArrayBuffer = __webpack_require__(427);
          var BaseSoundManager = __webpack_require__(144);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(69);
          var GameEvents = __webpack_require__(22);
          var WebAudioSound = __webpack_require__(428);
          var WebAudioSoundManager = new Class({
            Extends: BaseSoundManager,
            initialize: function WebAudioSoundManager2(game) {
              this.context = this.createAudioContext(game);
              this.masterMuteNode = this.context.createGain();
              this.masterVolumeNode = this.context.createGain();
              this.masterMuteNode.connect(this.masterVolumeNode);
              this.masterVolumeNode.connect(this.context.destination);
              this.destination = this.masterMuteNode;
              this.locked = this.context.state === "suspended" && ("ontouchstart" in window || "onclick" in window);
              BaseSoundManager.call(this, game);
              if (this.locked && game.isBooted) {
                this.unlock();
              } else {
                game.events.once(GameEvents.BOOT, this.unlock, this);
              }
            },
            createAudioContext: function(game) {
              var audioConfig = game.config.audio;
              if (audioConfig.context) {
                audioConfig.context.resume();
                return audioConfig.context;
              }
              return new AudioContext();
            },
            setAudioContext: function(context) {
              if (this.context) {
                this.context.close();
              }
              if (this.masterMuteNode) {
                this.masterMuteNode.disconnect();
              }
              if (this.masterVolumeNode) {
                this.masterVolumeNode.disconnect();
              }
              this.context = context;
              this.masterMuteNode = context.createGain();
              this.masterVolumeNode = context.createGain();
              this.masterMuteNode.connect(this.masterVolumeNode);
              this.masterVolumeNode.connect(context.destination);
              this.destination = this.masterMuteNode;
              return this;
            },
            add: function(key, config2) {
              var sound = new WebAudioSound(this, key, config2);
              this.sounds.push(sound);
              return sound;
            },
            decodeAudio: function(audioKey, audioData) {
              var audioFiles;
              if (!Array.isArray(audioKey)) {
                audioFiles = [{key: audioKey, data: audioData}];
              } else {
                audioFiles = audioKey;
              }
              var cache = this.game.cache.audio;
              var remaining = audioFiles.length;
              for (var i = 0; i < audioFiles.length; i++) {
                var entry = audioFiles[i];
                var key = entry.key;
                var data = entry.data;
                if (typeof data === "string") {
                  data = Base64ToArrayBuffer(data);
                }
                var success = function(key2, audioBuffer) {
                  cache.add(key2, audioBuffer);
                  this.emit(Events.DECODED, key2);
                  remaining--;
                  if (remaining === 0) {
                    this.emit(Events.DECODED_ALL);
                  }
                }.bind(this, key);
                var failure = function(key2, error) {
                  console.error("Error decoding audio: " + key2 + " - ", error ? error.message : "");
                  remaining--;
                  if (remaining === 0) {
                    this.emit(Events.DECODED_ALL);
                  }
                }.bind(this, key);
                this.context.decodeAudioData(data, success, failure);
              }
            },
            unlock: function() {
              var _this = this;
              var body = document.body;
              var unlockHandler = function unlockHandler2() {
                if (_this.context) {
                  _this.context.resume().then(function() {
                    body.removeEventListener("touchstart", unlockHandler2);
                    body.removeEventListener("touchend", unlockHandler2);
                    body.removeEventListener("click", unlockHandler2);
                    body.removeEventListener("keydown", unlockHandler2);
                    _this.unlocked = true;
                  }, function() {
                    body.removeEventListener("touchstart", unlockHandler2);
                    body.removeEventListener("touchend", unlockHandler2);
                    body.removeEventListener("click", unlockHandler2);
                    body.removeEventListener("keydown", unlockHandler2);
                  });
                }
              };
              if (body) {
                body.addEventListener("touchstart", unlockHandler, false);
                body.addEventListener("touchend", unlockHandler, false);
                body.addEventListener("click", unlockHandler, false);
                body.addEventListener("keydown", unlockHandler, false);
              }
            },
            onBlur: function() {
              if (!this.locked) {
                this.context.suspend();
              }
            },
            onFocus: function() {
              if (!this.locked) {
                this.context.resume();
              }
            },
            destroy: function() {
              this.destination = null;
              this.masterVolumeNode.disconnect();
              this.masterVolumeNode = null;
              this.masterMuteNode.disconnect();
              this.masterMuteNode = null;
              if (this.game.config.audio.context) {
                this.context.suspend();
              } else {
                var _this = this;
                this.context.close().then(function() {
                  _this.context = null;
                });
              }
              BaseSoundManager.prototype.destroy.call(this);
            },
            setMute: function(value) {
              this.mute = value;
              return this;
            },
            mute: {
              get: function() {
                return this.masterMuteNode.gain.value === 0;
              },
              set: function(value) {
                this.masterMuteNode.gain.setValueAtTime(value ? 0 : 1, 0);
                this.emit(Events.GLOBAL_MUTE, this, value);
              }
            },
            setVolume: function(value) {
              this.volume = value;
              return this;
            },
            volume: {
              get: function() {
                return this.masterVolumeNode.gain.value;
              },
              set: function(value) {
                this.masterVolumeNode.gain.setValueAtTime(value, 0);
                this.emit(Events.GLOBAL_VOLUME, this, value);
              }
            }
          });
          module2.exports = WebAudioSoundManager;
        },
        function(module2, exports2) {
          /**
           * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          var lookup = new Uint8Array(256);
          for (var i = 0; i < chars.length; i++) {
            lookup[chars.charCodeAt(i)] = i;
          }
          var Base64ToArrayBuffer = function(base64) {
            base64 = base64.substr(base64.indexOf(",") + 1);
            var len = base64.length;
            var bufferLength = len * 0.75;
            var p = 0;
            var encoded1;
            var encoded2;
            var encoded3;
            var encoded4;
            if (base64[len - 1] === "=") {
              bufferLength--;
              if (base64[len - 2] === "=") {
                bufferLength--;
              }
            }
            var arrayBuffer = new ArrayBuffer(bufferLength);
            var bytes = new Uint8Array(arrayBuffer);
            for (var i2 = 0; i2 < len; i2 += 4) {
              encoded1 = lookup[base64.charCodeAt(i2)];
              encoded2 = lookup[base64.charCodeAt(i2 + 1)];
              encoded3 = lookup[base64.charCodeAt(i2 + 2)];
              encoded4 = lookup[base64.charCodeAt(i2 + 3)];
              bytes[p++] = encoded1 << 2 | encoded2 >> 4;
              bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
              bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
            }
            return arrayBuffer;
          };
          module2.exports = Base64ToArrayBuffer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BaseSound = __webpack_require__(145);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(69);
          var WebAudioSound = new Class({
            Extends: BaseSound,
            initialize: function WebAudioSound2(manager, key, config2) {
              if (config2 === void 0) {
                config2 = {};
              }
              this.audioBuffer = manager.game.cache.audio.get(key);
              if (!this.audioBuffer) {
                throw new Error('Audio key "' + key + '" missing from cache');
              }
              this.source = null;
              this.loopSource = null;
              this.muteNode = manager.context.createGain();
              this.volumeNode = manager.context.createGain();
              this.pannerNode = null;
              this.playTime = 0;
              this.startTime = 0;
              this.loopTime = 0;
              this.rateUpdates = [];
              this.hasEnded = false;
              this.hasLooped = false;
              this.muteNode.connect(this.volumeNode);
              if (manager.context.createStereoPanner) {
                this.pannerNode = manager.context.createStereoPanner();
                this.volumeNode.connect(this.pannerNode);
                this.pannerNode.connect(manager.destination);
              } else {
                this.volumeNode.connect(manager.destination);
              }
              this.duration = this.audioBuffer.duration;
              this.totalDuration = this.audioBuffer.duration;
              BaseSound.call(this, manager, key, config2);
            },
            play: function(markerName, config2) {
              if (!BaseSound.prototype.play.call(this, markerName, config2)) {
                return false;
              }
              this.stopAndRemoveBufferSource();
              this.createAndStartBufferSource();
              this.emit(Events.PLAY, this);
              return true;
            },
            pause: function() {
              if (this.manager.context.currentTime < this.startTime) {
                return false;
              }
              if (!BaseSound.prototype.pause.call(this)) {
                return false;
              }
              this.currentConfig.seek = this.getCurrentTime();
              this.stopAndRemoveBufferSource();
              this.emit(Events.PAUSE, this);
              return true;
            },
            resume: function() {
              if (this.manager.context.currentTime < this.startTime) {
                return false;
              }
              if (!BaseSound.prototype.resume.call(this)) {
                return false;
              }
              this.createAndStartBufferSource();
              this.emit(Events.RESUME, this);
              return true;
            },
            stop: function() {
              if (!BaseSound.prototype.stop.call(this)) {
                return false;
              }
              this.stopAndRemoveBufferSource();
              this.emit(Events.STOP, this);
              return true;
            },
            createAndStartBufferSource: function() {
              var seek = this.currentConfig.seek;
              var delay = this.currentConfig.delay;
              var when = this.manager.context.currentTime + delay;
              var offset = (this.currentMarker ? this.currentMarker.start : 0) + seek;
              var duration = this.duration - seek;
              this.playTime = when - seek;
              this.startTime = when;
              this.source = this.createBufferSource();
              this.applyConfig();
              this.source.start(Math.max(0, when), Math.max(0, offset), Math.max(0, duration));
              this.resetConfig();
            },
            createAndStartLoopBufferSource: function() {
              var when = this.getLoopTime();
              var offset = this.currentMarker ? this.currentMarker.start : 0;
              var duration = this.duration;
              this.loopTime = when;
              this.loopSource = this.createBufferSource();
              this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0);
              this.loopSource.start(Math.max(0, when), Math.max(0, offset), Math.max(0, duration));
            },
            createBufferSource: function() {
              var _this = this;
              var source = this.manager.context.createBufferSource();
              source.buffer = this.audioBuffer;
              source.connect(this.muteNode);
              source.onended = function(ev) {
                if (ev.target === _this.source) {
                  if (_this.currentConfig.loop) {
                    _this.hasLooped = true;
                  } else {
                    _this.hasEnded = true;
                  }
                }
              };
              return source;
            },
            stopAndRemoveBufferSource: function() {
              if (this.source) {
                this.source.stop();
                this.source.disconnect();
                this.source = null;
              }
              this.playTime = 0;
              this.startTime = 0;
              this.stopAndRemoveLoopBufferSource();
            },
            stopAndRemoveLoopBufferSource: function() {
              if (this.loopSource) {
                this.loopSource.stop();
                this.loopSource.disconnect();
                this.loopSource = null;
              }
              this.loopTime = 0;
            },
            applyConfig: function() {
              this.rateUpdates.length = 0;
              this.rateUpdates.push({
                time: 0,
                rate: 1
              });
              BaseSound.prototype.applyConfig.call(this);
            },
            update: function() {
              if (this.hasEnded) {
                this.hasEnded = false;
                BaseSound.prototype.stop.call(this);
                this.stopAndRemoveBufferSource();
                this.emit(Events.COMPLETE, this);
              } else if (this.hasLooped) {
                this.hasLooped = false;
                this.source = this.loopSource;
                this.loopSource = null;
                this.playTime = this.startTime = this.loopTime;
                this.rateUpdates.length = 0;
                this.rateUpdates.push({
                  time: 0,
                  rate: this.totalRate
                });
                this.createAndStartLoopBufferSource();
                this.emit(Events.LOOPED, this);
              }
            },
            destroy: function() {
              BaseSound.prototype.destroy.call(this);
              this.audioBuffer = null;
              this.stopAndRemoveBufferSource();
              this.muteNode.disconnect();
              this.muteNode = null;
              this.volumeNode.disconnect();
              this.volumeNode = null;
              if (this.pannerNode) {
                this.pannerNode.disconnect();
                this.pannerNode = null;
              }
              this.rateUpdates.length = 0;
              this.rateUpdates = null;
            },
            calculateRate: function() {
              BaseSound.prototype.calculateRate.call(this);
              var now = this.manager.context.currentTime;
              if (this.source && typeof this.totalRate === "number") {
                this.source.playbackRate.setValueAtTime(this.totalRate, now);
              }
              if (this.isPlaying) {
                this.rateUpdates.push({
                  time: Math.max(this.startTime, now) - this.playTime,
                  rate: this.totalRate
                });
                if (this.loopSource) {
                  this.stopAndRemoveLoopBufferSource();
                  this.createAndStartLoopBufferSource();
                }
              }
            },
            getCurrentTime: function() {
              var currentTime = 0;
              for (var i = 0; i < this.rateUpdates.length; i++) {
                var nextTime = 0;
                if (i < this.rateUpdates.length - 1) {
                  nextTime = this.rateUpdates[i + 1].time;
                } else {
                  nextTime = this.manager.context.currentTime - this.playTime;
                }
                currentTime += (nextTime - this.rateUpdates[i].time) * this.rateUpdates[i].rate;
              }
              return currentTime;
            },
            getLoopTime: function() {
              var lastRateUpdateCurrentTime = 0;
              for (var i = 0; i < this.rateUpdates.length - 1; i++) {
                lastRateUpdateCurrentTime += (this.rateUpdates[i + 1].time - this.rateUpdates[i].time) * this.rateUpdates[i].rate;
              }
              var lastRateUpdate = this.rateUpdates[this.rateUpdates.length - 1];
              return this.playTime + lastRateUpdate.time + (this.duration - lastRateUpdateCurrentTime) / lastRateUpdate.rate;
            },
            rate: {
              get: function() {
                return this.currentConfig.rate;
              },
              set: function(value) {
                this.currentConfig.rate = value;
                this.calculateRate();
                this.emit(Events.RATE, this, value);
              }
            },
            setRate: function(value) {
              this.rate = value;
              return this;
            },
            detune: {
              get: function() {
                return this.currentConfig.detune;
              },
              set: function(value) {
                this.currentConfig.detune = value;
                this.calculateRate();
                this.emit(Events.DETUNE, this, value);
              }
            },
            setDetune: function(value) {
              this.detune = value;
              return this;
            },
            mute: {
              get: function() {
                return this.muteNode.gain.value === 0;
              },
              set: function(value) {
                this.currentConfig.mute = value;
                this.muteNode.gain.setValueAtTime(value ? 0 : 1, 0);
                this.emit(Events.MUTE, this, value);
              }
            },
            setMute: function(value) {
              this.mute = value;
              return this;
            },
            volume: {
              get: function() {
                return this.volumeNode.gain.value;
              },
              set: function(value) {
                this.currentConfig.volume = value;
                this.volumeNode.gain.setValueAtTime(value, 0);
                this.emit(Events.VOLUME, this, value);
              }
            },
            setVolume: function(value) {
              this.volume = value;
              return this;
            },
            seek: {
              get: function() {
                if (this.isPlaying) {
                  if (this.manager.context.currentTime < this.startTime) {
                    return this.startTime - this.playTime;
                  }
                  return this.getCurrentTime();
                } else if (this.isPaused) {
                  return this.currentConfig.seek;
                } else {
                  return 0;
                }
              },
              set: function(value) {
                if (this.manager.context.currentTime < this.startTime) {
                  return;
                }
                if (this.isPlaying || this.isPaused) {
                  value = Math.min(Math.max(0, value), this.duration);
                  this.currentConfig.seek = value;
                  if (this.isPlaying) {
                    this.stopAndRemoveBufferSource();
                    this.createAndStartBufferSource();
                  }
                  this.emit(Events.SEEK, this, value);
                }
              }
            },
            setSeek: function(value) {
              this.seek = value;
              return this;
            },
            loop: {
              get: function() {
                return this.currentConfig.loop;
              },
              set: function(value) {
                this.currentConfig.loop = value;
                if (this.isPlaying) {
                  this.stopAndRemoveLoopBufferSource();
                  if (value) {
                    this.createAndStartLoopBufferSource();
                  }
                }
                this.emit(Events.LOOP, this, value);
              }
            },
            setLoop: function(value) {
              this.loop = value;
              return this;
            },
            pan: {
              get: function() {
                if (this.pannerNode) {
                  return this.pannerNode.pan.value;
                } else {
                  return 0;
                }
              },
              set: function(value) {
                this.currentConfig.pan = value;
                if (this.pannerNode) {
                  this.pannerNode.pan.setValueAtTime(value, this.manager.context.currentTime);
                }
                this.emit(Events.PAN, this, value);
              }
            },
            setPan: function(value) {
              this.pan = value;
              return this;
            }
          });
          module2.exports = WebAudioSound;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TransposeMatrix = function(array) {
            var sourceRowCount = array.length;
            var sourceColCount = array[0].length;
            var result = new Array(sourceColCount);
            for (var i = 0; i < sourceColCount; i++) {
              result[i] = new Array(sourceRowCount);
              for (var j = sourceRowCount - 1; j > -1; j--) {
                result[i][j] = array[j][i];
              }
            }
            return result;
          };
          module2.exports = TransposeMatrix;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          function swap(arr, i, j) {
            var tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
          }
          function defaultCompare(a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
          }
          var QuickSelect = function(arr, k, left, right, compare) {
            if (left === void 0) {
              left = 0;
            }
            if (right === void 0) {
              right = arr.length - 1;
            }
            if (compare === void 0) {
              compare = defaultCompare;
            }
            while (right > left) {
              if (right - left > 600) {
                var n = right - left + 1;
                var m = k - left + 1;
                var z = Math.log(n);
                var s = 0.5 * Math.exp(2 * z / 3);
                var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                QuickSelect(arr, k, newLeft, newRight, compare);
              }
              var t = arr[k];
              var i = left;
              var j = right;
              swap(arr, left, k);
              if (compare(arr[right], t) > 0) {
                swap(arr, left, right);
              }
              while (i < j) {
                swap(arr, i, j);
                i++;
                j--;
                while (compare(arr[i], t) < 0) {
                  i++;
                }
                while (compare(arr[j], t) > 0) {
                  j--;
                }
              }
              if (compare(arr[left], t) === 0) {
                swap(arr, left, j);
              } else {
                j++;
                swap(arr, j, right);
              }
              if (j <= k) {
                left = j + 1;
              }
              if (k <= j) {
                right = j - 1;
              }
            }
          };
          module2.exports = QuickSelect;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetValue = __webpack_require__(6);
          var Shuffle = __webpack_require__(129);
          var BuildChunk = function(a, b, qty) {
            var out = [];
            for (var aIndex = 0; aIndex < a.length; aIndex++) {
              for (var bIndex = 0; bIndex < b.length; bIndex++) {
                for (var i = 0; i < qty; i++) {
                  out.push({a: a[aIndex], b: b[bIndex]});
                }
              }
            }
            return out;
          };
          var Range = function(a, b, options) {
            var max = GetValue(options, "max", 0);
            var qty = GetValue(options, "qty", 1);
            var random = GetValue(options, "random", false);
            var randomB = GetValue(options, "randomB", false);
            var repeat = GetValue(options, "repeat", 0);
            var yoyo = GetValue(options, "yoyo", false);
            var out = [];
            if (randomB) {
              Shuffle(b);
            }
            if (repeat === -1) {
              if (max === 0) {
                repeat = 0;
              } else {
                var total = a.length * b.length * qty;
                if (yoyo) {
                  total *= 2;
                }
                repeat = Math.ceil(max / total);
              }
            }
            for (var i = 0; i <= repeat; i++) {
              var chunk = BuildChunk(a, b, qty);
              if (random) {
                Shuffle(chunk);
              }
              out = out.concat(chunk);
              if (yoyo) {
                chunk.reverse();
                out = out.concat(chunk);
              }
            }
            if (max) {
              out.splice(max);
            }
            return out;
          };
          module2.exports = Range;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            PROCESS_QUEUE_ADD: __webpack_require__(1035),
            PROCESS_QUEUE_REMOVE: __webpack_require__(1036)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetAdvancedValue = __webpack_require__(13);
          var BuildGameObjectAnimation = function(sprite, config2) {
            var animConfig = GetAdvancedValue(config2, "anims", null);
            if (animConfig === null) {
              return sprite;
            }
            if (typeof animConfig === "string") {
              sprite.anims.play(animConfig);
            } else if (typeof animConfig === "object") {
              var anims = sprite.anims;
              var key = GetAdvancedValue(animConfig, "key", void 0);
              if (key) {
                var startFrame = GetAdvancedValue(animConfig, "startFrame", void 0);
                var delay = GetAdvancedValue(animConfig, "delay", 0);
                var repeat = GetAdvancedValue(animConfig, "repeat", 0);
                var repeatDelay = GetAdvancedValue(animConfig, "repeatDelay", 0);
                var yoyo = GetAdvancedValue(animConfig, "yoyo", false);
                var play = GetAdvancedValue(animConfig, "play", false);
                var delayedPlay = GetAdvancedValue(animConfig, "delayedPlay", 0);
                var playConfig = {
                  key,
                  delay,
                  repeat,
                  repeatDelay,
                  yoyo,
                  startFrame
                };
                if (play) {
                  anims.play(playConfig);
                } else if (delayedPlay > 0) {
                  anims.playAfterDelay(playConfig, delayedPlay);
                } else {
                  anims.load(playConfig);
                }
              }
            }
            return sprite;
          };
          module2.exports = BuildGameObjectAnimation;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Frame = __webpack_require__(106);
          var Bob = new Class({
            initialize: function Bob2(blitter, x, y, frame, visible) {
              this.parent = blitter;
              this.x = x;
              this.y = y;
              this.frame = frame;
              this.data = {};
              this.tint = 16777215;
              this._visible = visible;
              this._alpha = 1;
              this.flipX = false;
              this.flipY = false;
            },
            setFrame: function(frame) {
              if (frame === void 0) {
                this.frame = this.parent.frame;
              } else if (frame instanceof Frame && frame.texture === this.parent.texture) {
                this.frame = frame;
              } else {
                this.frame = this.parent.texture.get(frame);
              }
              return this;
            },
            resetFlip: function() {
              this.flipX = false;
              this.flipY = false;
              return this;
            },
            reset: function(x, y, frame) {
              this.x = x;
              this.y = y;
              this.flipX = false;
              this.flipY = false;
              this._alpha = 1;
              this._visible = true;
              this.parent.dirty = true;
              if (frame) {
                this.setFrame(frame);
              }
              return this;
            },
            setPosition: function(x, y) {
              this.x = x;
              this.y = y;
              return this;
            },
            setFlipX: function(value) {
              this.flipX = value;
              return this;
            },
            setFlipY: function(value) {
              this.flipY = value;
              return this;
            },
            setFlip: function(x, y) {
              this.flipX = x;
              this.flipY = y;
              return this;
            },
            setVisible: function(value) {
              this.visible = value;
              return this;
            },
            setAlpha: function(value) {
              this.alpha = value;
              return this;
            },
            setTint: function(value) {
              this.tint = value;
              return this;
            },
            destroy: function() {
              this.parent.dirty = true;
              this.parent.children.remove(this);
              this.parent = void 0;
              this.frame = void 0;
              this.data = void 0;
            },
            visible: {
              get: function() {
                return this._visible;
              },
              set: function(value) {
                this.parent.dirty |= this._visible !== value;
                this._visible = value;
              }
            },
            alpha: {
              get: function() {
                return this._alpha;
              },
              set: function(value) {
                this.parent.dirty |= this._alpha > 0 !== value > 0;
                this._alpha = value;
              }
            }
          });
          module2.exports = Bob;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rectangle = __webpack_require__(10);
          var Union = function(rectA, rectB, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            var x = Math.min(rectA.x, rectB.x);
            var y = Math.min(rectA.y, rectB.y);
            var w = Math.max(rectA.right, rectB.right) - x;
            var h = Math.max(rectA.bottom, rectB.bottom) - y;
            return out.setTo(x, y, w, h);
          };
          module2.exports = Union;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var DOMElementRender = __webpack_require__(1049);
          var GameObject = __webpack_require__(15);
          var IsPlainObject = __webpack_require__(7);
          var RemoveFromDOM = __webpack_require__(199);
          var SCENE_EVENTS = __webpack_require__(21);
          var Vector4 = __webpack_require__(138);
          var DOMElement = new Class({
            Extends: GameObject,
            Mixins: [
              Components.AlphaSingle,
              Components.BlendMode,
              Components.Depth,
              Components.Origin,
              Components.ScrollFactor,
              Components.Transform,
              Components.Visible,
              DOMElementRender
            ],
            initialize: function DOMElement2(scene, x, y, element, style, innerText) {
              GameObject.call(this, scene, "DOMElement");
              this.parent = scene.sys.game.domContainer;
              this.cache = scene.sys.cache.html;
              this.node;
              this.transformOnly = false;
              this.skewX = 0;
              this.skewY = 0;
              this.rotate3d = new Vector4();
              this.rotate3dAngle = "deg";
              this.width = 0;
              this.height = 0;
              this.displayWidth = 0;
              this.displayHeight = 0;
              this.handler = this.dispatchNativeEvent.bind(this);
              this.setPosition(x, y);
              if (typeof element === "string") {
                if (element[0] === "#") {
                  this.setElement(element.substr(1), style, innerText);
                } else {
                  this.createElement(element, style, innerText);
                }
              } else if (element) {
                this.setElement(element, style, innerText);
              }
              scene.sys.events.on(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);
              scene.sys.events.on(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);
            },
            addedToScene: function() {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function() {
              this.scene.sys.updateList.remove(this);
            },
            handleSceneEvent: function(sys) {
              var node = this.node;
              var style = node.style;
              if (node) {
                style.display = sys.settings.visible ? "block" : "none";
              }
            },
            setSkew: function(x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = x;
              }
              this.skewX = x;
              this.skewY = y;
              return this;
            },
            setPerspective: function(value) {
              this.parent.style.perspective = value + "px";
              return this;
            },
            perspective: {
              get: function() {
                return parseFloat(this.parent.style.perspective);
              },
              set: function(value) {
                this.parent.style.perspective = value + "px";
              }
            },
            addListener: function(events) {
              if (this.node) {
                events = events.split(" ");
                for (var i = 0; i < events.length; i++) {
                  this.node.addEventListener(events[i], this.handler, false);
                }
              }
              return this;
            },
            removeListener: function(events) {
              if (this.node) {
                events = events.split(" ");
                for (var i = 0; i < events.length; i++) {
                  this.node.removeEventListener(events[i], this.handler);
                }
              }
              return this;
            },
            dispatchNativeEvent: function(event) {
              this.emit(event.type, event);
            },
            createElement: function(tagName, style, innerText) {
              return this.setElement(document.createElement(tagName), style, innerText);
            },
            setElement: function(element, style, innerText) {
              this.removeElement();
              var target;
              if (typeof element === "string") {
                if (element[0] === "#") {
                  element = element.substr(1);
                }
                target = document.getElementById(element);
              } else if (typeof element === "object" && element.nodeType === 1) {
                target = element;
              }
              if (!target) {
                return this;
              }
              this.node = target;
              if (style && IsPlainObject(style)) {
                for (var key in style) {
                  target.style[key] = style[key];
                }
              } else if (typeof style === "string") {
                target.style = style;
              }
              target.style.zIndex = "0";
              target.style.display = "inline";
              target.style.position = "absolute";
              target.phaser = this;
              if (this.parent) {
                this.parent.appendChild(target);
              }
              if (innerText) {
                target.innerText = innerText;
              }
              return this.updateSize();
            },
            createFromCache: function(key, tagName) {
              var html = this.cache.get(key);
              if (html) {
                this.createFromHTML(html, tagName);
              }
              return this;
            },
            createFromHTML: function(html, tagName) {
              if (tagName === void 0) {
                tagName = "div";
              }
              this.removeElement();
              var element = document.createElement(tagName);
              this.node = element;
              element.style.zIndex = "0";
              element.style.display = "inline";
              element.style.position = "absolute";
              element.phaser = this;
              if (this.parent) {
                this.parent.appendChild(element);
              }
              element.innerHTML = html;
              return this.updateSize();
            },
            removeElement: function() {
              if (this.node) {
                RemoveFromDOM(this.node);
                this.node = null;
              }
              return this;
            },
            updateSize: function() {
              var node = this.node;
              var nodeBounds = node.getBoundingClientRect();
              this.width = node.clientWidth;
              this.height = node.clientHeight;
              this.displayWidth = nodeBounds.width || 0;
              this.displayHeight = nodeBounds.height || 0;
              return this;
            },
            getChildByProperty: function(property, value) {
              if (this.node) {
                var children = this.node.querySelectorAll("*");
                for (var i = 0; i < children.length; i++) {
                  if (children[i][property] === value) {
                    return children[i];
                  }
                }
              }
              return null;
            },
            getChildByID: function(id) {
              return this.getChildByProperty("id", id);
            },
            getChildByName: function(name) {
              return this.getChildByProperty("name", name);
            },
            setClassName: function(className) {
              if (this.node) {
                this.node.className = className;
                this.updateSize();
              }
              return this;
            },
            setText: function(text) {
              if (this.node) {
                this.node.innerText = text;
                this.updateSize();
              }
              return this;
            },
            setHTML: function(html) {
              if (this.node) {
                this.node.innerHTML = html;
                this.updateSize();
              }
              return this;
            },
            preUpdate: function() {
              var parent = this.parentContainer;
              var node = this.node;
              if (node && parent && !parent.willRender()) {
                node.style.display = "none";
              }
            },
            willRender: function() {
              return true;
            },
            preDestroy: function() {
              this.removeElement();
              this.scene.sys.events.off(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);
              this.scene.sys.events.off(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);
            }
          });
          module2.exports = DOMElement;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CSSBlendModes = __webpack_require__(1050);
          var GameObject = __webpack_require__(15);
          var TransformMatrix = __webpack_require__(25);
          var tempMatrix1 = new TransformMatrix();
          var tempMatrix2 = new TransformMatrix();
          var tempMatrix3 = new TransformMatrix();
          var DOMElementCSSRenderer = function(renderer, src, camera, parentMatrix) {
            var node = src.node;
            var style = node.style;
            var settings = src.scene.sys.settings;
            if (!node || !style || !settings.visible || GameObject.RENDER_MASK !== src.renderFlags || src.cameraFilter !== 0 && src.cameraFilter & camera.id || src.parentContainer && !src.parentContainer.willRender()) {
              if (node) {
                style.display = "none";
              }
              return;
            }
            var parent = src.parentContainer;
            var alpha = camera.alpha * src.alpha;
            if (parent) {
              alpha *= parent.alpha;
            }
            var camMatrix = tempMatrix1;
            var srcMatrix = tempMatrix2;
            var calcMatrix = tempMatrix3;
            var dx = 0;
            var dy = 0;
            var tx = "0%";
            var ty = "0%";
            if (parentMatrix) {
              dx = src.width * src.scaleX * src.originX;
              dy = src.height * src.scaleY * src.originY;
              srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);
              camMatrix.copyFrom(camera.matrix);
              camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
              srcMatrix.e = src.x - dx;
              srcMatrix.f = src.y - dy;
              camMatrix.multiply(srcMatrix, calcMatrix);
            } else {
              dx = src.width * src.originX;
              dy = src.height * src.originY;
              srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);
              camMatrix.copyFrom(camera.matrix);
              tx = 100 * src.originX + "%";
              ty = 100 * src.originY + "%";
              srcMatrix.e -= camera.scrollX * src.scrollFactorX;
              srcMatrix.f -= camera.scrollY * src.scrollFactorY;
              camMatrix.multiply(srcMatrix, calcMatrix);
            }
            if (!src.transformOnly) {
              style.display = "block";
              style.opacity = alpha;
              style.zIndex = src._depth;
              style.pointerEvents = "auto";
              style.mixBlendMode = CSSBlendModes[src._blendMode];
            }
            style.transform = calcMatrix.getCSSMatrix() + " skew(" + src.skewX + "rad, " + src.skewY + "rad) rotate3d(" + src.rotate3d.x + "," + src.rotate3d.y + "," + src.rotate3d.z + "," + src.rotate3d.w + src.rotate3dAngle + ")";
            style.transformOrigin = tx + " " + ty;
          };
          module2.exports = DOMElementCSSRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var ExternRender = __webpack_require__(1054);
          var Extern = new Class({
            Extends: GameObject,
            Mixins: [
              Components.Alpha,
              Components.BlendMode,
              Components.Depth,
              Components.Flip,
              Components.Origin,
              Components.ScrollFactor,
              Components.Size,
              Components.Texture,
              Components.Tint,
              Components.Transform,
              Components.Visible,
              ExternRender
            ],
            initialize: function Extern2(scene) {
              GameObject.call(this, scene, "Extern");
            },
            addedToScene: function() {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function() {
              this.scene.sys.updateList.remove(this);
            },
            preUpdate: function() {
            },
            render: function() {
            }
          });
          module2.exports = Extern;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CircumferencePoint = __webpack_require__(215);
          var FromPercent = __webpack_require__(95);
          var MATH_CONST = __webpack_require__(14);
          var Point = __webpack_require__(4);
          var GetPoint = function(ellipse, position, out) {
            if (out === void 0) {
              out = new Point();
            }
            var angle = FromPercent(position, 0, MATH_CONST.PI2);
            return CircumferencePoint(ellipse, angle, out);
          };
          module2.exports = GetPoint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Circumference = __webpack_require__(441);
          var CircumferencePoint = __webpack_require__(215);
          var FromPercent = __webpack_require__(95);
          var MATH_CONST = __webpack_require__(14);
          var GetPoints = function(ellipse, quantity, stepRate, out) {
            if (out === void 0) {
              out = [];
            }
            if (!quantity && stepRate > 0) {
              quantity = Circumference(ellipse) / stepRate;
            }
            for (var i = 0; i < quantity; i++) {
              var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);
              out.push(CircumferencePoint(ellipse, angle));
            }
            return out;
          };
          module2.exports = GetPoints;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Circumference = function(ellipse) {
            var rx = ellipse.width / 2;
            var ry = ellipse.height / 2;
            var h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
            return Math.PI * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));
          };
          module2.exports = Circumference;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Commands = __webpack_require__(214);
          var SetTransform = __webpack_require__(30);
          var GraphicsCanvasRenderer = function(renderer, src, camera, parentMatrix, renderTargetCtx, allowClip) {
            var commandBuffer = src.commandBuffer;
            var commandBufferLength = commandBuffer.length;
            var ctx = renderTargetCtx || renderer.currentContext;
            if (commandBufferLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              return;
            }
            camera.addToRenderList(src);
            var lineAlpha = 1;
            var fillAlpha = 1;
            var lineColor = 0;
            var fillColor = 0;
            var lineWidth = 1;
            var red = 0;
            var green = 0;
            var blue = 0;
            ctx.beginPath();
            for (var index = 0; index < commandBufferLength; ++index) {
              var commandID = commandBuffer[index];
              switch (commandID) {
                case Commands.ARC:
                  ctx.arc(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4], commandBuffer[index + 5], commandBuffer[index + 6]);
                  index += 7;
                  break;
                case Commands.LINE_STYLE:
                  lineWidth = commandBuffer[index + 1];
                  lineColor = commandBuffer[index + 2];
                  lineAlpha = commandBuffer[index + 3];
                  red = (lineColor & 16711680) >>> 16;
                  green = (lineColor & 65280) >>> 8;
                  blue = lineColor & 255;
                  ctx.strokeStyle = "rgba(" + red + "," + green + "," + blue + "," + lineAlpha + ")";
                  ctx.lineWidth = lineWidth;
                  index += 3;
                  break;
                case Commands.FILL_STYLE:
                  fillColor = commandBuffer[index + 1];
                  fillAlpha = commandBuffer[index + 2];
                  red = (fillColor & 16711680) >>> 16;
                  green = (fillColor & 65280) >>> 8;
                  blue = fillColor & 255;
                  ctx.fillStyle = "rgba(" + red + "," + green + "," + blue + "," + fillAlpha + ")";
                  index += 2;
                  break;
                case Commands.BEGIN_PATH:
                  ctx.beginPath();
                  break;
                case Commands.CLOSE_PATH:
                  ctx.closePath();
                  break;
                case Commands.FILL_PATH:
                  if (!allowClip) {
                    ctx.fill();
                  }
                  break;
                case Commands.STROKE_PATH:
                  if (!allowClip) {
                    ctx.stroke();
                  }
                  break;
                case Commands.FILL_RECT:
                  if (!allowClip) {
                    ctx.fillRect(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4]);
                  } else {
                    ctx.rect(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4]);
                  }
                  index += 4;
                  break;
                case Commands.FILL_TRIANGLE:
                  ctx.beginPath();
                  ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                  ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
                  ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
                  ctx.closePath();
                  if (!allowClip) {
                    ctx.fill();
                  }
                  index += 6;
                  break;
                case Commands.STROKE_TRIANGLE:
                  ctx.beginPath();
                  ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                  ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
                  ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
                  ctx.closePath();
                  if (!allowClip) {
                    ctx.stroke();
                  }
                  index += 6;
                  break;
                case Commands.LINE_TO:
                  ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                  index += 2;
                  break;
                case Commands.MOVE_TO:
                  ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                  index += 2;
                  break;
                case Commands.LINE_FX_TO:
                  ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                  index += 5;
                  break;
                case Commands.MOVE_FX_TO:
                  ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                  index += 5;
                  break;
                case Commands.SAVE:
                  ctx.save();
                  break;
                case Commands.RESTORE:
                  ctx.restore();
                  break;
                case Commands.TRANSLATE:
                  ctx.translate(commandBuffer[index + 1], commandBuffer[index + 2]);
                  index += 2;
                  break;
                case Commands.SCALE:
                  ctx.scale(commandBuffer[index + 1], commandBuffer[index + 2]);
                  index += 2;
                  break;
                case Commands.ROTATE:
                  ctx.rotate(commandBuffer[index + 1]);
                  index += 1;
                  break;
                case Commands.GRADIENT_FILL_STYLE:
                  index += 5;
                  break;
                case Commands.GRADIENT_LINE_STYLE:
                  index += 6;
                  break;
              }
            }
            ctx.restore();
          };
          module2.exports = GraphicsCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FloatBetween = __webpack_require__(135);
          var GetEaseFunction = __webpack_require__(80);
          var GetFastValue = __webpack_require__(2);
          var Wrap = __webpack_require__(66);
          var EmitterOp = new Class({
            initialize: function EmitterOp2(config2, key, defaultValue, emitOnly) {
              if (emitOnly === void 0) {
                emitOnly = false;
              }
              this.propertyKey = key;
              this.propertyValue = defaultValue;
              this.defaultValue = defaultValue;
              this.steps = 0;
              this.counter = 0;
              this.start = 0;
              this.end = 0;
              this.ease;
              this.emitOnly = emitOnly;
              this.onEmit = this.defaultEmit;
              this.onUpdate = this.defaultUpdate;
              this.loadConfig(config2);
            },
            loadConfig: function(config2, newKey) {
              if (config2 === void 0) {
                config2 = {};
              }
              if (newKey) {
                this.propertyKey = newKey;
              }
              this.propertyValue = GetFastValue(config2, this.propertyKey, this.defaultValue);
              this.setMethods();
              if (this.emitOnly) {
                this.onUpdate = this.defaultUpdate;
              }
            },
            toJSON: function() {
              return this.propertyValue;
            },
            onChange: function(value) {
              this.propertyValue = value;
              return this.setMethods();
            },
            setMethods: function() {
              var value = this.propertyValue;
              var t = typeof value;
              this.onEmit = this.defaultEmit;
              this.onUpdate = this.defaultUpdate;
              if (t === "number") {
                this.onEmit = this.staticValueEmit;
                this.onUpdate = this.staticValueUpdate;
              } else if (Array.isArray(value)) {
                this.onEmit = this.randomStaticValueEmit;
              } else if (t === "function") {
                if (this.emitOnly) {
                  this.onEmit = value;
                } else {
                  this.onUpdate = value;
                }
              } else if (t === "object" && this.hasBoth(value, "start", "end")) {
                this.start = value.start;
                this.end = value.end;
                var isRandom = this.has(value, "random");
                if (isRandom) {
                  this.onEmit = this.randomRangedValueEmit;
                }
                if (this.has(value, "steps")) {
                  this.steps = value.steps;
                  this.counter = this.start;
                  this.onEmit = this.steppedEmit;
                } else {
                  var easeType = this.has(value, "ease") ? value.ease : "Linear";
                  this.ease = GetEaseFunction(easeType, value.easeParams);
                  if (!isRandom) {
                    this.onEmit = this.easedValueEmit;
                  }
                  this.onUpdate = this.easeValueUpdate;
                }
              } else if (t === "object" && this.hasBoth(value, "min", "max")) {
                this.start = value.min;
                this.end = value.max;
                this.onEmit = this.randomRangedValueEmit;
              } else if (t === "object" && this.has(value, "random")) {
                var rnd = value.random;
                if (Array.isArray(rnd)) {
                  this.start = rnd[0];
                  this.end = rnd[1];
                }
                this.onEmit = this.randomRangedValueEmit;
              } else if (t === "object" && this.hasEither(value, "onEmit", "onUpdate")) {
                if (this.has(value, "onEmit")) {
                  this.onEmit = value.onEmit;
                }
                if (this.has(value, "onUpdate")) {
                  this.onUpdate = value.onUpdate;
                }
              }
              return this;
            },
            has: function(object, key) {
              return object.hasOwnProperty(key);
            },
            hasBoth: function(object, key1, key2) {
              return object.hasOwnProperty(key1) && object.hasOwnProperty(key2);
            },
            hasEither: function(object, key1, key2) {
              return object.hasOwnProperty(key1) || object.hasOwnProperty(key2);
            },
            defaultEmit: function(particle, key, value) {
              return value;
            },
            defaultUpdate: function(particle, key, t, value) {
              return value;
            },
            staticValueEmit: function() {
              return this.propertyValue;
            },
            staticValueUpdate: function() {
              return this.propertyValue;
            },
            randomStaticValueEmit: function() {
              var randomIndex = Math.floor(Math.random() * this.propertyValue.length);
              return this.propertyValue[randomIndex];
            },
            randomRangedValueEmit: function(particle, key) {
              var value = FloatBetween(this.start, this.end);
              if (particle && particle.data[key]) {
                particle.data[key].min = value;
              }
              return value;
            },
            steppedEmit: function() {
              var current = this.counter;
              var next = this.counter + (this.end - this.start) / this.steps;
              this.counter = Wrap(next, this.start, this.end);
              return current;
            },
            easedValueEmit: function(particle, key) {
              if (particle && particle.data[key]) {
                var data = particle.data[key];
                data.min = this.start;
                data.max = this.end;
              }
              return this.start;
            },
            easeValueUpdate: function(particle, key, t) {
              var data = particle.data[key];
              return (data.max - data.min) * this.ease(t) + data.min;
            }
          });
          module2.exports = EmitterOp;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var GravityWell = new Class({
            initialize: function GravityWell2(x, y, power, epsilon, gravity) {
              if (typeof x === "object") {
                var config2 = x;
                x = GetFastValue(config2, "x", 0);
                y = GetFastValue(config2, "y", 0);
                power = GetFastValue(config2, "power", 0);
                epsilon = GetFastValue(config2, "epsilon", 100);
                gravity = GetFastValue(config2, "gravity", 50);
              } else {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (power === void 0) {
                  power = 0;
                }
                if (epsilon === void 0) {
                  epsilon = 100;
                }
                if (gravity === void 0) {
                  gravity = 50;
                }
              }
              this.x = x;
              this.y = y;
              this.active = true;
              this._gravity = gravity;
              this._power = 0;
              this._epsilon = 0;
              this.power = power;
              this.epsilon = epsilon;
            },
            update: function(particle, delta) {
              var x = this.x - particle.x;
              var y = this.y - particle.y;
              var dSq = x * x + y * y;
              if (dSq === 0) {
                return;
              }
              var d = Math.sqrt(dSq);
              if (dSq < this._epsilon) {
                dSq = this._epsilon;
              }
              var factor = this._power * delta / (dSq * d) * 100;
              particle.velocityX += x * factor;
              particle.velocityY += y * factor;
            },
            epsilon: {
              get: function() {
                return Math.sqrt(this._epsilon);
              },
              set: function(value) {
                this._epsilon = value * value;
              }
            },
            power: {
              get: function() {
                return this._power / this._gravity;
              },
              set: function(value) {
                this._power = value * this._gravity;
              }
            },
            gravity: {
              get: function() {
                return this._gravity;
              },
              set: function(value) {
                var pwr = this.power;
                this._gravity = value;
                this.power = pwr;
              }
            }
          });
          module2.exports = GravityWell;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var DegToRad = __webpack_require__(35);
          var DistanceBetween = __webpack_require__(48);
          var Particle = new Class({
            initialize: function Particle2(emitter) {
              this.emitter = emitter;
              this.frame = null;
              this.x = 0;
              this.y = 0;
              this.velocityX = 0;
              this.velocityY = 0;
              this.accelerationX = 0;
              this.accelerationY = 0;
              this.maxVelocityX = 1e4;
              this.maxVelocityY = 1e4;
              this.bounce = 0;
              this.scaleX = 1;
              this.scaleY = 1;
              this.alpha = 1;
              this.angle = 0;
              this.rotation = 0;
              this.tint = 16777215;
              this.life = 1e3;
              this.lifeCurrent = 1e3;
              this.delayCurrent = 0;
              this.lifeT = 0;
              this.data = {
                tint: {min: 16777215, max: 16777215, current: 16777215},
                alpha: {min: 1, max: 1},
                rotate: {min: 0, max: 0},
                scaleX: {min: 1, max: 1},
                scaleY: {min: 1, max: 1}
              };
            },
            isAlive: function() {
              return this.lifeCurrent > 0;
            },
            resetPosition: function() {
              this.x = 0;
              this.y = 0;
            },
            fire: function(x, y) {
              var emitter = this.emitter;
              this.frame = emitter.getFrame();
              if (emitter.emitZone) {
                emitter.emitZone.getPoint(this);
              }
              if (x === void 0) {
                this.x += emitter.x.onEmit(this, "x");
              } else {
                this.x += x;
              }
              if (y === void 0) {
                this.y += emitter.y.onEmit(this, "y");
              } else {
                this.y += y;
              }
              this.life = emitter.lifespan.onEmit(this, "lifespan");
              this.lifeCurrent = this.life;
              this.lifeT = 0;
              var sx = emitter.speedX.onEmit(this, "speedX");
              var sy = emitter.speedY ? emitter.speedY.onEmit(this, "speedY") : sx;
              if (emitter.radial) {
                var rad = DegToRad(emitter.angle.onEmit(this, "angle"));
                this.velocityX = Math.cos(rad) * Math.abs(sx);
                this.velocityY = Math.sin(rad) * Math.abs(sy);
              } else if (emitter.moveTo) {
                var mx = emitter.moveToX.onEmit(this, "moveToX");
                var my = emitter.moveToY ? emitter.moveToY.onEmit(this, "moveToY") : mx;
                var angle = Math.atan2(my - this.y, mx - this.x);
                var speed = DistanceBetween(this.x, this.y, mx, my) / (this.life / 1e3);
                this.velocityX = Math.cos(angle) * speed;
                this.velocityY = Math.sin(angle) * speed;
              } else {
                this.velocityX = sx;
                this.velocityY = sy;
              }
              if (emitter.acceleration) {
                this.accelerationX = emitter.accelerationX.onEmit(this, "accelerationX");
                this.accelerationY = emitter.accelerationY.onEmit(this, "accelerationY");
              }
              this.maxVelocityX = emitter.maxVelocityX.onEmit(this, "maxVelocityX");
              this.maxVelocityY = emitter.maxVelocityY.onEmit(this, "maxVelocityY");
              this.delayCurrent = emitter.delay.onEmit(this, "delay");
              this.scaleX = emitter.scaleX.onEmit(this, "scaleX");
              this.scaleY = emitter.scaleY ? emitter.scaleY.onEmit(this, "scaleY") : this.scaleX;
              this.angle = emitter.rotate.onEmit(this, "rotate");
              this.rotation = DegToRad(this.angle);
              this.bounce = emitter.bounce.onEmit(this, "bounce");
              this.alpha = emitter.alpha.onEmit(this, "alpha");
              this.tint = emitter.tint.onEmit(this, "tint");
            },
            computeVelocity: function(emitter, delta, step, processors) {
              var vx = this.velocityX;
              var vy = this.velocityY;
              var ax = this.accelerationX;
              var ay = this.accelerationY;
              var mx = this.maxVelocityX;
              var my = this.maxVelocityY;
              vx += emitter.gravityX * step;
              vy += emitter.gravityY * step;
              if (ax) {
                vx += ax * step;
              }
              if (ay) {
                vy += ay * step;
              }
              if (vx > mx) {
                vx = mx;
              } else if (vx < -mx) {
                vx = -mx;
              }
              if (vy > my) {
                vy = my;
              } else if (vy < -my) {
                vy = -my;
              }
              this.velocityX = vx;
              this.velocityY = vy;
              for (var i = 0; i < processors.length; i++) {
                processors[i].update(this, delta, step);
              }
            },
            checkBounds: function(emitter) {
              var bounds = emitter.bounds;
              var bounce = -this.bounce;
              if (this.x < bounds.x && emitter.collideLeft) {
                this.x = bounds.x;
                this.velocityX *= bounce;
              } else if (this.x > bounds.right && emitter.collideRight) {
                this.x = bounds.right;
                this.velocityX *= bounce;
              }
              if (this.y < bounds.y && emitter.collideTop) {
                this.y = bounds.y;
                this.velocityY *= bounce;
              } else if (this.y > bounds.bottom && emitter.collideBottom) {
                this.y = bounds.bottom;
                this.velocityY *= bounce;
              }
            },
            update: function(delta, step, processors) {
              if (this.delayCurrent > 0) {
                this.delayCurrent -= delta;
                return false;
              }
              var emitter = this.emitter;
              var t = 1 - this.lifeCurrent / this.life;
              this.lifeT = t;
              this.computeVelocity(emitter, delta, step, processors);
              this.x += this.velocityX * step;
              this.y += this.velocityY * step;
              if (emitter.bounds) {
                this.checkBounds(emitter);
              }
              if (emitter.deathZone && emitter.deathZone.willKill(this)) {
                this.lifeCurrent = 0;
                return true;
              }
              this.scaleX = emitter.scaleX.onUpdate(this, "scaleX", t, this.scaleX);
              if (emitter.scaleY) {
                this.scaleY = emitter.scaleY.onUpdate(this, "scaleY", t, this.scaleY);
              } else {
                this.scaleY = this.scaleX;
              }
              this.angle = emitter.rotate.onUpdate(this, "rotate", t, this.angle);
              this.rotation = DegToRad(this.angle);
              this.alpha = emitter.alpha.onUpdate(this, "alpha", t, this.alpha);
              this.tint = emitter.tint.onUpdate(this, "tint", t, this.tint);
              this.lifeCurrent -= delta;
              return this.lifeCurrent <= 0;
            }
          });
          module2.exports = Particle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BlendModes = __webpack_require__(34);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var DeathZone = __webpack_require__(447);
          var EdgeZone = __webpack_require__(448);
          var EmitterOp = __webpack_require__(443);
          var GetFastValue = __webpack_require__(2);
          var GetRandom = __webpack_require__(207);
          var HasAny = __webpack_require__(449);
          var HasValue = __webpack_require__(125);
          var Particle = __webpack_require__(445);
          var RandomZone = __webpack_require__(450);
          var Rectangle = __webpack_require__(10);
          var StableSort = __webpack_require__(79);
          var Vector29 = __webpack_require__(3);
          var Wrap = __webpack_require__(66);
          var ParticleEmitter = new Class({
            Mixins: [
              Components.BlendMode,
              Components.Mask,
              Components.ScrollFactor,
              Components.Visible
            ],
            initialize: function ParticleEmitter2(manager, config2) {
              this.manager = manager;
              this.texture = manager.texture;
              this.frames = [manager.defaultFrame];
              this.defaultFrame = manager.defaultFrame;
              this.configFastMap = [
                "active",
                "blendMode",
                "collideBottom",
                "collideLeft",
                "collideRight",
                "collideTop",
                "deathCallback",
                "deathCallbackScope",
                "emitCallback",
                "emitCallbackScope",
                "follow",
                "frequency",
                "gravityX",
                "gravityY",
                "maxParticles",
                "name",
                "on",
                "particleBringToTop",
                "particleClass",
                "radial",
                "timeScale",
                "trackVisible",
                "visible"
              ];
              this.configOpMap = [
                "accelerationX",
                "accelerationY",
                "angle",
                "alpha",
                "bounce",
                "delay",
                "lifespan",
                "maxVelocityX",
                "maxVelocityY",
                "moveToX",
                "moveToY",
                "quantity",
                "rotate",
                "scaleX",
                "scaleY",
                "speedX",
                "speedY",
                "tint",
                "x",
                "y"
              ];
              this.name = "";
              this.particleClass = Particle;
              this.x = new EmitterOp(config2, "x", 0, true);
              this.y = new EmitterOp(config2, "y", 0, true);
              this.radial = true;
              this.gravityX = 0;
              this.gravityY = 0;
              this.acceleration = false;
              this.accelerationX = new EmitterOp(config2, "accelerationX", 0, true);
              this.accelerationY = new EmitterOp(config2, "accelerationY", 0, true);
              this.maxVelocityX = new EmitterOp(config2, "maxVelocityX", 1e4, true);
              this.maxVelocityY = new EmitterOp(config2, "maxVelocityY", 1e4, true);
              this.speedX = new EmitterOp(config2, "speedX", 0, true);
              this.speedY = new EmitterOp(config2, "speedY", 0, true);
              this.moveTo = false;
              this.moveToX = new EmitterOp(config2, "moveToX", 0, true);
              this.moveToY = new EmitterOp(config2, "moveToY", 0, true);
              this.bounce = new EmitterOp(config2, "bounce", 0, true);
              this.scaleX = new EmitterOp(config2, "scaleX", 1);
              this.scaleY = new EmitterOp(config2, "scaleY", 1);
              this.tint = new EmitterOp(config2, "tint", 16777215);
              this.alpha = new EmitterOp(config2, "alpha", 1);
              this.lifespan = new EmitterOp(config2, "lifespan", 1e3, true);
              this.angle = new EmitterOp(config2, "angle", {min: 0, max: 360}, true);
              this.rotate = new EmitterOp(config2, "rotate", 0);
              this.emitCallback = null;
              this.emitCallbackScope = null;
              this.deathCallback = null;
              this.deathCallbackScope = null;
              this.maxParticles = 0;
              this.quantity = new EmitterOp(config2, "quantity", 1, true);
              this.delay = new EmitterOp(config2, "delay", 0, true);
              this.frequency = 0;
              this.on = true;
              this.particleBringToTop = true;
              this.timeScale = 1;
              this.emitZone = null;
              this.deathZone = null;
              this.bounds = null;
              this.collideLeft = true;
              this.collideRight = true;
              this.collideTop = true;
              this.collideBottom = true;
              this.active = true;
              this.visible = true;
              this.blendMode = BlendModes.NORMAL;
              this.follow = null;
              this.followOffset = new Vector29();
              this.trackVisible = false;
              this.currentFrame = 0;
              this.randomFrame = true;
              this.frameQuantity = 1;
              this.dead = [];
              this.alive = [];
              this._counter = 0;
              this._frameCounter = 0;
              if (config2) {
                this.fromJSON(config2);
              }
            },
            fromJSON: function(config2) {
              if (!config2) {
                return this;
              }
              var i = 0;
              var key = "";
              for (i = 0; i < this.configFastMap.length; i++) {
                key = this.configFastMap[i];
                if (HasValue(config2, key)) {
                  this[key] = GetFastValue(config2, key);
                }
              }
              for (i = 0; i < this.configOpMap.length; i++) {
                key = this.configOpMap[i];
                if (HasValue(config2, key)) {
                  this[key].loadConfig(config2);
                }
              }
              this.acceleration = this.accelerationX.propertyValue !== 0 || this.accelerationY.propertyValue !== 0;
              this.moveTo = this.moveToX.propertyValue !== 0 || this.moveToY.propertyValue !== 0;
              if (HasValue(config2, "speed")) {
                this.speedX.loadConfig(config2, "speed");
                this.speedY = null;
              }
              if (HasAny(config2, ["speedX", "speedY"]) || this.moveTo) {
                this.radial = false;
              }
              if (HasValue(config2, "scale")) {
                this.scaleX.loadConfig(config2, "scale");
                this.scaleY = null;
              }
              if (HasValue(config2, "callbackScope")) {
                var callbackScope = GetFastValue(config2, "callbackScope", null);
                this.emitCallbackScope = callbackScope;
                this.deathCallbackScope = callbackScope;
              }
              if (HasValue(config2, "emitZone")) {
                this.setEmitZone(config2.emitZone);
              }
              if (HasValue(config2, "deathZone")) {
                this.setDeathZone(config2.deathZone);
              }
              if (HasValue(config2, "bounds")) {
                this.setBounds(config2.bounds);
              }
              if (HasValue(config2, "followOffset")) {
                this.followOffset.setFromObject(GetFastValue(config2, "followOffset", 0));
              }
              if (HasValue(config2, "frame")) {
                this.setFrame(config2.frame);
              }
              if (HasValue(config2, "reserve")) {
                this.reserve(config2.reserve);
              }
              return this;
            },
            toJSON: function(output) {
              if (output === void 0) {
                output = {};
              }
              var i = 0;
              var key = "";
              for (i = 0; i < this.configFastMap.length; i++) {
                key = this.configFastMap[i];
                output[key] = this[key];
              }
              for (i = 0; i < this.configOpMap.length; i++) {
                key = this.configOpMap[i];
                if (this[key]) {
                  output[key] = this[key].toJSON();
                }
              }
              if (!this.speedY) {
                delete output.speedX;
                output.speed = this.speedX.toJSON();
              }
              if (!this.scaleY) {
                delete output.scaleX;
                output.scale = this.scaleX.toJSON();
              }
              return output;
            },
            startFollow: function(target, offsetX, offsetY, trackVisible) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              if (trackVisible === void 0) {
                trackVisible = false;
              }
              this.follow = target;
              this.followOffset.set(offsetX, offsetY);
              this.trackVisible = trackVisible;
              return this;
            },
            stopFollow: function() {
              this.follow = null;
              this.followOffset.set(0, 0);
              this.trackVisible = false;
              return this;
            },
            getFrame: function() {
              if (this.frames.length === 1) {
                return this.defaultFrame;
              } else if (this.randomFrame) {
                return GetRandom(this.frames);
              } else {
                var frame = this.frames[this.currentFrame];
                this._frameCounter++;
                if (this._frameCounter === this.frameQuantity) {
                  this._frameCounter = 0;
                  this.currentFrame = Wrap(this.currentFrame + 1, 0, this._frameLength);
                }
                return frame;
              }
            },
            setFrame: function(frames, pickRandom, quantity) {
              if (pickRandom === void 0) {
                pickRandom = true;
              }
              if (quantity === void 0) {
                quantity = 1;
              }
              this.randomFrame = pickRandom;
              this.frameQuantity = quantity;
              this.currentFrame = 0;
              this._frameCounter = 0;
              var t = typeof frames;
              if (Array.isArray(frames) || t === "string" || t === "number") {
                this.manager.setEmitterFrames(frames, this);
              } else if (t === "object") {
                var frameConfig = frames;
                frames = GetFastValue(frameConfig, "frames", null);
                if (frames) {
                  this.manager.setEmitterFrames(frames, this);
                }
                var isCycle = GetFastValue(frameConfig, "cycle", false);
                this.randomFrame = isCycle ? false : true;
                this.frameQuantity = GetFastValue(frameConfig, "quantity", quantity);
              }
              this._frameLength = this.frames.length;
              if (this._frameLength === 1) {
                this.frameQuantity = 1;
                this.randomFrame = false;
              }
              return this;
            },
            setRadial: function(value) {
              if (value === void 0) {
                value = true;
              }
              this.radial = value;
              return this;
            },
            setPosition: function(x, y) {
              this.x.onChange(x);
              this.y.onChange(y);
              return this;
            },
            setBounds: function(x, y, width, height) {
              if (typeof x === "object") {
                var obj = x;
                x = obj.x;
                y = obj.y;
                width = HasValue(obj, "w") ? obj.w : obj.width;
                height = HasValue(obj, "h") ? obj.h : obj.height;
              }
              if (this.bounds) {
                this.bounds.setTo(x, y, width, height);
              } else {
                this.bounds = new Rectangle(x, y, width, height);
              }
              return this;
            },
            setSpeedX: function(value) {
              this.speedX.onChange(value);
              this.radial = false;
              return this;
            },
            setSpeedY: function(value) {
              if (this.speedY) {
                this.speedY.onChange(value);
                this.radial = false;
              }
              return this;
            },
            setSpeed: function(value) {
              this.speedX.onChange(value);
              this.speedY = null;
              this.radial = true;
              return this;
            },
            setScaleX: function(value) {
              this.scaleX.onChange(value);
              return this;
            },
            setScaleY: function(value) {
              this.scaleY.onChange(value);
              return this;
            },
            setScale: function(value) {
              this.scaleX.onChange(value);
              this.scaleY = null;
              return this;
            },
            setGravityX: function(value) {
              this.gravityX = value;
              return this;
            },
            setGravityY: function(value) {
              this.gravityY = value;
              return this;
            },
            setGravity: function(x, y) {
              this.gravityX = x;
              this.gravityY = y;
              return this;
            },
            setAlpha: function(value) {
              this.alpha.onChange(value);
              return this;
            },
            setTint: function(value) {
              this.tint.onChange(value);
              return this;
            },
            setEmitterAngle: function(value) {
              this.angle.onChange(value);
              return this;
            },
            setAngle: function(value) {
              this.angle.onChange(value);
              return this;
            },
            setLifespan: function(value) {
              this.lifespan.onChange(value);
              return this;
            },
            setQuantity: function(quantity) {
              this.quantity.onChange(quantity);
              return this;
            },
            setFrequency: function(frequency, quantity) {
              this.frequency = frequency;
              this._counter = 0;
              if (quantity) {
                this.quantity.onChange(quantity);
              }
              return this;
            },
            setEmitZone: function(zoneConfig) {
              if (zoneConfig === void 0) {
                this.emitZone = null;
              } else {
                var type = GetFastValue(zoneConfig, "type", "random");
                var source = GetFastValue(zoneConfig, "source", null);
                switch (type) {
                  case "random":
                    this.emitZone = new RandomZone(source);
                    break;
                  case "edge":
                    var quantity = GetFastValue(zoneConfig, "quantity", 1);
                    var stepRate = GetFastValue(zoneConfig, "stepRate", 0);
                    var yoyo = GetFastValue(zoneConfig, "yoyo", false);
                    var seamless = GetFastValue(zoneConfig, "seamless", true);
                    this.emitZone = new EdgeZone(source, quantity, stepRate, yoyo, seamless);
                    break;
                }
              }
              return this;
            },
            setDeathZone: function(zoneConfig) {
              if (zoneConfig === void 0) {
                this.deathZone = null;
              } else {
                var type = GetFastValue(zoneConfig, "type", "onEnter");
                var source = GetFastValue(zoneConfig, "source", null);
                if (source && typeof source.contains === "function") {
                  var killOnEnter = type === "onEnter" ? true : false;
                  this.deathZone = new DeathZone(source, killOnEnter);
                }
              }
              return this;
            },
            reserve: function(particleCount) {
              var dead = this.dead;
              for (var i = 0; i < particleCount; i++) {
                dead.push(new this.particleClass(this));
              }
              return this;
            },
            getAliveParticleCount: function() {
              return this.alive.length;
            },
            getDeadParticleCount: function() {
              return this.dead.length;
            },
            getParticleCount: function() {
              return this.getAliveParticleCount() + this.getDeadParticleCount();
            },
            atLimit: function() {
              return this.maxParticles > 0 && this.getParticleCount() === this.maxParticles;
            },
            onParticleEmit: function(callback, context) {
              if (callback === void 0) {
                this.emitCallback = null;
                this.emitCallbackScope = null;
              } else if (typeof callback === "function") {
                this.emitCallback = callback;
                if (context) {
                  this.emitCallbackScope = context;
                }
              }
              return this;
            },
            onParticleDeath: function(callback, context) {
              if (callback === void 0) {
                this.deathCallback = null;
                this.deathCallbackScope = null;
              } else if (typeof callback === "function") {
                this.deathCallback = callback;
                if (context) {
                  this.deathCallbackScope = context;
                }
              }
              return this;
            },
            killAll: function() {
              var dead = this.dead;
              var alive = this.alive;
              while (alive.length > 0) {
                dead.push(alive.pop());
              }
              return this;
            },
            forEachAlive: function(callback, context) {
              var alive = this.alive;
              var length = alive.length;
              for (var index = 0; index < length; ++index) {
                callback.call(context, alive[index], this);
              }
              return this;
            },
            forEachDead: function(callback, context) {
              var dead = this.dead;
              var length = dead.length;
              for (var index = 0; index < length; ++index) {
                callback.call(context, dead[index], this);
              }
              return this;
            },
            start: function() {
              this.on = true;
              this._counter = 0;
              return this;
            },
            stop: function() {
              this.on = false;
              return this;
            },
            pause: function() {
              this.active = false;
              return this;
            },
            resume: function() {
              this.active = true;
              return this;
            },
            remove: function() {
              this.manager.removeEmitter(this);
              return this;
            },
            depthSort: function() {
              StableSort(this.alive, this.depthSortCallback);
              return this;
            },
            flow: function(frequency, count) {
              if (count === void 0) {
                count = 1;
              }
              this.frequency = frequency;
              this.quantity.onChange(count);
              return this.start();
            },
            explode: function(count, x, y) {
              this.frequency = -1;
              return this.emitParticle(count, x, y);
            },
            emitParticleAt: function(x, y, count) {
              return this.emitParticle(count, x, y);
            },
            emitParticle: function(count, x, y) {
              if (this.atLimit()) {
                return;
              }
              if (count === void 0) {
                count = this.quantity.onEmit();
              }
              var dead = this.dead;
              var followX = this.follow ? this.follow.x + this.followOffset.x : x;
              var followY = this.follow ? this.follow.y + this.followOffset.y : y;
              for (var i = 0; i < count; i++) {
                var particle = dead.pop();
                if (!particle) {
                  particle = new this.particleClass(this);
                }
                particle.fire(followX, followY);
                if (this.particleBringToTop) {
                  this.alive.push(particle);
                } else {
                  this.alive.unshift(particle);
                }
                if (this.emitCallback) {
                  this.emitCallback.call(this.emitCallbackScope, particle, this);
                }
                if (this.atLimit()) {
                  break;
                }
              }
              return particle;
            },
            preUpdate: function(time, delta) {
              delta *= this.timeScale;
              var step = delta / 1e3;
              if (this.trackVisible) {
                this.visible = this.follow.visible;
              }
              var processors = this.manager.getProcessors();
              var particles = this.alive;
              var dead = this.dead;
              var i = 0;
              var rip = [];
              var length = particles.length;
              for (i = 0; i < length; i++) {
                var particle = particles[i];
                if (particle.update(delta, step, processors)) {
                  rip.push({index: i, particle});
                }
              }
              length = rip.length;
              if (length > 0) {
                var deathCallback = this.deathCallback;
                var deathCallbackScope = this.deathCallbackScope;
                for (i = length - 1; i >= 0; i--) {
                  var entry = rip[i];
                  particles.splice(entry.index, 1);
                  dead.push(entry.particle);
                  if (deathCallback) {
                    deathCallback.call(deathCallbackScope, entry.particle);
                  }
                  entry.particle.resetPosition();
                }
              }
              if (!this.on) {
                return;
              }
              if (this.frequency === 0) {
                this.emitParticle();
              } else if (this.frequency > 0) {
                this._counter -= delta;
                if (this._counter <= 0) {
                  this.emitParticle();
                  this._counter = this.frequency - Math.abs(this._counter);
                }
              }
            },
            depthSortCallback: function(a, b) {
              return a.y - b.y;
            }
          });
          module2.exports = ParticleEmitter;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var DeathZone = new Class({
            initialize: function DeathZone2(source, killOnEnter) {
              this.source = source;
              this.killOnEnter = killOnEnter;
            },
            willKill: function(particle) {
              var withinZone = this.source.contains(particle.x, particle.y);
              return withinZone && this.killOnEnter || !withinZone && !this.killOnEnter;
            }
          });
          module2.exports = DeathZone;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var EdgeZone = new Class({
            initialize: function EdgeZone2(source, quantity, stepRate, yoyo, seamless) {
              if (yoyo === void 0) {
                yoyo = false;
              }
              if (seamless === void 0) {
                seamless = true;
              }
              this.source = source;
              this.points = [];
              this.quantity = quantity;
              this.stepRate = stepRate;
              this.yoyo = yoyo;
              this.counter = -1;
              this.seamless = seamless;
              this._length = 0;
              this._direction = 0;
              this.updateSource();
            },
            updateSource: function() {
              this.points = this.source.getPoints(this.quantity, this.stepRate);
              if (this.seamless) {
                var a = this.points[0];
                var b = this.points[this.points.length - 1];
                if (a.x === b.x && a.y === b.y) {
                  this.points.pop();
                }
              }
              var oldLength = this._length;
              this._length = this.points.length;
              if (this._length < oldLength && this.counter > this._length) {
                this.counter = this._length - 1;
              }
              return this;
            },
            changeSource: function(source) {
              this.source = source;
              return this.updateSource();
            },
            getPoint: function(particle) {
              if (this._direction === 0) {
                this.counter++;
                if (this.counter >= this._length) {
                  if (this.yoyo) {
                    this._direction = 1;
                    this.counter = this._length - 1;
                  } else {
                    this.counter = 0;
                  }
                }
              } else {
                this.counter--;
                if (this.counter === -1) {
                  if (this.yoyo) {
                    this._direction = 0;
                    this.counter = 0;
                  } else {
                    this.counter = this._length - 1;
                  }
                }
              }
              var point = this.points[this.counter];
              if (point) {
                particle.x = point.x;
                particle.y = point.y;
              }
            }
          });
          module2.exports = EdgeZone;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var HasAny = function(source, keys) {
            for (var i = 0; i < keys.length; i++) {
              if (source.hasOwnProperty(keys[i])) {
                return true;
              }
            }
            return false;
          };
          module2.exports = HasAny;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Vector29 = __webpack_require__(3);
          var RandomZone = new Class({
            initialize: function RandomZone2(source) {
              this.source = source;
              this._tempVec = new Vector29();
            },
            getPoint: function(particle) {
              var vec = this._tempVec;
              this.source.getRandomPoint(vec);
              particle.x = vec.x;
              particle.y = vec.y;
            }
          });
          module2.exports = RandomZone;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var Sprite = __webpack_require__(73);
          var PathFollower = new Class({
            Extends: Sprite,
            Mixins: [
              Components.PathFollower
            ],
            initialize: function PathFollower2(scene, path, x, y, texture, frame) {
              Sprite.call(this, scene, x, y, texture, frame);
              this.path = path;
            },
            preUpdate: function(time, delta) {
              this.anims.update(time, delta);
              this.pathUpdate(time);
            }
          });
          module2.exports = PathFollower;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTextSize = function(text, size, lines) {
            var canvas = text.canvas;
            var context = text.context;
            var style = text.style;
            var lineWidths = [];
            var maxLineWidth = 0;
            var drawnLines = lines.length;
            if (style.maxLines > 0 && style.maxLines < lines.length) {
              drawnLines = style.maxLines;
            }
            style.syncFont(canvas, context);
            for (var i = 0; i < drawnLines; i++) {
              var lineWidth = style.strokeThickness;
              lineWidth += context.measureText(lines[i]).width;
              if (style.wordWrap) {
                lineWidth -= context.measureText(" ").width;
              }
              lineWidths[i] = Math.ceil(lineWidth);
              maxLineWidth = Math.max(maxLineWidth, lineWidths[i]);
            }
            var lineHeight = size.fontSize + style.strokeThickness;
            var height = lineHeight * drawnLines;
            var lineSpacing = text.lineSpacing;
            if (drawnLines > 1) {
              height += lineSpacing * (drawnLines - 1);
            }
            return {
              width: maxLineWidth,
              height,
              lines: drawnLines,
              lineWidths,
              lineSpacing,
              lineHeight
            };
          };
          module2.exports = GetTextSize;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetAdvancedValue = __webpack_require__(13);
          var GetValue = __webpack_require__(6);
          var MeasureText = __webpack_require__(454);
          var propertyMap = {
            fontFamily: ["fontFamily", "Courier"],
            fontSize: ["fontSize", "16px"],
            fontStyle: ["fontStyle", ""],
            backgroundColor: ["backgroundColor", null],
            color: ["color", "#fff"],
            stroke: ["stroke", "#fff"],
            strokeThickness: ["strokeThickness", 0],
            shadowOffsetX: ["shadow.offsetX", 0],
            shadowOffsetY: ["shadow.offsetY", 0],
            shadowColor: ["shadow.color", "#000"],
            shadowBlur: ["shadow.blur", 0],
            shadowStroke: ["shadow.stroke", false],
            shadowFill: ["shadow.fill", false],
            align: ["align", "left"],
            maxLines: ["maxLines", 0],
            fixedWidth: ["fixedWidth", 0],
            fixedHeight: ["fixedHeight", 0],
            resolution: ["resolution", 0],
            rtl: ["rtl", false],
            testString: ["testString", "|M\xC3\u2030qgy"],
            baselineX: ["baselineX", 1.2],
            baselineY: ["baselineY", 1.4],
            wordWrapWidth: ["wordWrap.width", null],
            wordWrapCallback: ["wordWrap.callback", null],
            wordWrapCallbackScope: ["wordWrap.callbackScope", null],
            wordWrapUseAdvanced: ["wordWrap.useAdvancedWrap", false]
          };
          var TextStyle = new Class({
            initialize: function TextStyle2(text, style) {
              this.parent = text;
              this.fontFamily;
              this.fontSize;
              this.fontStyle;
              this.backgroundColor;
              this.color;
              this.stroke;
              this.strokeThickness;
              this.shadowOffsetX;
              this.shadowOffsetY;
              this.shadowColor;
              this.shadowBlur;
              this.shadowStroke;
              this.shadowFill;
              this.align;
              this.maxLines;
              this.fixedWidth;
              this.fixedHeight;
              this.resolution;
              this.rtl;
              this.testString;
              this.baselineX;
              this.baselineY;
              this.wordWrapWidth;
              this.wordWrapCallback;
              this.wordWrapCallbackScope;
              this.wordWrapUseAdvanced;
              this._font;
              this.setStyle(style, false, true);
              var metrics = GetValue(style, "metrics", false);
              if (metrics) {
                this.metrics = {
                  ascent: GetValue(metrics, "ascent", 0),
                  descent: GetValue(metrics, "descent", 0),
                  fontSize: GetValue(metrics, "fontSize", 0)
                };
              } else {
                this.metrics = MeasureText(this);
              }
            },
            setStyle: function(style, updateText, setDefaults) {
              if (updateText === void 0) {
                updateText = true;
              }
              if (setDefaults === void 0) {
                setDefaults = false;
              }
              if (style && style.hasOwnProperty("fontSize") && typeof style.fontSize === "number") {
                style.fontSize = style.fontSize.toString() + "px";
              }
              for (var key in propertyMap) {
                var value = setDefaults ? propertyMap[key][1] : this[key];
                if (key === "wordWrapCallback" || key === "wordWrapCallbackScope") {
                  this[key] = GetValue(style, propertyMap[key][0], value);
                } else {
                  this[key] = GetAdvancedValue(style, propertyMap[key][0], value);
                }
              }
              var font = GetValue(style, "font", null);
              if (font !== null) {
                this.setFont(font, false);
              }
              this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
              var fill = GetValue(style, "fill", null);
              if (fill !== null) {
                this.color = fill;
              }
              if (updateText) {
                return this.update(true);
              } else {
                return this.parent;
              }
            },
            syncFont: function(canvas, context) {
              context.font = this._font;
            },
            syncStyle: function(canvas, context) {
              context.textBaseline = "alphabetic";
              context.fillStyle = this.color;
              context.strokeStyle = this.stroke;
              context.lineWidth = this.strokeThickness;
              context.lineCap = "round";
              context.lineJoin = "round";
            },
            syncShadow: function(context, enabled) {
              if (enabled) {
                context.shadowOffsetX = this.shadowOffsetX;
                context.shadowOffsetY = this.shadowOffsetY;
                context.shadowColor = this.shadowColor;
                context.shadowBlur = this.shadowBlur;
              } else {
                context.shadowOffsetX = 0;
                context.shadowOffsetY = 0;
                context.shadowColor = 0;
                context.shadowBlur = 0;
              }
            },
            update: function(recalculateMetrics) {
              if (recalculateMetrics) {
                this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
                this.metrics = MeasureText(this);
              }
              return this.parent.updateText();
            },
            setFont: function(font, updateText) {
              if (updateText === void 0) {
                updateText = true;
              }
              var fontFamily = font;
              var fontSize = "";
              var fontStyle = "";
              if (typeof font !== "string") {
                fontFamily = GetValue(font, "fontFamily", "Courier");
                fontSize = GetValue(font, "fontSize", "16px");
                fontStyle = GetValue(font, "fontStyle", "");
              } else {
                var fontSplit = font.split(" ");
                var i = 0;
                fontStyle = fontSplit.length > 2 ? fontSplit[i++] : "";
                fontSize = fontSplit[i++] || "16px";
                fontFamily = fontSplit[i++] || "Courier";
              }
              if (fontFamily !== this.fontFamily || fontSize !== this.fontSize || fontStyle !== this.fontStyle) {
                this.fontFamily = fontFamily;
                this.fontSize = fontSize;
                this.fontStyle = fontStyle;
                if (updateText) {
                  this.update(true);
                }
              }
              return this.parent;
            },
            setFontFamily: function(family) {
              if (this.fontFamily !== family) {
                this.fontFamily = family;
                this.update(true);
              }
              return this.parent;
            },
            setFontStyle: function(style) {
              if (this.fontStyle !== style) {
                this.fontStyle = style;
                this.update(true);
              }
              return this.parent;
            },
            setFontSize: function(size) {
              if (typeof size === "number") {
                size = size.toString() + "px";
              }
              if (this.fontSize !== size) {
                this.fontSize = size;
                this.update(true);
              }
              return this.parent;
            },
            setTestString: function(string) {
              this.testString = string;
              return this.update(true);
            },
            setFixedSize: function(width, height) {
              this.fixedWidth = width;
              this.fixedHeight = height;
              if (width) {
                this.parent.width = width;
              }
              if (height) {
                this.parent.height = height;
              }
              return this.update(false);
            },
            setBackgroundColor: function(color) {
              this.backgroundColor = color;
              return this.update(false);
            },
            setFill: function(color) {
              this.color = color;
              return this.update(false);
            },
            setColor: function(color) {
              this.color = color;
              return this.update(false);
            },
            setResolution: function(value) {
              this.resolution = value;
              return this.update(false);
            },
            setStroke: function(color, thickness) {
              if (thickness === void 0) {
                thickness = this.strokeThickness;
              }
              if (color === void 0 && this.strokeThickness !== 0) {
                this.strokeThickness = 0;
                this.update(true);
              } else if (this.stroke !== color || this.strokeThickness !== thickness) {
                this.stroke = color;
                this.strokeThickness = thickness;
                this.update(true);
              }
              return this.parent;
            },
            setShadow: function(x, y, color, blur, shadowStroke, shadowFill) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (color === void 0) {
                color = "#000";
              }
              if (blur === void 0) {
                blur = 0;
              }
              if (shadowStroke === void 0) {
                shadowStroke = false;
              }
              if (shadowFill === void 0) {
                shadowFill = true;
              }
              this.shadowOffsetX = x;
              this.shadowOffsetY = y;
              this.shadowColor = color;
              this.shadowBlur = blur;
              this.shadowStroke = shadowStroke;
              this.shadowFill = shadowFill;
              return this.update(false);
            },
            setShadowOffset: function(x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = x;
              }
              this.shadowOffsetX = x;
              this.shadowOffsetY = y;
              return this.update(false);
            },
            setShadowColor: function(color) {
              if (color === void 0) {
                color = "#000";
              }
              this.shadowColor = color;
              return this.update(false);
            },
            setShadowBlur: function(blur) {
              if (blur === void 0) {
                blur = 0;
              }
              this.shadowBlur = blur;
              return this.update(false);
            },
            setShadowStroke: function(enabled) {
              this.shadowStroke = enabled;
              return this.update(false);
            },
            setShadowFill: function(enabled) {
              this.shadowFill = enabled;
              return this.update(false);
            },
            setWordWrapWidth: function(width, useAdvancedWrap) {
              if (useAdvancedWrap === void 0) {
                useAdvancedWrap = false;
              }
              this.wordWrapWidth = width;
              this.wordWrapUseAdvanced = useAdvancedWrap;
              return this.update(false);
            },
            setWordWrapCallback: function(callback, scope) {
              if (scope === void 0) {
                scope = null;
              }
              this.wordWrapCallback = callback;
              this.wordWrapCallbackScope = scope;
              return this.update(false);
            },
            setAlign: function(align) {
              if (align === void 0) {
                align = "left";
              }
              this.align = align;
              return this.update(false);
            },
            setMaxLines: function(max) {
              if (max === void 0) {
                max = 0;
              }
              this.maxLines = max;
              return this.update(false);
            },
            getTextMetrics: function() {
              var metrics = this.metrics;
              return {
                ascent: metrics.ascent,
                descent: metrics.descent,
                fontSize: metrics.fontSize
              };
            },
            toJSON: function() {
              var output = {};
              for (var key in propertyMap) {
                output[key] = this[key];
              }
              output.metrics = this.getTextMetrics();
              return output;
            },
            destroy: function() {
              this.parent = void 0;
            }
          });
          module2.exports = TextStyle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CanvasPool = __webpack_require__(31);
          var MeasureText = function(textStyle) {
            var canvas = CanvasPool.create(this);
            var context = canvas.getContext("2d");
            textStyle.syncFont(canvas, context);
            var metrics = context.measureText(textStyle.testString);
            if (metrics.hasOwnProperty("actualBoundingBoxAscent")) {
              var ascent = metrics.actualBoundingBoxAscent;
              var descent = metrics.actualBoundingBoxDescent;
              CanvasPool.remove(canvas);
              return {
                ascent,
                descent,
                fontSize: ascent + descent
              };
            }
            var width = Math.ceil(metrics.width * textStyle.baselineX);
            var baseline = width;
            var height = 2 * baseline;
            baseline = baseline * textStyle.baselineY | 0;
            canvas.width = width;
            canvas.height = height;
            context.fillStyle = "#f00";
            context.fillRect(0, 0, width, height);
            context.font = textStyle._font;
            context.textBaseline = "alphabetic";
            context.fillStyle = "#000";
            context.fillText(textStyle.testString, 0, baseline);
            var output = {
              ascent: 0,
              descent: 0,
              fontSize: 0
            };
            if (!context.getImageData(0, 0, width, height)) {
              output.ascent = baseline;
              output.descent = baseline + 6;
              output.fontSize = output.ascent + output.descent;
              CanvasPool.remove(canvas);
              return output;
            }
            var imagedata = context.getImageData(0, 0, width, height).data;
            var pixels = imagedata.length;
            var line = width * 4;
            var i;
            var j;
            var idx = 0;
            var stop = false;
            for (i = 0; i < baseline; i++) {
              for (j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                  stop = true;
                  break;
                }
              }
              if (!stop) {
                idx += line;
              } else {
                break;
              }
            }
            output.ascent = baseline - i;
            idx = pixels - line;
            stop = false;
            for (i = height; i > baseline; i--) {
              for (j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                  stop = true;
                  break;
                }
              }
              if (!stop) {
                idx -= line;
              } else {
                break;
              }
            }
            output.descent = i - baseline;
            output.fontSize = output.ascent + output.descent;
            CanvasPool.remove(canvas);
            return output;
          };
          module2.exports = MeasureText;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ArcRender = __webpack_require__(1091);
          var Class = __webpack_require__(0);
          var DegToRad = __webpack_require__(35);
          var Earcut = __webpack_require__(68);
          var GeomCircle = __webpack_require__(62);
          var MATH_CONST = __webpack_require__(14);
          var Shape = __webpack_require__(33);
          var Arc = new Class({
            Extends: Shape,
            Mixins: [
              ArcRender
            ],
            initialize: function Arc2(scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (radius === void 0) {
                radius = 128;
              }
              if (startAngle === void 0) {
                startAngle = 0;
              }
              if (endAngle === void 0) {
                endAngle = 360;
              }
              if (anticlockwise === void 0) {
                anticlockwise = false;
              }
              Shape.call(this, scene, "Arc", new GeomCircle(0, 0, radius));
              this._startAngle = startAngle;
              this._endAngle = endAngle;
              this._anticlockwise = anticlockwise;
              this._iterations = 0.01;
              this.setPosition(x, y);
              var diameter = this.geom.radius * 2;
              this.setSize(diameter, diameter);
              if (fillColor !== void 0) {
                this.setFillStyle(fillColor, fillAlpha);
              }
              this.updateDisplayOrigin();
              this.updateData();
            },
            iterations: {
              get: function() {
                return this._iterations;
              },
              set: function(value) {
                this._iterations = value;
                this.updateData();
              }
            },
            radius: {
              get: function() {
                return this.geom.radius;
              },
              set: function(value) {
                this.geom.radius = value;
                var diameter = value * 2;
                this.setSize(diameter, diameter);
                this.updateDisplayOrigin();
                this.updateData();
              }
            },
            startAngle: {
              get: function() {
                return this._startAngle;
              },
              set: function(value) {
                this._startAngle = value;
                this.updateData();
              }
            },
            endAngle: {
              get: function() {
                return this._endAngle;
              },
              set: function(value) {
                this._endAngle = value;
                this.updateData();
              }
            },
            anticlockwise: {
              get: function() {
                return this._anticlockwise;
              },
              set: function(value) {
                this._anticlockwise = value;
                this.updateData();
              }
            },
            setRadius: function(value) {
              this.radius = value;
              return this;
            },
            setIterations: function(value) {
              if (value === void 0) {
                value = 0.01;
              }
              this.iterations = value;
              return this;
            },
            setStartAngle: function(angle, anticlockwise) {
              this._startAngle = angle;
              if (anticlockwise !== void 0) {
                this._anticlockwise = anticlockwise;
              }
              return this.updateData();
            },
            setEndAngle: function(angle, anticlockwise) {
              this._endAngle = angle;
              if (anticlockwise !== void 0) {
                this._anticlockwise = anticlockwise;
              }
              return this.updateData();
            },
            updateData: function() {
              var step = this._iterations;
              var iteration = step;
              var radius = this.geom.radius;
              var startAngle = DegToRad(this._startAngle);
              var endAngle = DegToRad(this._endAngle);
              var anticlockwise = this._anticlockwise;
              var x = radius;
              var y = radius;
              endAngle -= startAngle;
              if (anticlockwise) {
                if (endAngle < -MATH_CONST.PI2) {
                  endAngle = -MATH_CONST.PI2;
                } else if (endAngle > 0) {
                  endAngle = -MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;
                }
              } else if (endAngle > MATH_CONST.PI2) {
                endAngle = MATH_CONST.PI2;
              } else if (endAngle < 0) {
                endAngle = MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;
              }
              var path = [x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius];
              var ta;
              while (iteration < 1) {
                ta = endAngle * iteration + startAngle;
                path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);
                iteration += step;
              }
              ta = endAngle + startAngle;
              path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);
              path.push(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius);
              this.pathIndexes = Earcut(path);
              this.pathData = path;
              return this;
            }
          });
          module2.exports = Arc;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CurveRender = __webpack_require__(1094);
          var Earcut = __webpack_require__(68);
          var Rectangle = __webpack_require__(10);
          var Shape = __webpack_require__(33);
          var Curve = new Class({
            Extends: Shape,
            Mixins: [
              CurveRender
            ],
            initialize: function Curve2(scene, x, y, curve, fillColor, fillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              Shape.call(this, scene, "Curve", curve);
              this._smoothness = 32;
              this._curveBounds = new Rectangle();
              this.closePath = false;
              this.setPosition(x, y);
              if (fillColor !== void 0) {
                this.setFillStyle(fillColor, fillAlpha);
              }
              this.updateData();
            },
            smoothness: {
              get: function() {
                return this._smoothness;
              },
              set: function(value) {
                this._smoothness = value;
                this.updateData();
              }
            },
            setSmoothness: function(value) {
              this._smoothness = value;
              return this.updateData();
            },
            updateData: function() {
              var bounds = this._curveBounds;
              var smoothness = this._smoothness;
              this.geom.getBounds(bounds, smoothness);
              this.setSize(bounds.width, bounds.height);
              this.updateDisplayOrigin();
              var path = [];
              var points = this.geom.getPoints(smoothness);
              for (var i = 0; i < points.length; i++) {
                path.push(points[i].x, points[i].y);
              }
              path.push(points[0].x, points[0].y);
              this.pathIndexes = Earcut(path);
              this.pathData = path;
              return this;
            }
          });
          module2.exports = Curve;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Earcut = __webpack_require__(68);
          var EllipseRender = __webpack_require__(1097);
          var GeomEllipse = __webpack_require__(108);
          var Shape = __webpack_require__(33);
          var Ellipse = new Class({
            Extends: Shape,
            Mixins: [
              EllipseRender
            ],
            initialize: function Ellipse2(scene, x, y, width, height, fillColor, fillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 128;
              }
              if (height === void 0) {
                height = 128;
              }
              Shape.call(this, scene, "Ellipse", new GeomEllipse(width / 2, height / 2, width, height));
              this._smoothness = 64;
              this.setPosition(x, y);
              this.width = width;
              this.height = height;
              if (fillColor !== void 0) {
                this.setFillStyle(fillColor, fillAlpha);
              }
              this.updateDisplayOrigin();
              this.updateData();
            },
            smoothness: {
              get: function() {
                return this._smoothness;
              },
              set: function(value) {
                this._smoothness = value;
                this.updateData();
              }
            },
            setSize: function(width, height) {
              this.width = width;
              this.height = height;
              this.geom.setPosition(width / 2, height / 2);
              this.geom.setSize(width, height);
              return this.updateData();
            },
            setSmoothness: function(value) {
              this._smoothness = value;
              return this.updateData();
            },
            updateData: function() {
              var path = [];
              var points = this.geom.getPoints(this._smoothness);
              for (var i = 0; i < points.length; i++) {
                path.push(points[i].x, points[i].y);
              }
              path.push(points[0].x, points[0].y);
              this.pathIndexes = Earcut(path);
              this.pathData = path;
              return this;
            }
          });
          module2.exports = Ellipse;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Shape = __webpack_require__(33);
          var GridRender = __webpack_require__(1100);
          var Grid = new Class({
            Extends: Shape,
            Mixins: [
              GridRender
            ],
            initialize: function Grid2(scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 128;
              }
              if (height === void 0) {
                height = 128;
              }
              if (cellWidth === void 0) {
                cellWidth = 32;
              }
              if (cellHeight === void 0) {
                cellHeight = 32;
              }
              Shape.call(this, scene, "Grid", null);
              this.cellWidth = cellWidth;
              this.cellHeight = cellHeight;
              this.showCells = true;
              this.outlineFillColor = 0;
              this.outlineFillAlpha = 0;
              this.showOutline = true;
              this.showAltCells = false;
              this.altFillColor;
              this.altFillAlpha;
              this.setPosition(x, y);
              this.setSize(width, height);
              this.setFillStyle(fillColor, fillAlpha);
              if (outlineFillColor !== void 0) {
                this.setOutlineStyle(outlineFillColor, outlineFillAlpha);
              }
              this.updateDisplayOrigin();
            },
            setFillStyle: function(fillColor, fillAlpha) {
              if (fillAlpha === void 0) {
                fillAlpha = 1;
              }
              if (fillColor === void 0) {
                this.showCells = false;
              } else {
                this.fillColor = fillColor;
                this.fillAlpha = fillAlpha;
                this.showCells = true;
              }
              return this;
            },
            setAltFillStyle: function(fillColor, fillAlpha) {
              if (fillAlpha === void 0) {
                fillAlpha = 1;
              }
              if (fillColor === void 0) {
                this.showAltCells = false;
              } else {
                this.altFillColor = fillColor;
                this.altFillAlpha = fillAlpha;
                this.showAltCells = true;
              }
              return this;
            },
            setOutlineStyle: function(fillColor, fillAlpha) {
              if (fillAlpha === void 0) {
                fillAlpha = 1;
              }
              if (fillColor === void 0) {
                this.showOutline = false;
              } else {
                this.outlineFillColor = fillColor;
                this.outlineFillAlpha = fillAlpha;
                this.showOutline = true;
              }
              return this;
            }
          });
          module2.exports = Grid;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var IsoBoxRender = __webpack_require__(1103);
          var Class = __webpack_require__(0);
          var Shape = __webpack_require__(33);
          var IsoBox = new Class({
            Extends: Shape,
            Mixins: [
              IsoBoxRender
            ],
            initialize: function IsoBox2(scene, x, y, size, height, fillTop, fillLeft, fillRight) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (size === void 0) {
                size = 48;
              }
              if (height === void 0) {
                height = 32;
              }
              if (fillTop === void 0) {
                fillTop = 15658734;
              }
              if (fillLeft === void 0) {
                fillLeft = 10066329;
              }
              if (fillRight === void 0) {
                fillRight = 13421772;
              }
              Shape.call(this, scene, "IsoBox", null);
              this.projection = 4;
              this.fillTop = fillTop;
              this.fillLeft = fillLeft;
              this.fillRight = fillRight;
              this.showTop = true;
              this.showLeft = true;
              this.showRight = true;
              this.isFilled = true;
              this.setPosition(x, y);
              this.setSize(size, height);
              this.updateDisplayOrigin();
            },
            setProjection: function(value) {
              this.projection = value;
              return this;
            },
            setFaces: function(showTop, showLeft, showRight) {
              if (showTop === void 0) {
                showTop = true;
              }
              if (showLeft === void 0) {
                showLeft = true;
              }
              if (showRight === void 0) {
                showRight = true;
              }
              this.showTop = showTop;
              this.showLeft = showLeft;
              this.showRight = showRight;
              return this;
            },
            setFillStyle: function(fillTop, fillLeft, fillRight) {
              this.fillTop = fillTop;
              this.fillLeft = fillLeft;
              this.fillRight = fillRight;
              this.isFilled = true;
              return this;
            }
          });
          module2.exports = IsoBox;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var IsoTriangleRender = __webpack_require__(1106);
          var Shape = __webpack_require__(33);
          var IsoTriangle = new Class({
            Extends: Shape,
            Mixins: [
              IsoTriangleRender
            ],
            initialize: function IsoTriangle2(scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (size === void 0) {
                size = 48;
              }
              if (height === void 0) {
                height = 32;
              }
              if (reversed === void 0) {
                reversed = false;
              }
              if (fillTop === void 0) {
                fillTop = 15658734;
              }
              if (fillLeft === void 0) {
                fillLeft = 10066329;
              }
              if (fillRight === void 0) {
                fillRight = 13421772;
              }
              Shape.call(this, scene, "IsoTriangle", null);
              this.projection = 4;
              this.fillTop = fillTop;
              this.fillLeft = fillLeft;
              this.fillRight = fillRight;
              this.showTop = true;
              this.showLeft = true;
              this.showRight = true;
              this.isReversed = reversed;
              this.isFilled = true;
              this.setPosition(x, y);
              this.setSize(size, height);
              this.updateDisplayOrigin();
            },
            setProjection: function(value) {
              this.projection = value;
              return this;
            },
            setReversed: function(reversed) {
              this.isReversed = reversed;
              return this;
            },
            setFaces: function(showTop, showLeft, showRight) {
              if (showTop === void 0) {
                showTop = true;
              }
              if (showLeft === void 0) {
                showLeft = true;
              }
              if (showRight === void 0) {
                showRight = true;
              }
              this.showTop = showTop;
              this.showLeft = showLeft;
              this.showRight = showRight;
              return this;
            },
            setFillStyle: function(fillTop, fillLeft, fillRight) {
              this.fillTop = fillTop;
              this.fillLeft = fillLeft;
              this.fillRight = fillRight;
              this.isFilled = true;
              return this;
            }
          });
          module2.exports = IsoTriangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Shape = __webpack_require__(33);
          var GeomLine = __webpack_require__(45);
          var LineRender = __webpack_require__(1109);
          var Line = new Class({
            Extends: Shape,
            Mixins: [
              LineRender
            ],
            initialize: function Line2(scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (x1 === void 0) {
                x1 = 0;
              }
              if (y1 === void 0) {
                y1 = 0;
              }
              if (x2 === void 0) {
                x2 = 128;
              }
              if (y2 === void 0) {
                y2 = 0;
              }
              Shape.call(this, scene, "Line", new GeomLine(x1, y1, x2, y2));
              var width = Math.max(1, this.geom.right - this.geom.left);
              var height = Math.max(1, this.geom.bottom - this.geom.top);
              this.lineWidth = 1;
              this._startWidth = 1;
              this._endWidth = 1;
              this.setPosition(x, y);
              this.setSize(width, height);
              if (strokeColor !== void 0) {
                this.setStrokeStyle(1, strokeColor, strokeAlpha);
              }
              this.updateDisplayOrigin();
            },
            setLineWidth: function(startWidth, endWidth) {
              if (endWidth === void 0) {
                endWidth = startWidth;
              }
              this._startWidth = startWidth;
              this._endWidth = endWidth;
              this.lineWidth = startWidth;
              return this;
            },
            setTo: function(x1, y1, x2, y2) {
              this.geom.setTo(x1, y1, x2, y2);
              return this;
            }
          });
          module2.exports = Line;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PolygonRender = __webpack_require__(1112);
          var Class = __webpack_require__(0);
          var Earcut = __webpack_require__(68);
          var GetAABB = __webpack_require__(463);
          var GeomPolygon = __webpack_require__(224);
          var Shape = __webpack_require__(33);
          var Smooth = __webpack_require__(466);
          var Polygon = new Class({
            Extends: Shape,
            Mixins: [
              PolygonRender
            ],
            initialize: function Polygon2(scene, x, y, points, fillColor, fillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              Shape.call(this, scene, "Polygon", new GeomPolygon(points));
              var bounds = GetAABB(this.geom);
              this.setPosition(x, y);
              this.setSize(bounds.width, bounds.height);
              if (fillColor !== void 0) {
                this.setFillStyle(fillColor, fillAlpha);
              }
              this.updateDisplayOrigin();
              this.updateData();
            },
            smooth: function(iterations) {
              if (iterations === void 0) {
                iterations = 1;
              }
              for (var i = 0; i < iterations; i++) {
                Smooth(this.geom);
              }
              return this.updateData();
            },
            updateData: function() {
              var path = [];
              var points = this.geom.points;
              for (var i = 0; i < points.length; i++) {
                path.push(points[i].x, points[i].y);
              }
              path.push(points[0].x, points[0].y);
              this.pathIndexes = Earcut(path);
              this.pathData = path;
              return this;
            }
          });
          module2.exports = Polygon;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rectangle = __webpack_require__(10);
          var GetAABB = function(polygon, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            var minX = Infinity;
            var minY = Infinity;
            var maxX = -minX;
            var maxY = -minY;
            var p;
            for (var i = 0; i < polygon.points.length; i++) {
              p = polygon.points[i];
              minX = Math.min(minX, p.x);
              minY = Math.min(minY, p.y);
              maxX = Math.max(maxX, p.x);
              maxY = Math.max(maxY, p.y);
            }
            out.x = minX;
            out.y = minY;
            out.width = maxX - minX;
            out.height = maxY - minY;
            return out;
          };
          module2.exports = GetAABB;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Length = __webpack_require__(64);
          var Line = __webpack_require__(45);
          var Perimeter = __webpack_require__(465);
          var GetPoints = function(polygon, quantity, stepRate, out) {
            if (out === void 0) {
              out = [];
            }
            var points = polygon.points;
            var perimeter = Perimeter(polygon);
            if (!quantity && stepRate > 0) {
              quantity = perimeter / stepRate;
            }
            for (var i = 0; i < quantity; i++) {
              var position = perimeter * (i / quantity);
              var accumulatedPerimeter = 0;
              for (var j = 0; j < points.length; j++) {
                var pointA = points[j];
                var pointB = points[(j + 1) % points.length];
                var line = new Line(pointA.x, pointA.y, pointB.x, pointB.y);
                var length = Length(line);
                if (position < accumulatedPerimeter || position > accumulatedPerimeter + length) {
                  accumulatedPerimeter += length;
                  continue;
                }
                var point = line.getPoint((position - accumulatedPerimeter) / length);
                out.push(point);
                break;
              }
            }
            return out;
          };
          module2.exports = GetPoints;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Length = __webpack_require__(64);
          var Line = __webpack_require__(45);
          var Perimeter = function(polygon) {
            var points = polygon.points;
            var perimeter = 0;
            for (var i = 0; i < points.length; i++) {
              var pointA = points[i];
              var pointB = points[(i + 1) % points.length];
              var line = new Line(pointA.x, pointA.y, pointB.x, pointB.y);
              perimeter += Length(line);
            }
            return perimeter;
          };
          module2.exports = Perimeter;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Igor Ognichenko <ognichenko.igor@gmail.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var copy = function(out, a) {
            out[0] = a[0];
            out[1] = a[1];
            return out;
          };
          var Smooth = function(polygon) {
            var i;
            var points = [];
            var data = polygon.points;
            for (i = 0; i < data.length; i++) {
              points.push([data[i].x, data[i].y]);
            }
            var output = [];
            if (points.length > 0) {
              output.push(copy([0, 0], points[0]));
            }
            for (i = 0; i < points.length - 1; i++) {
              var p0 = points[i];
              var p1 = points[i + 1];
              var p0x = p0[0];
              var p0y = p0[1];
              var p1x = p1[0];
              var p1y = p1[1];
              output.push([0.85 * p0x + 0.15 * p1x, 0.85 * p0y + 0.15 * p1y]);
              output.push([0.15 * p0x + 0.85 * p1x, 0.15 * p0y + 0.85 * p1y]);
            }
            if (points.length > 1) {
              output.push(copy([0, 0], points[points.length - 1]));
            }
            return polygon.setTo(output);
          };
          module2.exports = Smooth;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GeomRectangle = __webpack_require__(10);
          var Shape = __webpack_require__(33);
          var RectangleRender = __webpack_require__(1115);
          var Rectangle = new Class({
            Extends: Shape,
            Mixins: [
              RectangleRender
            ],
            initialize: function Rectangle2(scene, x, y, width, height, fillColor, fillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 128;
              }
              if (height === void 0) {
                height = 128;
              }
              Shape.call(this, scene, "Rectangle", new GeomRectangle(0, 0, width, height));
              this.setPosition(x, y);
              this.setSize(width, height);
              if (fillColor !== void 0) {
                this.setFillStyle(fillColor, fillAlpha);
              }
              this.updateDisplayOrigin();
              this.updateData();
            },
            setSize: function(width, height) {
              this.width = width;
              this.height = height;
              this.geom.setSize(width, height);
              this.updateData();
              return this;
            },
            updateData: function() {
              var path = [];
              var rect = this.geom;
              var line = this._tempLine;
              rect.getLineA(line);
              path.push(line.x1, line.y1, line.x2, line.y2);
              rect.getLineB(line);
              path.push(line.x2, line.y2);
              rect.getLineC(line);
              path.push(line.x2, line.y2);
              rect.getLineD(line);
              path.push(line.x2, line.y2);
              this.pathData = path;
              return this;
            }
          });
          module2.exports = Rectangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var StarRender = __webpack_require__(1118);
          var Class = __webpack_require__(0);
          var Earcut = __webpack_require__(68);
          var Shape = __webpack_require__(33);
          var Star = new Class({
            Extends: Shape,
            Mixins: [
              StarRender
            ],
            initialize: function Star2(scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (points === void 0) {
                points = 5;
              }
              if (innerRadius === void 0) {
                innerRadius = 32;
              }
              if (outerRadius === void 0) {
                outerRadius = 64;
              }
              Shape.call(this, scene, "Star", null);
              this._points = points;
              this._innerRadius = innerRadius;
              this._outerRadius = outerRadius;
              this.setPosition(x, y);
              this.setSize(outerRadius * 2, outerRadius * 2);
              if (fillColor !== void 0) {
                this.setFillStyle(fillColor, fillAlpha);
              }
              this.updateDisplayOrigin();
              this.updateData();
            },
            setPoints: function(value) {
              this._points = value;
              return this.updateData();
            },
            setInnerRadius: function(value) {
              this._innerRadius = value;
              return this.updateData();
            },
            setOuterRadius: function(value) {
              this._outerRadius = value;
              return this.updateData();
            },
            points: {
              get: function() {
                return this._points;
              },
              set: function(value) {
                this._points = value;
                this.updateData();
              }
            },
            innerRadius: {
              get: function() {
                return this._innerRadius;
              },
              set: function(value) {
                this._innerRadius = value;
                this.updateData();
              }
            },
            outerRadius: {
              get: function() {
                return this._outerRadius;
              },
              set: function(value) {
                this._outerRadius = value;
                this.updateData();
              }
            },
            updateData: function() {
              var path = [];
              var points = this._points;
              var innerRadius = this._innerRadius;
              var outerRadius = this._outerRadius;
              var rot = Math.PI / 2 * 3;
              var step = Math.PI / points;
              var x = outerRadius;
              var y = outerRadius;
              path.push(x, y + -outerRadius);
              for (var i = 0; i < points; i++) {
                path.push(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius);
                rot += step;
                path.push(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius);
                rot += step;
              }
              path.push(x, y + -outerRadius);
              this.pathIndexes = Earcut(path);
              this.pathData = path;
              return this;
            }
          });
          module2.exports = Star;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Shape = __webpack_require__(33);
          var GeomTriangle = __webpack_require__(82);
          var TriangleRender = __webpack_require__(1121);
          var Triangle = new Class({
            Extends: Shape,
            Mixins: [
              TriangleRender
            ],
            initialize: function Triangle2(scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (x1 === void 0) {
                x1 = 0;
              }
              if (y1 === void 0) {
                y1 = 128;
              }
              if (x2 === void 0) {
                x2 = 64;
              }
              if (y2 === void 0) {
                y2 = 0;
              }
              if (x3 === void 0) {
                x3 = 128;
              }
              if (y3 === void 0) {
                y3 = 128;
              }
              Shape.call(this, scene, "Triangle", new GeomTriangle(x1, y1, x2, y2, x3, y3));
              var width = this.geom.right - this.geom.left;
              var height = this.geom.bottom - this.geom.top;
              this.setPosition(x, y);
              this.setSize(width, height);
              if (fillColor !== void 0) {
                this.setFillStyle(fillColor, fillAlpha);
              }
              this.updateDisplayOrigin();
              this.updateData();
            },
            setTo: function(x1, y1, x2, y2, x3, y3) {
              this.geom.setTo(x1, y1, x2, y2, x3, y3);
              return this.updateData();
            },
            updateData: function() {
              var path = [];
              var tri = this.geom;
              var line = this._tempLine;
              tri.getLineA(line);
              path.push(line.x1, line.y1, line.x2, line.y2);
              tri.getLineB(line);
              path.push(line.x2, line.y2);
              tri.getLineC(line);
              path.push(line.x2, line.y2);
              this.pathData = path;
              return this;
            }
          });
          module2.exports = Triangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var Length = __webpack_require__(64);
          var GetPoint = function(triangle, position, out) {
            if (out === void 0) {
              out = new Point();
            }
            var line1 = triangle.getLineA();
            var line2 = triangle.getLineB();
            var line3 = triangle.getLineC();
            if (position <= 0 || position >= 1) {
              out.x = line1.x1;
              out.y = line1.y1;
              return out;
            }
            var length1 = Length(line1);
            var length2 = Length(line2);
            var length3 = Length(line3);
            var perimeter = length1 + length2 + length3;
            var p = perimeter * position;
            var localPosition = 0;
            if (p < length1) {
              localPosition = p / length1;
              out.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;
              out.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;
            } else if (p > length1 + length2) {
              p -= length1 + length2;
              localPosition = p / length3;
              out.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;
              out.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;
            } else {
              p -= length1;
              localPosition = p / length2;
              out.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;
              out.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;
            }
            return out;
          };
          module2.exports = GetPoint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Length = __webpack_require__(64);
          var Point = __webpack_require__(4);
          var GetPoints = function(triangle, quantity, stepRate, out) {
            if (out === void 0) {
              out = [];
            }
            var line1 = triangle.getLineA();
            var line2 = triangle.getLineB();
            var line3 = triangle.getLineC();
            var length1 = Length(line1);
            var length2 = Length(line2);
            var length3 = Length(line3);
            var perimeter = length1 + length2 + length3;
            if (!quantity && stepRate > 0) {
              quantity = perimeter / stepRate;
            }
            for (var i = 0; i < quantity; i++) {
              var p = perimeter * (i / quantity);
              var localPosition = 0;
              var point = new Point();
              if (p < length1) {
                localPosition = p / length1;
                point.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;
                point.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;
              } else if (p > length1 + length2) {
                p -= length1 + length2;
                localPosition = p / length3;
                point.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;
                point.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;
              } else {
                p -= length1;
                localPosition = p / length2;
                point.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;
                point.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;
              }
              out.push(point);
            }
            return out;
          };
          module2.exports = GetPoints;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetValue = function(source, key, value) {
            if (!source || typeof source === "number") {
              return false;
            } else if (source.hasOwnProperty(key)) {
              source[key] = value;
              return true;
            } else if (key.indexOf(".") !== -1) {
              var keys = key.split(".");
              var parent = source;
              var prev = source;
              for (var i = 0; i < keys.length; i++) {
                if (parent.hasOwnProperty(keys[i])) {
                  prev = parent;
                  parent = parent[keys[i]];
                } else {
                  return false;
                }
              }
              prev[keys[keys.length - 1]] = value;
              return true;
            }
            return false;
          };
          module2.exports = SetValue;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Face = __webpack_require__(113);
          var Vertex = __webpack_require__(115);
          var GenerateVerts = function(vertices, uvs, indicies, containsZ, normals, colors, alphas) {
            if (containsZ === void 0) {
              containsZ = false;
            }
            if (colors === void 0) {
              colors = 16777215;
            }
            if (alphas === void 0) {
              alphas = 1;
            }
            if (vertices.length !== uvs.length) {
              console.warn("GenerateVerts: vertices and uvs count not equal");
              return;
            }
            var result = {
              faces: [],
              vertices: []
            };
            var i;
            var x;
            var y;
            var z;
            var u;
            var v;
            var color;
            var alpha;
            var normalX;
            var normalY;
            var normalZ;
            var iInc = containsZ ? 3 : 2;
            var isColorArray = Array.isArray(colors);
            var isAlphaArray = Array.isArray(alphas);
            if (Array.isArray(indicies) && indicies.length > 0) {
              for (i = 0; i < indicies.length; i++) {
                var index1 = indicies[i];
                var index2 = indicies[i] * 2;
                var index3 = indicies[i] * iInc;
                x = vertices[index3];
                y = vertices[index3 + 1];
                z = containsZ ? vertices[index3 + 2] : 0;
                u = uvs[index2];
                v = uvs[index2 + 1];
                color = isColorArray ? colors[index1] : colors;
                alpha = isAlphaArray ? alphas[index1] : alphas;
                normalX = 0;
                normalY = 0;
                normalZ = 0;
                if (normals) {
                  normalX = normals[index3];
                  normalY = normals[index3 + 1];
                  normalZ = containsZ ? normals[index3 + 2] : 0;
                }
                result.vertices.push(new Vertex(x, y, z, u, v, color, alpha, normalX, normalY, normalZ));
              }
            } else {
              var uvIndex = 0;
              var colorIndex = 0;
              for (i = 0; i < vertices.length; i += iInc) {
                x = vertices[i];
                y = vertices[i + 1];
                z = containsZ ? vertices[i + 2] : 0;
                u = uvs[uvIndex];
                v = uvs[uvIndex + 1];
                color = isColorArray ? colors[colorIndex] : colors;
                alpha = isAlphaArray ? alphas[colorIndex] : alphas;
                normalX = 0;
                normalY = 0;
                normalZ = 0;
                if (normals) {
                  normalX = normals[i];
                  normalY = normals[i + 1];
                  normalZ = containsZ ? normals[i + 2] : 0;
                }
                result.vertices.push(new Vertex(x, y, z, u, v, color, alpha, normalX, normalY, normalZ));
                uvIndex += 2;
                colorIndex++;
              }
            }
            for (i = 0; i < result.vertices.length; i += 3) {
              var vert1 = result.vertices[i];
              var vert2 = result.vertices[i + 1];
              var vert3 = result.vertices[i + 2];
              result.faces.push(new Face(vert1, vert2, vert3));
            }
            return result;
          };
          module2.exports = GenerateVerts;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Face = __webpack_require__(113);
          var Matrix4 = __webpack_require__(67);
          var Vector3 = __webpack_require__(38);
          var Vertex = __webpack_require__(115);
          var tempPosition = new Vector3();
          var tempRotation = new Vector3();
          var tempMatrix = new Matrix4();
          var GenerateObjVerts = function(data, mesh, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp) {
            if (scale === void 0) {
              scale = 1;
            }
            if (x === void 0) {
              x = 0;
            }
            if (y === void 0) {
              y = 0;
            }
            if (z === void 0) {
              z = 0;
            }
            if (rotateX === void 0) {
              rotateX = 0;
            }
            if (rotateY === void 0) {
              rotateY = 0;
            }
            if (rotateZ === void 0) {
              rotateZ = 0;
            }
            if (zIsUp === void 0) {
              zIsUp = true;
            }
            var result = {
              faces: [],
              verts: []
            };
            var materials = data.materials;
            tempPosition.set(x, y, z);
            tempRotation.set(rotateX, rotateY, rotateZ);
            tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);
            for (var m = 0; m < data.models.length; m++) {
              var model = data.models[m];
              var vertices = model.vertices;
              var textureCoords = model.textureCoords;
              var faces = model.faces;
              for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                var v1 = face.vertices[0];
                var v2 = face.vertices[1];
                var v3 = face.vertices[2];
                var m1 = vertices[v1.vertexIndex];
                var m2 = vertices[v2.vertexIndex];
                var m3 = vertices[v3.vertexIndex];
                var t1 = v1.textureCoordsIndex;
                var t2 = v2.textureCoordsIndex;
                var t3 = v3.textureCoordsIndex;
                var uv1 = t1 === -1 ? {u: 0, v: 1} : textureCoords[t1];
                var uv2 = t2 === -1 ? {u: 0, v: 0} : textureCoords[t2];
                var uv3 = t3 === -1 ? {u: 1, v: 1} : textureCoords[t3];
                var color = 16777215;
                if (face.material !== "" && materials[face.material]) {
                  color = materials[face.material];
                }
                var vert1 = new Vertex(m1.x * scale, m1.y * scale, m1.z * scale, uv1.u, uv1.v, color).transformMat4(tempMatrix);
                var vert2 = new Vertex(m2.x * scale, m2.y * scale, m2.z * scale, uv2.u, uv2.v, color).transformMat4(tempMatrix);
                var vert3 = new Vertex(m3.x * scale, m3.y * scale, m3.z * scale, uv3.u, uv3.v, color).transformMat4(tempMatrix);
                result.verts.push(vert1, vert2, vert3);
                result.faces.push(new Face(vert1, vert2, vert3));
              }
            }
            if (mesh) {
              mesh.faces = mesh.faces.concat(result.faces);
              mesh.vertices = mesh.vertices.concat(result.verts);
            }
            return result;
          };
          module2.exports = GenerateObjVerts;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Circle = __webpack_require__(62);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var RGB = __webpack_require__(197);
          var Utils = __webpack_require__(12);
          var Light = new Class({
            Extends: Circle,
            Mixins: [
              Components.ScrollFactor,
              Components.Visible
            ],
            initialize: function Light2(x, y, radius, r, g, b, intensity) {
              Circle.call(this, x, y, radius);
              this.color = new RGB(r, g, b);
              this.intensity = intensity;
              this.renderFlags = 15;
              this.cameraFilter = 0;
              this.setScrollFactor(1, 1);
            },
            willRender: function(camera) {
              return !(Light.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
            },
            setColor: function(rgb) {
              var color = Utils.getFloatsFromUintRGB(rgb);
              this.color.set(color[0], color[1], color[2]);
              return this;
            },
            setIntensity: function(intensity) {
              this.intensity = intensity;
              return this;
            },
            setRadius: function(radius) {
              this.radius = radius;
              return this;
            }
          });
          Light.RENDER_MASK = 15;
          module2.exports = Light;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CircleToRectangle = __webpack_require__(150);
          var Class = __webpack_require__(0);
          var DistanceBetween = __webpack_require__(48);
          var Light = __webpack_require__(475);
          var PointLight = __webpack_require__(149);
          var RGB = __webpack_require__(197);
          var SpliceOne = __webpack_require__(74);
          var StableSort = __webpack_require__(79);
          var Utils = __webpack_require__(12);
          var LightsManager = new Class({
            initialize: function LightsManager2() {
              this.lights = [];
              this.ambientColor = new RGB(0.1, 0.1, 0.1);
              this.active = false;
              this.maxLights = -1;
              this.visibleLights = 0;
            },
            addPointLight: function(x, y, color, radius, intensity) {
              return this.systems.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity));
            },
            enable: function() {
              if (this.maxLights === -1) {
                this.maxLights = this.scene.sys.renderer.config.maxLights;
              }
              this.active = true;
              return this;
            },
            disable: function() {
              this.active = false;
              return this;
            },
            getLights: function(camera) {
              var lights = this.lights;
              var worldView = camera.worldView;
              var visibleLights = [];
              for (var i = 0; i < lights.length; i++) {
                var light = lights[i];
                if (light.willRender(camera) && CircleToRectangle(light, worldView)) {
                  visibleLights.push({
                    light,
                    distance: DistanceBetween(light.x, light.y, worldView.centerX, worldView.centerY)
                  });
                }
              }
              if (visibleLights.length > this.maxLights) {
                StableSort(visibleLights, this.sortByDistance);
                visibleLights = visibleLights.slice(0, this.maxLights);
              }
              this.visibleLights = visibleLights.length;
              return visibleLights;
            },
            sortByDistance: function(a, b) {
              return a.distance >= b.distance;
            },
            setAmbientColor: function(rgb) {
              var color = Utils.getFloatsFromUintRGB(rgb);
              this.ambientColor.set(color[0], color[1], color[2]);
              return this;
            },
            getMaxVisibleLights: function() {
              return this.maxLights;
            },
            getLightCount: function() {
              return this.lights.length;
            },
            addLight: function(x, y, radius, rgb, intensity) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (radius === void 0) {
                radius = 128;
              }
              if (rgb === void 0) {
                rgb = 16777215;
              }
              if (intensity === void 0) {
                intensity = 1;
              }
              var color = Utils.getFloatsFromUintRGB(rgb);
              var light = new Light(x, y, radius, color[0], color[1], color[2], intensity);
              this.lights.push(light);
              return light;
            },
            removeLight: function(light) {
              var index = this.lights.indexOf(light);
              if (index >= 0) {
                SpliceOne(this.lights, index);
              }
              return this;
            },
            shutdown: function() {
              this.lights.length = 0;
            },
            destroy: function() {
              this.shutdown();
            }
          });
          module2.exports = LightsManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(55);
          var Extend = __webpack_require__(17);
          var Geom = {
            Circle: __webpack_require__(1185),
            Ellipse: __webpack_require__(1195),
            Intersects: __webpack_require__(478),
            Line: __webpack_require__(1215),
            Mesh: __webpack_require__(1237),
            Point: __webpack_require__(1240),
            Polygon: __webpack_require__(1254),
            Rectangle: __webpack_require__(496),
            Triangle: __webpack_require__(1287)
          };
          Geom = Extend(false, Geom, CONST);
          module2.exports = Geom;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            CircleToCircle: __webpack_require__(228),
            CircleToRectangle: __webpack_require__(150),
            GetCircleToCircle: __webpack_require__(1205),
            GetCircleToRectangle: __webpack_require__(1206),
            GetLineToCircle: __webpack_require__(229),
            GetLineToLine: __webpack_require__(479),
            GetLineToPoints: __webpack_require__(480),
            GetLineToPolygon: __webpack_require__(481),
            GetLineToRectangle: __webpack_require__(231),
            GetRaysFromPointToPolygon: __webpack_require__(1207),
            GetRectangleIntersection: __webpack_require__(1208),
            GetRectangleToRectangle: __webpack_require__(1209),
            GetRectangleToTriangle: __webpack_require__(1210),
            GetTriangleToCircle: __webpack_require__(1211),
            GetTriangleToLine: __webpack_require__(486),
            GetTriangleToTriangle: __webpack_require__(1212),
            LineToCircle: __webpack_require__(230),
            LineToLine: __webpack_require__(92),
            LineToRectangle: __webpack_require__(482),
            PointToLine: __webpack_require__(490),
            PointToLineSegment: __webpack_require__(1213),
            RectangleToRectangle: __webpack_require__(114),
            RectangleToTriangle: __webpack_require__(483),
            RectangleToValues: __webpack_require__(1214),
            TriangleToCircle: __webpack_require__(485),
            TriangleToLine: __webpack_require__(487),
            TriangleToTriangle: __webpack_require__(488)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector3 = __webpack_require__(38);
          var GetLineToLine = function(line1, line2, out) {
            var x1 = line1.x1;
            var y1 = line1.y1;
            var x2 = line1.x2;
            var y2 = line1.y2;
            var x3 = line2.x1;
            var y3 = line2.y1;
            var x4 = line2.x2;
            var y4 = line2.y2;
            var dx1 = x2 - x1;
            var dy1 = y2 - y1;
            var dx2 = x4 - x3;
            var dy2 = y4 - y3;
            var denom = dy2 * dx1 - dx2 * dy1;
            if (dx1 === 0 || denom === 0) {
              return false;
            }
            var T2 = (dx1 * (y3 - y1) + dy1 * (x1 - x3)) / (dx2 * dy1 - dy2 * dx1);
            var T1 = (x3 + dx2 * T2 - x1) / dx1;
            if (T1 < 0 || T2 < 0 || T2 > 1) {
              return null;
            }
            if (out === void 0) {
              out = new Vector3();
            }
            return out.set(x1 + dx1 * T1, y1 + dy1 * T1, T1);
          };
          module2.exports = GetLineToLine;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector3 = __webpack_require__(38);
          var GetLineToLine = __webpack_require__(479);
          var Line = __webpack_require__(45);
          var segment = new Line();
          var tempIntersect = new Vector3();
          var GetLineToPoints = function(line, points, out) {
            if (out === void 0) {
              out = new Vector3();
            }
            var closestIntersect = false;
            out.set();
            tempIntersect.set();
            var prev = points[0];
            for (var i = 1; i < points.length; i++) {
              var current = points[i];
              segment.setTo(prev.x, prev.y, current.x, current.y);
              prev = current;
              if (GetLineToLine(line, segment, tempIntersect)) {
                if (!closestIntersect || tempIntersect.z < out.z) {
                  out.copy(tempIntersect);
                  closestIntersect = true;
                }
              }
            }
            return closestIntersect ? out : null;
          };
          module2.exports = GetLineToPoints;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector3 = __webpack_require__(38);
          var Vector4 = __webpack_require__(138);
          var GetLineToPoints = __webpack_require__(480);
          var tempIntersect = new Vector3();
          var GetLineToPolygon = function(line, polygons, out) {
            if (out === void 0) {
              out = new Vector4();
            }
            if (!Array.isArray(polygons)) {
              polygons = [polygons];
            }
            var closestIntersect = false;
            out.set();
            tempIntersect.set();
            for (var i = 0; i < polygons.length; i++) {
              if (GetLineToPoints(line, polygons[i].points, tempIntersect)) {
                if (!closestIntersect || tempIntersect.z < out.z) {
                  out.set(tempIntersect.x, tempIntersect.y, tempIntersect.z, i);
                  closestIntersect = true;
                }
              }
            }
            return closestIntersect ? out : null;
          };
          module2.exports = GetLineToPolygon;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var LineToRectangle = function(line, rect) {
            var x1 = line.x1;
            var y1 = line.y1;
            var x2 = line.x2;
            var y2 = line.y2;
            var bx1 = rect.x;
            var by1 = rect.y;
            var bx2 = rect.right;
            var by2 = rect.bottom;
            var t = 0;
            if (x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2 || x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2) {
              return true;
            }
            if (x1 < bx1 && x2 >= bx1) {
              t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);
              if (t > by1 && t <= by2) {
                return true;
              }
            } else if (x1 > bx2 && x2 <= bx2) {
              t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);
              if (t >= by1 && t <= by2) {
                return true;
              }
            }
            if (y1 < by1 && y2 >= by1) {
              t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);
              if (t >= bx1 && t <= bx2) {
                return true;
              }
            } else if (y1 > by2 && y2 <= by2) {
              t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);
              if (t >= bx1 && t <= bx2) {
                return true;
              }
            }
            return false;
          };
          module2.exports = LineToRectangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var LineToLine = __webpack_require__(92);
          var Contains = __webpack_require__(56);
          var ContainsArray = __webpack_require__(232);
          var Decompose = __webpack_require__(484);
          var RectangleToTriangle = function(rect, triangle) {
            if (triangle.left > rect.right || triangle.right < rect.left || triangle.top > rect.bottom || triangle.bottom < rect.top) {
              return false;
            }
            var triA = triangle.getLineA();
            var triB = triangle.getLineB();
            var triC = triangle.getLineC();
            if (Contains(rect, triA.x1, triA.y1) || Contains(rect, triA.x2, triA.y2)) {
              return true;
            }
            if (Contains(rect, triB.x1, triB.y1) || Contains(rect, triB.x2, triB.y2)) {
              return true;
            }
            if (Contains(rect, triC.x1, triC.y1) || Contains(rect, triC.x2, triC.y2)) {
              return true;
            }
            var rectA = rect.getLineA();
            var rectB = rect.getLineB();
            var rectC = rect.getLineC();
            var rectD = rect.getLineD();
            if (LineToLine(triA, rectA) || LineToLine(triA, rectB) || LineToLine(triA, rectC) || LineToLine(triA, rectD)) {
              return true;
            }
            if (LineToLine(triB, rectA) || LineToLine(triB, rectB) || LineToLine(triB, rectC) || LineToLine(triB, rectD)) {
              return true;
            }
            if (LineToLine(triC, rectA) || LineToLine(triC, rectB) || LineToLine(triC, rectC) || LineToLine(triC, rectD)) {
              return true;
            }
            var points = Decompose(rect);
            var within = ContainsArray(triangle, points, true);
            return within.length > 0;
          };
          module2.exports = RectangleToTriangle;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Decompose = function(rect, out) {
            if (out === void 0) {
              out = [];
            }
            out.push({x: rect.x, y: rect.y});
            out.push({x: rect.right, y: rect.y});
            out.push({x: rect.right, y: rect.bottom});
            out.push({x: rect.x, y: rect.bottom});
            return out;
          };
          module2.exports = Decompose;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var LineToCircle = __webpack_require__(230);
          var Contains = __webpack_require__(112);
          var TriangleToCircle = function(triangle, circle) {
            if (triangle.left > circle.right || triangle.right < circle.left || triangle.top > circle.bottom || triangle.bottom < circle.top) {
              return false;
            }
            if (Contains(triangle, circle.x, circle.y)) {
              return true;
            }
            if (LineToCircle(triangle.getLineA(), circle)) {
              return true;
            }
            if (LineToCircle(triangle.getLineB(), circle)) {
              return true;
            }
            if (LineToCircle(triangle.getLineC(), circle)) {
              return true;
            }
            return false;
          };
          module2.exports = TriangleToCircle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Florian Vazelle
           * @author       Geoffrey Glaive
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var TriangleToLine = __webpack_require__(487);
          var LineToLine = __webpack_require__(92);
          var GetTriangleToLine = function(triangle, line, out) {
            if (out === void 0) {
              out = [];
            }
            if (TriangleToLine(triangle, line)) {
              var lineA = triangle.getLineA();
              var lineB = triangle.getLineB();
              var lineC = triangle.getLineC();
              var output = [new Point(), new Point(), new Point()];
              var result = [
                LineToLine(lineA, line, output[0]),
                LineToLine(lineB, line, output[1]),
                LineToLine(lineC, line, output[2])
              ];
              for (var i = 0; i < 3; i++) {
                if (result[i]) {
                  out.push(output[i]);
                }
              }
            }
            return out;
          };
          module2.exports = GetTriangleToLine;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var LineToLine = __webpack_require__(92);
          var TriangleToLine = function(triangle, line) {
            if (triangle.contains(line.x1, line.y1) || triangle.contains(line.x2, line.y2)) {
              return true;
            }
            if (LineToLine(triangle.getLineA(), line)) {
              return true;
            }
            if (LineToLine(triangle.getLineB(), line)) {
              return true;
            }
            if (LineToLine(triangle.getLineC(), line)) {
              return true;
            }
            return false;
          };
          module2.exports = TriangleToLine;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ContainsArray = __webpack_require__(232);
          var Decompose = __webpack_require__(489);
          var LineToLine = __webpack_require__(92);
          var TriangleToTriangle = function(triangleA, triangleB) {
            if (triangleA.left > triangleB.right || triangleA.right < triangleB.left || triangleA.top > triangleB.bottom || triangleA.bottom < triangleB.top) {
              return false;
            }
            var lineAA = triangleA.getLineA();
            var lineAB = triangleA.getLineB();
            var lineAC = triangleA.getLineC();
            var lineBA = triangleB.getLineA();
            var lineBB = triangleB.getLineB();
            var lineBC = triangleB.getLineC();
            if (LineToLine(lineAA, lineBA) || LineToLine(lineAA, lineBB) || LineToLine(lineAA, lineBC)) {
              return true;
            }
            if (LineToLine(lineAB, lineBA) || LineToLine(lineAB, lineBB) || LineToLine(lineAB, lineBC)) {
              return true;
            }
            if (LineToLine(lineAC, lineBA) || LineToLine(lineAC, lineBB) || LineToLine(lineAC, lineBC)) {
              return true;
            }
            var points = Decompose(triangleA);
            var within = ContainsArray(triangleB, points, true);
            if (within.length > 0) {
              return true;
            }
            points = Decompose(triangleB);
            within = ContainsArray(triangleA, points, true);
            if (within.length > 0) {
              return true;
            }
            return false;
          };
          module2.exports = TriangleToTriangle;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Decompose = function(triangle, out) {
            if (out === void 0) {
              out = [];
            }
            out.push({x: triangle.x1, y: triangle.y1});
            out.push({x: triangle.x2, y: triangle.y2});
            out.push({x: triangle.x3, y: triangle.y3});
            return out;
          };
          module2.exports = Decompose;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Florian Mertens
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PointToLine = function(point, line, lineThickness) {
            if (lineThickness === void 0) {
              lineThickness = 1;
            }
            var x1 = line.x1;
            var y1 = line.y1;
            var x2 = line.x2;
            var y2 = line.y2;
            var px = point.x;
            var py = point.y;
            var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            if (L2 === 0) {
              return false;
            }
            var r = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / L2;
            if (r < 0) {
              return Math.sqrt((x1 - px) * (x1 - px) + (y1 - py) * (y1 - py)) <= lineThickness;
            } else if (r >= 0 && r <= 1) {
              var s = ((y1 - py) * (x2 - x1) - (x1 - px) * (y2 - y1)) / L2;
              return Math.abs(s) * Math.sqrt(L2) <= lineThickness;
            } else {
              return Math.sqrt((x2 - px) * (x2 - px) + (y2 - py) * (y2 - py)) <= lineThickness;
            }
          };
          module2.exports = PointToLine;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MATH_CONST = __webpack_require__(14);
          var Wrap = __webpack_require__(66);
          var Angle = __webpack_require__(93);
          var NormalAngle = function(line) {
            var angle = Angle(line) - MATH_CONST.TAU;
            return Wrap(angle, -Math.PI, Math.PI);
          };
          module2.exports = NormalAngle;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var flip = true;
          var defaultModelName = "untitled";
          var currentGroup = "";
          var currentMaterial = "";
          function stripComments(line) {
            var idx = line.indexOf("#");
            return idx > -1 ? line.substring(0, idx) : line;
          }
          function currentModel(result) {
            if (result.models.length === 0) {
              result.models.push({
                faces: [],
                name: defaultModelName,
                textureCoords: [],
                vertexNormals: [],
                vertices: []
              });
            }
            currentGroup = "";
            return result.models[result.models.length - 1];
          }
          function parseObject(lineItems, result) {
            var modelName = lineItems.length >= 2 ? lineItems[1] : defaultModelName;
            result.models.push({
              faces: [],
              name: modelName,
              textureCoords: [],
              vertexNormals: [],
              vertices: []
            });
            currentGroup = "";
          }
          function parseGroup(lineItems) {
            if (lineItems.length === 2) {
              currentGroup = lineItems[1];
            }
          }
          function parseVertexCoords(lineItems, result) {
            var len = lineItems.length;
            var x = len >= 2 ? parseFloat(lineItems[1]) : 0;
            var y = len >= 3 ? parseFloat(lineItems[2]) : 0;
            var z = len >= 4 ? parseFloat(lineItems[3]) : 0;
            currentModel(result).vertices.push({x, y, z});
          }
          function parseTextureCoords(lineItems, result) {
            var len = lineItems.length;
            var u = len >= 2 ? parseFloat(lineItems[1]) : 0;
            var v = len >= 3 ? parseFloat(lineItems[2]) : 0;
            var w = len >= 4 ? parseFloat(lineItems[3]) : 0;
            if (isNaN(u)) {
              u = 0;
            }
            if (isNaN(v)) {
              v = 0;
            }
            if (isNaN(w)) {
              w = 0;
            }
            if (flip) {
              v = 1 - v;
            }
            currentModel(result).textureCoords.push({u, v, w});
          }
          function parseVertexNormal(lineItems, result) {
            var len = lineItems.length;
            var x = len >= 2 ? parseFloat(lineItems[1]) : 0;
            var y = len >= 3 ? parseFloat(lineItems[2]) : 0;
            var z = len >= 4 ? parseFloat(lineItems[3]) : 0;
            currentModel(result).vertexNormals.push({x, y, z});
          }
          function parsePolygon(lineItems, result) {
            var totalVertices = lineItems.length - 1;
            if (totalVertices < 3) {
              return;
            }
            var face = {
              group: currentGroup,
              material: currentMaterial,
              vertices: []
            };
            for (var i = 0; i < totalVertices; i++) {
              var vertexString = lineItems[i + 1];
              var vertexValues = vertexString.split("/");
              var vvLen = vertexValues.length;
              if (vvLen < 1 || vvLen > 3) {
                continue;
              }
              var vertexIndex = 0;
              var textureCoordsIndex = 0;
              var vertexNormalIndex = 0;
              vertexIndex = parseInt(vertexValues[0], 10);
              if (vvLen > 1 && vertexValues[1] !== "") {
                textureCoordsIndex = parseInt(vertexValues[1], 10);
              }
              if (vvLen > 2) {
                vertexNormalIndex = parseInt(vertexValues[2], 10);
              }
              if (vertexIndex !== 0) {
                if (vertexIndex < 0) {
                  vertexIndex = currentModel(result).vertices.length + 1 + vertexIndex;
                }
                textureCoordsIndex -= 1;
                vertexIndex -= 1;
                vertexNormalIndex -= 1;
                face.vertices.push({
                  textureCoordsIndex,
                  vertexIndex,
                  vertexNormalIndex
                });
              }
            }
            currentModel(result).faces.push(face);
          }
          function parseMtlLib(lineItems, result) {
            if (lineItems.length >= 2) {
              result.materialLibraries.push(lineItems[1]);
            }
          }
          function parseUseMtl(lineItems) {
            if (lineItems.length >= 2) {
              currentMaterial = lineItems[1];
            }
          }
          var ParseObj = function(data, flipUV) {
            if (flipUV === void 0) {
              flipUV = true;
            }
            flip = flipUV;
            var result = {
              materials: {},
              materialLibraries: [],
              models: []
            };
            currentGroup = "";
            currentMaterial = "";
            var lines = data.split("\n");
            for (var i = 0; i < lines.length; i++) {
              var line = stripComments(lines[i]);
              var lineItems = line.replace(/\s\s+/g, " ").trim().split(" ");
              switch (lineItems[0].toLowerCase()) {
                case "o":
                  parseObject(lineItems, result);
                  break;
                case "g":
                  parseGroup(lineItems);
                  break;
                case "v":
                  parseVertexCoords(lineItems, result);
                  break;
                case "vt":
                  parseTextureCoords(lineItems, result);
                  break;
                case "vn":
                  parseVertexNormal(lineItems, result);
                  break;
                case "f":
                  parsePolygon(lineItems, result);
                  break;
                case "mtllib":
                  parseMtlLib(lineItems, result);
                  break;
                case "usemtl":
                  parseUseMtl(lineItems);
                  break;
              }
            }
            return result;
          };
          module2.exports = ParseObj;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetColor = __webpack_require__(100);
          var ParseObjMaterial = function(mtl) {
            var output = {};
            var lines = mtl.split("\n");
            var currentMaterial = "";
            for (var i = 0; i < lines.length; i++) {
              var line = lines[i].trim();
              if (line.indexOf("#") === 0 || line === "") {
                continue;
              }
              var lineItems = line.replace(/\s\s+/g, " ").trim().split(" ");
              switch (lineItems[0].toLowerCase()) {
                case "newmtl": {
                  currentMaterial = lineItems[1];
                  break;
                }
                case "kd": {
                  var r = Math.floor(lineItems[1] * 255);
                  var g = lineItems.length >= 2 ? Math.floor(lineItems[2] * 255) : r;
                  var b = lineItems.length >= 3 ? Math.floor(lineItems[3] * 255) : r;
                  output[currentMaterial] = GetColor(r, g, b);
                  break;
                }
              }
            }
            return output;
          };
          module2.exports = ParseObjMaterial;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetMagnitude = function(point) {
            return Math.sqrt(point.x * point.x + point.y * point.y);
          };
          module2.exports = GetMagnitude;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetMagnitudeSq = function(point) {
            return point.x * point.x + point.y * point.y;
          };
          module2.exports = GetMagnitudeSq;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rectangle = __webpack_require__(10);
          Rectangle.Area = __webpack_require__(1261);
          Rectangle.Ceil = __webpack_require__(1262);
          Rectangle.CeilAll = __webpack_require__(1263);
          Rectangle.CenterOn = __webpack_require__(187);
          Rectangle.Clone = __webpack_require__(1264);
          Rectangle.Contains = __webpack_require__(56);
          Rectangle.ContainsPoint = __webpack_require__(1265);
          Rectangle.ContainsRect = __webpack_require__(497);
          Rectangle.CopyFrom = __webpack_require__(1266);
          Rectangle.Decompose = __webpack_require__(484);
          Rectangle.Equals = __webpack_require__(1267);
          Rectangle.FitInside = __webpack_require__(1268);
          Rectangle.FitOutside = __webpack_require__(1269);
          Rectangle.Floor = __webpack_require__(1270);
          Rectangle.FloorAll = __webpack_require__(1271);
          Rectangle.FromPoints = __webpack_require__(196);
          Rectangle.FromXY = __webpack_require__(1272);
          Rectangle.GetAspectRatio = __webpack_require__(234);
          Rectangle.GetCenter = __webpack_require__(1273);
          Rectangle.GetPoint = __webpack_require__(167);
          Rectangle.GetPoints = __webpack_require__(300);
          Rectangle.GetSize = __webpack_require__(1274);
          Rectangle.Inflate = __webpack_require__(1275);
          Rectangle.Intersection = __webpack_require__(1276);
          Rectangle.MarchingAnts = __webpack_require__(310);
          Rectangle.MergePoints = __webpack_require__(1277);
          Rectangle.MergeRect = __webpack_require__(1278);
          Rectangle.MergeXY = __webpack_require__(1279);
          Rectangle.Offset = __webpack_require__(1280);
          Rectangle.OffsetPoint = __webpack_require__(1281);
          Rectangle.Overlaps = __webpack_require__(1282);
          Rectangle.Perimeter = __webpack_require__(128);
          Rectangle.PerimeterPoint = __webpack_require__(1283);
          Rectangle.Random = __webpack_require__(170);
          Rectangle.RandomOutside = __webpack_require__(1284);
          Rectangle.SameDimensions = __webpack_require__(1285);
          Rectangle.Scale = __webpack_require__(1286);
          Rectangle.Union = __webpack_require__(435);
          module2.exports = Rectangle;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ContainsRect = function(rectA, rectB) {
            if (rectB.width * rectB.height > rectA.width * rectA.height) {
              return false;
            }
            return rectB.x > rectA.x && rectB.x < rectA.right && (rectB.right > rectA.x && rectB.right < rectA.right) && (rectB.y > rectA.y && rectB.y < rectA.bottom) && (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom);
          };
          module2.exports = ContainsRect;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var Centroid = function(triangle, out) {
            if (out === void 0) {
              out = new Point();
            }
            out.x = (triangle.x1 + triangle.x2 + triangle.x3) / 3;
            out.y = (triangle.y1 + triangle.y2 + triangle.y3) / 3;
            return out;
          };
          module2.exports = Centroid;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Offset = function(triangle, x, y) {
            triangle.x1 += x;
            triangle.y1 += y;
            triangle.x2 += x;
            triangle.y2 += y;
            triangle.x3 += x;
            triangle.y3 += y;
            return triangle;
          };
          module2.exports = Offset;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          function getLength(x1, y1, x2, y2) {
            var x = x1 - x2;
            var y = y1 - y2;
            var magnitude = x * x + y * y;
            return Math.sqrt(magnitude);
          }
          var InCenter = function(triangle, out) {
            if (out === void 0) {
              out = new Point();
            }
            var x1 = triangle.x1;
            var y1 = triangle.y1;
            var x2 = triangle.x2;
            var y2 = triangle.y2;
            var x3 = triangle.x3;
            var y3 = triangle.y3;
            var d1 = getLength(x3, y3, x2, y2);
            var d2 = getLength(x1, y1, x3, y3);
            var d3 = getLength(x2, y2, x1, y1);
            var p = d1 + d2 + d3;
            out.x = (x1 * d1 + x2 * d2 + x3 * d3) / p;
            out.y = (y1 * d1 + y2 * d2 + y3 * d3) / p;
            return out;
          };
          module2.exports = InCenter;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CreatePixelPerfectHandler = function(textureManager, alphaTolerance) {
            return function(hitArea, x, y, gameObject) {
              var alpha = textureManager.getPixelAlpha(x, y, gameObject.texture.key, gameObject.frame.name);
              return alpha && alpha >= alphaTolerance;
            };
          };
          module2.exports = CreatePixelPerfectHandler;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CreateInteractiveObject = function(gameObject, hitArea, hitAreaCallback) {
            return {
              gameObject,
              enabled: true,
              alwaysEnabled: false,
              draggable: false,
              dropZone: false,
              cursor: false,
              target: null,
              camera: null,
              hitArea,
              hitAreaCallback,
              hitAreaDebug: null,
              customHitArea: false,
              localX: 0,
              localY: 0,
              dragState: 0,
              dragStartX: 0,
              dragStartY: 0,
              dragStartXGlobal: 0,
              dragStartYGlobal: 0,
              dragX: 0,
              dragY: 0
            };
          };
          module2.exports = CreateInteractiveObject;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Axis = new Class({
            initialize: function Axis2(pad, index) {
              this.pad = pad;
              this.events = pad.events;
              this.index = index;
              this.value = 0;
              this.threshold = 0.1;
            },
            update: function(value) {
              this.value = value;
            },
            getValue: function() {
              return Math.abs(this.value) < this.threshold ? 0 : this.value;
            },
            destroy: function() {
              this.pad = null;
              this.events = null;
            }
          });
          module2.exports = Axis;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(236);
          var Button = new Class({
            initialize: function Button2(pad, index) {
              this.pad = pad;
              this.events = pad.manager;
              this.index = index;
              this.value = 0;
              this.threshold = 1;
              this.pressed = false;
            },
            update: function(value) {
              this.value = value;
              var pad = this.pad;
              var index = this.index;
              if (value >= this.threshold) {
                if (!this.pressed) {
                  this.pressed = true;
                  this.events.emit(Events.BUTTON_DOWN, pad, this, value);
                  this.pad.emit(Events.GAMEPAD_BUTTON_DOWN, index, value, this);
                }
              } else if (this.pressed) {
                this.pressed = false;
                this.events.emit(Events.BUTTON_UP, pad, this, value);
                this.pad.emit(Events.GAMEPAD_BUTTON_UP, index, value, this);
              }
            },
            destroy: function() {
              this.pad = null;
              this.events = null;
            }
          });
          module2.exports = Button;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Axis = __webpack_require__(503);
          var Button = __webpack_require__(504);
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Vector29 = __webpack_require__(3);
          var Gamepad = new Class({
            Extends: EventEmitter,
            initialize: function Gamepad2(manager, pad) {
              EventEmitter.call(this);
              this.manager = manager;
              this.pad = pad;
              this.id = pad.id;
              this.index = pad.index;
              var buttons = [];
              for (var i = 0; i < pad.buttons.length; i++) {
                buttons.push(new Button(this, i));
              }
              this.buttons = buttons;
              var axes = [];
              for (i = 0; i < pad.axes.length; i++) {
                axes.push(new Axis(this, i));
              }
              this.axes = axes;
              this.vibration = pad.vibrationActuator;
              var _noButton = {value: 0, pressed: false};
              this._LCLeft = buttons[14] ? buttons[14] : _noButton;
              this._LCRight = buttons[15] ? buttons[15] : _noButton;
              this._LCTop = buttons[12] ? buttons[12] : _noButton;
              this._LCBottom = buttons[13] ? buttons[13] : _noButton;
              this._RCLeft = buttons[2] ? buttons[2] : _noButton;
              this._RCRight = buttons[1] ? buttons[1] : _noButton;
              this._RCTop = buttons[3] ? buttons[3] : _noButton;
              this._RCBottom = buttons[0] ? buttons[0] : _noButton;
              this._FBLeftTop = buttons[4] ? buttons[4] : _noButton;
              this._FBLeftBottom = buttons[6] ? buttons[6] : _noButton;
              this._FBRightTop = buttons[5] ? buttons[5] : _noButton;
              this._FBRightBottom = buttons[7] ? buttons[7] : _noButton;
              var _noAxis = {value: 0};
              this._HAxisLeft = axes[0] ? axes[0] : _noAxis;
              this._VAxisLeft = axes[1] ? axes[1] : _noAxis;
              this._HAxisRight = axes[2] ? axes[2] : _noAxis;
              this._VAxisRight = axes[3] ? axes[3] : _noAxis;
              this.leftStick = new Vector29();
              this.rightStick = new Vector29();
              this._created = performance.now();
            },
            getAxisTotal: function() {
              return this.axes.length;
            },
            getAxisValue: function(index) {
              return this.axes[index].getValue();
            },
            setAxisThreshold: function(value) {
              for (var i = 0; i < this.axes.length; i++) {
                this.axes[i].threshold = value;
              }
            },
            getButtonTotal: function() {
              return this.buttons.length;
            },
            getButtonValue: function(index) {
              return this.buttons[index].value;
            },
            isButtonDown: function(index) {
              return this.buttons[index].pressed;
            },
            update: function(pad) {
              if (pad.timestamp < this._created) {
                return;
              }
              var i;
              var localButtons = this.buttons;
              var gamepadButtons = pad.buttons;
              var len = localButtons.length;
              for (i = 0; i < len; i++) {
                localButtons[i].update(gamepadButtons[i].value);
              }
              var localAxes = this.axes;
              var gamepadAxes = pad.axes;
              len = localAxes.length;
              for (i = 0; i < len; i++) {
                localAxes[i].update(gamepadAxes[i]);
              }
              if (len >= 2) {
                this.leftStick.set(localAxes[0].getValue(), localAxes[1].getValue());
                if (len >= 4) {
                  this.rightStick.set(localAxes[2].getValue(), localAxes[3].getValue());
                }
              }
            },
            destroy: function() {
              this.removeAllListeners();
              this.manager = null;
              this.pad = null;
              var i;
              for (i = 0; i < this.buttons.length; i++) {
                this.buttons[i].destroy();
              }
              for (i = 0; i < this.axes.length; i++) {
                this.axes[i].destroy();
              }
              this.buttons = [];
              this.axes = [];
            },
            connected: {
              get: function() {
                return this.pad.connected;
              }
            },
            timestamp: {
              get: function() {
                return this.pad.timestamp;
              }
            },
            left: {
              get: function() {
                return this._LCLeft.pressed;
              }
            },
            right: {
              get: function() {
                return this._LCRight.pressed;
              }
            },
            up: {
              get: function() {
                return this._LCTop.pressed;
              }
            },
            down: {
              get: function() {
                return this._LCBottom.pressed;
              }
            },
            A: {
              get: function() {
                return this._RCBottom.pressed;
              }
            },
            Y: {
              get: function() {
                return this._RCTop.pressed;
              }
            },
            X: {
              get: function() {
                return this._RCLeft.pressed;
              }
            },
            B: {
              get: function() {
                return this._RCRight.pressed;
              }
            },
            L1: {
              get: function() {
                return this._FBLeftTop.value;
              }
            },
            L2: {
              get: function() {
                return this._FBLeftBottom.value;
              }
            },
            R1: {
              get: function() {
                return this._FBRightTop.value;
              }
            },
            R2: {
              get: function() {
                return this._FBRightBottom.value;
              }
            }
          });
          module2.exports = Gamepad;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(152);
          var Key = new Class({
            Extends: EventEmitter,
            initialize: function Key2(plugin, keyCode) {
              EventEmitter.call(this);
              this.plugin = plugin;
              this.keyCode = keyCode;
              this.originalEvent = void 0;
              this.enabled = true;
              this.isDown = false;
              this.isUp = true;
              this.altKey = false;
              this.ctrlKey = false;
              this.shiftKey = false;
              this.metaKey = false;
              this.location = 0;
              this.timeDown = 0;
              this.duration = 0;
              this.timeUp = 0;
              this.emitOnRepeat = false;
              this.repeats = 0;
              this._justDown = false;
              this._justUp = false;
              this._tick = -1;
            },
            setEmitOnRepeat: function(value) {
              this.emitOnRepeat = value;
              return this;
            },
            onDown: function(event) {
              this.originalEvent = event;
              if (!this.enabled) {
                return;
              }
              this.altKey = event.altKey;
              this.ctrlKey = event.ctrlKey;
              this.shiftKey = event.shiftKey;
              this.metaKey = event.metaKey;
              this.location = event.location;
              this.repeats++;
              if (!this.isDown) {
                this.isDown = true;
                this.isUp = false;
                this.timeDown = event.timeStamp;
                this.duration = 0;
                this._justDown = true;
                this._justUp = false;
                this.emit(Events.DOWN, this, event);
              } else if (this.emitOnRepeat) {
                this.emit(Events.DOWN, this, event);
              }
            },
            onUp: function(event) {
              this.originalEvent = event;
              if (!this.enabled) {
                return;
              }
              this.isDown = false;
              this.isUp = true;
              this.timeUp = event.timeStamp;
              this.duration = this.timeUp - this.timeDown;
              this.repeats = 0;
              this._justDown = false;
              this._justUp = true;
              this._tick = -1;
              this.emit(Events.UP, this, event);
            },
            reset: function() {
              this.preventDefault = true;
              this.enabled = true;
              this.isDown = false;
              this.isUp = true;
              this.altKey = false;
              this.ctrlKey = false;
              this.shiftKey = false;
              this.metaKey = false;
              this.timeDown = 0;
              this.duration = 0;
              this.timeUp = 0;
              this.repeats = 0;
              this._justDown = false;
              this._justUp = false;
              this._tick = -1;
              return this;
            },
            getDuration: function() {
              if (this.isDown) {
                return this.plugin.game.loop.time - this.timeDown;
              } else {
                return 0;
              }
            },
            destroy: function() {
              this.removeAllListeners();
              this.originalEvent = null;
              this.plugin = null;
            }
          });
          module2.exports = Key;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(152);
          var GetFastValue = __webpack_require__(2);
          var ProcessKeyCombo = __webpack_require__(508);
          var ResetKeyCombo = __webpack_require__(510);
          var KeyCombo = new Class({
            initialize: function KeyCombo2(keyboardPlugin, keys, config2) {
              if (config2 === void 0) {
                config2 = {};
              }
              if (keys.length < 2) {
                return false;
              }
              this.manager = keyboardPlugin;
              this.enabled = true;
              this.keyCodes = [];
              for (var i = 0; i < keys.length; i++) {
                var char = keys[i];
                if (typeof char === "string") {
                  this.keyCodes.push(char.toUpperCase().charCodeAt(0));
                } else if (typeof char === "number") {
                  this.keyCodes.push(char);
                } else if (char.hasOwnProperty("keyCode")) {
                  this.keyCodes.push(char.keyCode);
                }
              }
              this.current = this.keyCodes[0];
              this.index = 0;
              this.size = this.keyCodes.length;
              this.timeLastMatched = 0;
              this.matched = false;
              this.timeMatched = 0;
              this.resetOnWrongKey = GetFastValue(config2, "resetOnWrongKey", true);
              this.maxKeyDelay = GetFastValue(config2, "maxKeyDelay", 0);
              this.resetOnMatch = GetFastValue(config2, "resetOnMatch", false);
              this.deleteOnMatch = GetFastValue(config2, "deleteOnMatch", false);
              var _this = this;
              var onKeyDownHandler = function(event) {
                if (_this.matched || !_this.enabled) {
                  return;
                }
                var matched = ProcessKeyCombo(event, _this);
                if (matched) {
                  _this.manager.emit(Events.COMBO_MATCH, _this, event);
                  if (_this.resetOnMatch) {
                    ResetKeyCombo(_this);
                  } else if (_this.deleteOnMatch) {
                    _this.destroy();
                  }
                }
              };
              this.onKeyDown = onKeyDownHandler;
              this.manager.on(Events.ANY_KEY_DOWN, this.onKeyDown);
            },
            progress: {
              get: function() {
                return this.index / this.size;
              }
            },
            destroy: function() {
              this.enabled = false;
              this.keyCodes = [];
              this.manager.off(Events.ANY_KEY_DOWN, this.onKeyDown);
              this.manager = null;
            }
          });
          module2.exports = KeyCombo;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AdvanceKeyCombo = __webpack_require__(509);
          var ProcessKeyCombo = function(event, combo) {
            if (combo.matched) {
              return true;
            }
            var comboMatched = false;
            var keyMatched = false;
            if (event.keyCode === combo.current) {
              if (combo.index > 0 && combo.maxKeyDelay > 0) {
                var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;
                if (event.timeStamp <= timeLimit) {
                  keyMatched = true;
                  comboMatched = AdvanceKeyCombo(event, combo);
                }
              } else {
                keyMatched = true;
                comboMatched = AdvanceKeyCombo(event, combo);
              }
            }
            if (!keyMatched && combo.resetOnWrongKey) {
              combo.index = 0;
              combo.current = combo.keyCodes[0];
            }
            if (comboMatched) {
              combo.timeLastMatched = event.timeStamp;
              combo.matched = true;
              combo.timeMatched = event.timeStamp;
            }
            return comboMatched;
          };
          module2.exports = ProcessKeyCombo;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AdvanceKeyCombo = function(event, combo) {
            combo.timeLastMatched = event.timeStamp;
            combo.index++;
            if (combo.index === combo.size) {
              return true;
            } else {
              combo.current = combo.keyCodes[combo.index];
              return false;
            }
          };
          module2.exports = AdvanceKeyCombo;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ResetKeyCombo = function(combo) {
            combo.current = combo.keyCodes[0];
            combo.index = 0;
            combo.timeLastMatched = 0;
            combo.matched = false;
            combo.timeMatched = 0;
            return combo;
          };
          module2.exports = ResetKeyCombo;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MergeXHRSettings = __webpack_require__(237);
          var XHRLoader = function(file, globalXHRSettings) {
            var config2 = MergeXHRSettings(globalXHRSettings, file.xhrSettings);
            var xhr = new XMLHttpRequest();
            xhr.open("GET", file.src, config2.async, config2.user, config2.password);
            xhr.responseType = file.xhrSettings.responseType;
            xhr.timeout = config2.timeout;
            if (config2.headers) {
              for (var key in config2.headers) {
                xhr.setRequestHeader(key, config2.headers[key]);
              }
            }
            if (config2.header && config2.headerValue) {
              xhr.setRequestHeader(config2.header, config2.headerValue);
            }
            if (config2.requestedWith) {
              xhr.setRequestHeader("X-Requested-With", config2.requestedWith);
            }
            if (config2.overrideMimeType) {
              xhr.overrideMimeType(config2.overrideMimeType);
            }
            if (config2.withCredentials) {
              xhr.withCredentials = true;
            }
            xhr.onload = file.onLoad.bind(file, xhr);
            xhr.onerror = file.onError.bind(file, xhr);
            xhr.onprogress = file.onProgress.bind(file);
            xhr.send();
            return xhr;
          };
          module2.exports = XHRLoader;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var HTML5AudioFile = __webpack_require__(513);
          var IsPlainObject = __webpack_require__(7);
          var AudioFile = new Class({
            Extends: File,
            initialize: function AudioFile2(loader, key, urlConfig, xhrSettings, audioContext) {
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                audioContext = GetFastValue(config2, "context", audioContext);
              }
              var fileConfig = {
                type: "audio",
                cache: loader.cacheManager.audio,
                extension: urlConfig.type,
                responseType: "arraybuffer",
                key,
                url: urlConfig.url,
                xhrSettings,
                config: {context: audioContext}
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              var _this = this;
              this.config.context.decodeAudioData(this.xhrLoader.response, function(audioBuffer) {
                _this.data = audioBuffer;
                _this.onProcessComplete();
              }, function(e) {
                console.error("Error decoding audio: " + _this.key + " - ", e ? e.message : null);
                _this.onProcessError();
              });
              this.config.context = null;
            }
          });
          AudioFile.create = function(loader, key, urls, config2, xhrSettings) {
            var game = loader.systems.game;
            var audioConfig = game.config.audio;
            var deviceAudio = game.device.audio;
            if (IsPlainObject(key)) {
              urls = GetFastValue(key, "url", []);
              config2 = GetFastValue(key, "config", {});
            }
            var urlConfig = AudioFile.getAudioURL(game, urls);
            if (!urlConfig) {
              return null;
            }
            if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
              return new AudioFile(loader, key, urlConfig, xhrSettings, game.sound.context);
            } else {
              return new HTML5AudioFile(loader, key, urlConfig, config2);
            }
          };
          AudioFile.getAudioURL = function(game, urls) {
            if (!Array.isArray(urls)) {
              urls = [urls];
            }
            for (var i = 0; i < urls.length; i++) {
              var url = GetFastValue(urls[i], "url", urls[i]);
              if (url.indexOf("blob:") === 0 || url.indexOf("data:") === 0) {
                return {
                  url,
                  type: ""
                };
              }
              var audioType = url.match(/\.([a-zA-Z0-9]+)($|\?)/);
              audioType = GetFastValue(urls[i], "type", audioType ? audioType[1] : "").toLowerCase();
              if (game.device.audio[audioType]) {
                return {
                  url,
                  type: audioType
                };
              }
            }
            return null;
          };
          FileTypesManager.register("audio", function(key, urls, config2, xhrSettings) {
            var game = this.systems.game;
            var audioConfig = game.config.audio;
            var deviceAudio = game.device.audio;
            if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
              return this;
            }
            var audioFile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                audioFile = AudioFile.create(this, key[i]);
                if (audioFile) {
                  this.addFile(audioFile);
                }
              }
            } else {
              audioFile = AudioFile.create(this, key, urls, config2, xhrSettings);
              if (audioFile) {
                this.addFile(audioFile);
              }
            }
            return this;
          });
          module2.exports = AudioFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(91);
          var File = __webpack_require__(23);
          var GetFastValue = __webpack_require__(2);
          var GetURL = __webpack_require__(153);
          var IsPlainObject = __webpack_require__(7);
          var HTML5AudioFile = new Class({
            Extends: File,
            initialize: function HTML5AudioFile2(loader, key, urlConfig, audioConfig) {
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                audioConfig = GetFastValue(config2, "config", audioConfig);
              }
              var fileConfig = {
                type: "audio",
                cache: loader.cacheManager.audio,
                extension: urlConfig.type,
                key,
                url: urlConfig.url,
                config: audioConfig
              };
              File.call(this, loader, fileConfig);
              this.locked = "ontouchstart" in window;
              this.loaded = false;
              this.filesLoaded = 0;
              this.filesTotal = 0;
            },
            onLoad: function() {
              if (this.loaded) {
                return;
              }
              this.loaded = true;
              this.loader.nextFile(this, true);
            },
            onError: function() {
              for (var i = 0; i < this.data.length; i++) {
                var audio = this.data[i];
                audio.oncanplaythrough = null;
                audio.onerror = null;
              }
              this.loader.nextFile(this, false);
            },
            onProgress: function(event) {
              var audio = event.target;
              audio.oncanplaythrough = null;
              audio.onerror = null;
              this.filesLoaded++;
              this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1);
              this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);
              if (this.filesLoaded === this.filesTotal) {
                this.onLoad();
              }
            },
            load: function() {
              this.data = [];
              var instances = this.config && this.config.instances || 1;
              this.filesTotal = instances;
              this.filesLoaded = 0;
              this.percentComplete = 0;
              for (var i = 0; i < instances; i++) {
                var audio = new Audio();
                if (!audio.dataset) {
                  audio.dataset = {};
                }
                audio.dataset.name = this.key + ("0" + i).slice(-2);
                audio.dataset.used = "false";
                if (this.locked) {
                  audio.dataset.locked = "true";
                } else {
                  audio.dataset.locked = "false";
                  audio.preload = "auto";
                  audio.oncanplaythrough = this.onProgress.bind(this);
                  audio.onerror = this.onError.bind(this);
                }
                this.data.push(audio);
              }
              for (i = 0; i < this.data.length; i++) {
                audio = this.data[i];
                audio.src = GetURL(this, this.loader.baseURL);
                if (!this.locked) {
                  audio.load();
                }
              }
              if (this.locked) {
                setTimeout(this.onLoad.bind(this));
              }
            }
          });
          module2.exports = HTML5AudioFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var ScriptFile = new Class({
            Extends: File,
            initialize: function ScriptFile2(loader, key, url, xhrSettings) {
              var extension = "js";
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
              }
              var fileConfig = {
                type: "script",
                cache: false,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              this.data = document.createElement("script");
              this.data.language = "javascript";
              this.data.type = "text/javascript";
              this.data.defer = false;
              this.data.text = this.xhrLoader.responseText;
              document.head.appendChild(this.data);
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("script", function(key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new ScriptFile(this, key[i]));
              }
            } else {
              this.addFile(new ScriptFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = ScriptFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ArcadeImage = __webpack_require__(516);
          var ArcadeSprite = __webpack_require__(155);
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(60);
          var PhysicsGroup = __webpack_require__(518);
          var StaticPhysicsGroup = __webpack_require__(519);
          var Factory = new Class({
            initialize: function Factory2(world) {
              this.world = world;
              this.scene = world.scene;
              this.sys = world.scene.sys;
            },
            collider: function(object1, object2, collideCallback, processCallback, callbackContext) {
              return this.world.addCollider(object1, object2, collideCallback, processCallback, callbackContext);
            },
            overlap: function(object1, object2, collideCallback, processCallback, callbackContext) {
              return this.world.addOverlap(object1, object2, collideCallback, processCallback, callbackContext);
            },
            existing: function(gameObject, isStatic) {
              var type = isStatic ? CONST.STATIC_BODY : CONST.DYNAMIC_BODY;
              this.world.enableBody(gameObject, type);
              return gameObject;
            },
            staticImage: function(x, y, key, frame) {
              var image = new ArcadeImage(this.scene, x, y, key, frame);
              this.sys.displayList.add(image);
              this.world.enableBody(image, CONST.STATIC_BODY);
              return image;
            },
            image: function(x, y, key, frame) {
              var image = new ArcadeImage(this.scene, x, y, key, frame);
              this.sys.displayList.add(image);
              this.world.enableBody(image, CONST.DYNAMIC_BODY);
              return image;
            },
            staticSprite: function(x, y, key, frame) {
              var sprite = new ArcadeSprite(this.scene, x, y, key, frame);
              this.sys.displayList.add(sprite);
              this.sys.updateList.add(sprite);
              this.world.enableBody(sprite, CONST.STATIC_BODY);
              return sprite;
            },
            sprite: function(x, y, key, frame) {
              var sprite = new ArcadeSprite(this.scene, x, y, key, frame);
              this.sys.displayList.add(sprite);
              this.sys.updateList.add(sprite);
              this.world.enableBody(sprite, CONST.DYNAMIC_BODY);
              return sprite;
            },
            staticGroup: function(children, config2) {
              return this.sys.updateList.add(new StaticPhysicsGroup(this.world, this.world.scene, children, config2));
            },
            group: function(children, config2) {
              return this.sys.updateList.add(new PhysicsGroup(this.world, this.world.scene, children, config2));
            },
            destroy: function() {
              this.world = null;
              this.scene = null;
              this.sys = null;
            }
          });
          module2.exports = Factory;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(240);
          var Image2 = __webpack_require__(124);
          var ArcadeImage = new Class({
            Extends: Image2,
            Mixins: [
              Components.Acceleration,
              Components.Angular,
              Components.Bounce,
              Components.Debug,
              Components.Drag,
              Components.Enable,
              Components.Friction,
              Components.Gravity,
              Components.Immovable,
              Components.Mass,
              Components.Pushable,
              Components.Size,
              Components.Velocity
            ],
            initialize: function ArcadeImage2(scene, x, y, texture, frame) {
              Image2.call(this, scene, x, y, texture, frame);
              this.body = null;
            }
          });
          module2.exports = ArcadeImage;
        },
        function(module2, exports2, __webpack_require__) {
          var OverlapRect = __webpack_require__(241);
          var Circle = __webpack_require__(62);
          var CircleToCircle = __webpack_require__(228);
          var CircleToRectangle = __webpack_require__(150);
          var OverlapCirc = function(world, x, y, radius, includeDynamic, includeStatic) {
            var bodiesInRect = OverlapRect(world, x - radius, y - radius, 2 * radius, 2 * radius, includeDynamic, includeStatic);
            if (bodiesInRect.length === 0) {
              return bodiesInRect;
            }
            var area = new Circle(x, y, radius);
            var circFromBody = new Circle();
            var bodiesInArea = [];
            for (var i = 0; i < bodiesInRect.length; i++) {
              var body = bodiesInRect[i];
              if (body.isCircle) {
                circFromBody.setTo(body.center.x, body.center.y, body.halfWidth);
                if (CircleToCircle(area, circFromBody)) {
                  bodiesInArea.push(body);
                }
              } else if (CircleToRectangle(area, body)) {
                bodiesInArea.push(body);
              }
            }
            return bodiesInArea;
          };
          module2.exports = OverlapCirc;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ArcadeSprite = __webpack_require__(155);
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(60);
          var GetFastValue = __webpack_require__(2);
          var Group = __webpack_require__(110);
          var IsPlainObject = __webpack_require__(7);
          var PhysicsGroup = new Class({
            Extends: Group,
            initialize: function PhysicsGroup2(world, scene, children, config2) {
              if (!children && !config2) {
                config2 = {
                  internalCreateCallback: this.createCallbackHandler,
                  internalRemoveCallback: this.removeCallbackHandler
                };
              } else if (IsPlainObject(children)) {
                config2 = children;
                children = null;
                config2.internalCreateCallback = this.createCallbackHandler;
                config2.internalRemoveCallback = this.removeCallbackHandler;
              } else if (Array.isArray(children) && IsPlainObject(children[0])) {
                config2 = children[0];
                var _this = this;
                children.forEach(function(singleConfig) {
                  singleConfig.internalCreateCallback = _this.createCallbackHandler;
                  singleConfig.internalRemoveCallback = _this.removeCallbackHandler;
                });
                children = null;
              } else {
                config2 = {
                  internalCreateCallback: this.createCallbackHandler,
                  internalRemoveCallback: this.removeCallbackHandler
                };
              }
              this.world = world;
              config2.classType = GetFastValue(config2, "classType", ArcadeSprite);
              this.physicsType = CONST.DYNAMIC_BODY;
              this.defaults = {
                setCollideWorldBounds: GetFastValue(config2, "collideWorldBounds", false),
                setBoundsRectangle: GetFastValue(config2, "customBoundsRectangle", null),
                setAccelerationX: GetFastValue(config2, "accelerationX", 0),
                setAccelerationY: GetFastValue(config2, "accelerationY", 0),
                setAllowDrag: GetFastValue(config2, "allowDrag", true),
                setAllowGravity: GetFastValue(config2, "allowGravity", true),
                setAllowRotation: GetFastValue(config2, "allowRotation", true),
                setBounceX: GetFastValue(config2, "bounceX", 0),
                setBounceY: GetFastValue(config2, "bounceY", 0),
                setDragX: GetFastValue(config2, "dragX", 0),
                setDragY: GetFastValue(config2, "dragY", 0),
                setEnable: GetFastValue(config2, "enable", true),
                setGravityX: GetFastValue(config2, "gravityX", 0),
                setGravityY: GetFastValue(config2, "gravityY", 0),
                setFrictionX: GetFastValue(config2, "frictionX", 0),
                setFrictionY: GetFastValue(config2, "frictionY", 0),
                setMaxVelocityX: GetFastValue(config2, "maxVelocityX", 1e4),
                setMaxVelocityY: GetFastValue(config2, "maxVelocityY", 1e4),
                setVelocityX: GetFastValue(config2, "velocityX", 0),
                setVelocityY: GetFastValue(config2, "velocityY", 0),
                setAngularVelocity: GetFastValue(config2, "angularVelocity", 0),
                setAngularAcceleration: GetFastValue(config2, "angularAcceleration", 0),
                setAngularDrag: GetFastValue(config2, "angularDrag", 0),
                setMass: GetFastValue(config2, "mass", 1),
                setImmovable: GetFastValue(config2, "immovable", false)
              };
              Group.call(this, scene, children, config2);
              this.type = "PhysicsGroup";
            },
            createCallbackHandler: function(child) {
              if (!child.body) {
                this.world.enableBody(child, CONST.DYNAMIC_BODY);
              }
              var body = child.body;
              for (var key in this.defaults) {
                body[key](this.defaults[key]);
              }
            },
            removeCallbackHandler: function(child) {
              if (child.body) {
                this.world.disableBody(child);
              }
            },
            setVelocity: function(x, y, step) {
              if (step === void 0) {
                step = 0;
              }
              var items = this.getChildren();
              for (var i = 0; i < items.length; i++) {
                items[i].body.velocity.set(x + i * step, y + i * step);
              }
              return this;
            },
            setVelocityX: function(value, step) {
              if (step === void 0) {
                step = 0;
              }
              var items = this.getChildren();
              for (var i = 0; i < items.length; i++) {
                items[i].body.velocity.x = value + i * step;
              }
              return this;
            },
            setVelocityY: function(value, step) {
              if (step === void 0) {
                step = 0;
              }
              var items = this.getChildren();
              for (var i = 0; i < items.length; i++) {
                items[i].body.velocity.y = value + i * step;
              }
              return this;
            }
          });
          module2.exports = PhysicsGroup;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ArcadeSprite = __webpack_require__(155);
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(60);
          var GetFastValue = __webpack_require__(2);
          var Group = __webpack_require__(110);
          var IsPlainObject = __webpack_require__(7);
          var StaticPhysicsGroup = new Class({
            Extends: Group,
            initialize: function StaticPhysicsGroup2(world, scene, children, config2) {
              if (!children && !config2) {
                config2 = {
                  internalCreateCallback: this.createCallbackHandler,
                  internalRemoveCallback: this.removeCallbackHandler,
                  createMultipleCallback: this.createMultipleCallbackHandler,
                  classType: ArcadeSprite
                };
              } else if (IsPlainObject(children)) {
                config2 = children;
                children = null;
                config2.internalCreateCallback = this.createCallbackHandler;
                config2.internalRemoveCallback = this.removeCallbackHandler;
                config2.createMultipleCallback = this.createMultipleCallbackHandler;
                config2.classType = GetFastValue(config2, "classType", ArcadeSprite);
              } else if (Array.isArray(children) && IsPlainObject(children[0])) {
                config2 = children;
                children = null;
                config2.forEach(function(singleConfig) {
                  singleConfig.internalCreateCallback = this.createCallbackHandler;
                  singleConfig.internalRemoveCallback = this.removeCallbackHandler;
                  singleConfig.createMultipleCallback = this.createMultipleCallbackHandler;
                  singleConfig.classType = GetFastValue(singleConfig, "classType", ArcadeSprite);
                });
              } else {
                config2 = {
                  internalCreateCallback: this.createCallbackHandler,
                  internalRemoveCallback: this.removeCallbackHandler
                };
              }
              this.world = world;
              this.physicsType = CONST.STATIC_BODY;
              Group.call(this, scene, children, config2);
              this.type = "StaticPhysicsGroup";
            },
            createCallbackHandler: function(child) {
              if (!child.body) {
                this.world.enableBody(child, CONST.STATIC_BODY);
              }
            },
            removeCallbackHandler: function(child) {
              if (child.body) {
                this.world.disableBody(child);
              }
            },
            createMultipleCallbackHandler: function() {
              this.refresh();
            },
            refresh: function() {
              var children = this.children.entries;
              for (var i = 0; i < children.length; i++) {
                children[i].body.reset();
              }
              return this;
            }
          });
          module2.exports = StaticPhysicsGroup;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AngleBetweenPoints = __webpack_require__(344);
          var Body = __webpack_require__(521);
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Collider = __webpack_require__(522);
          var CONST = __webpack_require__(60);
          var DistanceBetween = __webpack_require__(48);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(242);
          var FuzzyEqual = __webpack_require__(123);
          var FuzzyGreaterThan = __webpack_require__(348);
          var FuzzyLessThan = __webpack_require__(349);
          var GetOverlapX = __webpack_require__(243);
          var GetOverlapY = __webpack_require__(244);
          var GetTilesWithinWorldXY = __webpack_require__(523);
          var GetValue = __webpack_require__(6);
          var MATH_CONST = __webpack_require__(14);
          var ProcessQueue = __webpack_require__(208);
          var ProcessTileCallbacks = __webpack_require__(524);
          var Rectangle = __webpack_require__(10);
          var RTree = __webpack_require__(525);
          var SeparateTile = __webpack_require__(526);
          var SeparateX = __webpack_require__(531);
          var SeparateY = __webpack_require__(532);
          var Set2 = __webpack_require__(148);
          var StaticBody = __webpack_require__(533);
          var TileIntersectsBody = __webpack_require__(245);
          var TransformMatrix = __webpack_require__(25);
          var Vector29 = __webpack_require__(3);
          var Wrap = __webpack_require__(66);
          var World = new Class({
            Extends: EventEmitter,
            initialize: function World2(scene, config2) {
              EventEmitter.call(this);
              this.scene = scene;
              this.bodies = new Set2();
              this.staticBodies = new Set2();
              this.pendingDestroy = new Set2();
              this.colliders = new ProcessQueue();
              this.gravity = new Vector29(GetValue(config2, "gravity.x", 0), GetValue(config2, "gravity.y", 0));
              this.bounds = new Rectangle(GetValue(config2, "x", 0), GetValue(config2, "y", 0), GetValue(config2, "width", scene.sys.scale.width), GetValue(config2, "height", scene.sys.scale.height));
              this.checkCollision = {
                up: GetValue(config2, "checkCollision.up", true),
                down: GetValue(config2, "checkCollision.down", true),
                left: GetValue(config2, "checkCollision.left", true),
                right: GetValue(config2, "checkCollision.right", true)
              };
              this.fps = GetValue(config2, "fps", 60);
              this.fixedStep = GetValue(config2, "fixedStep", true);
              this._elapsed = 0;
              this._frameTime = 1 / this.fps;
              this._frameTimeMS = 1e3 * this._frameTime;
              this.stepsLastFrame = 0;
              this.timeScale = GetValue(config2, "timeScale", 1);
              this.OVERLAP_BIAS = GetValue(config2, "overlapBias", 4);
              this.TILE_BIAS = GetValue(config2, "tileBias", 16);
              this.forceX = GetValue(config2, "forceX", false);
              this.isPaused = GetValue(config2, "isPaused", false);
              this._total = 0;
              this.drawDebug = GetValue(config2, "debug", false);
              this.debugGraphic;
              this.defaults = {
                debugShowBody: GetValue(config2, "debugShowBody", true),
                debugShowStaticBody: GetValue(config2, "debugShowStaticBody", true),
                debugShowVelocity: GetValue(config2, "debugShowVelocity", true),
                bodyDebugColor: GetValue(config2, "debugBodyColor", 16711935),
                staticBodyDebugColor: GetValue(config2, "debugStaticBodyColor", 255),
                velocityDebugColor: GetValue(config2, "debugVelocityColor", 65280)
              };
              this.maxEntries = GetValue(config2, "maxEntries", 16);
              this.useTree = GetValue(config2, "useTree", true);
              this.tree = new RTree(this.maxEntries);
              this.staticTree = new RTree(this.maxEntries);
              this.treeMinMax = {minX: 0, minY: 0, maxX: 0, maxY: 0};
              this._tempMatrix = new TransformMatrix();
              this._tempMatrix2 = new TransformMatrix();
              if (this.drawDebug) {
                this.createDebugGraphic();
              }
            },
            enable: function(object, bodyType) {
              if (bodyType === void 0) {
                bodyType = CONST.DYNAMIC_BODY;
              }
              if (!Array.isArray(object)) {
                object = [object];
              }
              for (var i = 0; i < object.length; i++) {
                var entry = object[i];
                if (entry.isParent) {
                  var children = entry.getChildren();
                  for (var c = 0; c < children.length; c++) {
                    var child = children[c];
                    if (child.isParent) {
                      this.enable(child, bodyType);
                    } else {
                      this.enableBody(child, bodyType);
                    }
                  }
                } else {
                  this.enableBody(entry, bodyType);
                }
              }
            },
            enableBody: function(object, bodyType) {
              if (bodyType === void 0) {
                bodyType = CONST.DYNAMIC_BODY;
              }
              if (!object.body) {
                if (bodyType === CONST.DYNAMIC_BODY) {
                  object.body = new Body(this, object);
                } else if (bodyType === CONST.STATIC_BODY) {
                  object.body = new StaticBody(this, object);
                }
              }
              this.add(object.body);
              return object;
            },
            add: function(body) {
              if (body.physicsType === CONST.DYNAMIC_BODY) {
                this.bodies.set(body);
              } else if (body.physicsType === CONST.STATIC_BODY) {
                this.staticBodies.set(body);
                this.staticTree.insert(body);
              }
              body.enable = true;
              return body;
            },
            disable: function(object) {
              if (!Array.isArray(object)) {
                object = [object];
              }
              for (var i = 0; i < object.length; i++) {
                var entry = object[i];
                if (entry.isParent) {
                  var children = entry.getChildren();
                  for (var c = 0; c < children.length; c++) {
                    var child = children[c];
                    if (child.isParent) {
                      this.disable(child);
                    } else {
                      this.disableBody(child.body);
                    }
                  }
                } else {
                  this.disableBody(entry.body);
                }
              }
            },
            disableBody: function(body) {
              this.remove(body);
              body.enable = false;
            },
            remove: function(body) {
              if (body.physicsType === CONST.DYNAMIC_BODY) {
                this.tree.remove(body);
                this.bodies.delete(body);
              } else if (body.physicsType === CONST.STATIC_BODY) {
                this.staticBodies.delete(body);
                this.staticTree.remove(body);
              }
            },
            createDebugGraphic: function() {
              var graphic = this.scene.sys.add.graphics({x: 0, y: 0});
              graphic.setDepth(Number.MAX_VALUE);
              this.debugGraphic = graphic;
              this.drawDebug = true;
              return graphic;
            },
            setBounds: function(x, y, width, height, checkLeft, checkRight, checkUp, checkDown) {
              this.bounds.setTo(x, y, width, height);
              if (checkLeft !== void 0) {
                this.setBoundsCollision(checkLeft, checkRight, checkUp, checkDown);
              }
              return this;
            },
            setBoundsCollision: function(left, right, up, down) {
              if (left === void 0) {
                left = true;
              }
              if (right === void 0) {
                right = true;
              }
              if (up === void 0) {
                up = true;
              }
              if (down === void 0) {
                down = true;
              }
              this.checkCollision.left = left;
              this.checkCollision.right = right;
              this.checkCollision.up = up;
              this.checkCollision.down = down;
              return this;
            },
            pause: function() {
              this.isPaused = true;
              this.emit(Events.PAUSE);
              return this;
            },
            resume: function() {
              this.isPaused = false;
              this.emit(Events.RESUME);
              return this;
            },
            addCollider: function(object1, object2, collideCallback, processCallback, callbackContext) {
              if (collideCallback === void 0) {
                collideCallback = null;
              }
              if (processCallback === void 0) {
                processCallback = null;
              }
              if (callbackContext === void 0) {
                callbackContext = collideCallback;
              }
              var collider = new Collider(this, false, object1, object2, collideCallback, processCallback, callbackContext);
              this.colliders.add(collider);
              return collider;
            },
            addOverlap: function(object1, object2, collideCallback, processCallback, callbackContext) {
              if (collideCallback === void 0) {
                collideCallback = null;
              }
              if (processCallback === void 0) {
                processCallback = null;
              }
              if (callbackContext === void 0) {
                callbackContext = collideCallback;
              }
              var collider = new Collider(this, true, object1, object2, collideCallback, processCallback, callbackContext);
              this.colliders.add(collider);
              return collider;
            },
            removeCollider: function(collider) {
              this.colliders.remove(collider);
              return this;
            },
            setFPS: function(framerate) {
              this.fps = framerate;
              this._frameTime = 1 / this.fps;
              this._frameTimeMS = 1e3 * this._frameTime;
              return this;
            },
            update: function(time, delta) {
              if (this.isPaused || this.bodies.size === 0) {
                return;
              }
              var i;
              var fixedDelta = this._frameTime;
              var msPerFrame = this._frameTimeMS * this.timeScale;
              this._elapsed += delta;
              var body;
              var bodies = this.bodies.entries;
              var willStep = this._elapsed >= msPerFrame;
              if (!this.fixedStep) {
                fixedDelta = delta * 1e-3;
                willStep = true;
                this._elapsed = 0;
              }
              for (i = 0; i < bodies.length; i++) {
                body = bodies[i];
                if (body.enable) {
                  body.preUpdate(willStep, fixedDelta);
                }
              }
              if (willStep) {
                this._elapsed -= msPerFrame;
                this.stepsLastFrame = 1;
                if (this.useTree) {
                  this.tree.clear();
                  this.tree.load(bodies);
                }
                var colliders = this.colliders.update();
                for (i = 0; i < colliders.length; i++) {
                  var collider = colliders[i];
                  if (collider.active) {
                    collider.update();
                  }
                }
                this.emit(Events.WORLD_STEP, fixedDelta);
              }
              while (this._elapsed >= msPerFrame) {
                this._elapsed -= msPerFrame;
                this.step(fixedDelta);
              }
            },
            step: function(delta) {
              var i;
              var body;
              var bodies = this.bodies.entries;
              var len = bodies.length;
              for (i = 0; i < len; i++) {
                body = bodies[i];
                if (body.enable) {
                  body.update(delta);
                }
              }
              if (this.useTree) {
                this.tree.clear();
                this.tree.load(bodies);
              }
              var colliders = this.colliders.update();
              for (i = 0; i < colliders.length; i++) {
                var collider = colliders[i];
                if (collider.active) {
                  collider.update();
                }
              }
              this.emit(Events.WORLD_STEP, delta);
              this.stepsLastFrame++;
            },
            postUpdate: function() {
              var i;
              var body;
              var bodies = this.bodies.entries;
              var len = bodies.length;
              var dynamic = this.bodies;
              var staticBodies = this.staticBodies;
              if (this.stepsLastFrame) {
                this.stepsLastFrame = 0;
                for (i = 0; i < len; i++) {
                  body = bodies[i];
                  if (body.enable) {
                    body.postUpdate();
                  }
                }
              }
              if (this.drawDebug) {
                var graphics = this.debugGraphic;
                graphics.clear();
                for (i = 0; i < len; i++) {
                  body = bodies[i];
                  if (body.willDrawDebug()) {
                    body.drawDebug(graphics);
                  }
                }
                bodies = staticBodies.entries;
                len = bodies.length;
                for (i = 0; i < len; i++) {
                  body = bodies[i];
                  if (body.willDrawDebug()) {
                    body.drawDebug(graphics);
                  }
                }
              }
              var pending = this.pendingDestroy;
              if (pending.size > 0) {
                var dynamicTree = this.tree;
                var staticTree = this.staticTree;
                bodies = pending.entries;
                len = bodies.length;
                for (i = 0; i < len; i++) {
                  body = bodies[i];
                  if (body.physicsType === CONST.DYNAMIC_BODY) {
                    dynamicTree.remove(body);
                    dynamic.delete(body);
                  } else if (body.physicsType === CONST.STATIC_BODY) {
                    staticTree.remove(body);
                    staticBodies.delete(body);
                  }
                  body.world = void 0;
                  body.gameObject = void 0;
                }
                pending.clear();
              }
            },
            updateMotion: function(body, delta) {
              if (body.allowRotation) {
                this.computeAngularVelocity(body, delta);
              }
              this.computeVelocity(body, delta);
            },
            computeAngularVelocity: function(body, delta) {
              var velocity = body.angularVelocity;
              var acceleration = body.angularAcceleration;
              var drag = body.angularDrag;
              var max = body.maxAngular;
              if (acceleration) {
                velocity += acceleration * delta;
              } else if (body.allowDrag && drag) {
                drag *= delta;
                if (FuzzyGreaterThan(velocity - drag, 0, 0.1)) {
                  velocity -= drag;
                } else if (FuzzyLessThan(velocity + drag, 0, 0.1)) {
                  velocity += drag;
                } else {
                  velocity = 0;
                }
              }
              velocity = Clamp(velocity, -max, max);
              var velocityDelta = velocity - body.angularVelocity;
              body.angularVelocity += velocityDelta;
              body.rotation += body.angularVelocity * delta;
            },
            computeVelocity: function(body, delta) {
              var velocityX = body.velocity.x;
              var accelerationX = body.acceleration.x;
              var dragX = body.drag.x;
              var maxX = body.maxVelocity.x;
              var velocityY = body.velocity.y;
              var accelerationY = body.acceleration.y;
              var dragY = body.drag.y;
              var maxY = body.maxVelocity.y;
              var speed = body.speed;
              var maxSpeed = body.maxSpeed;
              var allowDrag = body.allowDrag;
              var useDamping = body.useDamping;
              if (body.allowGravity) {
                velocityX += (this.gravity.x + body.gravity.x) * delta;
                velocityY += (this.gravity.y + body.gravity.y) * delta;
              }
              if (accelerationX) {
                velocityX += accelerationX * delta;
              } else if (allowDrag && dragX) {
                if (useDamping) {
                  dragX = Math.pow(dragX, delta);
                  velocityX *= dragX;
                  speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                  if (FuzzyEqual(speed, 0, 1e-3)) {
                    velocityX = 0;
                  }
                } else {
                  dragX *= delta;
                  if (FuzzyGreaterThan(velocityX - dragX, 0, 0.01)) {
                    velocityX -= dragX;
                  } else if (FuzzyLessThan(velocityX + dragX, 0, 0.01)) {
                    velocityX += dragX;
                  } else {
                    velocityX = 0;
                  }
                }
              }
              if (accelerationY) {
                velocityY += accelerationY * delta;
              } else if (allowDrag && dragY) {
                if (useDamping) {
                  dragY = Math.pow(dragY, delta);
                  velocityY *= dragY;
                  speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                  if (FuzzyEqual(speed, 0, 1e-3)) {
                    velocityY = 0;
                  }
                } else {
                  dragY *= delta;
                  if (FuzzyGreaterThan(velocityY - dragY, 0, 0.01)) {
                    velocityY -= dragY;
                  } else if (FuzzyLessThan(velocityY + dragY, 0, 0.01)) {
                    velocityY += dragY;
                  } else {
                    velocityY = 0;
                  }
                }
              }
              velocityX = Clamp(velocityX, -maxX, maxX);
              velocityY = Clamp(velocityY, -maxY, maxY);
              body.velocity.set(velocityX, velocityY);
              if (maxSpeed > -1 && speed > maxSpeed) {
                body.velocity.normalize().scale(maxSpeed);
                speed = maxSpeed;
              }
              body.speed = speed;
            },
            separate: function(body1, body2, processCallback, callbackContext, overlapOnly, intersects) {
              if (!intersects && !body1.enable || !body2.enable || body1.checkCollision.none || body2.checkCollision.none || !this.intersects(body1, body2)) {
                return false;
              }
              if (processCallback && processCallback.call(callbackContext, body1.gameObject, body2.gameObject) === false) {
                return false;
              }
              if (body1.isCircle && body2.isCircle) {
                return this.separateCircle(body1, body2, overlapOnly);
              }
              if (body1.isCircle !== body2.isCircle) {
                var bodyRect = body1.isCircle ? body2 : body1;
                var bodyCircle = body1.isCircle ? body1 : body2;
                var rect = {
                  x: bodyRect.x,
                  y: bodyRect.y,
                  right: bodyRect.right,
                  bottom: bodyRect.bottom
                };
                var circle = bodyCircle.center;
                if (circle.y < rect.y || circle.y > rect.bottom) {
                  if (circle.x < rect.x || circle.x > rect.right) {
                    return this.separateCircle(body1, body2, overlapOnly);
                  }
                }
              }
              var resultX = false;
              var resultY = false;
              if (overlapOnly) {
                resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);
                resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);
              } else if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x)) {
                resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);
                if (this.intersects(body1, body2)) {
                  resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);
                }
              } else {
                resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);
                if (this.intersects(body1, body2)) {
                  resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);
                }
              }
              var result = resultX || resultY;
              if (result) {
                if (overlapOnly) {
                  if (body1.onOverlap || body2.onOverlap) {
                    this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);
                  }
                } else if (body1.onCollide || body2.onCollide) {
                  this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);
                }
              }
              return result;
            },
            separateCircle: function(body1, body2, overlapOnly, bias) {
              GetOverlapX(body1, body2, false, bias);
              GetOverlapY(body1, body2, false, bias);
              var overlap = 0;
              if (body1.isCircle !== body2.isCircle) {
                var rect = {
                  x: body2.isCircle ? body1.position.x : body2.position.x,
                  y: body2.isCircle ? body1.position.y : body2.position.y,
                  right: body2.isCircle ? body1.right : body2.right,
                  bottom: body2.isCircle ? body1.bottom : body2.bottom
                };
                var circle = {
                  x: body1.isCircle ? body1.center.x : body2.center.x,
                  y: body1.isCircle ? body1.center.y : body2.center.y,
                  radius: body1.isCircle ? body1.halfWidth : body2.halfWidth
                };
                if (circle.y < rect.y) {
                  if (circle.x < rect.x) {
                    overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.y) - circle.radius;
                  } else if (circle.x > rect.right) {
                    overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.y) - circle.radius;
                  }
                } else if (circle.y > rect.bottom) {
                  if (circle.x < rect.x) {
                    overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.bottom) - circle.radius;
                  } else if (circle.x > rect.right) {
                    overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.bottom) - circle.radius;
                  }
                }
                overlap *= -1;
              } else {
                overlap = body1.halfWidth + body2.halfWidth - DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y);
              }
              body1.overlapR = overlap;
              body2.overlapR = overlap;
              if (overlapOnly || overlap === 0 || body1.immovable && body2.immovable || body1.customSeparateX || body2.customSeparateX) {
                if (overlap !== 0 && (body1.onOverlap || body2.onOverlap)) {
                  this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);
                }
                return overlap !== 0;
              }
              var dx = body1.center.x - body2.center.x;
              var dy = body1.center.y - body2.center.y;
              var d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
              var nx = (body2.center.x - body1.center.x) / d || 0;
              var ny = (body2.center.y - body1.center.y) / d || 0;
              var p = 2 * (body1.velocity.x * nx + body1.velocity.y * ny - body2.velocity.x * nx - body2.velocity.y * ny) / (body1.mass + body2.mass);
              if (body1.immovable || body2.immovable) {
                p *= 2;
              }
              if (!body1.immovable) {
                body1.velocity.x = body1.velocity.x - p / body1.mass * nx;
                body1.velocity.y = body1.velocity.y - p / body1.mass * ny;
              }
              if (!body2.immovable) {
                body2.velocity.x = body2.velocity.x + p / body2.mass * nx;
                body2.velocity.y = body2.velocity.y + p / body2.mass * ny;
              }
              if (!body1.immovable && !body2.immovable) {
                overlap /= 2;
              }
              var angle = AngleBetweenPoints(body1.center, body2.center);
              var overlapX = (overlap + MATH_CONST.EPSILON) * Math.cos(angle);
              var overlapY = (overlap + MATH_CONST.EPSILON) * Math.sin(angle);
              if (!body1.immovable) {
                body1.x -= overlapX;
                body1.y -= overlapY;
                body1.updateCenter();
              }
              if (!body2.immovable) {
                body2.x += overlapX;
                body2.y += overlapY;
                body2.updateCenter();
              }
              body1.velocity.x *= body1.bounce.x;
              body1.velocity.y *= body1.bounce.y;
              body2.velocity.x *= body2.bounce.x;
              body2.velocity.y *= body2.bounce.y;
              if (body1.onCollide || body2.onCollide) {
                this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);
              }
              return true;
            },
            intersects: function(body1, body2) {
              if (body1 === body2) {
                return false;
              }
              if (!body1.isCircle && !body2.isCircle) {
                return !(body1.right <= body2.position.x || body1.bottom <= body2.position.y || body1.position.x >= body2.right || body1.position.y >= body2.bottom);
              } else if (body1.isCircle) {
                if (body2.isCircle) {
                  return DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y) <= body1.halfWidth + body2.halfWidth;
                } else {
                  return this.circleBodyIntersects(body1, body2);
                }
              } else {
                return this.circleBodyIntersects(body2, body1);
              }
            },
            circleBodyIntersects: function(circle, body) {
              var x = Clamp(circle.center.x, body.left, body.right);
              var y = Clamp(circle.center.y, body.top, body.bottom);
              var dx = (circle.center.x - x) * (circle.center.x - x);
              var dy = (circle.center.y - y) * (circle.center.y - y);
              return dx + dy <= circle.halfWidth * circle.halfWidth;
            },
            overlap: function(object1, object2, overlapCallback, processCallback, callbackContext) {
              if (overlapCallback === void 0) {
                overlapCallback = null;
              }
              if (processCallback === void 0) {
                processCallback = null;
              }
              if (callbackContext === void 0) {
                callbackContext = overlapCallback;
              }
              return this.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);
            },
            collide: function(object1, object2, collideCallback, processCallback, callbackContext) {
              if (collideCallback === void 0) {
                collideCallback = null;
              }
              if (processCallback === void 0) {
                processCallback = null;
              }
              if (callbackContext === void 0) {
                callbackContext = collideCallback;
              }
              return this.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);
            },
            collideObjects: function(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
              var i;
              var j;
              if (object1.isParent && object1.physicsType === void 0) {
                object1 = object1.children.entries;
              }
              if (object2 && object2.isParent && object2.physicsType === void 0) {
                object2 = object2.children.entries;
              }
              var object1isArray = Array.isArray(object1);
              var object2isArray = Array.isArray(object2);
              this._total = 0;
              if (!object1isArray && !object2isArray) {
                this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
              } else if (!object1isArray && object2isArray) {
                for (i = 0; i < object2.length; i++) {
                  this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, overlapOnly);
                }
              } else if (object1isArray && !object2isArray) {
                if (!object2) {
                  for (i = 0; i < object1.length; i++) {
                    var child = object1[i];
                    for (j = i + 1; j < object1.length; j++) {
                      if (i === j) {
                        continue;
                      }
                      this.collideHandler(child, object1[j], collideCallback, processCallback, callbackContext, overlapOnly);
                    }
                  }
                } else {
                  for (i = 0; i < object1.length; i++) {
                    this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, overlapOnly);
                  }
                }
              } else {
                for (i = 0; i < object1.length; i++) {
                  for (j = 0; j < object2.length; j++) {
                    this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, overlapOnly);
                  }
                }
              }
              return this._total > 0;
            },
            collideHandler: function(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
              if (object2 === void 0 && object1.isParent) {
                return this.collideGroupVsGroup(object1, object1, collideCallback, processCallback, callbackContext, overlapOnly);
              }
              if (!object1 || !object2) {
                return false;
              }
              if (object1.body) {
                if (object2.body) {
                  return this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.isParent) {
                  return this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.isTilemap) {
                  return this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                }
              } else if (object1.isParent) {
                if (object2.body) {
                  return this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.isParent) {
                  return this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.isTilemap) {
                  return this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                }
              } else if (object1.isTilemap) {
                if (object2.body) {
                  return this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.isParent) {
                  return this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                }
              }
            },
            collideSpriteVsSprite: function(sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {
              if (!sprite1.body || !sprite2.body) {
                return false;
              }
              if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly)) {
                if (collideCallback) {
                  collideCallback.call(callbackContext, sprite1, sprite2);
                }
                this._total++;
              }
              return true;
            },
            collideSpriteVsGroup: function(sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {
              var bodyA = sprite.body;
              if (group.length === 0 || !bodyA || !bodyA.enable || bodyA.checkCollision.none) {
                return;
              }
              var i;
              var len;
              var bodyB;
              if (this.useTree || group.physicsType === CONST.STATIC_BODY) {
                var minMax = this.treeMinMax;
                minMax.minX = bodyA.left;
                minMax.minY = bodyA.top;
                minMax.maxX = bodyA.right;
                minMax.maxY = bodyA.bottom;
                var results = group.physicsType === CONST.DYNAMIC_BODY ? this.tree.search(minMax) : this.staticTree.search(minMax);
                len = results.length;
                for (i = 0; i < len; i++) {
                  bodyB = results[i];
                  if (bodyA === bodyB || !bodyB.enable || bodyB.checkCollision.none || !group.contains(bodyB.gameObject)) {
                    continue;
                  }
                  if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly, true)) {
                    if (collideCallback) {
                      collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);
                    }
                    this._total++;
                  }
                }
              } else {
                var children = group.getChildren();
                var skipIndex = group.children.entries.indexOf(sprite);
                len = children.length;
                for (i = 0; i < len; i++) {
                  bodyB = children[i].body;
                  if (!bodyB || i === skipIndex || !bodyB.enable) {
                    continue;
                  }
                  if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly)) {
                    if (collideCallback) {
                      collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);
                    }
                    this._total++;
                  }
                }
              }
            },
            collideGroupVsTilemapLayer: function(group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {
              var children = group.getChildren();
              if (children.length === 0) {
                return false;
              }
              var didCollide = false;
              for (var i = 0; i < children.length; i++) {
                if (children[i].body) {
                  if (this.collideSpriteVsTilemapLayer(children[i], tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)) {
                    didCollide = true;
                  }
                }
              }
              return didCollide;
            },
            collideTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
              if (!sprite.body.enable || tiles.length === 0) {
                return false;
              } else {
                return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, false, false);
              }
            },
            overlapTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
              if (!sprite.body.enable || tiles.length === 0) {
                return false;
              } else {
                return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, true, false);
              }
            },
            collideSpriteVsTilemapLayer: function(sprite, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {
              var body = sprite.body;
              if (!body.enable || body.checkCollision.none) {
                return false;
              }
              var x = body.position.x;
              var y = body.position.y;
              var w = body.width;
              var h = body.height;
              var layerData = tilemapLayer.layer;
              if (layerData.tileWidth > layerData.baseTileWidth) {
                var xDiff = (layerData.tileWidth - layerData.baseTileWidth) * tilemapLayer.scaleX;
                x -= xDiff;
                w += xDiff;
              }
              if (layerData.tileHeight > layerData.baseTileHeight) {
                var yDiff = (layerData.tileHeight - layerData.baseTileHeight) * tilemapLayer.scaleY;
                h += yDiff;
              }
              var mapData = GetTilesWithinWorldXY(x, y, w, h, null, tilemapLayer.scene.cameras.main, tilemapLayer.layer);
              if (mapData.length === 0) {
                return false;
              } else {
                return this.collideSpriteVsTilesHandler(sprite, mapData, collideCallback, processCallback, callbackContext, overlapOnly, true);
              }
            },
            collideSpriteVsTilesHandler: function(sprite, tiles, collideCallback, processCallback, callbackContext, overlapOnly, isLayer) {
              var body = sprite.body;
              var tile;
              var tileWorldRect = {left: 0, right: 0, top: 0, bottom: 0};
              var tilemapLayer;
              var collision = false;
              for (var i = 0; i < tiles.length; i++) {
                tile = tiles[i];
                tilemapLayer = tile.tilemapLayer;
                var point = tilemapLayer.tileToWorldXY(tile.x, tile.y);
                tileWorldRect.left = point.x;
                tileWorldRect.top = point.y;
                if (tile.baseHeight !== tile.height) {
                  tileWorldRect.top -= (tile.height - tile.baseHeight) * tilemapLayer.scaleY;
                }
                tileWorldRect.right = tileWorldRect.left + tile.width * tilemapLayer.scaleX;
                tileWorldRect.bottom = tileWorldRect.top + tile.height * tilemapLayer.scaleY;
                if (TileIntersectsBody(tileWorldRect, body) && (!processCallback || processCallback.call(callbackContext, sprite, tile)) && ProcessTileCallbacks(tile, sprite) && (overlapOnly || SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, this.TILE_BIAS, isLayer))) {
                  this._total++;
                  collision = true;
                  if (collideCallback) {
                    collideCallback.call(callbackContext, sprite, tile);
                  }
                  if (overlapOnly && body.onOverlap) {
                    this.emit(Events.TILE_OVERLAP, sprite, tile, body);
                  } else if (body.onCollide) {
                    this.emit(Events.TILE_COLLIDE, sprite, tile, body);
                  }
                }
              }
              return collision;
            },
            collideGroupVsGroup: function(group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {
              if (group1.length === 0 || group2.length === 0) {
                return;
              }
              var children = group1.getChildren();
              for (var i = 0; i < children.length; i++) {
                this.collideSpriteVsGroup(children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);
              }
            },
            wrap: function(object, padding) {
              if (object.body) {
                this.wrapObject(object, padding);
              } else if (object.getChildren) {
                this.wrapArray(object.getChildren(), padding);
              } else if (Array.isArray(object)) {
                this.wrapArray(object, padding);
              } else {
                this.wrapObject(object, padding);
              }
            },
            wrapArray: function(objects, padding) {
              for (var i = 0; i < objects.length; i++) {
                this.wrapObject(objects[i], padding);
              }
            },
            wrapObject: function(object, padding) {
              if (padding === void 0) {
                padding = 0;
              }
              object.x = Wrap(object.x, this.bounds.left - padding, this.bounds.right + padding);
              object.y = Wrap(object.y, this.bounds.top - padding, this.bounds.bottom + padding);
            },
            shutdown: function() {
              this.tree.clear();
              this.staticTree.clear();
              this.bodies.clear();
              this.staticBodies.clear();
              this.colliders.destroy();
              this.removeAllListeners();
            },
            destroy: function() {
              this.shutdown();
              this.scene = null;
            }
          });
          module2.exports = World;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Benjamin D. Richards <benjamindrichards@gmail.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(60);
          var Events = __webpack_require__(242);
          var RadToDeg = __webpack_require__(193);
          var Rectangle = __webpack_require__(10);
          var RectangleContains = __webpack_require__(56);
          var Vector29 = __webpack_require__(3);
          var Body = new Class({
            initialize: function Body2(world, gameObject) {
              var width = gameObject.displayWidth ? gameObject.displayWidth : 64;
              var height = gameObject.displayHeight ? gameObject.displayHeight : 64;
              this.world = world;
              this.gameObject = gameObject;
              this.transform = {
                x: gameObject.x,
                y: gameObject.y,
                rotation: gameObject.angle,
                scaleX: gameObject.scaleX,
                scaleY: gameObject.scaleY,
                displayOriginX: gameObject.displayOriginX,
                displayOriginY: gameObject.displayOriginY
              };
              this.debugShowBody = world.defaults.debugShowBody;
              this.debugShowVelocity = world.defaults.debugShowVelocity;
              this.debugBodyColor = world.defaults.bodyDebugColor;
              this.enable = true;
              this.isCircle = false;
              this.radius = 0;
              this.offset = new Vector29();
              this.position = new Vector29(gameObject.x - gameObject.scaleX * gameObject.displayOriginX, gameObject.y - gameObject.scaleY * gameObject.displayOriginY);
              this.prev = this.position.clone();
              this.prevFrame = this.position.clone();
              this.allowRotation = true;
              this.rotation = gameObject.angle;
              this.preRotation = gameObject.angle;
              this.width = width;
              this.height = height;
              this.sourceWidth = width;
              this.sourceHeight = height;
              if (gameObject.frame) {
                this.sourceWidth = gameObject.frame.realWidth;
                this.sourceHeight = gameObject.frame.realHeight;
              }
              this.halfWidth = Math.abs(width / 2);
              this.halfHeight = Math.abs(height / 2);
              this.center = new Vector29(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
              this.velocity = new Vector29();
              this.newVelocity = new Vector29();
              this.deltaMax = new Vector29();
              this.acceleration = new Vector29();
              this.allowDrag = true;
              this.drag = new Vector29();
              this.allowGravity = true;
              this.gravity = new Vector29();
              this.bounce = new Vector29();
              this.worldBounce = null;
              this.customBoundsRectangle = world.bounds;
              this.onWorldBounds = false;
              this.onCollide = false;
              this.onOverlap = false;
              this.maxVelocity = new Vector29(1e4, 1e4);
              this.maxSpeed = -1;
              this.friction = new Vector29(1, 0);
              this.useDamping = false;
              this.angularVelocity = 0;
              this.angularAcceleration = 0;
              this.angularDrag = 0;
              this.maxAngular = 1e3;
              this.mass = 1;
              this.angle = 0;
              this.speed = 0;
              this.facing = CONST.FACING_NONE;
              this.immovable = false;
              this.pushable = true;
              this.moves = true;
              this.customSeparateX = false;
              this.customSeparateY = false;
              this.overlapX = 0;
              this.overlapY = 0;
              this.overlapR = 0;
              this.embedded = false;
              this.collideWorldBounds = false;
              this.checkCollision = {none: false, up: true, down: true, left: true, right: true};
              this.touching = {none: true, up: false, down: false, left: false, right: false};
              this.wasTouching = {none: true, up: false, down: false, left: false, right: false};
              this.blocked = {none: true, up: false, down: false, left: false, right: false};
              this.syncBounds = false;
              this.physicsType = CONST.DYNAMIC_BODY;
              this._sx = gameObject.scaleX;
              this._sy = gameObject.scaleY;
              this._dx = 0;
              this._dy = 0;
              this._tx = 0;
              this._ty = 0;
              this._bounds = new Rectangle();
            },
            updateBounds: function() {
              var sprite = this.gameObject;
              var transform = this.transform;
              if (sprite.parentContainer) {
                var matrix = sprite.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);
                transform.x = matrix.tx;
                transform.y = matrix.ty;
                transform.rotation = RadToDeg(matrix.rotation);
                transform.scaleX = matrix.scaleX;
                transform.scaleY = matrix.scaleY;
                transform.displayOriginX = sprite.displayOriginX;
                transform.displayOriginY = sprite.displayOriginY;
              } else {
                transform.x = sprite.x;
                transform.y = sprite.y;
                transform.rotation = sprite.angle;
                transform.scaleX = sprite.scaleX;
                transform.scaleY = sprite.scaleY;
                transform.displayOriginX = sprite.displayOriginX;
                transform.displayOriginY = sprite.displayOriginY;
              }
              var recalc = false;
              if (this.syncBounds) {
                var b = sprite.getBounds(this._bounds);
                this.width = b.width;
                this.height = b.height;
                recalc = true;
              } else {
                var asx = Math.abs(transform.scaleX);
                var asy = Math.abs(transform.scaleY);
                if (this._sx !== asx || this._sy !== asy) {
                  this.width = this.sourceWidth * asx;
                  this.height = this.sourceHeight * asy;
                  this._sx = asx;
                  this._sy = asy;
                  recalc = true;
                }
              }
              if (recalc) {
                this.halfWidth = Math.floor(this.width / 2);
                this.halfHeight = Math.floor(this.height / 2);
                this.updateCenter();
              }
            },
            updateCenter: function() {
              this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
            },
            updateFromGameObject: function() {
              this.updateBounds();
              var transform = this.transform;
              this.position.x = transform.x + transform.scaleX * (this.offset.x - transform.displayOriginX);
              this.position.y = transform.y + transform.scaleY * (this.offset.y - transform.displayOriginY);
              this.updateCenter();
            },
            resetFlags: function(clear) {
              if (clear === void 0) {
                clear = false;
              }
              var wasTouching = this.wasTouching;
              var touching = this.touching;
              var blocked = this.blocked;
              if (clear) {
                wasTouching.none = true;
                wasTouching.up = false;
                wasTouching.down = false;
                wasTouching.left = false;
                wasTouching.right = false;
              } else {
                wasTouching.none = touching.none;
                wasTouching.up = touching.up;
                wasTouching.down = touching.down;
                wasTouching.left = touching.left;
                wasTouching.right = touching.right;
              }
              touching.none = true;
              touching.up = false;
              touching.down = false;
              touching.left = false;
              touching.right = false;
              blocked.none = true;
              blocked.up = false;
              blocked.down = false;
              blocked.left = false;
              blocked.right = false;
              this.overlapR = 0;
              this.overlapX = 0;
              this.overlapY = 0;
              this.embedded = false;
            },
            preUpdate: function(willStep, delta) {
              if (willStep) {
                this.resetFlags();
              }
              this.updateFromGameObject();
              this.rotation = this.transform.rotation;
              this.preRotation = this.rotation;
              if (this.moves) {
                this.prev.x = this.position.x;
                this.prev.y = this.position.y;
                this.prevFrame.x = this.position.x;
                this.prevFrame.y = this.position.y;
              }
              if (willStep) {
                this.update(delta);
              }
            },
            update: function(delta) {
              this.prev.x = this.position.x;
              this.prev.y = this.position.y;
              if (this.moves) {
                this.world.updateMotion(this, delta);
                var vx = this.velocity.x;
                var vy = this.velocity.y;
                this.newVelocity.set(vx * delta, vy * delta);
                this.position.add(this.newVelocity);
                this.updateCenter();
                this.angle = Math.atan2(vy, vx);
                this.speed = Math.sqrt(vx * vx + vy * vy);
                if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds) {
                  this.world.emit(Events.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right);
                }
              }
              this._dx = this.position.x - this.prev.x;
              this._dy = this.position.y - this.prev.y;
            },
            postUpdate: function() {
              var dx = this.position.x - this.prevFrame.x;
              var dy = this.position.y - this.prevFrame.y;
              if (this.moves) {
                var mx = this.deltaMax.x;
                var my = this.deltaMax.y;
                if (mx !== 0 && dx !== 0) {
                  if (dx < 0 && dx < -mx) {
                    dx = -mx;
                  } else if (dx > 0 && dx > mx) {
                    dx = mx;
                  }
                }
                if (my !== 0 && dy !== 0) {
                  if (dy < 0 && dy < -my) {
                    dy = -my;
                  } else if (dy > 0 && dy > my) {
                    dy = my;
                  }
                }
                this.gameObject.x += dx;
                this.gameObject.y += dy;
              }
              if (dx < 0) {
                this.facing = CONST.FACING_LEFT;
              } else if (dx > 0) {
                this.facing = CONST.FACING_RIGHT;
              }
              if (dy < 0) {
                this.facing = CONST.FACING_UP;
              } else if (dy > 0) {
                this.facing = CONST.FACING_DOWN;
              }
              if (this.allowRotation) {
                this.gameObject.angle += this.deltaZ();
              }
              this._tx = dx;
              this._ty = dy;
            },
            setBoundsRectangle: function(bounds) {
              this.customBoundsRectangle = !bounds ? this.world.bounds : bounds;
              return this;
            },
            checkWorldBounds: function() {
              var pos = this.position;
              var bounds = this.customBoundsRectangle;
              var check = this.world.checkCollision;
              var bx = this.worldBounce ? -this.worldBounce.x : -this.bounce.x;
              var by = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
              var wasSet = false;
              if (pos.x < bounds.x && check.left) {
                pos.x = bounds.x;
                this.velocity.x *= bx;
                this.blocked.left = true;
                wasSet = true;
              } else if (this.right > bounds.right && check.right) {
                pos.x = bounds.right - this.width;
                this.velocity.x *= bx;
                this.blocked.right = true;
                wasSet = true;
              }
              if (pos.y < bounds.y && check.up) {
                pos.y = bounds.y;
                this.velocity.y *= by;
                this.blocked.up = true;
                wasSet = true;
              } else if (this.bottom > bounds.bottom && check.down) {
                pos.y = bounds.bottom - this.height;
                this.velocity.y *= by;
                this.blocked.down = true;
                wasSet = true;
              }
              if (wasSet) {
                this.blocked.none = false;
                this.updateCenter();
              }
              return wasSet;
            },
            setOffset: function(x, y) {
              if (y === void 0) {
                y = x;
              }
              this.offset.set(x, y);
              return this;
            },
            setSize: function(width, height, center) {
              if (center === void 0) {
                center = true;
              }
              var gameObject = this.gameObject;
              if (!width && gameObject.frame) {
                width = gameObject.frame.realWidth;
              }
              if (!height && gameObject.frame) {
                height = gameObject.frame.realHeight;
              }
              this.sourceWidth = width;
              this.sourceHeight = height;
              this.width = this.sourceWidth * this._sx;
              this.height = this.sourceHeight * this._sy;
              this.halfWidth = Math.floor(this.width / 2);
              this.halfHeight = Math.floor(this.height / 2);
              this.updateCenter();
              if (center && gameObject.getCenter) {
                var ox = (gameObject.width - width) / 2;
                var oy = (gameObject.height - height) / 2;
                this.offset.set(ox, oy);
              }
              this.isCircle = false;
              this.radius = 0;
              return this;
            },
            setCircle: function(radius, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = this.offset.x;
              }
              if (offsetY === void 0) {
                offsetY = this.offset.y;
              }
              if (radius > 0) {
                this.isCircle = true;
                this.radius = radius;
                this.sourceWidth = radius * 2;
                this.sourceHeight = radius * 2;
                this.width = this.sourceWidth * this._sx;
                this.height = this.sourceHeight * this._sy;
                this.halfWidth = Math.floor(this.width / 2);
                this.halfHeight = Math.floor(this.height / 2);
                this.offset.set(offsetX, offsetY);
                this.updateCenter();
              } else {
                this.isCircle = false;
              }
              return this;
            },
            reset: function(x, y) {
              this.stop();
              var gameObject = this.gameObject;
              gameObject.setPosition(x, y);
              if (gameObject.getTopLeft) {
                gameObject.getTopLeft(this.position);
              } else {
                this.position.set(x, y);
              }
              this.prev.copy(this.position);
              this.prevFrame.copy(this.position);
              this.rotation = gameObject.angle;
              this.preRotation = gameObject.angle;
              this.updateBounds();
              this.updateCenter();
              this.resetFlags(true);
            },
            stop: function() {
              this.velocity.set(0);
              this.acceleration.set(0);
              this.speed = 0;
              this.angularVelocity = 0;
              this.angularAcceleration = 0;
              return this;
            },
            getBounds: function(obj) {
              obj.x = this.x;
              obj.y = this.y;
              obj.right = this.right;
              obj.bottom = this.bottom;
              return obj;
            },
            hitTest: function(x, y) {
              if (!this.isCircle) {
                return RectangleContains(this, x, y);
              }
              if (this.radius > 0 && x >= this.left && x <= this.right && y >= this.top && y <= this.bottom) {
                var dx = (this.center.x - x) * (this.center.x - x);
                var dy = (this.center.y - y) * (this.center.y - y);
                return dx + dy <= this.radius * this.radius;
              }
              return false;
            },
            onFloor: function() {
              return this.blocked.down;
            },
            onCeiling: function() {
              return this.blocked.up;
            },
            onWall: function() {
              return this.blocked.left || this.blocked.right;
            },
            deltaAbsX: function() {
              return this._dx > 0 ? this._dx : -this._dx;
            },
            deltaAbsY: function() {
              return this._dy > 0 ? this._dy : -this._dy;
            },
            deltaX: function() {
              return this._dx;
            },
            deltaY: function() {
              return this._dy;
            },
            deltaXFinal: function() {
              return this._tx;
            },
            deltaYFinal: function() {
              return this._ty;
            },
            deltaZ: function() {
              return this.rotation - this.preRotation;
            },
            destroy: function() {
              this.enable = false;
              if (this.world) {
                this.world.pendingDestroy.set(this);
              }
            },
            drawDebug: function(graphic) {
              var pos = this.position;
              var x = pos.x + this.halfWidth;
              var y = pos.y + this.halfHeight;
              if (this.debugShowBody) {
                graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor);
                if (this.isCircle) {
                  graphic.strokeCircle(x, y, this.width / 2);
                } else {
                  if (this.checkCollision.up) {
                    graphic.lineBetween(pos.x, pos.y, pos.x + this.width, pos.y);
                  }
                  if (this.checkCollision.right) {
                    graphic.lineBetween(pos.x + this.width, pos.y, pos.x + this.width, pos.y + this.height);
                  }
                  if (this.checkCollision.down) {
                    graphic.lineBetween(pos.x, pos.y + this.height, pos.x + this.width, pos.y + this.height);
                  }
                  if (this.checkCollision.left) {
                    graphic.lineBetween(pos.x, pos.y, pos.x, pos.y + this.height);
                  }
                }
              }
              if (this.debugShowVelocity) {
                graphic.lineStyle(graphic.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1);
                graphic.lineBetween(x, y, x + this.velocity.x / 2, y + this.velocity.y / 2);
              }
            },
            willDrawDebug: function() {
              return this.debugShowBody || this.debugShowVelocity;
            },
            setCollideWorldBounds: function(value, bounceX, bounceY, onWorldBounds) {
              if (value === void 0) {
                value = true;
              }
              this.collideWorldBounds = value;
              var setBounceX = bounceX !== void 0;
              var setBounceY = bounceY !== void 0;
              if (setBounceX || setBounceY) {
                if (!this.worldBounce) {
                  this.worldBounce = new Vector29();
                }
                if (setBounceX) {
                  this.worldBounce.x = bounceX;
                }
                if (setBounceY) {
                  this.worldBounce.y = bounceY;
                }
              }
              if (onWorldBounds !== void 0) {
                this.onWorldBounds = onWorldBounds;
              }
              return this;
            },
            setVelocity: function(x, y) {
              this.velocity.set(x, y);
              x = this.velocity.x;
              y = this.velocity.y;
              this.speed = Math.sqrt(x * x + y * y);
              return this;
            },
            setVelocityX: function(value) {
              this.velocity.x = value;
              var x = value;
              var y = this.velocity.y;
              this.speed = Math.sqrt(x * x + y * y);
              return this;
            },
            setVelocityY: function(value) {
              this.velocity.y = value;
              var x = this.velocity.x;
              var y = value;
              this.speed = Math.sqrt(x * x + y * y);
              return this;
            },
            setMaxVelocity: function(x, y) {
              this.maxVelocity.set(x, y);
              return this;
            },
            setMaxVelocityX: function(value) {
              this.maxVelocity.x = value;
              return this;
            },
            setMaxVelocityY: function(value) {
              this.maxVelocity.y = value;
              return this;
            },
            setMaxSpeed: function(value) {
              this.maxSpeed = value;
              return this;
            },
            setBounce: function(x, y) {
              this.bounce.set(x, y);
              return this;
            },
            setBounceX: function(value) {
              this.bounce.x = value;
              return this;
            },
            setBounceY: function(value) {
              this.bounce.y = value;
              return this;
            },
            setAcceleration: function(x, y) {
              this.acceleration.set(x, y);
              return this;
            },
            setAccelerationX: function(value) {
              this.acceleration.x = value;
              return this;
            },
            setAccelerationY: function(value) {
              this.acceleration.y = value;
              return this;
            },
            setAllowDrag: function(value) {
              if (value === void 0) {
                value = true;
              }
              this.allowDrag = value;
              return this;
            },
            setAllowGravity: function(value) {
              if (value === void 0) {
                value = true;
              }
              this.allowGravity = value;
              return this;
            },
            setAllowRotation: function(value) {
              if (value === void 0) {
                value = true;
              }
              this.allowRotation = value;
              return this;
            },
            setDrag: function(x, y) {
              this.drag.set(x, y);
              return this;
            },
            setDamping: function(value) {
              this.useDamping = value;
              return this;
            },
            setDragX: function(value) {
              this.drag.x = value;
              return this;
            },
            setDragY: function(value) {
              this.drag.y = value;
              return this;
            },
            setGravity: function(x, y) {
              this.gravity.set(x, y);
              return this;
            },
            setGravityX: function(value) {
              this.gravity.x = value;
              return this;
            },
            setGravityY: function(value) {
              this.gravity.y = value;
              return this;
            },
            setFriction: function(x, y) {
              this.friction.set(x, y);
              return this;
            },
            setFrictionX: function(value) {
              this.friction.x = value;
              return this;
            },
            setFrictionY: function(value) {
              this.friction.y = value;
              return this;
            },
            setAngularVelocity: function(value) {
              this.angularVelocity = value;
              return this;
            },
            setAngularAcceleration: function(value) {
              this.angularAcceleration = value;
              return this;
            },
            setAngularDrag: function(value) {
              this.angularDrag = value;
              return this;
            },
            setMass: function(value) {
              this.mass = value;
              return this;
            },
            setImmovable: function(value) {
              if (value === void 0) {
                value = true;
              }
              this.immovable = value;
              return this;
            },
            setEnable: function(value) {
              if (value === void 0) {
                value = true;
              }
              this.enable = value;
              return this;
            },
            processX: function(x, vx, left, right) {
              this.x += x;
              this.updateCenter();
              if (vx !== null) {
                this.velocity.x = vx;
              }
              var blocked = this.blocked;
              if (left) {
                blocked.left = true;
              }
              if (right) {
                blocked.right = true;
              }
            },
            processY: function(y, vy, up, down) {
              this.y += y;
              this.updateCenter();
              if (vy !== null) {
                this.velocity.y = vy;
              }
              var blocked = this.blocked;
              if (up) {
                blocked.up = true;
              }
              if (down) {
                blocked.down = true;
              }
            },
            x: {
              get: function() {
                return this.position.x;
              },
              set: function(value) {
                this.position.x = value;
              }
            },
            y: {
              get: function() {
                return this.position.y;
              },
              set: function(value) {
                this.position.y = value;
              }
            },
            left: {
              get: function() {
                return this.position.x;
              }
            },
            right: {
              get: function() {
                return this.position.x + this.width;
              }
            },
            top: {
              get: function() {
                return this.position.y;
              }
            },
            bottom: {
              get: function() {
                return this.position.y + this.height;
              }
            }
          });
          module2.exports = Body;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Collider = new Class({
            initialize: function Collider2(world, overlapOnly, object1, object2, collideCallback, processCallback, callbackContext) {
              this.world = world;
              this.name = "";
              this.active = true;
              this.overlapOnly = overlapOnly;
              this.object1 = object1;
              this.object2 = object2;
              this.collideCallback = collideCallback;
              this.processCallback = processCallback;
              this.callbackContext = callbackContext;
            },
            setName: function(name) {
              this.name = name;
              return this;
            },
            update: function() {
              this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly);
            },
            destroy: function() {
              this.world.removeCollider(this);
              this.active = false;
              this.world = null;
              this.object1 = null;
              this.object2 = null;
              this.collideCallback = null;
              this.processCallback = null;
              this.callbackContext = null;
            }
          });
          module2.exports = Collider;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTilesWithin = __webpack_require__(26);
          var Vector29 = __webpack_require__(3);
          var pointStart = new Vector29();
          var pointEnd = new Vector29();
          var GetTilesWithinWorldXY = function(worldX, worldY, width, height, filteringOptions, camera, layer) {
            var worldToTileXY = layer.tilemapLayer.tilemap._convert.WorldToTileXY;
            worldToTileXY(worldX, worldY, true, pointStart, camera, layer);
            var xStart = pointStart.x;
            var yStart = pointStart.y;
            worldToTileXY(worldX + width, worldY + height, false, pointEnd, camera, layer);
            var xEnd = Math.ceil(pointEnd.x);
            var yEnd = Math.ceil(pointEnd.y);
            return GetTilesWithin(xStart, yStart, xEnd - xStart, yEnd - yStart, filteringOptions, layer);
          };
          module2.exports = GetTilesWithinWorldXY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ProcessTileCallbacks = function(tile, sprite) {
            if (tile.collisionCallback) {
              return !tile.collisionCallback.call(tile.collisionCallbackContext, sprite, tile);
            } else if (tile.layer.callbacks[tile.index]) {
              return !tile.layer.callbacks[tile.index].callback.call(tile.layer.callbacks[tile.index].callbackContext, sprite, tile);
            }
            return true;
          };
          module2.exports = ProcessTileCallbacks;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Vladimir Agafonkin
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var quickselect = __webpack_require__(430);
          function rbush(maxEntries) {
            var format = [".left", ".top", ".right", ".bottom"];
            if (!(this instanceof rbush))
              return new rbush(maxEntries, format);
            this._maxEntries = Math.max(4, maxEntries || 9);
            this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
            this.clear();
          }
          rbush.prototype = {
            all: function() {
              return this._all(this.data, []);
            },
            search: function(bbox) {
              var node = this.data, result = [], toBBox = this.toBBox;
              if (!intersects(bbox, node))
                return result;
              var nodesToSearch = [], i, len, child, childBBox;
              while (node) {
                for (i = 0, len = node.children.length; i < len; i++) {
                  child = node.children[i];
                  childBBox = node.leaf ? toBBox(child) : child;
                  if (intersects(bbox, childBBox)) {
                    if (node.leaf)
                      result.push(child);
                    else if (contains(bbox, childBBox))
                      this._all(child, result);
                    else
                      nodesToSearch.push(child);
                  }
                }
                node = nodesToSearch.pop();
              }
              return result;
            },
            collides: function(bbox) {
              var node = this.data, toBBox = this.toBBox;
              if (!intersects(bbox, node))
                return false;
              var nodesToSearch = [], i, len, child, childBBox;
              while (node) {
                for (i = 0, len = node.children.length; i < len; i++) {
                  child = node.children[i];
                  childBBox = node.leaf ? toBBox(child) : child;
                  if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox))
                      return true;
                    nodesToSearch.push(child);
                  }
                }
                node = nodesToSearch.pop();
              }
              return false;
            },
            load: function(data) {
              if (!(data && data.length))
                return this;
              if (data.length < this._minEntries) {
                for (var i = 0, len = data.length; i < len; i++) {
                  this.insert(data[i]);
                }
                return this;
              }
              var node = this._build(data.slice(), 0, data.length - 1, 0);
              if (!this.data.children.length) {
                this.data = node;
              } else if (this.data.height === node.height) {
                this._splitRoot(this.data, node);
              } else {
                if (this.data.height < node.height) {
                  var tmpNode = this.data;
                  this.data = node;
                  node = tmpNode;
                }
                this._insert(node, this.data.height - node.height - 1, true);
              }
              return this;
            },
            insert: function(item) {
              if (item)
                this._insert(item, this.data.height - 1);
              return this;
            },
            clear: function() {
              this.data = createNode([]);
              return this;
            },
            remove: function(item, equalsFn) {
              if (!item)
                return this;
              var node = this.data, bbox = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;
              while (node || path.length) {
                if (!node) {
                  node = path.pop();
                  parent = path[path.length - 1];
                  i = indexes.pop();
                  goingUp = true;
                }
                if (node.leaf) {
                  index = findItem(item, node.children, equalsFn);
                  if (index !== -1) {
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                  }
                }
                if (!goingUp && !node.leaf && contains(node, bbox)) {
                  path.push(node);
                  indexes.push(i);
                  i = 0;
                  parent = node;
                  node = node.children[0];
                } else if (parent) {
                  i++;
                  node = parent.children[i];
                  goingUp = false;
                } else
                  node = null;
              }
              return this;
            },
            toBBox: function(item) {
              return item;
            },
            compareMinX: compareNodeMinX,
            compareMinY: compareNodeMinY,
            toJSON: function() {
              return this.data;
            },
            fromJSON: function(data) {
              this.data = data;
              return this;
            },
            _all: function(node, result) {
              var nodesToSearch = [];
              while (node) {
                if (node.leaf)
                  result.push.apply(result, node.children);
                else
                  nodesToSearch.push.apply(nodesToSearch, node.children);
                node = nodesToSearch.pop();
              }
              return result;
            },
            _build: function(items, left, right, height) {
              var N = right - left + 1, M = this._maxEntries, node;
              if (N <= M) {
                node = createNode(items.slice(left, right + 1));
                calcBBox(node, this.toBBox);
                return node;
              }
              if (!height) {
                height = Math.ceil(Math.log(N) / Math.log(M));
                M = Math.ceil(N / Math.pow(M, height - 1));
              }
              node = createNode([]);
              node.leaf = false;
              node.height = height;
              var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
              multiSelect(items, left, right, N1, this.compareMinX);
              for (i = left; i <= right; i += N1) {
                right2 = Math.min(i + N1 - 1, right);
                multiSelect(items, i, right2, N2, this.compareMinY);
                for (j = i; j <= right2; j += N2) {
                  right3 = Math.min(j + N2 - 1, right2);
                  node.children.push(this._build(items, j, right3, height - 1));
                }
              }
              calcBBox(node, this.toBBox);
              return node;
            },
            _chooseSubtree: function(bbox, node, level, path) {
              var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;
              while (true) {
                path.push(node);
                if (node.leaf || path.length - 1 === level)
                  break;
                minArea = minEnlargement = Infinity;
                for (i = 0, len = node.children.length; i < len; i++) {
                  child = node.children[i];
                  area = bboxArea(child);
                  enlargement = enlargedArea(bbox, child) - area;
                  if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;
                  } else if (enlargement === minEnlargement) {
                    if (area < minArea) {
                      minArea = area;
                      targetNode = child;
                    }
                  }
                }
                node = targetNode || node.children[0];
              }
              return node;
            },
            _insert: function(item, level, isNode) {
              var toBBox = this.toBBox, bbox = isNode ? item : toBBox(item), insertPath = [];
              var node = this._chooseSubtree(bbox, this.data, level, insertPath);
              node.children.push(item);
              extend(node, bbox);
              while (level >= 0) {
                if (insertPath[level].children.length > this._maxEntries) {
                  this._split(insertPath, level);
                  level--;
                } else
                  break;
              }
              this._adjustParentBBoxes(bbox, insertPath, level);
            },
            _split: function(insertPath, level) {
              var node = insertPath[level], M = node.children.length, m = this._minEntries;
              this._chooseSplitAxis(node, m, M);
              var splitIndex = this._chooseSplitIndex(node, m, M);
              var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
              newNode.height = node.height;
              newNode.leaf = node.leaf;
              calcBBox(node, this.toBBox);
              calcBBox(newNode, this.toBBox);
              if (level)
                insertPath[level - 1].children.push(newNode);
              else
                this._splitRoot(node, newNode);
            },
            _splitRoot: function(node, newNode) {
              this.data = createNode([node, newNode]);
              this.data.height = node.height + 1;
              this.data.leaf = false;
              calcBBox(this.data, this.toBBox);
            },
            _chooseSplitIndex: function(node, m, M) {
              var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
              minOverlap = minArea = Infinity;
              for (i = m; i <= M - m; i++) {
                bbox1 = distBBox(node, 0, i, this.toBBox);
                bbox2 = distBBox(node, i, M, this.toBBox);
                overlap = intersectionArea(bbox1, bbox2);
                area = bboxArea(bbox1) + bboxArea(bbox2);
                if (overlap < minOverlap) {
                  minOverlap = overlap;
                  index = i;
                  minArea = area < minArea ? area : minArea;
                } else if (overlap === minOverlap) {
                  if (area < minArea) {
                    minArea = area;
                    index = i;
                  }
                }
              }
              return index;
            },
            _chooseSplitAxis: function(node, m, M) {
              var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
              if (xMargin < yMargin)
                node.children.sort(compareMinX);
            },
            _allDistMargin: function(node, m, M, compare) {
              node.children.sort(compare);
              var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
              for (i = m; i < M - m; i++) {
                child = node.children[i];
                extend(leftBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(leftBBox);
              }
              for (i = M - m - 1; i >= m; i--) {
                child = node.children[i];
                extend(rightBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(rightBBox);
              }
              return margin;
            },
            _adjustParentBBoxes: function(bbox, path, level) {
              for (var i = level; i >= 0; i--) {
                extend(path[i], bbox);
              }
            },
            _condense: function(path) {
              for (var i = path.length - 1, siblings; i >= 0; i--) {
                if (path[i].children.length === 0) {
                  if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);
                  } else
                    this.clear();
                } else
                  calcBBox(path[i], this.toBBox);
              }
            },
            compareMinX: function(a, b) {
              return a.left - b.left;
            },
            compareMinY: function(a, b) {
              return a.top - b.top;
            },
            toBBox: function(a) {
              return {
                minX: a.left,
                minY: a.top,
                maxX: a.right,
                maxY: a.bottom
              };
            }
          };
          function findItem(item, items, equalsFn) {
            if (!equalsFn)
              return items.indexOf(item);
            for (var i = 0; i < items.length; i++) {
              if (equalsFn(item, items[i]))
                return i;
            }
            return -1;
          }
          function calcBBox(node, toBBox) {
            distBBox(node, 0, node.children.length, toBBox, node);
          }
          function distBBox(node, k, p, toBBox, destNode) {
            if (!destNode)
              destNode = createNode(null);
            destNode.minX = Infinity;
            destNode.minY = Infinity;
            destNode.maxX = -Infinity;
            destNode.maxY = -Infinity;
            for (var i = k, child; i < p; i++) {
              child = node.children[i];
              extend(destNode, node.leaf ? toBBox(child) : child);
            }
            return destNode;
          }
          function extend(a, b) {
            a.minX = Math.min(a.minX, b.minX);
            a.minY = Math.min(a.minY, b.minY);
            a.maxX = Math.max(a.maxX, b.maxX);
            a.maxY = Math.max(a.maxY, b.maxY);
            return a;
          }
          function compareNodeMinX(a, b) {
            return a.minX - b.minX;
          }
          function compareNodeMinY(a, b) {
            return a.minY - b.minY;
          }
          function bboxArea(a) {
            return (a.maxX - a.minX) * (a.maxY - a.minY);
          }
          function bboxMargin(a) {
            return a.maxX - a.minX + (a.maxY - a.minY);
          }
          function enlargedArea(a, b) {
            return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
          }
          function intersectionArea(a, b) {
            var minX = Math.max(a.minX, b.minX), minY = Math.max(a.minY, b.minY), maxX = Math.min(a.maxX, b.maxX), maxY = Math.min(a.maxY, b.maxY);
            return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
          }
          function contains(a, b) {
            return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
          }
          function intersects(a, b) {
            return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
          }
          function createNode(children) {
            return {
              children,
              height: 1,
              leaf: true,
              minX: Infinity,
              minY: Infinity,
              maxX: -Infinity,
              maxY: -Infinity
            };
          }
          function multiSelect(arr, left, right, n, compare) {
            var stack = [left, right], mid;
            while (stack.length) {
              right = stack.pop();
              left = stack.pop();
              if (right - left <= n)
                continue;
              mid = left + Math.ceil((right - left) / n / 2) * n;
              quickselect(arr, mid, left, right, compare);
              stack.push(left, mid, mid, right);
            }
          }
          module2.exports = rbush;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TileCheckX = __webpack_require__(527);
          var TileCheckY = __webpack_require__(529);
          var TileIntersectsBody = __webpack_require__(245);
          var SeparateTile = function(i, body, tile, tileWorldRect, tilemapLayer, tileBias, isLayer) {
            var tileLeft = tileWorldRect.left;
            var tileTop = tileWorldRect.top;
            var tileRight = tileWorldRect.right;
            var tileBottom = tileWorldRect.bottom;
            var faceHorizontal = tile.faceLeft || tile.faceRight;
            var faceVertical = tile.faceTop || tile.faceBottom;
            if (!isLayer) {
              faceHorizontal = true;
              faceVertical = true;
            }
            if (!faceHorizontal && !faceVertical) {
              return false;
            }
            var ox = 0;
            var oy = 0;
            var minX = 0;
            var minY = 1;
            if (body.deltaAbsX() > body.deltaAbsY()) {
              minX = -1;
            } else if (body.deltaAbsX() < body.deltaAbsY()) {
              minY = -1;
            }
            if (body.deltaX() !== 0 && body.deltaY() !== 0 && faceHorizontal && faceVertical) {
              minX = Math.min(Math.abs(body.position.x - tileRight), Math.abs(body.right - tileLeft));
              minY = Math.min(Math.abs(body.position.y - tileBottom), Math.abs(body.bottom - tileTop));
            }
            if (minX < minY) {
              if (faceHorizontal) {
                ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);
                if (ox !== 0 && !TileIntersectsBody(tileWorldRect, body)) {
                  return true;
                }
              }
              if (faceVertical) {
                oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);
              }
            } else {
              if (faceVertical) {
                oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);
                if (oy !== 0 && !TileIntersectsBody(tileWorldRect, body)) {
                  return true;
                }
              }
              if (faceHorizontal) {
                ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);
              }
            }
            return ox !== 0 || oy !== 0;
          };
          module2.exports = SeparateTile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ProcessTileSeparationX = __webpack_require__(528);
          var TileCheckX = function(body, tile, tileLeft, tileRight, tileBias, isLayer) {
            var ox = 0;
            var faceLeft = tile.faceLeft;
            var faceRight = tile.faceRight;
            var collideLeft = tile.collideLeft;
            var collideRight = tile.collideRight;
            if (!isLayer) {
              faceLeft = true;
              faceRight = true;
              collideLeft = true;
              collideRight = true;
            }
            if (body.deltaX() < 0 && collideRight && body.checkCollision.left) {
              if (faceRight && body.x < tileRight) {
                ox = body.x - tileRight;
                if (ox < -tileBias) {
                  ox = 0;
                }
              }
            } else if (body.deltaX() > 0 && collideLeft && body.checkCollision.right) {
              if (faceLeft && body.right > tileLeft) {
                ox = body.right - tileLeft;
                if (ox > tileBias) {
                  ox = 0;
                }
              }
            }
            if (ox !== 0) {
              if (body.customSeparateX) {
                body.overlapX = ox;
              } else {
                ProcessTileSeparationX(body, ox);
              }
            }
            return ox;
          };
          module2.exports = TileCheckX;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ProcessTileSeparationX = function(body, x) {
            if (x < 0) {
              body.blocked.none = false;
              body.blocked.left = true;
            } else if (x > 0) {
              body.blocked.none = false;
              body.blocked.right = true;
            }
            body.position.x -= x;
            if (body.bounce.x === 0) {
              body.velocity.x = 0;
            } else {
              body.velocity.x = -body.velocity.x * body.bounce.x;
            }
          };
          module2.exports = ProcessTileSeparationX;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ProcessTileSeparationY = __webpack_require__(530);
          var TileCheckY = function(body, tile, tileTop, tileBottom, tileBias, isLayer) {
            var oy = 0;
            var faceTop = tile.faceTop;
            var faceBottom = tile.faceBottom;
            var collideUp = tile.collideUp;
            var collideDown = tile.collideDown;
            if (!isLayer) {
              faceTop = true;
              faceBottom = true;
              collideUp = true;
              collideDown = true;
            }
            if (body.deltaY() < 0 && collideDown && body.checkCollision.up) {
              if (faceBottom && body.y < tileBottom) {
                oy = body.y - tileBottom;
                if (oy < -tileBias) {
                  oy = 0;
                }
              }
            } else if (body.deltaY() > 0 && collideUp && body.checkCollision.down) {
              if (faceTop && body.bottom > tileTop) {
                oy = body.bottom - tileTop;
                if (oy > tileBias) {
                  oy = 0;
                }
              }
            }
            if (oy !== 0) {
              if (body.customSeparateY) {
                body.overlapY = oy;
              } else {
                ProcessTileSeparationY(body, oy);
              }
            }
            return oy;
          };
          module2.exports = TileCheckY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ProcessTileSeparationY = function(body, y) {
            if (y < 0) {
              body.blocked.none = false;
              body.blocked.up = true;
            } else if (y > 0) {
              body.blocked.none = false;
              body.blocked.down = true;
            }
            body.position.y -= y;
            if (body.bounce.y === 0) {
              body.velocity.y = 0;
            } else {
              body.velocity.y = -body.velocity.y * body.bounce.y;
            }
          };
          module2.exports = ProcessTileSeparationY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetOverlapX = __webpack_require__(243);
          var ProcessX = __webpack_require__(1383);
          var SeparateX = function(body1, body2, overlapOnly, bias) {
            var overlap = GetOverlapX(body1, body2, overlapOnly, bias);
            var body1Immovable = body1.immovable;
            var body2Immovable = body2.immovable;
            if (overlapOnly || overlap === 0 || body1Immovable && body2Immovable || body1.customSeparateX || body2.customSeparateX) {
              return overlap !== 0 || body1.embedded && body2.embedded;
            }
            var blockedState = ProcessX.Set(body1, body2, overlap);
            if (!body1Immovable && !body2Immovable) {
              if (blockedState > 0) {
                return true;
              }
              return ProcessX.Check();
            } else if (body1Immovable) {
              ProcessX.RunImmovableBody1(blockedState);
            } else if (body2Immovable) {
              ProcessX.RunImmovableBody2(blockedState);
            }
            return true;
          };
          module2.exports = SeparateX;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetOverlapY = __webpack_require__(244);
          var ProcessY = __webpack_require__(1384);
          var SeparateY = function(body1, body2, overlapOnly, bias) {
            var overlap = GetOverlapY(body1, body2, overlapOnly, bias);
            var body1Immovable = body1.immovable;
            var body2Immovable = body2.immovable;
            if (overlapOnly || overlap === 0 || body1Immovable && body2Immovable || body1.customSeparateY || body2.customSeparateY) {
              return overlap !== 0 || body1.embedded && body2.embedded;
            }
            var blockedState = ProcessY.Set(body1, body2, overlap);
            if (!body1Immovable && !body2Immovable) {
              if (blockedState > 0) {
                return true;
              }
              return ProcessY.Check();
            } else if (body1Immovable) {
              ProcessY.RunImmovableBody1(blockedState);
            } else if (body2Immovable) {
              ProcessY.RunImmovableBody2(blockedState);
            }
            return true;
          };
          module2.exports = SeparateY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CircleContains = __webpack_require__(63);
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(60);
          var RectangleContains = __webpack_require__(56);
          var Vector29 = __webpack_require__(3);
          var StaticBody = new Class({
            initialize: function StaticBody2(world, gameObject) {
              var width = gameObject.displayWidth ? gameObject.displayWidth : 64;
              var height = gameObject.displayHeight ? gameObject.displayHeight : 64;
              this.world = world;
              this.gameObject = gameObject;
              this.debugShowBody = world.defaults.debugShowStaticBody;
              this.debugBodyColor = world.defaults.staticBodyDebugColor;
              this.enable = true;
              this.isCircle = false;
              this.radius = 0;
              this.offset = new Vector29();
              this.position = new Vector29(gameObject.x - width * gameObject.originX, gameObject.y - height * gameObject.originY);
              this.width = width;
              this.height = height;
              this.halfWidth = Math.abs(this.width / 2);
              this.halfHeight = Math.abs(this.height / 2);
              this.center = new Vector29(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
              this.velocity = Vector29.ZERO;
              this.allowGravity = false;
              this.gravity = Vector29.ZERO;
              this.bounce = Vector29.ZERO;
              this.onWorldBounds = false;
              this.onCollide = false;
              this.onOverlap = false;
              this.mass = 1;
              this.immovable = true;
              this.pushable = false;
              this.customSeparateX = false;
              this.customSeparateY = false;
              this.overlapX = 0;
              this.overlapY = 0;
              this.overlapR = 0;
              this.embedded = false;
              this.collideWorldBounds = false;
              this.checkCollision = {none: false, up: true, down: true, left: true, right: true};
              this.touching = {none: true, up: false, down: false, left: false, right: false};
              this.wasTouching = {none: true, up: false, down: false, left: false, right: false};
              this.blocked = {none: true, up: false, down: false, left: false, right: false};
              this.physicsType = CONST.STATIC_BODY;
              this._dx = 0;
              this._dy = 0;
            },
            setGameObject: function(gameObject, update) {
              if (gameObject && gameObject !== this.gameObject) {
                this.gameObject.body = null;
                gameObject.body = this;
                this.gameObject = gameObject;
              }
              if (update) {
                this.updateFromGameObject();
              }
              return this;
            },
            updateFromGameObject: function() {
              this.world.staticTree.remove(this);
              var gameObject = this.gameObject;
              gameObject.getTopLeft(this.position);
              this.width = gameObject.displayWidth;
              this.height = gameObject.displayHeight;
              this.halfWidth = Math.abs(this.width / 2);
              this.halfHeight = Math.abs(this.height / 2);
              this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
              this.world.staticTree.insert(this);
              return this;
            },
            setOffset: function(x, y) {
              if (y === void 0) {
                y = x;
              }
              this.world.staticTree.remove(this);
              this.position.x -= this.offset.x;
              this.position.y -= this.offset.y;
              this.offset.set(x, y);
              this.position.x += this.offset.x;
              this.position.y += this.offset.y;
              this.updateCenter();
              this.world.staticTree.insert(this);
              return this;
            },
            setSize: function(width, height, center) {
              if (center === void 0) {
                center = true;
              }
              var gameObject = this.gameObject;
              if (!width && gameObject.frame) {
                width = gameObject.frame.realWidth;
              }
              if (!height && gameObject.frame) {
                height = gameObject.frame.realHeight;
              }
              this.world.staticTree.remove(this);
              this.width = width;
              this.height = height;
              this.halfWidth = Math.floor(width / 2);
              this.halfHeight = Math.floor(height / 2);
              if (center && gameObject.getCenter) {
                var ox = gameObject.displayWidth / 2;
                var oy = gameObject.displayHeight / 2;
                this.position.x -= this.offset.x;
                this.position.y -= this.offset.y;
                this.offset.set(ox - this.halfWidth, oy - this.halfHeight);
                this.position.x += this.offset.x;
                this.position.y += this.offset.y;
              }
              this.updateCenter();
              this.isCircle = false;
              this.radius = 0;
              this.world.staticTree.insert(this);
              return this;
            },
            setCircle: function(radius, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = this.offset.x;
              }
              if (offsetY === void 0) {
                offsetY = this.offset.y;
              }
              if (radius > 0) {
                this.world.staticTree.remove(this);
                this.isCircle = true;
                this.radius = radius;
                this.width = radius * 2;
                this.height = radius * 2;
                this.halfWidth = Math.floor(this.width / 2);
                this.halfHeight = Math.floor(this.height / 2);
                this.offset.set(offsetX, offsetY);
                this.updateCenter();
                this.world.staticTree.insert(this);
              } else {
                this.isCircle = false;
              }
              return this;
            },
            updateCenter: function() {
              this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
            },
            reset: function(x, y) {
              var gameObject = this.gameObject;
              if (x === void 0) {
                x = gameObject.x;
              }
              if (y === void 0) {
                y = gameObject.y;
              }
              this.world.staticTree.remove(this);
              gameObject.setPosition(x, y);
              gameObject.getTopLeft(this.position);
              this.updateCenter();
              this.world.staticTree.insert(this);
            },
            stop: function() {
              return this;
            },
            getBounds: function(obj) {
              obj.x = this.x;
              obj.y = this.y;
              obj.right = this.right;
              obj.bottom = this.bottom;
              return obj;
            },
            hitTest: function(x, y) {
              return this.isCircle ? CircleContains(this, x, y) : RectangleContains(this, x, y);
            },
            postUpdate: function() {
            },
            deltaAbsX: function() {
              return 0;
            },
            deltaAbsY: function() {
              return 0;
            },
            deltaX: function() {
              return 0;
            },
            deltaY: function() {
              return 0;
            },
            deltaZ: function() {
              return 0;
            },
            destroy: function() {
              this.enable = false;
              this.world.pendingDestroy.set(this);
            },
            drawDebug: function(graphic) {
              var pos = this.position;
              var x = pos.x + this.halfWidth;
              var y = pos.y + this.halfHeight;
              if (this.debugShowBody) {
                graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor, 1);
                if (this.isCircle) {
                  graphic.strokeCircle(x, y, this.width / 2);
                } else {
                  graphic.strokeRect(pos.x, pos.y, this.width, this.height);
                }
              }
            },
            willDrawDebug: function() {
              return this.debugShowBody;
            },
            setMass: function(value) {
              if (value <= 0) {
                value = 0.1;
              }
              this.mass = value;
              return this;
            },
            x: {
              get: function() {
                return this.position.x;
              },
              set: function(value) {
                this.world.staticTree.remove(this);
                this.position.x = value;
                this.world.staticTree.insert(this);
              }
            },
            y: {
              get: function() {
                return this.position.y;
              },
              set: function(value) {
                this.world.staticTree.remove(this);
                this.position.y = value;
                this.world.staticTree.insert(this);
              }
            },
            left: {
              get: function() {
                return this.position.x;
              }
            },
            right: {
              get: function() {
                return this.position.x + this.width;
              }
            },
            top: {
              get: function() {
                return this.position.y;
              }
            },
            bottom: {
              get: function() {
                return this.position.y + this.height;
              }
            }
          });
          module2.exports = StaticBody;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Bounce: __webpack_require__(1500),
            Collision: __webpack_require__(1501),
            Force: __webpack_require__(1502),
            Friction: __webpack_require__(1503),
            Gravity: __webpack_require__(1504),
            Mass: __webpack_require__(1505),
            Sensor: __webpack_require__(1506),
            SetBody: __webpack_require__(1507),
            Sleep: __webpack_require__(1508),
            Static: __webpack_require__(1525),
            Transform: __webpack_require__(1526),
            Velocity: __webpack_require__(1527)
          };
        },
        function(module2, exports2) {
          var Pair = {};
          module2.exports = Pair;
          (function() {
            Pair.create = function(collision, timestamp) {
              var bodyA = collision.bodyA, bodyB = collision.bodyB;
              var pair = {
                id: Pair.id(bodyA, bodyB),
                bodyA,
                bodyB,
                activeContacts: [],
                separation: 0,
                isActive: true,
                confirmedActive: true,
                isSensor: bodyA.isSensor || bodyB.isSensor,
                timeCreated: timestamp,
                timeUpdated: timestamp,
                collision: null,
                inverseMass: 0,
                friction: 0,
                frictionStatic: 0,
                restitution: 0,
                slop: 0
              };
              Pair.update(pair, collision, timestamp);
              return pair;
            };
            Pair.update = function(pair, collision, timestamp) {
              pair.collision = collision;
              if (collision.collided) {
                var supports = collision.supports, activeContacts = pair.activeContacts, parentA = collision.parentA, parentB = collision.parentB;
                pair.inverseMass = parentA.inverseMass + parentB.inverseMass;
                pair.friction = Math.min(parentA.friction, parentB.friction);
                pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);
                pair.restitution = Math.max(parentA.restitution, parentB.restitution);
                pair.slop = Math.max(parentA.slop, parentB.slop);
                for (var i = 0; i < supports.length; i++) {
                  activeContacts[i] = supports[i].contact;
                }
                var supportCount = supports.length;
                if (supportCount < activeContacts.length) {
                  activeContacts.length = supportCount;
                }
                pair.separation = collision.depth;
                Pair.setActive(pair, true, timestamp);
              } else {
                if (pair.isActive === true)
                  Pair.setActive(pair, false, timestamp);
              }
            };
            Pair.setActive = function(pair, isActive, timestamp) {
              if (isActive) {
                pair.isActive = true;
                pair.timeUpdated = timestamp;
              } else {
                pair.isActive = false;
                pair.activeContacts.length = 0;
              }
            };
            Pair.id = function(bodyA, bodyB) {
              if (bodyA.id < bodyB.id) {
                return "A" + bodyA.id + "B" + bodyB.id;
              } else {
                return "A" + bodyB.id + "B" + bodyA.id;
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          /**
          * @author       Richard Davey <rich@photonstorm.com>
          * @copyright    2020 Photon Storm Ltd.
          * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}
          */
          var Class = __webpack_require__(0);
          var BasePlugin = new Class({
            initialize: function BasePlugin2(pluginManager) {
              this.pluginManager = pluginManager;
              this.game = pluginManager.game;
            },
            init: function() {
            },
            start: function() {
            },
            stop: function() {
            },
            destroy: function() {
              this.pluginManager = null;
              this.game = null;
              this.scene = null;
              this.systems = null;
            }
          });
          module2.exports = BasePlugin;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector29 = __webpack_require__(3);
          var point = new Vector29();
          var CheckIsoBounds = function(tileX, tileY, layer, camera) {
            var tilemapLayer = layer.tilemapLayer;
            var cullPaddingX = tilemapLayer.cullPaddingX;
            var cullPaddingY = tilemapLayer.cullPaddingY;
            var pos = tilemapLayer.tilemap.tileToWorldXY(tileX, tileY, point, camera, tilemapLayer);
            return pos.x > camera.worldView.x + tilemapLayer.scaleX * layer.tileWidth * (-cullPaddingX - 0.5) && pos.x < camera.worldView.right + tilemapLayer.scaleX * layer.tileWidth * (cullPaddingX - 0.5) && pos.y > camera.worldView.y + tilemapLayer.scaleY * layer.tileHeight * (-cullPaddingY - 1) && pos.y < camera.worldView.bottom + tilemapLayer.scaleY * layer.tileHeight * (cullPaddingY - 0.5);
          };
          module2.exports = CheckIsoBounds;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTilesWithin = __webpack_require__(26);
          var ReplaceByIndex = function(findIndex, newIndex, tileX, tileY, width, height, layer) {
            var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
            for (var i = 0; i < tiles.length; i++) {
              if (tiles[i] && tiles[i].index === findIndex) {
                tiles[i].index = newIndex;
              }
            }
          };
          module2.exports = ReplaceByIndex;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rectangle = __webpack_require__(10);
          var SnapCeil = __webpack_require__(137);
          var SnapFloor = __webpack_require__(76);
          var bounds = new Rectangle();
          var CullBounds = function(layer, camera) {
            var tilemap = layer.tilemapLayer.tilemap;
            var tilemapLayer = layer.tilemapLayer;
            var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
            var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
            var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
            var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
            var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH, 0, true) - tilemapLayer.cullPaddingY;
            var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH, 0, true) + tilemapLayer.cullPaddingY;
            return bounds.setTo(boundsLeft, boundsTop, boundsRight - boundsLeft, boundsBottom - boundsTop);
          };
          module2.exports = CullBounds;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CullBounds = __webpack_require__(539);
          var RunCull = __webpack_require__(157);
          var CullTiles = function(layer, camera, outputArray, renderOrder) {
            if (outputArray === void 0) {
              outputArray = [];
            }
            if (renderOrder === void 0) {
              renderOrder = 0;
            }
            outputArray.length = 0;
            var tilemapLayer = layer.tilemapLayer;
            var bounds = CullBounds(layer, camera);
            if (tilemapLayer.skipCull || tilemapLayer.scrollFactorX !== 1 || tilemapLayer.scrollFactorY !== 1) {
              bounds.left = 0;
              bounds.right = layer.width;
              bounds.top = 0;
              bounds.bottom = layer.height;
            }
            RunCull(layer, bounds, renderOrder, outputArray);
            return outputArray;
          };
          module2.exports = CullTiles;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CullBounds = __webpack_require__(542);
          var RunCull = __webpack_require__(157);
          var HexagonalCullTiles = function(layer, camera, outputArray, renderOrder) {
            if (outputArray === void 0) {
              outputArray = [];
            }
            if (renderOrder === void 0) {
              renderOrder = 0;
            }
            outputArray.length = 0;
            var tilemapLayer = layer.tilemapLayer;
            if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1) {
              var bounds = CullBounds(layer, camera);
              RunCull(layer, bounds, renderOrder, outputArray);
            }
            return outputArray;
          };
          module2.exports = HexagonalCullTiles;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SnapCeil = __webpack_require__(137);
          var SnapFloor = __webpack_require__(76);
          var HexagonalCullBounds = function(layer, camera) {
            var tilemap = layer.tilemapLayer.tilemap;
            var tilemapLayer = layer.tilemapLayer;
            var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
            var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
            var len = layer.hexSideLength;
            var rowH = (tileH - len) / 2 + len;
            var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
            var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
            var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, rowH, 0, true) - tilemapLayer.cullPaddingY;
            var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, rowH, 0, true) + tilemapLayer.cullPaddingY;
            return {
              left: boundsLeft,
              right: boundsRight,
              top: boundsTop,
              bottom: boundsBottom
            };
          };
          module2.exports = HexagonalCullBounds;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CheckIsoBounds = __webpack_require__(537);
          var IsometricCullTiles = function(layer, camera, outputArray, renderOrder) {
            if (outputArray === void 0) {
              outputArray = [];
            }
            if (renderOrder === void 0) {
              renderOrder = 0;
            }
            outputArray.length = 0;
            var tilemapLayer = layer.tilemapLayer;
            var mapData = layer.data;
            var mapWidth = layer.width;
            var mapHeight = layer.height;
            var drawLeft = 0;
            var drawRight = mapWidth;
            var drawTop = 0;
            var drawBottom = mapHeight;
            if (!tilemapLayer.skipCull) {
              var x;
              var y;
              var tile;
              if (renderOrder === 0) {
                for (y = drawTop; y < drawBottom; y++) {
                  for (x = drawLeft; mapData[y] && x < drawRight; x++) {
                    if (CheckIsoBounds(x, y, layer, camera)) {
                      tile = mapData[y][x];
                      if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                        continue;
                      }
                      outputArray.push(tile);
                    }
                  }
                }
              } else if (renderOrder === 1) {
                for (y = drawTop; y < drawBottom; y++) {
                  for (x = drawRight; mapData[y] && x >= drawLeft; x--) {
                    if (CheckIsoBounds(x, y, layer, camera)) {
                      tile = mapData[y][x];
                      if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                        continue;
                      }
                      outputArray.push(tile);
                    }
                  }
                }
              } else if (renderOrder === 2) {
                for (y = drawBottom; y >= drawTop; y--) {
                  for (x = drawLeft; mapData[y] && x < drawRight; x++) {
                    if (CheckIsoBounds(x, y, layer, camera)) {
                      tile = mapData[y][x];
                      if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                        continue;
                      }
                      outputArray.push(tile);
                    }
                  }
                }
              } else if (renderOrder === 3) {
                for (y = drawBottom; y >= drawTop; y--) {
                  for (x = drawRight; mapData[y] && x >= drawLeft; x--) {
                    if (CheckIsoBounds(x, y, layer, camera)) {
                      tile = mapData[y][x];
                      if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                        continue;
                      }
                      outputArray.push(tile);
                    }
                  }
                }
              }
            }
            tilemapLayer.tilesDrawn = outputArray.length;
            tilemapLayer.tilesTotal = mapWidth * mapHeight;
            return outputArray;
          };
          module2.exports = IsometricCullTiles;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CullBounds = __webpack_require__(545);
          var RunCull = __webpack_require__(157);
          var StaggeredCullTiles = function(layer, camera, outputArray, renderOrder) {
            if (outputArray === void 0) {
              outputArray = [];
            }
            if (renderOrder === void 0) {
              renderOrder = 0;
            }
            outputArray.length = 0;
            var tilemapLayer = layer.tilemapLayer;
            if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1) {
              var bounds = CullBounds(layer, camera);
              RunCull(layer, bounds, renderOrder, outputArray);
            }
            return outputArray;
          };
          module2.exports = StaggeredCullTiles;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SnapCeil = __webpack_require__(137);
          var SnapFloor = __webpack_require__(76);
          var StaggeredCullBounds = function(layer, camera) {
            var tilemap = layer.tilemapLayer.tilemap;
            var tilemapLayer = layer.tilemapLayer;
            var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
            var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
            var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
            var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
            var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH / 2, 0, true) - tilemapLayer.cullPaddingY;
            var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH / 2, 0, true) + tilemapLayer.cullPaddingY;
            return {
              left: boundsLeft,
              right: boundsRight,
              top: boundsTop,
              bottom: boundsBottom
            };
          };
          module2.exports = StaggeredCullBounds;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector29 = __webpack_require__(3);
          var HexagonalTileToWorldXY = function(tileX, tileY, point, camera, layer) {
            if (!point) {
              point = new Vector29();
            }
            var tileWidth = layer.baseTileWidth;
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            var layerWorldX = 0;
            var layerWorldY = 0;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
              tileWidth *= tilemapLayer.scaleX;
              layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
              tileHeight *= tilemapLayer.scaleY;
            }
            var len = layer.hexSideLength;
            var rowHeight = (tileHeight - len) / 2 + len;
            var x = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);
            var y = layerWorldY + tileY * rowHeight;
            return point.set(x, y);
          };
          module2.exports = HexagonalTileToWorldXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector29 = __webpack_require__(3);
          var IsometricTileToWorldXY = function(tileX, tileY, point, camera, layer) {
            if (!point) {
              point = new Vector29();
            }
            var tileWidth = layer.baseTileWidth;
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            var layerWorldX = 0;
            var layerWorldY = 0;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
              tileWidth *= tilemapLayer.scaleX;
              layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
              tileHeight *= tilemapLayer.scaleY;
            }
            var x = layerWorldX + (tileX - tileY) * (tileWidth / 2);
            var y = layerWorldY + (tileX + tileY) * (tileHeight / 2);
            return point.set(x, y);
          };
          module2.exports = IsometricTileToWorldXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector29 = __webpack_require__(3);
          var StaggeredTileToWorldXY = function(tileX, tileY, point, camera, layer) {
            if (!point) {
              point = new Vector29();
            }
            var tileWidth = layer.baseTileWidth;
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            var layerWorldX = 0;
            var layerWorldY = 0;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
              tileWidth *= tilemapLayer.scaleX;
              layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
              tileHeight *= tilemapLayer.scaleY;
            }
            var x = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);
            var y = layerWorldY + tileY * (tileHeight / 2);
            return point.set(x, y);
          };
          module2.exports = StaggeredTileToWorldXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TileToWorldX = __webpack_require__(249);
          var TileToWorldY = __webpack_require__(250);
          var Vector29 = __webpack_require__(3);
          var TileToWorldXY = function(tileX, tileY, point, camera, layer) {
            if (!point) {
              point = new Vector29(0, 0);
            }
            point.x = TileToWorldX(tileX, camera, layer);
            point.y = TileToWorldY(tileY, camera, layer);
            return point;
          };
          module2.exports = TileToWorldXY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var HexagonalTileToWorldY = function(tileY, camera, layer) {
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            var layerWorldY = 0;
            if (tilemapLayer) {
              if (camera === void 0) {
                camera = tilemapLayer.scene.cameras.main;
              }
              layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
              tileHeight *= tilemapLayer.scaleY;
            }
            var len = tilemapLayer.tilemap.hexSideLength;
            var rowHeight = (tileHeight - len) / 2 + len;
            return layerWorldY + tileY * rowHeight;
          };
          module2.exports = HexagonalTileToWorldY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var StaggeredTileToWorldY = function(tileY, camera, layer) {
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            var layerWorldY = 0;
            if (tilemapLayer) {
              if (camera === void 0) {
                camera = tilemapLayer.scene.cameras.main;
              }
              layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
              tileHeight *= tilemapLayer.scaleY;
            }
            return layerWorldY + tileY * (tileHeight / 2);
          };
          module2.exports = StaggeredTileToWorldY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector29 = __webpack_require__(3);
          var HexagonalWorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
            if (!point) {
              point = new Vector29();
            }
            var tileWidth = layer.baseTileWidth;
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
              tileHeight *= tilemapLayer.scaleY;
              worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
              tileWidth *= tilemapLayer.scaleX;
            }
            var len = layer.hexSideLength;
            var rowHeight = (tileHeight - len) / 2 + len;
            var y = snapToFloor ? Math.floor(worldY / rowHeight) : worldY / rowHeight;
            var x = snapToFloor ? Math.floor((worldX - y % 2 * 0.5 * tileWidth) / tileWidth) : (worldX - y % 2 * 0.5 * tileWidth) / tileWidth;
            return point.set(x, y);
          };
          module2.exports = HexagonalWorldToTileXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector29 = __webpack_require__(3);
          var IsometricWorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
            if (!point) {
              point = new Vector29();
            }
            var tileWidth = layer.baseTileWidth;
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
              tileHeight *= tilemapLayer.scaleY;
              worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
              tileWidth *= tilemapLayer.scaleX;
            }
            worldX -= tileWidth / 2;
            var x = snapToFloor ? Math.floor((worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2) : (worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2;
            var y = snapToFloor ? Math.floor((worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2) : (worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2;
            return point.set(x, y);
          };
          module2.exports = IsometricWorldToTileXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector29 = __webpack_require__(3);
          var StaggeredWorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
            if (!point) {
              point = new Vector29();
            }
            var tileWidth = layer.baseTileWidth;
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
              tileHeight *= tilemapLayer.scaleY;
              worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
              tileWidth *= tilemapLayer.scaleX;
            }
            var y = snapToFloor ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);
            var x = snapToFloor ? Math.floor((worldX + y % 2 * 0.5 * tileWidth) / tileWidth) : (worldX + y % 2 * 0.5 * tileWidth) / tileWidth;
            return point.set(x, y);
          };
          module2.exports = StaggeredWorldToTileXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var WorldToTileX = __webpack_require__(251);
          var WorldToTileY = __webpack_require__(252);
          var Vector29 = __webpack_require__(3);
          var WorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
            if (snapToFloor === void 0) {
              snapToFloor = true;
            }
            if (!point) {
              point = new Vector29(0, 0);
            }
            point.x = WorldToTileX(worldX, snapToFloor, camera, layer);
            point.y = WorldToTileY(worldY, snapToFloor, camera, layer);
            return point;
          };
          module2.exports = WorldToTileXY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var HexagonalWorldToTileY = function(worldY, snapToFloor, camera, layer) {
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
              tileHeight *= tilemapLayer.scaleY;
            }
            var len = layer.hexSideLength;
            var rowHeight = (tileHeight - len) / 2 + len;
            return snapToFloor ? Math.floor(worldY / rowHeight) : worldY / rowHeight;
          };
          module2.exports = HexagonalWorldToTileY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var StaggeredWorldToTileY = function(worldY, snapToFloor, camera, layer) {
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
              tileHeight *= tilemapLayer.scaleY;
            }
            return snapToFloor ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);
          };
          module2.exports = StaggeredWorldToTileY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var IsInLayerBounds = __webpack_require__(118);
          var HasTileAt = function(tileX, tileY, layer) {
            if (IsInLayerBounds(tileX, tileY, layer)) {
              var tile = layer.data[tileY][tileX];
              return tile !== null && tile.index > -1;
            } else {
              return false;
            }
          };
          module2.exports = HasTileAt;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Tile = __webpack_require__(83);
          var IsInLayerBounds = __webpack_require__(118);
          var CalculateFacesAt = __webpack_require__(248);
          var RemoveTileAt = function(tileX, tileY, replaceWithNull, recalculateFaces, layer) {
            if (replaceWithNull === void 0) {
              replaceWithNull = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (!IsInLayerBounds(tileX, tileY, layer)) {
              return null;
            }
            var tile = layer.data[tileY][tileX];
            if (!tile) {
              return null;
            } else {
              layer.data[tileY][tileX] = replaceWithNull ? null : new Tile(layer, -1, tileX, tileY, layer.tileWidth, layer.tileHeight);
            }
            if (recalculateFaces && tile && tile.collides) {
              CalculateFacesAt(tileX, tileY, layer);
            }
            return tile;
          };
          module2.exports = RemoveTileAt;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Formats = __webpack_require__(39);
          var Parse2DArray = __webpack_require__(255);
          var ParseCSV = __webpack_require__(561);
          var ParseJSONTiled = __webpack_require__(562);
          var ParseWeltmeister = __webpack_require__(573);
          var Parse = function(name, mapFormat, data, tileWidth, tileHeight, insertNull) {
            var newMap;
            switch (mapFormat) {
              case Formats.ARRAY_2D:
                newMap = Parse2DArray(name, data, tileWidth, tileHeight, insertNull);
                break;
              case Formats.CSV:
                newMap = ParseCSV(name, data, tileWidth, tileHeight, insertNull);
                break;
              case Formats.TILED_JSON:
                newMap = ParseJSONTiled(name, data, insertNull);
                break;
              case Formats.WELTMEISTER:
                newMap = ParseWeltmeister(name, data, insertNull);
                break;
              default:
                console.warn("Unrecognized tilemap data format: " + mapFormat);
                newMap = null;
            }
            return newMap;
          };
          module2.exports = Parse;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Formats = __webpack_require__(39);
          var Parse2DArray = __webpack_require__(255);
          var ParseCSV = function(name, data, tileWidth, tileHeight, insertNull) {
            var array2D = data.trim().split("\n").map(function(row) {
              return row.split(",");
            });
            var map = Parse2DArray(name, array2D, tileWidth, tileHeight, insertNull);
            map.format = Formats.CSV;
            return map;
          };
          module2.exports = ParseCSV;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AssignTileProperties = __webpack_require__(563);
          var BuildTilesetIndex = __webpack_require__(564);
          var CONST = __webpack_require__(29);
          var Formats = __webpack_require__(39);
          var FromOrientationString = __webpack_require__(254);
          var MapData = __webpack_require__(120);
          var ParseImageLayers = __webpack_require__(565);
          var ParseObjectLayers = __webpack_require__(566);
          var ParseTileLayers = __webpack_require__(569);
          var ParseTilesets = __webpack_require__(571);
          var ParseJSONTiled = function(name, json, insertNull) {
            var mapData = new MapData({
              width: json.width,
              height: json.height,
              name,
              tileWidth: json.tilewidth,
              tileHeight: json.tileheight,
              orientation: FromOrientationString(json.orientation),
              format: Formats.TILED_JSON,
              version: json.version,
              properties: json.properties,
              renderOrder: json.renderorder,
              infinite: json.infinite
            });
            if (mapData.orientation === CONST.HEXAGONAL) {
              mapData.hexSideLength = json.hexsidelength;
            }
            mapData.layers = ParseTileLayers(json, insertNull);
            mapData.images = ParseImageLayers(json);
            var sets = ParseTilesets(json);
            mapData.tilesets = sets.tilesets;
            mapData.imageCollections = sets.imageCollections;
            mapData.objects = ParseObjectLayers(json);
            mapData.tiles = BuildTilesetIndex(mapData);
            AssignTileProperties(mapData);
            return mapData;
          };
          module2.exports = ParseJSONTiled;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Extend = __webpack_require__(17);
          var AssignTileProperties = function(mapData) {
            var layerData;
            var tile;
            var sid;
            var set;
            var row;
            for (var i = 0; i < mapData.layers.length; i++) {
              layerData = mapData.layers[i];
              set = null;
              for (var j = 0; j < layerData.data.length; j++) {
                row = layerData.data[j];
                for (var k = 0; k < row.length; k++) {
                  tile = row[k];
                  if (tile === null || tile.index < 0) {
                    continue;
                  }
                  sid = mapData.tiles[tile.index][2];
                  set = mapData.tilesets[sid];
                  tile.width = set.tileWidth;
                  tile.height = set.tileHeight;
                  if (set.tileProperties && set.tileProperties[tile.index - set.firstgid]) {
                    tile.properties = Extend(tile.properties, set.tileProperties[tile.index - set.firstgid]);
                  }
                }
              }
            }
          };
          module2.exports = AssignTileProperties;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Tileset = __webpack_require__(121);
          var BuildTilesetIndex = function(mapData) {
            var i;
            var set;
            var tiles = [];
            for (i = 0; i < mapData.imageCollections.length; i++) {
              var collection = mapData.imageCollections[i];
              var images = collection.images;
              for (var j = 0; j < images.length; j++) {
                var image = images[j];
                set = new Tileset(image.image, image.gid, collection.imageWidth, collection.imageHeight, 0, 0);
                set.updateTileData(collection.imageWidth, collection.imageHeight);
                mapData.tilesets.push(set);
              }
            }
            for (i = 0; i < mapData.tilesets.length; i++) {
              set = mapData.tilesets[i];
              var x = set.tileMargin;
              var y = set.tileMargin;
              var count = 0;
              var countX = 0;
              var countY = 0;
              for (var t = set.firstgid; t < set.firstgid + set.total; t++) {
                tiles[t] = [x, y, i];
                x += set.tileWidth + set.tileSpacing;
                count++;
                if (count === set.total) {
                  break;
                }
                countX++;
                if (countX === set.columns) {
                  x = set.tileMargin;
                  y += set.tileHeight + set.tileSpacing;
                  countX = 0;
                  countY++;
                  if (countY === set.rows) {
                    break;
                  }
                }
              }
            }
            return tiles;
          };
          module2.exports = BuildTilesetIndex;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetFastValue = __webpack_require__(2);
          var CreateGroupLayer = __webpack_require__(159);
          var ParseImageLayers = function(json) {
            var images = [];
            var groupStack = [];
            var curGroupState = CreateGroupLayer(json);
            while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
              if (curGroupState.i >= curGroupState.layers.length) {
                if (groupStack.length < 1) {
                  console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                  break;
                }
                curGroupState = groupStack.pop();
                continue;
              }
              var curi = curGroupState.layers[curGroupState.i];
              curGroupState.i++;
              if (curi.type !== "imagelayer") {
                if (curi.type === "group") {
                  var nextGroupState = CreateGroupLayer(json, curi, curGroupState);
                  groupStack.push(curGroupState);
                  curGroupState = nextGroupState;
                }
                continue;
              }
              var layerOffsetX = GetFastValue(curi, "offsetx", 0) + GetFastValue(curi, "startx", 0);
              var layerOffsetY = GetFastValue(curi, "offsety", 0) + GetFastValue(curi, "starty", 0);
              images.push({
                name: curGroupState.name + curi.name,
                image: curi.image,
                x: curGroupState.x + layerOffsetX + curi.x,
                y: curGroupState.y + layerOffsetY + curi.y,
                alpha: curGroupState.opacity * curi.opacity,
                visible: curGroupState.visible && curi.visible,
                properties: GetFastValue(curi, "properties", {})
              });
            }
            return images;
          };
          module2.exports = ParseImageLayers;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetFastValue = __webpack_require__(2);
          var ParseObject = __webpack_require__(256);
          var ObjectLayer = __webpack_require__(568);
          var CreateGroupLayer = __webpack_require__(159);
          var ParseObjectLayers = function(json) {
            var objectLayers = [];
            var groupStack = [];
            var curGroupState = CreateGroupLayer(json);
            while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
              if (curGroupState.i >= curGroupState.layers.length) {
                if (groupStack.length < 1) {
                  console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                  break;
                }
                curGroupState = groupStack.pop();
                continue;
              }
              var curo = curGroupState.layers[curGroupState.i];
              curGroupState.i++;
              curo.opacity *= curGroupState.opacity;
              curo.visible = curGroupState.visible && curo.visible;
              if (curo.type !== "objectgroup") {
                if (curo.type === "group") {
                  var nextGroupState = CreateGroupLayer(json, curo, curGroupState);
                  groupStack.push(curGroupState);
                  curGroupState = nextGroupState;
                }
                continue;
              }
              curo.name = curGroupState.name + curo.name;
              var offsetX = curGroupState.x + GetFastValue(curo, "startx", 0) + GetFastValue(curo, "offsetx", 0);
              var offsetY = curGroupState.y + GetFastValue(curo, "starty", 0) + GetFastValue(curo, "offsety", 0);
              var objects = [];
              for (var j = 0; j < curo.objects.length; j++) {
                var parsedObject = ParseObject(curo.objects[j], offsetX, offsetY);
                objects.push(parsedObject);
              }
              var objectLayer = new ObjectLayer(curo);
              objectLayer.objects = objects;
              objectLayers.push(objectLayer);
            }
            return objectLayers;
          };
          module2.exports = ParseObjectLayers;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var HasValue = __webpack_require__(125);
          var Pick = function(object, keys) {
            var obj = {};
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (HasValue(object, key)) {
                obj[key] = object[key];
              }
            }
            return obj;
          };
          module2.exports = Pick;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var ObjectLayer = new Class({
            initialize: function ObjectLayer2(config2) {
              if (config2 === void 0) {
                config2 = {};
              }
              this.name = GetFastValue(config2, "name", "object layer");
              this.opacity = GetFastValue(config2, "opacity", 1);
              this.properties = GetFastValue(config2, "properties", {});
              this.propertyTypes = GetFastValue(config2, "propertytypes", {});
              this.type = GetFastValue(config2, "type", "objectgroup");
              this.visible = GetFastValue(config2, "visible", true);
              this.objects = GetFastValue(config2, "objects", []);
            }
          });
          module2.exports = ObjectLayer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Base64Decode = __webpack_require__(570);
          var CONST = __webpack_require__(29);
          var CreateGroupLayer = __webpack_require__(159);
          var FromOrientationString = __webpack_require__(254);
          var GetFastValue = __webpack_require__(2);
          var LayerData = __webpack_require__(119);
          var ParseGID = __webpack_require__(257);
          var Tile = __webpack_require__(83);
          var ParseTileLayers = function(json, insertNull) {
            var infiniteMap = GetFastValue(json, "infinite", false);
            var tileLayers = [];
            var groupStack = [];
            var curGroupState = CreateGroupLayer(json);
            while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
              if (curGroupState.i >= curGroupState.layers.length) {
                if (groupStack.length < 1) {
                  console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                  break;
                }
                curGroupState = groupStack.pop();
                continue;
              }
              var curl = curGroupState.layers[curGroupState.i];
              curGroupState.i++;
              if (curl.type !== "tilelayer") {
                if (curl.type === "group") {
                  var nextGroupState = CreateGroupLayer(json, curl, curGroupState);
                  groupStack.push(curGroupState);
                  curGroupState = nextGroupState;
                }
                continue;
              }
              if (curl.compression) {
                console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + curl.name + "'");
                continue;
              } else if (curl.encoding && curl.encoding === "base64") {
                if (curl.chunks) {
                  for (var i = 0; i < curl.chunks.length; i++) {
                    curl.chunks[i].data = Base64Decode(curl.chunks[i].data);
                  }
                }
                if (curl.data) {
                  curl.data = Base64Decode(curl.data);
                }
                delete curl.encoding;
              }
              var layerData;
              var gidInfo;
              var tile;
              var blankTile;
              var output = [];
              var x = 0;
              if (infiniteMap) {
                var layerOffsetX = GetFastValue(curl, "startx", 0) + curl.x;
                var layerOffsetY = GetFastValue(curl, "starty", 0) + curl.y;
                layerData = new LayerData({
                  name: curGroupState.name + curl.name,
                  x: curGroupState.x + GetFastValue(curl, "offsetx", 0) + layerOffsetX * json.tilewidth,
                  y: curGroupState.y + GetFastValue(curl, "offsety", 0) + layerOffsetY * json.tileheight,
                  width: curl.width,
                  height: curl.height,
                  tileWidth: json.tilewidth,
                  tileHeight: json.tileheight,
                  alpha: curGroupState.opacity * curl.opacity,
                  visible: curGroupState.visible && curl.visible,
                  properties: GetFastValue(curl, "properties", []),
                  orientation: FromOrientationString(json.orientation)
                });
                if (layerData.orientation === CONST.HEXAGONAL) {
                  layerData.hexSideLength = json.hexsidelength;
                }
                for (var c = 0; c < curl.height; c++) {
                  output.push([null]);
                  for (var j = 0; j < curl.width; j++) {
                    output[c][j] = null;
                  }
                }
                for (c = 0, len = curl.chunks.length; c < len; c++) {
                  var chunk = curl.chunks[c];
                  var offsetX = chunk.x - layerOffsetX;
                  var offsetY = chunk.y - layerOffsetY;
                  var y = 0;
                  for (var t = 0, len2 = chunk.data.length; t < len2; t++) {
                    var newOffsetX = x + offsetX;
                    var newOffsetY = y + offsetY;
                    gidInfo = ParseGID(chunk.data[t]);
                    if (gidInfo.gid > 0) {
                      tile = new Tile(layerData, gidInfo.gid, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);
                      tile.rotation = gidInfo.rotation;
                      tile.flipX = gidInfo.flipped;
                      output[newOffsetY][newOffsetX] = tile;
                    } else {
                      blankTile = insertNull ? null : new Tile(layerData, -1, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);
                      output[newOffsetY][newOffsetX] = blankTile;
                    }
                    x++;
                    if (x === chunk.width) {
                      y++;
                      x = 0;
                    }
                  }
                }
              } else {
                layerData = new LayerData({
                  name: curGroupState.name + curl.name,
                  x: curGroupState.x + GetFastValue(curl, "offsetx", 0) + curl.x,
                  y: curGroupState.y + GetFastValue(curl, "offsety", 0) + curl.y,
                  width: curl.width,
                  height: curl.height,
                  tileWidth: json.tilewidth,
                  tileHeight: json.tileheight,
                  alpha: curGroupState.opacity * curl.opacity,
                  visible: curGroupState.visible && curl.visible,
                  properties: GetFastValue(curl, "properties", []),
                  orientation: FromOrientationString(json.orientation)
                });
                if (layerData.orientation === CONST.HEXAGONAL) {
                  layerData.hexSideLength = json.hexsidelength;
                }
                var row = [];
                for (var k = 0, len = curl.data.length; k < len; k++) {
                  gidInfo = ParseGID(curl.data[k]);
                  if (gidInfo.gid > 0) {
                    tile = new Tile(layerData, gidInfo.gid, x, output.length, json.tilewidth, json.tileheight);
                    tile.rotation = gidInfo.rotation;
                    tile.flipX = gidInfo.flipped;
                    row.push(tile);
                  } else {
                    blankTile = insertNull ? null : new Tile(layerData, -1, x, output.length, json.tilewidth, json.tileheight);
                    row.push(blankTile);
                  }
                  x++;
                  if (x === curl.width) {
                    output.push(row);
                    x = 0;
                    row = [];
                  }
                }
              }
              layerData.data = output;
              tileLayers.push(layerData);
            }
            return tileLayers;
          };
          module2.exports = ParseTileLayers;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Base64Decode = function(data) {
            var binaryString = window.atob(data);
            var len = binaryString.length;
            var bytes = new Array(len / 4);
            for (var i = 0; i < len; i += 4) {
              bytes[i / 4] = (binaryString.charCodeAt(i) | binaryString.charCodeAt(i + 1) << 8 | binaryString.charCodeAt(i + 2) << 16 | binaryString.charCodeAt(i + 3) << 24) >>> 0;
            }
            return bytes;
          };
          module2.exports = Base64Decode;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Tileset = __webpack_require__(121);
          var ImageCollection = __webpack_require__(572);
          var ParseObject = __webpack_require__(256);
          var ParseTilesets = function(json) {
            var tilesets = [];
            var imageCollections = [];
            var lastSet = null;
            var stringID;
            for (var i = 0; i < json.tilesets.length; i++) {
              var set = json.tilesets[i];
              if (set.source) {
                console.warn("External tilesets unsupported. Use Embed Tileset and re-export");
              } else if (set.image) {
                var newSet = new Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing);
                if (json.version > 1) {
                  if (Array.isArray(set.tiles)) {
                    var tiles = {};
                    var props = {};
                    for (var t = 0; t < set.tiles.length; t++) {
                      var tile = set.tiles[t];
                      if (tile.properties) {
                        var newPropData = {};
                        tile.properties.forEach(function(propData) {
                          newPropData[propData["name"]] = propData["value"];
                        });
                        props[tile.id] = newPropData;
                      }
                      if (tile.objectgroup) {
                        tiles[tile.id] = {objectgroup: tile.objectgroup};
                        if (tile.objectgroup.objects) {
                          var parsedObjects2 = tile.objectgroup.objects.map(function(obj) {
                            return ParseObject(obj);
                          });
                          tiles[tile.id].objectgroup.objects = parsedObjects2;
                        }
                      }
                      if (tile.animation) {
                        if (tiles.hasOwnProperty(tile.id)) {
                          tiles[tile.id].animation = tile.animation;
                        } else {
                          tiles[tile.id] = {animation: tile.animation};
                        }
                      }
                    }
                    newSet.tileData = tiles;
                    newSet.tileProperties = props;
                  }
                } else {
                  if (set.tileproperties) {
                    newSet.tileProperties = set.tileproperties;
                  }
                  if (set.tiles) {
                    newSet.tileData = set.tiles;
                    for (stringID in newSet.tileData) {
                      var objectGroup = newSet.tileData[stringID].objectgroup;
                      if (objectGroup && objectGroup.objects) {
                        var parsedObjects1 = objectGroup.objects.map(function(obj) {
                          return ParseObject(obj);
                        });
                        newSet.tileData[stringID].objectgroup.objects = parsedObjects1;
                      }
                    }
                  }
                }
                newSet.updateTileData(set.imagewidth, set.imageheight);
                tilesets.push(newSet);
              } else {
                var newCollection = new ImageCollection(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);
                var maxId = 0;
                for (t = 0; t < set.tiles.length; t++) {
                  tile = set.tiles[t];
                  var image = tile.image;
                  var tileId = parseInt(tile.id, 10);
                  var gid = set.firstgid + tileId;
                  newCollection.addImage(gid, image);
                  maxId = Math.max(tileId, maxId);
                }
                newCollection.maxId = maxId;
                imageCollections.push(newCollection);
              }
              if (lastSet) {
                lastSet.lastgid = set.firstgid - 1;
              }
              lastSet = set;
            }
            return {tilesets, imageCollections};
          };
          module2.exports = ParseTilesets;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var ImageCollection = new Class({
            initialize: function ImageCollection2(name, firstgid, width, height, margin, spacing, properties) {
              if (width === void 0 || width <= 0) {
                width = 32;
              }
              if (height === void 0 || height <= 0) {
                height = 32;
              }
              if (margin === void 0) {
                margin = 0;
              }
              if (spacing === void 0) {
                spacing = 0;
              }
              this.name = name;
              this.firstgid = firstgid | 0;
              this.imageWidth = width | 0;
              this.imageHeight = height | 0;
              this.imageMargin = margin | 0;
              this.imageSpacing = spacing | 0;
              this.properties = properties || {};
              this.images = [];
              this.total = 0;
            },
            containsImageIndex: function(imageIndex) {
              return imageIndex >= this.firstgid && imageIndex < this.firstgid + this.total;
            },
            addImage: function(gid, image) {
              this.images.push({gid, image});
              this.total++;
              return this;
            }
          });
          module2.exports = ImageCollection;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Formats = __webpack_require__(39);
          var MapData = __webpack_require__(120);
          var ParseTileLayers = __webpack_require__(574);
          var ParseTilesets = __webpack_require__(575);
          var ParseWeltmeister = function(name, json, insertNull) {
            if (json.layer.length === 0) {
              console.warn("No layers found in the Weltmeister map: " + name);
              return null;
            }
            var width = 0;
            var height = 0;
            for (var i = 0; i < json.layer.length; i++) {
              if (json.layer[i].width > width) {
                width = json.layer[i].width;
              }
              if (json.layer[i].height > height) {
                height = json.layer[i].height;
              }
            }
            var mapData = new MapData({
              width,
              height,
              name,
              tileWidth: json.layer[0].tilesize,
              tileHeight: json.layer[0].tilesize,
              format: Formats.WELTMEISTER
            });
            mapData.layers = ParseTileLayers(json, insertNull);
            mapData.tilesets = ParseTilesets(json);
            return mapData;
          };
          module2.exports = ParseWeltmeister;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var LayerData = __webpack_require__(119);
          var Tile = __webpack_require__(83);
          var ParseTileLayers = function(json, insertNull) {
            var tileLayers = [];
            for (var i = 0; i < json.layer.length; i++) {
              var layer = json.layer[i];
              var layerData = new LayerData({
                name: layer.name,
                width: layer.width,
                height: layer.height,
                tileWidth: layer.tilesize,
                tileHeight: layer.tilesize,
                visible: layer.visible === 1
              });
              var row = [];
              var tileGrid = [];
              for (var y = 0; y < layer.data.length; y++) {
                for (var x = 0; x < layer.data[y].length; x++) {
                  var index = layer.data[y][x] - 1;
                  var tile;
                  if (index > -1) {
                    tile = new Tile(layerData, index, x, y, layer.tilesize, layer.tilesize);
                  } else {
                    tile = insertNull ? null : new Tile(layerData, -1, x, y, layer.tilesize, layer.tilesize);
                  }
                  row.push(tile);
                }
                tileGrid.push(row);
                row = [];
              }
              layerData.data = tileGrid;
              tileLayers.push(layerData);
            }
            return tileLayers;
          };
          module2.exports = ParseTileLayers;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Tileset = __webpack_require__(121);
          var ParseTilesets = function(json) {
            var tilesets = [];
            var tilesetsNames = [];
            for (var i = 0; i < json.layer.length; i++) {
              var layer = json.layer[i];
              var tilesetName = layer.tilesetName;
              if (tilesetName !== "" && tilesetsNames.indexOf(tilesetName) === -1) {
                tilesetsNames.push(tilesetName);
                tilesets.push(new Tileset(tilesetName, 0, layer.tilesize, layer.tilesize, 0, 0));
              }
            }
            return tilesets;
          };
          module2.exports = ParseTilesets;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var DegToRad = __webpack_require__(35);
          var Formats = __webpack_require__(39);
          var GetFastValue = __webpack_require__(2);
          var LayerData = __webpack_require__(119);
          var ORIENTATION = __webpack_require__(29);
          var Rotate = __webpack_require__(356);
          var SpliceOne = __webpack_require__(74);
          var Sprite = __webpack_require__(73);
          var Tile = __webpack_require__(83);
          var TilemapComponents = __webpack_require__(247);
          var TilemapLayer = __webpack_require__(577);
          var Tileset = __webpack_require__(121);
          var Tilemap = new Class({
            initialize: function Tilemap2(scene, mapData) {
              this.scene = scene;
              this.tileWidth = mapData.tileWidth;
              this.tileHeight = mapData.tileHeight;
              this.width = mapData.width;
              this.height = mapData.height;
              this.orientation = mapData.orientation;
              this.renderOrder = mapData.renderOrder;
              this.format = mapData.format;
              this.version = mapData.version;
              this.properties = mapData.properties;
              this.widthInPixels = mapData.widthInPixels;
              this.heightInPixels = mapData.heightInPixels;
              this.imageCollections = mapData.imageCollections;
              this.images = mapData.images;
              this.layers = mapData.layers;
              this.tilesets = mapData.tilesets;
              this.objects = mapData.objects;
              this.currentLayerIndex = 0;
              this.hexSideLength = mapData.hexSideLength;
              var orientation = this.orientation;
              this._convert = {
                WorldToTileXY: TilemapComponents.GetWorldToTileXYFunction(orientation),
                WorldToTileX: TilemapComponents.GetWorldToTileXFunction(orientation),
                WorldToTileY: TilemapComponents.GetWorldToTileYFunction(orientation),
                TileToWorldXY: TilemapComponents.GetTileToWorldXYFunction(orientation),
                TileToWorldX: TilemapComponents.GetTileToWorldXFunction(orientation),
                TileToWorldY: TilemapComponents.GetTileToWorldYFunction(orientation)
              };
            },
            createBlankDynamicLayer: function(name, tileset, x, y, width, height, tileWidth, tileHeight) {
              console.warn("createBlankDynamicLayer is deprecated. Use createBlankLayer");
              return this.createBlankLayer(name, tileset, x, y, width, height, tileWidth, tileHeight);
            },
            createDynamicLayer: function(layerID, tileset, x, y) {
              console.warn("createDynamicLayer is deprecated. Use createLayer");
              return this.createLayer(layerID, tileset, x, y);
            },
            createStaticLayer: function(layerID, tileset, x, y) {
              console.warn("createStaticLayer is deprecated. Use createLayer");
              return this.createLayer(layerID, tileset, x, y);
            },
            setRenderOrder: function(renderOrder) {
              var orders = ["right-down", "left-down", "right-up", "left-up"];
              if (typeof renderOrder === "number") {
                renderOrder = orders[renderOrder];
              }
              if (orders.indexOf(renderOrder) > -1) {
                this.renderOrder = renderOrder;
              }
              return this;
            },
            addTilesetImage: function(tilesetName, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid) {
              if (tilesetName === void 0) {
                return null;
              }
              if (key === void 0 || key === null) {
                key = tilesetName;
              }
              if (!this.scene.sys.textures.exists(key)) {
                console.warn("Invalid Tileset Image: " + key);
                return null;
              }
              var texture = this.scene.sys.textures.get(key);
              var index = this.getTilesetIndex(tilesetName);
              if (index === null && this.format === Formats.TILED_JSON) {
                console.warn("No data found for Tileset: " + tilesetName);
                return null;
              }
              var tileset = this.tilesets[index];
              if (tileset) {
                tileset.setTileSize(tileWidth, tileHeight);
                tileset.setSpacing(tileMargin, tileSpacing);
                tileset.setImage(texture);
                return tileset;
              }
              if (tileWidth === void 0) {
                tileWidth = this.tileWidth;
              }
              if (tileHeight === void 0) {
                tileHeight = this.tileHeight;
              }
              if (tileMargin === void 0) {
                tileMargin = 0;
              }
              if (tileSpacing === void 0) {
                tileSpacing = 0;
              }
              if (gid === void 0) {
                gid = 0;
              }
              tileset = new Tileset(tilesetName, gid, tileWidth, tileHeight, tileMargin, tileSpacing);
              tileset.setImage(texture);
              this.tilesets.push(tileset);
              return tileset;
            },
            copy: function(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer) {
              layer = this.getLayer(layer);
              if (layer !== null) {
                TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer);
                return this;
              } else {
                return null;
              }
            },
            createBlankLayer: function(name, tileset, x, y, width, height, tileWidth, tileHeight) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = this.width;
              }
              if (height === void 0) {
                height = this.height;
              }
              if (tileWidth === void 0) {
                tileWidth = this.tileWidth;
              }
              if (tileHeight === void 0) {
                tileHeight = this.tileHeight;
              }
              var index = this.getLayerIndex(name);
              if (index !== null) {
                console.warn("Invalid Tilemap Layer ID: " + name);
                return null;
              }
              var layerData = new LayerData({
                name,
                tileWidth,
                tileHeight,
                width,
                height,
                orientation: this.orientation
              });
              var row;
              for (var tileY = 0; tileY < height; tileY++) {
                row = [];
                for (var tileX = 0; tileX < width; tileX++) {
                  row.push(new Tile(layerData, -1, tileX, tileY, tileWidth, tileHeight, this.tileWidth, this.tileHeight));
                }
                layerData.data.push(row);
              }
              this.layers.push(layerData);
              this.currentLayerIndex = this.layers.length - 1;
              var layer = new TilemapLayer(this.scene, this, this.currentLayerIndex, tileset, x, y);
              layer.setRenderOrder(this.renderOrder);
              this.scene.sys.displayList.add(layer);
              return layer;
            },
            createLayer: function(layerID, tileset, x, y) {
              var index = this.getLayerIndex(layerID);
              if (index === null) {
                console.warn("Invalid Tilemap Layer ID: " + layerID);
                if (typeof layerID === "string") {
                  console.warn("Valid tilelayer names:\n	" + this.getTileLayerNames().join(",\n	"));
                }
                return null;
              }
              var layerData = this.layers[index];
              if (layerData.tilemapLayer) {
                console.warn("Tilemap Layer ID already exists:" + layerID);
                return null;
              }
              this.currentLayerIndex = index;
              if (x === void 0) {
                x = layerData.x;
              }
              if (y === void 0) {
                y = layerData.y;
              }
              var layer = new TilemapLayer(this.scene, this, index, tileset, x, y);
              layer.setRenderOrder(this.renderOrder);
              this.scene.sys.displayList.add(layer);
              return layer;
            },
            createFromObjects: function(objectLayerName, config2) {
              var results = [];
              var objectLayer = this.getObjectLayer(objectLayerName);
              if (!objectLayer) {
                console.warn("createFromObjects: Invalid objectLayerName given: " + objectLayerName);
                return results;
              }
              if (!Array.isArray(config2)) {
                config2 = [config2];
              }
              var objects = objectLayer.objects;
              for (var c = 0; c < config2.length; c++) {
                var singleConfig = config2[c];
                var id = GetFastValue(singleConfig, "id", null);
                var gid = GetFastValue(singleConfig, "gid", null);
                var name = GetFastValue(singleConfig, "name", null);
                var obj;
                var toConvert = [];
                for (var s = 0; s < objects.length; s++) {
                  obj = objects[s];
                  if (id === null && gid === null && name === null || id !== null && obj.id === id || gid !== null && obj.gid === gid || name !== null && obj.name === name) {
                    toConvert.push(obj);
                  }
                }
                var classType = GetFastValue(singleConfig, "classType", Sprite);
                var scene = GetFastValue(singleConfig, "scene", this.scene);
                var container = GetFastValue(singleConfig, "container", null);
                var texture = GetFastValue(singleConfig, "key", null);
                var frame = GetFastValue(singleConfig, "frame", null);
                for (var i = 0; i < toConvert.length; i++) {
                  obj = toConvert[i];
                  var sprite = new classType(scene);
                  sprite.setName(obj.name);
                  sprite.setPosition(obj.x, obj.y);
                  sprite.setTexture(texture, frame);
                  if (obj.width) {
                    sprite.displayWidth = obj.width;
                  }
                  if (obj.height) {
                    sprite.displayHeight = obj.height;
                  }
                  var offset = {
                    x: sprite.originX * obj.width,
                    y: (sprite.originY - 1) * obj.height
                  };
                  if (obj.rotation) {
                    var angle = DegToRad(obj.rotation);
                    Rotate(offset, angle);
                    sprite.rotation = angle;
                  }
                  sprite.x += offset.x;
                  sprite.y += offset.y;
                  if (obj.flippedHorizontal !== void 0 || obj.flippedVertical !== void 0) {
                    sprite.setFlip(obj.flippedHorizontal, obj.flippedVertical);
                  }
                  if (!obj.visible) {
                    sprite.visible = false;
                  }
                  for (var key in obj.properties) {
                    if (sprite[key] !== void 0) {
                      sprite[key] = obj.properties[key];
                    } else {
                      sprite.setData(key, obj.properties[key]);
                    }
                  }
                  if (container) {
                    container.add(sprite);
                  } else {
                    scene.add.existing(sprite);
                  }
                  results.push(sprite);
                }
              }
              return results;
            },
            createFromTiles: function(indexes, replacements, spriteConfig, scene, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, layer);
            },
            fill: function(index, tileX, tileY, width, height, recalculateFaces, layer) {
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, layer);
              return this;
            },
            filterObjects: function(objectLayer, callback, context) {
              if (typeof objectLayer === "string") {
                var name = objectLayer;
                objectLayer = this.getObjectLayer(objectLayer);
                if (!objectLayer) {
                  console.warn("No object layer found with the name: " + name);
                  return null;
                }
              }
              return objectLayer.objects.filter(callback, context);
            },
            filterTiles: function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, layer);
            },
            findByIndex: function(findIndex, skip, reverse, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.FindByIndex(findIndex, skip, reverse, layer);
            },
            findObject: function(objectLayer, callback, context) {
              if (typeof objectLayer === "string") {
                var name = objectLayer;
                objectLayer = this.getObjectLayer(objectLayer);
                if (!objectLayer) {
                  console.warn("No object layer found with the name: " + name);
                  return null;
                }
              }
              return objectLayer.objects.find(callback, context) || null;
            },
            findTile: function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);
            },
            forEachTile: function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);
              return this;
            },
            getImageIndex: function(name) {
              return this.getIndex(this.images, name);
            },
            getImageLayerNames: function() {
              if (!this.images || !Array.isArray(this.images)) {
                return [];
              }
              return this.images.map(function(image) {
                return image.name;
              });
            },
            getIndex: function(location, name) {
              for (var i = 0; i < location.length; i++) {
                if (location[i].name === name) {
                  return i;
                }
              }
              return null;
            },
            getLayer: function(layer) {
              var index = this.getLayerIndex(layer);
              return index !== null ? this.layers[index] : null;
            },
            getObjectLayer: function(name) {
              var index = this.getIndex(this.objects, name);
              return index !== null ? this.objects[index] : null;
            },
            getObjectLayerNames: function() {
              if (!this.objects || !Array.isArray(this.objects)) {
                return [];
              }
              return this.objects.map(function(object) {
                return object.name;
              });
            },
            getLayerIndex: function(layer) {
              if (layer === void 0) {
                return this.currentLayerIndex;
              } else if (typeof layer === "string") {
                return this.getLayerIndexByName(layer);
              } else if (typeof layer === "number" && layer < this.layers.length) {
                return layer;
              } else if (layer instanceof TilemapLayer) {
                return layer.layerIndex;
              } else {
                return null;
              }
            },
            getLayerIndexByName: function(name) {
              return this.getIndex(this.layers, name);
            },
            getTileAt: function(tileX, tileY, nonNull, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.GetTileAt(tileX, tileY, nonNull, layer);
            },
            getTileAtWorldXY: function(worldX, worldY, nonNull, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, layer);
            },
            getTileLayerNames: function() {
              if (!this.layers || !Array.isArray(this.layers)) {
                return [];
              }
              return this.layers.map(function(layer) {
                return layer.name;
              });
            },
            getTilesWithin: function(tileX, tileY, width, height, filteringOptions, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
            },
            getTilesWithinShape: function(shape, filteringOptions, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, layer);
            },
            getTilesWithinWorldXY: function(worldX, worldY, width, height, filteringOptions, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, layer);
            },
            getTileset: function(name) {
              var index = this.getIndex(this.tilesets, name);
              return index !== null ? this.tilesets[index] : null;
            },
            getTilesetIndex: function(name) {
              return this.getIndex(this.tilesets, name);
            },
            hasTileAt: function(tileX, tileY, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.HasTileAt(tileX, tileY, layer);
            },
            hasTileAtWorldXY: function(worldX, worldY, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, layer);
            },
            layer: {
              get: function() {
                return this.layers[this.currentLayerIndex];
              },
              set: function(layer) {
                this.setLayer(layer);
              }
            },
            putTileAt: function(tile, tileX, tileY, recalculateFaces, layer) {
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, layer);
            },
            putTileAtWorldXY: function(tile, worldX, worldY, recalculateFaces, camera, layer) {
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, layer);
            },
            putTilesAt: function(tilesArray, tileX, tileY, recalculateFaces, layer) {
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, layer);
              return this;
            },
            randomize: function(tileX, tileY, width, height, indexes, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.Randomize(tileX, tileY, width, height, indexes, layer);
              return this;
            },
            calculateFacesAt: function(tileX, tileY, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.CalculateFacesAt(tileX, tileY, layer);
              return this;
            },
            calculateFacesWithin: function(tileX, tileY, width, height, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, layer);
              return this;
            },
            removeLayer: function(layer) {
              var index = this.getLayerIndex(layer);
              if (index !== null) {
                SpliceOne(this.layers, index);
                for (var i = index; i < this.layers.length; i++) {
                  if (this.layers[i].tilemapLayer) {
                    this.layers[i].tilemapLayer.layerIndex--;
                  }
                }
                if (this.currentLayerIndex === index) {
                  this.currentLayerIndex = 0;
                }
                return this;
              } else {
                return null;
              }
            },
            destroyLayer: function(layer) {
              var index = this.getLayerIndex(layer);
              if (index !== null) {
                layer = this.layers[index];
                layer.destroy();
                SpliceOne(this.layers, index);
                if (this.currentLayerIndex === index) {
                  this.currentLayerIndex = 0;
                }
                return this;
              } else {
                return null;
              }
            },
            removeAllLayers: function() {
              var layers = this.layers;
              for (var i = 0; i < layers.length; i++) {
                if (layers[i].tilemapLayer) {
                  layers[i].tilemapLayer.destroy(false);
                }
              }
              layers.length = 0;
              this.currentLayerIndex = 0;
              return this;
            },
            removeTile: function(tiles, replaceIndex, recalculateFaces) {
              if (replaceIndex === void 0) {
                replaceIndex = -1;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              var removed = [];
              if (!Array.isArray(tiles)) {
                tiles = [tiles];
              }
              for (var i = 0; i < tiles.length; i++) {
                var tile = tiles[i];
                removed.push(this.removeTileAt(tile.x, tile.y, true, recalculateFaces, tile.tilemapLayer));
                if (replaceIndex > -1) {
                  this.putTileAt(replaceIndex, tile.x, tile.y, recalculateFaces, tile.tilemapLayer);
                }
              }
              return removed;
            },
            removeTileAt: function(tileX, tileY, replaceWithNull, recalculateFaces, layer) {
              if (replaceWithNull === void 0) {
                replaceWithNull = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, layer);
            },
            removeTileAtWorldXY: function(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer) {
              if (replaceWithNull === void 0) {
                replaceWithNull = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer);
            },
            renderDebug: function(graphics, styleConfig, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              if (this.orientation === ORIENTATION.ORTHOGONAL) {
                TilemapComponents.RenderDebug(graphics, styleConfig, layer);
              }
              return this;
            },
            renderDebugFull: function(graphics, styleConfig) {
              var layers = this.layers;
              for (var i = 0; i < layers.length; i++) {
                TilemapComponents.RenderDebug(graphics, styleConfig, layers[i]);
              }
              return this;
            },
            replaceByIndex: function(findIndex, newIndex, tileX, tileY, width, height, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, layer);
              return this;
            },
            setCollision: function(indexes, collides, recalculateFaces, layer, updateLayer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              if (updateLayer === void 0) {
                updateLayer = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SetCollision(indexes, collides, recalculateFaces, layer, updateLayer);
              return this;
            },
            setCollisionBetween: function(start, stop, collides, recalculateFaces, layer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, layer);
              return this;
            },
            setCollisionByProperty: function(properties, collides, recalculateFaces, layer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, layer);
              return this;
            },
            setCollisionByExclusion: function(indexes, collides, recalculateFaces, layer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, layer);
              return this;
            },
            setCollisionFromCollisionGroup: function(collides, recalculateFaces, layer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, layer);
              return this;
            },
            setTileIndexCallback: function(indexes, callback, callbackContext, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, layer);
              return this;
            },
            setTileLocationCallback: function(tileX, tileY, width, height, callback, callbackContext, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, layer);
              return this;
            },
            setLayer: function(layer) {
              var index = this.getLayerIndex(layer);
              if (index !== null) {
                this.currentLayerIndex = index;
              }
              return this;
            },
            setBaseTileSize: function(tileWidth, tileHeight) {
              this.tileWidth = tileWidth;
              this.tileHeight = tileHeight;
              this.widthInPixels = this.width * tileWidth;
              this.heightInPixels = this.height * tileHeight;
              for (var i = 0; i < this.layers.length; i++) {
                this.layers[i].baseTileWidth = tileWidth;
                this.layers[i].baseTileHeight = tileHeight;
                var mapData = this.layers[i].data;
                var mapWidth = this.layers[i].width;
                var mapHeight = this.layers[i].height;
                for (var row = 0; row < mapHeight; row++) {
                  for (var col = 0; col < mapWidth; col++) {
                    var tile = mapData[row][col];
                    if (tile !== null) {
                      tile.setSize(void 0, void 0, tileWidth, tileHeight);
                    }
                  }
                }
              }
              return this;
            },
            setLayerTileSize: function(tileWidth, tileHeight, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return this;
              }
              layer.tileWidth = tileWidth;
              layer.tileHeight = tileHeight;
              var mapData = layer.data;
              var mapWidth = layer.width;
              var mapHeight = layer.height;
              for (var row = 0; row < mapHeight; row++) {
                for (var col = 0; col < mapWidth; col++) {
                  var tile = mapData[row][col];
                  if (tile !== null) {
                    tile.setSize(tileWidth, tileHeight);
                  }
                }
              }
              return this;
            },
            shuffle: function(tileX, tileY, width, height, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.Shuffle(tileX, tileY, width, height, layer);
              return this;
            },
            swapByIndex: function(indexA, indexB, tileX, tileY, width, height, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, layer);
              return this;
            },
            tileToWorldX: function(tileX, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return this._convert.TileToWorldX(tileX, camera, layer);
            },
            tileToWorldY: function(tileX, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return this._convert.TileToWorldY(tileX, camera, layer);
            },
            tileToWorldXY: function(tileX, tileY, vec2, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return this._convert.TileToWorldXY(tileX, tileY, vec2, camera, layer);
            },
            weightedRandomize: function(weightedIndexes, tileX, tileY, width, height, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, layer);
              return this;
            },
            worldToTileX: function(worldX, snapToFloor, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return this._convert.WorldToTileX(worldX, snapToFloor, camera, layer);
            },
            worldToTileY: function(worldY, snapToFloor, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return this._convert.WorldToTileY(worldY, snapToFloor, camera, layer);
            },
            worldToTileXY: function(worldX, worldY, snapToFloor, vec2, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return this._convert.WorldToTileXY(worldX, worldY, snapToFloor, vec2, camera, layer);
            },
            destroy: function() {
              this.removeAllLayers();
              this.tilesets.length = 0;
              this.objects.length = 0;
              this.scene = null;
            }
          });
          module2.exports = Tilemap;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var TilemapComponents = __webpack_require__(247);
          var TilemapLayerRender = __webpack_require__(1449);
          var TilemapLayer = new Class({
            Extends: GameObject,
            Mixins: [
              Components.Alpha,
              Components.BlendMode,
              Components.ComputedSize,
              Components.Depth,
              Components.Flip,
              Components.GetBounds,
              Components.Origin,
              Components.Pipeline,
              Components.Transform,
              Components.Visible,
              Components.ScrollFactor,
              TilemapLayerRender
            ],
            initialize: function TilemapLayer2(scene, tilemap, layerIndex, tileset, x, y) {
              GameObject.call(this, scene, "TilemapLayer");
              this.isTilemap = true;
              this.tilemap = tilemap;
              this.layerIndex = layerIndex;
              this.layer = tilemap.layers[layerIndex];
              this.layer.tilemapLayer = this;
              this.tileset = [];
              this.tilesDrawn = 0;
              this.tilesTotal = this.layer.width * this.layer.height;
              this.culledTiles = [];
              this.skipCull = false;
              this.cullPaddingX = 1;
              this.cullPaddingY = 1;
              this.cullCallback = TilemapComponents.GetCullTilesFunction(this.layer.orientation);
              this._renderOrder = 0;
              this.gidMap = [];
              this.setTilesets(tileset);
              this.setAlpha(this.layer.alpha);
              this.setPosition(x, y);
              this.setOrigin();
              this.setSize(tilemap.tileWidth * this.layer.width, tilemap.tileHeight * this.layer.height);
              this.initPipeline();
            },
            setTilesets: function(tilesets) {
              var gidMap = [];
              var setList = [];
              var map = this.tilemap;
              if (!Array.isArray(tilesets)) {
                tilesets = [tilesets];
              }
              for (var i = 0; i < tilesets.length; i++) {
                var tileset = tilesets[i];
                if (typeof tileset === "string") {
                  tileset = map.getTileset(tileset);
                }
                if (tileset) {
                  setList.push(tileset);
                  var s = tileset.firstgid;
                  for (var t = 0; t < tileset.total; t++) {
                    gidMap[s + t] = tileset;
                  }
                }
              }
              this.gidMap = gidMap;
              this.tileset = setList;
            },
            setRenderOrder: function(renderOrder) {
              var orders = ["right-down", "left-down", "right-up", "left-up"];
              if (typeof renderOrder === "string") {
                renderOrder = orders.indexOf(renderOrder);
              }
              if (renderOrder >= 0 && renderOrder < 4) {
                this._renderOrder = renderOrder;
              }
              return this;
            },
            calculateFacesAt: function(tileX, tileY) {
              TilemapComponents.CalculateFacesAt(tileX, tileY, this.layer);
              return this;
            },
            calculateFacesWithin: function(tileX, tileY, width, height) {
              TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, this.layer);
              return this;
            },
            createFromTiles: function(indexes, replacements, spriteConfig, scene, camera) {
              return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, this.layer);
            },
            cull: function(camera) {
              return this.cullCallback(this.layer, camera, this.culledTiles, this._renderOrder);
            },
            copy: function(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces) {
              TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, this.layer);
              return this;
            },
            fill: function(index, tileX, tileY, width, height, recalculateFaces) {
              TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, this.layer);
              return this;
            },
            filterTiles: function(callback, context, tileX, tileY, width, height, filteringOptions) {
              return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
            },
            findByIndex: function(findIndex, skip, reverse) {
              return TilemapComponents.FindByIndex(findIndex, skip, reverse, this.layer);
            },
            findTile: function(callback, context, tileX, tileY, width, height, filteringOptions) {
              return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
            },
            forEachTile: function(callback, context, tileX, tileY, width, height, filteringOptions) {
              TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
              return this;
            },
            getTileAt: function(tileX, tileY, nonNull) {
              return TilemapComponents.GetTileAt(tileX, tileY, nonNull, this.layer);
            },
            getTileAtWorldXY: function(worldX, worldY, nonNull, camera) {
              return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, this.layer);
            },
            getTilesWithin: function(tileX, tileY, width, height, filteringOptions) {
              return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, this.layer);
            },
            getTilesWithinShape: function(shape, filteringOptions, camera) {
              return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, this.layer);
            },
            getTilesWithinWorldXY: function(worldX, worldY, width, height, filteringOptions, camera) {
              return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, this.layer);
            },
            hasTileAt: function(tileX, tileY) {
              return TilemapComponents.HasTileAt(tileX, tileY, this.layer);
            },
            hasTileAtWorldXY: function(worldX, worldY, camera) {
              return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, this.layer);
            },
            putTileAt: function(tile, tileX, tileY, recalculateFaces) {
              return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, this.layer);
            },
            putTileAtWorldXY: function(tile, worldX, worldY, recalculateFaces, camera) {
              return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, this.layer);
            },
            putTilesAt: function(tilesArray, tileX, tileY, recalculateFaces) {
              TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, this.layer);
              return this;
            },
            randomize: function(tileX, tileY, width, height, indexes) {
              TilemapComponents.Randomize(tileX, tileY, width, height, indexes, this.layer);
              return this;
            },
            removeTileAt: function(tileX, tileY, replaceWithNull, recalculateFaces) {
              return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, this.layer);
            },
            removeTileAtWorldXY: function(worldX, worldY, replaceWithNull, recalculateFaces, camera) {
              return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, this.layer);
            },
            renderDebug: function(graphics, styleConfig) {
              TilemapComponents.RenderDebug(graphics, styleConfig, this.layer);
              return this;
            },
            replaceByIndex: function(findIndex, newIndex, tileX, tileY, width, height) {
              TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, this.layer);
              return this;
            },
            setSkipCull: function(value) {
              if (value === void 0) {
                value = true;
              }
              this.skipCull = value;
              return this;
            },
            setCullPadding: function(paddingX, paddingY) {
              if (paddingX === void 0) {
                paddingX = 1;
              }
              if (paddingY === void 0) {
                paddingY = 1;
              }
              this.cullPaddingX = paddingX;
              this.cullPaddingY = paddingY;
              return this;
            },
            setCollision: function(indexes, collides, recalculateFaces, updateLayer) {
              TilemapComponents.SetCollision(indexes, collides, recalculateFaces, this.layer, updateLayer);
              return this;
            },
            setCollisionBetween: function(start, stop, collides, recalculateFaces) {
              TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, this.layer);
              return this;
            },
            setCollisionByProperty: function(properties, collides, recalculateFaces) {
              TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, this.layer);
              return this;
            },
            setCollisionByExclusion: function(indexes, collides, recalculateFaces) {
              TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, this.layer);
              return this;
            },
            setCollisionFromCollisionGroup: function(collides, recalculateFaces) {
              TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, this.layer);
              return this;
            },
            setTileIndexCallback: function(indexes, callback, callbackContext) {
              TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, this.layer);
              return this;
            },
            setTileLocationCallback: function(tileX, tileY, width, height, callback, callbackContext) {
              TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, this.layer);
              return this;
            },
            shuffle: function(tileX, tileY, width, height) {
              TilemapComponents.Shuffle(tileX, tileY, width, height, this.layer);
              return this;
            },
            swapByIndex: function(indexA, indexB, tileX, tileY, width, height) {
              TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, this.layer);
              return this;
            },
            tileToWorldX: function(tileX, camera) {
              return this.tilemap.tileToWorldX(tileX, camera, this);
            },
            tileToWorldY: function(tileY, camera) {
              return this.tilemap.tileToWorldY(tileY, camera, this);
            },
            tileToWorldXY: function(tileX, tileY, point, camera) {
              return this.tilemap.tileToWorldXY(tileX, tileY, point, camera, this);
            },
            weightedRandomize: function(weightedIndexes, tileX, tileY, width, height) {
              TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, this.layer);
              return this;
            },
            worldToTileX: function(worldX, snapToFloor, camera) {
              return this.tilemap.worldToTileX(worldX, snapToFloor, camera, this);
            },
            worldToTileY: function(worldY, snapToFloor, camera) {
              return this.tilemap.worldToTileY(worldY, snapToFloor, camera, this);
            },
            worldToTileXY: function(worldX, worldY, snapToFloor, point, camera) {
              return this.tilemap.worldToTileXY(worldX, worldY, snapToFloor, point, camera, this);
            },
            destroy: function(removeFromTilemap) {
              if (removeFromTilemap === void 0) {
                removeFromTilemap = true;
              }
              if (!this.tilemap) {
                return;
              }
              if (this.layer.tilemapLayer === this) {
                this.layer.tilemapLayer = void 0;
              }
              if (removeFromTilemap) {
                this.tilemap.removeLayer(this);
              }
              this.tilemap = void 0;
              this.layer = void 0;
              this.culledTiles.length = 0;
              this.cullCallback = null;
              this.gidMap = [];
              this.tileset = [];
              GameObject.prototype.destroy.call(this);
            }
          });
          module2.exports = TilemapLayer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var TimerEvent = new Class({
            initialize: function TimerEvent2(config2) {
              this.delay = 0;
              this.repeat = 0;
              this.repeatCount = 0;
              this.loop = false;
              this.callback;
              this.callbackScope;
              this.args;
              this.timeScale = 1;
              this.startAt = 0;
              this.elapsed = 0;
              this.paused = false;
              this.hasDispatched = false;
              this.reset(config2);
            },
            reset: function(config2) {
              this.delay = GetFastValue(config2, "delay", 0);
              this.repeat = GetFastValue(config2, "repeat", 0);
              this.loop = GetFastValue(config2, "loop", false);
              this.callback = GetFastValue(config2, "callback", void 0);
              this.callbackScope = GetFastValue(config2, "callbackScope", this.callback);
              this.args = GetFastValue(config2, "args", []);
              this.timeScale = GetFastValue(config2, "timeScale", 1);
              this.startAt = GetFastValue(config2, "startAt", 0);
              this.paused = GetFastValue(config2, "paused", false);
              this.elapsed = this.startAt;
              this.hasDispatched = false;
              this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 : this.repeat;
              return this;
            },
            getProgress: function() {
              return this.elapsed / this.delay;
            },
            getOverallProgress: function() {
              if (this.repeat > 0) {
                var totalDuration = this.delay + this.delay * this.repeat;
                var totalElapsed = this.elapsed + this.delay * (this.repeat - this.repeatCount);
                return totalElapsed / totalDuration;
              } else {
                return this.getProgress();
              }
            },
            getRepeatCount: function() {
              return this.repeatCount;
            },
            getElapsed: function() {
              return this.elapsed;
            },
            getElapsedSeconds: function() {
              return this.elapsed * 1e-3;
            },
            getRemaining: function() {
              return this.delay - this.elapsed;
            },
            getRemainingSeconds: function() {
              return this.getRemaining() * 1e-3;
            },
            getOverallRemaining: function() {
              return this.delay * (1 + this.repeatCount) - this.elapsed;
            },
            getOverallRemainingSeconds: function() {
              return this.getOverallRemaining() * 1e-3;
            },
            remove: function(dispatchCallback) {
              if (dispatchCallback === void 0) {
                dispatchCallback = false;
              }
              this.elapsed = this.delay;
              this.hasDispatched = !dispatchCallback;
              this.repeatCount = 0;
            },
            destroy: function() {
              this.callback = void 0;
              this.callbackScope = void 0;
              this.args = [];
            }
          });
          module2.exports = TimerEvent;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RESERVED = __webpack_require__(1458);
          var GetProps = function(config2) {
            var key;
            var keys = [];
            if (config2.hasOwnProperty("props")) {
              for (key in config2.props) {
                if (key.substr(0, 1) !== "_") {
                  keys.push({key, value: config2.props[key]});
                }
              }
            } else {
              for (key in config2) {
                if (RESERVED.indexOf(key) === -1 && key.substr(0, 1) !== "_") {
                  keys.push({key, value: config2[key]});
                }
              }
            }
            return keys;
          };
          module2.exports = GetProps;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetValue = __webpack_require__(6);
          var GetTweens = function(config2) {
            var tweens = GetValue(config2, "tweens", null);
            if (tweens === null) {
              return [];
            } else if (typeof tweens === "function") {
              tweens = tweens.call();
            }
            if (!Array.isArray(tweens)) {
              tweens = [tweens];
            }
            return tweens;
          };
          module2.exports = GetTweens;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Defaults = __webpack_require__(261);
          var GetAdvancedValue = __webpack_require__(13);
          var GetBoolean = __webpack_require__(96);
          var GetEaseFunction = __webpack_require__(80);
          var GetNewValue = __webpack_require__(160);
          var GetValue = __webpack_require__(6);
          var GetValueOp = __webpack_require__(260);
          var Tween = __webpack_require__(262);
          var TweenData = __webpack_require__(264);
          var NumberTweenBuilder = function(parent, config2, defaults) {
            if (defaults === void 0) {
              defaults = Defaults;
            }
            var from = GetValue(config2, "from", 0);
            var to = GetValue(config2, "to", 1);
            var targets = [{value: from}];
            var delay = GetNewValue(config2, "delay", defaults.delay);
            var duration = GetNewValue(config2, "duration", defaults.duration);
            var easeParams = GetValue(config2, "easeParams", defaults.easeParams);
            var ease = GetEaseFunction(GetValue(config2, "ease", defaults.ease), easeParams);
            var hold = GetNewValue(config2, "hold", defaults.hold);
            var repeat = GetNewValue(config2, "repeat", defaults.repeat);
            var repeatDelay = GetNewValue(config2, "repeatDelay", defaults.repeatDelay);
            var yoyo = GetBoolean(config2, "yoyo", defaults.yoyo);
            var data = [];
            var ops = GetValueOp("value", to);
            var tweenData = TweenData(targets[0], 0, "value", ops.getEnd, ops.getStart, ops.getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, false, false);
            tweenData.start = from;
            tweenData.current = from;
            tweenData.to = to;
            data.push(tweenData);
            var tween = new Tween(parent, data, targets);
            tween.offset = GetAdvancedValue(config2, "offset", null);
            tween.completeDelay = GetAdvancedValue(config2, "completeDelay", 0);
            tween.loop = Math.round(GetAdvancedValue(config2, "loop", 0));
            tween.loopDelay = Math.round(GetAdvancedValue(config2, "loopDelay", 0));
            tween.paused = GetBoolean(config2, "paused", false);
            tween.useFrames = GetBoolean(config2, "useFrames", false);
            var scope = GetValue(config2, "callbackScope", tween);
            var tweenArray = [tween, null];
            var callbacks = Tween.TYPES;
            for (var i = 0; i < callbacks.length; i++) {
              var type = callbacks[i];
              var callback = GetValue(config2, type, false);
              if (callback) {
                var callbackScope = GetValue(config2, type + "Scope", scope);
                var callbackParams = GetValue(config2, type + "Params", []);
                tween.setCallback(type, callback, tweenArray.concat(callbackParams), callbackScope);
              }
            }
            return tween;
          };
          module2.exports = NumberTweenBuilder;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetEaseFunction = __webpack_require__(80);
          var GetValue = __webpack_require__(6);
          var MATH_CONST = __webpack_require__(14);
          var StaggerBuilder = function(value, options) {
            if (options === void 0) {
              options = {};
            }
            var result;
            var start = GetValue(options, "start", 0);
            var ease = GetValue(options, "ease", null);
            var grid = GetValue(options, "grid", null);
            var from = GetValue(options, "from", 0);
            var fromFirst = from === "first";
            var fromCenter = from === "center";
            var fromLast = from === "last";
            var fromValue = typeof from === "number";
            var isRange = Array.isArray(value);
            var value1 = isRange ? parseFloat(value[0]) : parseFloat(value);
            var value2 = isRange ? parseFloat(value[1]) : 0;
            var maxValue = Math.max(value1, value2);
            if (isRange) {
              start += value1;
            }
            if (grid) {
              var gridWidth = grid[0];
              var gridHeight = grid[1];
              var fromX = 0;
              var fromY = 0;
              var distanceX = 0;
              var distanceY = 0;
              var gridValues = [];
              if (fromLast) {
                fromX = gridWidth - 1;
                fromY = gridHeight - 1;
              } else if (fromValue) {
                fromX = from % gridWidth;
                fromY = Math.floor(from / gridWidth);
              } else if (fromCenter) {
                fromX = (gridWidth - 1) / 2;
                fromY = (gridHeight - 1) / 2;
              }
              var gridMax = MATH_CONST.MIN_SAFE_INTEGER;
              for (var toY = 0; toY < gridHeight; toY++) {
                gridValues[toY] = [];
                for (var toX = 0; toX < gridWidth; toX++) {
                  distanceX = fromX - toX;
                  distanceY = fromY - toY;
                  var dist = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                  if (dist > gridMax) {
                    gridMax = dist;
                  }
                  gridValues[toY][toX] = dist;
                }
              }
            }
            var easeFunction = ease ? GetEaseFunction(ease) : null;
            if (grid) {
              result = function(target, key, value3, index) {
                var gridSpace = 0;
                var toX2 = index % gridWidth;
                var toY2 = Math.floor(index / gridWidth);
                if (toX2 >= 0 && toX2 < gridWidth && toY2 >= 0 && toY2 < gridHeight) {
                  gridSpace = gridValues[toY2][toX2];
                }
                var output;
                if (isRange) {
                  var diff = value2 - value1;
                  if (easeFunction) {
                    output = gridSpace / gridMax * diff * easeFunction(gridSpace / gridMax);
                  } else {
                    output = gridSpace / gridMax * diff;
                  }
                } else if (easeFunction) {
                  output = gridSpace * value1 * easeFunction(gridSpace / gridMax);
                } else {
                  output = gridSpace * value1;
                }
                return output + start;
              };
            } else {
              result = function(target, key, value3, index, total) {
                total--;
                var fromIndex;
                if (fromFirst) {
                  fromIndex = index;
                } else if (fromCenter) {
                  fromIndex = Math.abs(total / 2 - index);
                } else if (fromLast) {
                  fromIndex = total - index;
                } else if (fromValue) {
                  fromIndex = Math.abs(from - index);
                }
                var output;
                if (isRange) {
                  var spacing;
                  if (fromCenter) {
                    spacing = (value2 - value1) / total * (fromIndex * 2);
                  } else {
                    spacing = (value2 - value1) / total * fromIndex;
                  }
                  if (easeFunction) {
                    output = spacing * easeFunction(fromIndex / total);
                  } else {
                    output = spacing;
                  }
                } else if (easeFunction) {
                  output = total * maxValue * easeFunction(fromIndex / total);
                } else {
                  output = fromIndex * value1;
                }
                return output + start;
              };
            }
            return result;
          };
          module2.exports = StaggerBuilder;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clone = __webpack_require__(77);
          var Defaults = __webpack_require__(261);
          var GetAdvancedValue = __webpack_require__(13);
          var GetBoolean = __webpack_require__(96);
          var GetEaseFunction = __webpack_require__(80);
          var GetNewValue = __webpack_require__(160);
          var GetTargets = __webpack_require__(259);
          var GetTweens = __webpack_require__(580);
          var GetValue = __webpack_require__(6);
          var Timeline = __webpack_require__(584);
          var TweenBuilder = __webpack_require__(161);
          var TimelineBuilder = function(manager, config2) {
            var timeline = new Timeline(manager);
            timeline.completeDelay = GetAdvancedValue(config2, "completeDelay", 0);
            timeline.loop = Math.round(GetAdvancedValue(config2, "loop", 0));
            timeline.loopDelay = Math.round(GetAdvancedValue(config2, "loopDelay", 0));
            timeline.paused = GetBoolean(config2, "paused", false);
            timeline.useFrames = GetBoolean(config2, "useFrames", false);
            var scope = GetValue(config2, "callbackScope", timeline);
            var timelineArray = [timeline];
            var onStart = GetValue(config2, "onStart", false);
            if (onStart) {
              var onStartScope = GetValue(config2, "onStartScope", scope);
              var onStartParams = GetValue(config2, "onStartParams", []);
              timeline.setCallback("onStart", onStart, timelineArray.concat(onStartParams), onStartScope);
            }
            var onUpdate = GetValue(config2, "onUpdate", false);
            if (onUpdate) {
              var onUpdateScope = GetValue(config2, "onUpdateScope", scope);
              var onUpdateParams = GetValue(config2, "onUpdateParams", []);
              timeline.setCallback("onUpdate", onUpdate, timelineArray.concat(onUpdateParams), onUpdateScope);
            }
            var onLoop = GetValue(config2, "onLoop", false);
            if (onLoop) {
              var onLoopScope = GetValue(config2, "onLoopScope", scope);
              var onLoopParams = GetValue(config2, "onLoopParams", []);
              timeline.setCallback("onLoop", onLoop, timelineArray.concat(onLoopParams), onLoopScope);
            }
            var onYoyo = GetValue(config2, "onYoyo", false);
            if (onYoyo) {
              var onYoyoScope = GetValue(config2, "onYoyoScope", scope);
              var onYoyoParams = GetValue(config2, "onYoyoParams", []);
              timeline.setCallback("onYoyo", onYoyo, timelineArray.concat(null, onYoyoParams), onYoyoScope);
            }
            var onComplete = GetValue(config2, "onComplete", false);
            if (onComplete) {
              var onCompleteScope = GetValue(config2, "onCompleteScope", scope);
              var onCompleteParams = GetValue(config2, "onCompleteParams", []);
              timeline.setCallback("onComplete", onComplete, timelineArray.concat(onCompleteParams), onCompleteScope);
            }
            var tweens = GetTweens(config2);
            if (tweens.length === 0) {
              timeline.paused = true;
              return timeline;
            }
            var defaults = Clone(Defaults);
            defaults.targets = GetTargets(config2);
            var totalDuration = GetAdvancedValue(config2, "totalDuration", 0);
            if (totalDuration > 0) {
              defaults.duration = Math.floor(totalDuration / tweens.length);
            } else {
              defaults.duration = GetNewValue(config2, "duration", defaults.duration);
            }
            defaults.delay = GetNewValue(config2, "delay", defaults.delay);
            defaults.easeParams = GetValue(config2, "easeParams", defaults.easeParams);
            defaults.ease = GetEaseFunction(GetValue(config2, "ease", defaults.ease), defaults.easeParams);
            defaults.hold = GetNewValue(config2, "hold", defaults.hold);
            defaults.repeat = GetNewValue(config2, "repeat", defaults.repeat);
            defaults.repeatDelay = GetNewValue(config2, "repeatDelay", defaults.repeatDelay);
            defaults.yoyo = GetBoolean(config2, "yoyo", defaults.yoyo);
            defaults.flipX = GetBoolean(config2, "flipX", defaults.flipX);
            defaults.flipY = GetBoolean(config2, "flipY", defaults.flipY);
            for (var i = 0; i < tweens.length; i++) {
              timeline.queue(TweenBuilder(timeline, tweens[i], defaults));
            }
            return timeline;
          };
          module2.exports = TimelineBuilder;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(263);
          var TweenBuilder = __webpack_require__(161);
          var TWEEN_CONST = __webpack_require__(97);
          var Timeline = new Class({
            Extends: EventEmitter,
            initialize: function Timeline2(manager) {
              EventEmitter.call(this);
              this.manager = manager;
              this.isTimeline = true;
              this.data = [];
              this.totalData = 0;
              this.useFrames = false;
              this.timeScale = 1;
              this.loop = 0;
              this.loopDelay = 0;
              this.loopCounter = 0;
              this.completeDelay = 0;
              this.countdown = 0;
              this.state = TWEEN_CONST.PENDING_ADD;
              this._pausedState = TWEEN_CONST.PENDING_ADD;
              this.paused = false;
              this.elapsed = 0;
              this.totalElapsed = 0;
              this.duration = 0;
              this.progress = 0;
              this.totalDuration = 0;
              this.totalProgress = 0;
              this.callbacks = {
                onComplete: null,
                onLoop: null,
                onStart: null,
                onUpdate: null,
                onYoyo: null
              };
              this.callbackScope;
            },
            dispatchTimelineEvent: function(event, callback) {
              this.emit(event, this);
              if (callback) {
                callback.func.apply(callback.scope, callback.params);
              }
            },
            setTimeScale: function(value) {
              this.timeScale = value;
              return this;
            },
            getTimeScale: function() {
              return this.timeScale;
            },
            isPlaying: function() {
              return this.state === TWEEN_CONST.ACTIVE;
            },
            add: function(config2) {
              return this.queue(TweenBuilder(this, config2));
            },
            queue: function(tween) {
              if (!this.isPlaying()) {
                tween.parent = this;
                tween.parentIsTimeline = true;
                this.data.push(tween);
                this.totalData = this.data.length;
              }
              return this;
            },
            hasOffset: function(tween) {
              return tween.offset !== null;
            },
            isOffsetAbsolute: function(value) {
              return typeof value === "number";
            },
            isOffsetRelative: function(value) {
              var t = typeof value;
              if (t === "string") {
                var op = value[0];
                if (op === "-" || op === "+") {
                  return true;
                }
              }
              return false;
            },
            getRelativeOffset: function(value, base) {
              var op = value[0];
              var num = parseFloat(value.substr(2));
              var result = base;
              switch (op) {
                case "+":
                  result += num;
                  break;
                case "-":
                  result -= num;
                  break;
              }
              return Math.max(0, result);
            },
            calcDuration: function() {
              var prevEnd = 0;
              var totalDuration = 0;
              var offsetDuration = 0;
              for (var i = 0; i < this.totalData; i++) {
                var tween = this.data[i];
                tween.init();
                if (this.hasOffset(tween)) {
                  if (this.isOffsetAbsolute(tween.offset)) {
                    tween.calculatedOffset = tween.offset;
                    if (tween.offset === 0) {
                      offsetDuration = 0;
                    }
                  } else if (this.isOffsetRelative(tween.offset)) {
                    tween.calculatedOffset = this.getRelativeOffset(tween.offset, prevEnd);
                  }
                } else {
                  tween.calculatedOffset = offsetDuration;
                }
                prevEnd = tween.totalDuration + tween.calculatedOffset;
                totalDuration += tween.totalDuration;
                offsetDuration += tween.totalDuration;
              }
              this.duration = totalDuration;
              this.loopCounter = this.loop === -1 ? 999999999999 : this.loop;
              if (this.loopCounter > 0) {
                this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter;
              } else {
                this.totalDuration = this.duration + this.completeDelay;
              }
            },
            init: function() {
              this.calcDuration();
              this.progress = 0;
              this.totalProgress = 0;
              if (this.paused) {
                this.state = TWEEN_CONST.PAUSED;
                return false;
              } else {
                return true;
              }
            },
            resetTweens: function(resetFromLoop) {
              for (var i = 0; i < this.totalData; i++) {
                var tween = this.data[i];
                tween.play(resetFromLoop);
              }
            },
            setCallback: function(type, callback, params, scope) {
              if (Timeline.TYPES.indexOf(type) !== -1) {
                this.callbacks[type] = {func: callback, scope, params};
              }
              return this;
            },
            makeActive: function(tween) {
              return this.manager.makeActive(tween);
            },
            play: function() {
              if (this.state === TWEEN_CONST.ACTIVE) {
                return;
              }
              if (this.paused) {
                this.paused = false;
                this.manager.makeActive(this);
                return;
              } else {
                this.resetTweens(false);
                this.state = TWEEN_CONST.ACTIVE;
              }
              this.dispatchTimelineEvent(Events.TIMELINE_START, this.callbacks.onStart);
            },
            nextState: function() {
              if (this.loopCounter > 0) {
                this.elapsed = 0;
                this.progress = 0;
                this.loopCounter--;
                this.resetTweens(true);
                if (this.loopDelay > 0) {
                  this.countdown = this.loopDelay;
                  this.state = TWEEN_CONST.LOOP_DELAY;
                } else {
                  this.state = TWEEN_CONST.ACTIVE;
                  this.dispatchTimelineEvent(Events.TIMELINE_LOOP, this.callbacks.onLoop);
                }
              } else if (this.completeDelay > 0) {
                this.state = TWEEN_CONST.COMPLETE_DELAY;
                this.countdown = this.completeDelay;
              } else {
                this.state = TWEEN_CONST.PENDING_REMOVE;
                this.dispatchTimelineEvent(Events.TIMELINE_COMPLETE, this.callbacks.onComplete);
              }
            },
            update: function(timestamp, delta) {
              if (this.state === TWEEN_CONST.PAUSED) {
                return;
              }
              if (this.useFrames) {
                delta = 1 * this.manager.timeScale;
              }
              delta *= this.timeScale;
              this.elapsed += delta;
              this.progress = Math.min(this.elapsed / this.duration, 1);
              this.totalElapsed += delta;
              this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);
              switch (this.state) {
                case TWEEN_CONST.ACTIVE:
                  var stillRunning = this.totalData;
                  for (var i = 0; i < this.totalData; i++) {
                    var tween = this.data[i];
                    if (tween.update(timestamp, delta)) {
                      stillRunning--;
                    }
                  }
                  this.dispatchTimelineEvent(Events.TIMELINE_UPDATE, this.callbacks.onUpdate);
                  if (stillRunning === 0) {
                    this.nextState();
                  }
                  break;
                case TWEEN_CONST.LOOP_DELAY:
                  this.countdown -= delta;
                  if (this.countdown <= 0) {
                    this.state = TWEEN_CONST.ACTIVE;
                    this.dispatchTimelineEvent(Events.TIMELINE_LOOP, this.callbacks.onLoop);
                  }
                  break;
                case TWEEN_CONST.COMPLETE_DELAY:
                  this.countdown -= delta;
                  if (this.countdown <= 0) {
                    this.state = TWEEN_CONST.PENDING_REMOVE;
                    this.dispatchTimelineEvent(Events.TIMELINE_COMPLETE, this.callbacks.onComplete);
                  }
                  break;
              }
              return this.state === TWEEN_CONST.PENDING_REMOVE;
            },
            stop: function() {
              this.state = TWEEN_CONST.PENDING_REMOVE;
            },
            pause: function() {
              if (this.state === TWEEN_CONST.PAUSED) {
                return;
              }
              this.paused = true;
              this._pausedState = this.state;
              this.state = TWEEN_CONST.PAUSED;
              this.emit(Events.TIMELINE_PAUSE, this);
              return this;
            },
            resume: function() {
              if (this.state === TWEEN_CONST.PAUSED) {
                this.paused = false;
                this.state = this._pausedState;
                this.emit(Events.TIMELINE_RESUME, this);
              }
              return this;
            },
            hasTarget: function(target) {
              for (var i = 0; i < this.data.length; i++) {
                if (this.data[i].hasTarget(target)) {
                  return true;
                }
              }
              return false;
            },
            destroy: function() {
              for (var i = 0; i < this.data.length; i++) {
                this.data[i].stop();
              }
            }
          });
          Timeline.TYPES = ["onStart", "onUpdate", "onLoop", "onComplete", "onYoyo"];
          module2.exports = Timeline;
        },
        function(module2, exports2, __webpack_require__) {
          var Axes = {};
          module2.exports = Axes;
          var Vector = __webpack_require__(116);
          var Common = __webpack_require__(50);
          (function() {
            Axes.fromVertices = function(vertices) {
              var axes = {};
              for (var i = 0; i < vertices.length; i++) {
                var j = (i + 1) % vertices.length, normal = Vector.normalise({
                  x: vertices[j].y - vertices[i].y,
                  y: vertices[i].x - vertices[j].x
                }), gradient = normal.y === 0 ? Infinity : normal.x / normal.y;
                gradient = gradient.toFixed(3).toString();
                axes[gradient] = normal;
              }
              return Common.values(axes);
            };
            Axes.rotate = function(axes, angle) {
              if (angle === 0)
                return;
              var cos = Math.cos(angle), sin = Math.sin(angle);
              for (var i = 0; i < axes.length; i++) {
                var axis = axes[i], xx;
                xx = axis.x * cos - axis.y * sin;
                axis.y = axis.x * sin + axis.y * cos;
                axis.x = xx;
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            AFTER_ADD: __webpack_require__(1509),
            AFTER_REMOVE: __webpack_require__(1510),
            AFTER_UPDATE: __webpack_require__(1511),
            BEFORE_ADD: __webpack_require__(1512),
            BEFORE_REMOVE: __webpack_require__(1513),
            BEFORE_UPDATE: __webpack_require__(1514),
            COLLISION_ACTIVE: __webpack_require__(1515),
            COLLISION_END: __webpack_require__(1516),
            COLLISION_START: __webpack_require__(1517),
            DRAG_END: __webpack_require__(1518),
            DRAG: __webpack_require__(1519),
            DRAG_START: __webpack_require__(1520),
            PAUSE: __webpack_require__(1521),
            RESUME: __webpack_require__(1522),
            SLEEP_END: __webpack_require__(1523),
            SLEEP_START: __webpack_require__(1524)
          };
        },
        function(module2, exports2, __webpack_require__) {
          var Detector = {};
          module2.exports = Detector;
          var SAT = __webpack_require__(588);
          var Pair = __webpack_require__(535);
          var Bounds = __webpack_require__(117);
          (function() {
            Detector.collisions = function(broadphasePairs, engine) {
              var collisions = [], pairsTable = engine.pairs.table;
              var metrics = engine.metrics;
              for (var i = 0; i < broadphasePairs.length; i++) {
                var bodyA = broadphasePairs[i][0], bodyB = broadphasePairs[i][1];
                if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))
                  continue;
                if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))
                  continue;
                metrics.midphaseTests += 1;
                if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {
                  for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {
                    var partA = bodyA.parts[j];
                    for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {
                      var partB = bodyB.parts[k];
                      if (partA === bodyA && partB === bodyB || Bounds.overlaps(partA.bounds, partB.bounds)) {
                        var pairId = Pair.id(partA, partB), pair = pairsTable[pairId], previousCollision;
                        if (pair && pair.isActive) {
                          previousCollision = pair.collision;
                        } else {
                          previousCollision = null;
                        }
                        var collision = SAT.collides(partA, partB, previousCollision);
                        metrics.narrowphaseTests += 1;
                        if (collision.reused)
                          metrics.narrowReuseCount += 1;
                        if (collision.collided) {
                          collisions.push(collision);
                          metrics.narrowDetections += 1;
                        }
                      }
                    }
                  }
                }
              }
              return collisions;
            };
            Detector.canCollide = function(filterA, filterB) {
              if (filterA.group === filterB.group && filterA.group !== 0)
                return filterA.group > 0;
              return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var SAT = {};
          module2.exports = SAT;
          var Vertices = __webpack_require__(94);
          var Vector = __webpack_require__(116);
          (function() {
            SAT.collides = function(bodyA, bodyB, previousCollision) {
              var overlapAB, overlapBA, minOverlap, collision, canReusePrevCol = false;
              if (previousCollision) {
                var parentA = bodyA.parent, parentB = bodyB.parent, motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;
                canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;
                collision = previousCollision;
              } else {
                collision = {collided: false, bodyA, bodyB};
              }
              if (previousCollision && canReusePrevCol) {
                var axisBodyA = collision.axisBody, axisBodyB = axisBodyA === bodyA ? bodyB : bodyA, axes = [axisBodyA.axes[previousCollision.axisNumber]];
                minOverlap = SAT._overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);
                collision.reused = true;
                if (minOverlap.overlap <= 0) {
                  collision.collided = false;
                  return collision;
                }
              } else {
                overlapAB = SAT._overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);
                if (overlapAB.overlap <= 0) {
                  collision.collided = false;
                  return collision;
                }
                overlapBA = SAT._overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);
                if (overlapBA.overlap <= 0) {
                  collision.collided = false;
                  return collision;
                }
                if (overlapAB.overlap < overlapBA.overlap) {
                  minOverlap = overlapAB;
                  collision.axisBody = bodyA;
                } else {
                  minOverlap = overlapBA;
                  collision.axisBody = bodyB;
                }
                collision.axisNumber = minOverlap.axisNumber;
              }
              collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;
              collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;
              collision.collided = true;
              collision.depth = minOverlap.overlap;
              collision.parentA = collision.bodyA.parent;
              collision.parentB = collision.bodyB.parent;
              bodyA = collision.bodyA;
              bodyB = collision.bodyB;
              if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {
                collision.normal = {
                  x: minOverlap.axis.x,
                  y: minOverlap.axis.y
                };
              } else {
                collision.normal = {
                  x: -minOverlap.axis.x,
                  y: -minOverlap.axis.y
                };
              }
              collision.tangent = Vector.perp(collision.normal);
              collision.penetration = collision.penetration || {};
              collision.penetration.x = collision.normal.x * collision.depth;
              collision.penetration.y = collision.normal.y * collision.depth;
              var verticesB = SAT._findSupports(bodyA, bodyB, collision.normal), supports = [];
              if (Vertices.contains(bodyA.vertices, verticesB[0]))
                supports.push(verticesB[0]);
              if (Vertices.contains(bodyA.vertices, verticesB[1]))
                supports.push(verticesB[1]);
              if (supports.length < 2) {
                var verticesA = SAT._findSupports(bodyB, bodyA, Vector.neg(collision.normal));
                if (Vertices.contains(bodyB.vertices, verticesA[0]))
                  supports.push(verticesA[0]);
                if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1]))
                  supports.push(verticesA[1]);
              }
              if (supports.length < 1)
                supports = [verticesB[0]];
              collision.supports = supports;
              return collision;
            };
            SAT._overlapAxes = function(verticesA, verticesB, axes) {
              var projectionA = Vector._temp[0], projectionB = Vector._temp[1], result = {overlap: Number.MAX_VALUE}, overlap, axis;
              for (var i = 0; i < axes.length; i++) {
                axis = axes[i];
                SAT._projectToAxis(projectionA, verticesA, axis);
                SAT._projectToAxis(projectionB, verticesB, axis);
                overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);
                if (overlap <= 0) {
                  result.overlap = overlap;
                  return result;
                }
                if (overlap < result.overlap) {
                  result.overlap = overlap;
                  result.axis = axis;
                  result.axisNumber = i;
                }
              }
              return result;
            };
            SAT._projectToAxis = function(projection, vertices, axis) {
              var min = Vector.dot(vertices[0], axis), max = min;
              for (var i = 1; i < vertices.length; i += 1) {
                var dot = Vector.dot(vertices[i], axis);
                if (dot > max) {
                  max = dot;
                } else if (dot < min) {
                  min = dot;
                }
              }
              projection.min = min;
              projection.max = max;
            };
            SAT._findSupports = function(bodyA, bodyB, normal) {
              var nearestDistance = Number.MAX_VALUE, vertexToBody = Vector._temp[0], vertices = bodyB.vertices, bodyAPosition = bodyA.position, distance, vertex, vertexA, vertexB;
              for (var i = 0; i < vertices.length; i++) {
                vertex = vertices[i];
                vertexToBody.x = vertex.x - bodyAPosition.x;
                vertexToBody.y = vertex.y - bodyAPosition.y;
                distance = -Vector.dot(normal, vertexToBody);
                if (distance < nearestDistance) {
                  nearestDistance = distance;
                  vertexA = vertex;
                }
              }
              var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;
              vertex = vertices[prevIndex];
              vertexToBody.x = vertex.x - bodyAPosition.x;
              vertexToBody.y = vertex.y - bodyAPosition.y;
              nearestDistance = -Vector.dot(normal, vertexToBody);
              vertexB = vertex;
              var nextIndex = (vertexA.index + 1) % vertices.length;
              vertex = vertices[nextIndex];
              vertexToBody.x = vertex.x - bodyAPosition.x;
              vertexToBody.y = vertex.y - bodyAPosition.y;
              distance = -Vector.dot(normal, vertexToBody);
              if (distance < nearestDistance) {
                vertexB = vertex;
              }
              return [vertexA, vertexB];
            };
          })();
        },
        function(module2, exports2) {
          var g;
          g = function() {
            return this;
          }();
          try {
            g = g || new Function("return this")();
          } catch (e) {
            if (typeof window === "object")
              g = window;
          }
          module2.exports = g;
        },
        function(module2, exports2, __webpack_require__) {
          __webpack_require__(591);
          __webpack_require__(592);
          __webpack_require__(593);
          __webpack_require__(594);
          __webpack_require__(595);
          __webpack_require__(596);
          __webpack_require__(597);
          __webpack_require__(598);
        },
        function(module2, exports2) {
          if (!Array.prototype.forEach) {
            Array.prototype.forEach = function(fun) {
              "use strict";
              if (this === void 0 || this === null) {
                throw new TypeError();
              }
              var t = Object(this);
              var len = t.length >>> 0;
              if (typeof fun !== "function") {
                throw new TypeError();
              }
              var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
              for (var i = 0; i < len; i++) {
                if (i in t) {
                  fun.call(thisArg, t[i], i, t);
                }
              }
            };
          }
        },
        function(module2, exports2) {
          if (!Array.isArray) {
            Array.isArray = function(arg) {
              return Object.prototype.toString.call(arg) === "[object Array]";
            };
          }
        },
        function(module2, exports2) {
          (function() {
            function fixSetTarget(param) {
              if (!param)
                return;
              if (!param.setTargetAtTime)
                param.setTargetAtTime = param.setTargetValueAtTime;
            }
            if (window.hasOwnProperty("webkitAudioContext") && !window.hasOwnProperty("AudioContext")) {
              window.AudioContext = webkitAudioContext;
              if (!AudioContext.prototype.hasOwnProperty("createGain"))
                AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
              if (!AudioContext.prototype.hasOwnProperty("createDelay"))
                AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
              if (!AudioContext.prototype.hasOwnProperty("createScriptProcessor"))
                AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;
              if (!AudioContext.prototype.hasOwnProperty("createPeriodicWave"))
                AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;
              AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain;
              AudioContext.prototype.createGain = function() {
                var node = this.internal_createGain();
                fixSetTarget(node.gain);
                return node;
              };
              AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay;
              AudioContext.prototype.createDelay = function(maxDelayTime) {
                var node = maxDelayTime ? this.internal_createDelay(maxDelayTime) : this.internal_createDelay();
                fixSetTarget(node.delayTime);
                return node;
              };
              AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource;
              AudioContext.prototype.createBufferSource = function() {
                var node = this.internal_createBufferSource();
                if (!node.start) {
                  node.start = function(when, offset, duration) {
                    if (offset || duration)
                      this.noteGrainOn(when || 0, offset, duration);
                    else
                      this.noteOn(when || 0);
                  };
                } else {
                  node.internal_start = node.start;
                  node.start = function(when, offset, duration) {
                    if (typeof duration !== "undefined")
                      node.internal_start(when || 0, offset, duration);
                    else
                      node.internal_start(when || 0, offset || 0);
                  };
                }
                if (!node.stop) {
                  node.stop = function(when) {
                    this.noteOff(when || 0);
                  };
                } else {
                  node.internal_stop = node.stop;
                  node.stop = function(when) {
                    node.internal_stop(when || 0);
                  };
                }
                fixSetTarget(node.playbackRate);
                return node;
              };
              AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;
              AudioContext.prototype.createDynamicsCompressor = function() {
                var node = this.internal_createDynamicsCompressor();
                fixSetTarget(node.threshold);
                fixSetTarget(node.knee);
                fixSetTarget(node.ratio);
                fixSetTarget(node.reduction);
                fixSetTarget(node.attack);
                fixSetTarget(node.release);
                return node;
              };
              AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter;
              AudioContext.prototype.createBiquadFilter = function() {
                var node = this.internal_createBiquadFilter();
                fixSetTarget(node.frequency);
                fixSetTarget(node.detune);
                fixSetTarget(node.Q);
                fixSetTarget(node.gain);
                return node;
              };
              if (AudioContext.prototype.hasOwnProperty("createOscillator")) {
                AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator;
                AudioContext.prototype.createOscillator = function() {
                  var node = this.internal_createOscillator();
                  if (!node.start) {
                    node.start = function(when) {
                      this.noteOn(when || 0);
                    };
                  } else {
                    node.internal_start = node.start;
                    node.start = function(when) {
                      node.internal_start(when || 0);
                    };
                  }
                  if (!node.stop) {
                    node.stop = function(when) {
                      this.noteOff(when || 0);
                    };
                  } else {
                    node.internal_stop = node.stop;
                    node.stop = function(when) {
                      node.internal_stop(when || 0);
                    };
                  }
                  if (!node.setPeriodicWave)
                    node.setPeriodicWave = node.setWaveTable;
                  fixSetTarget(node.frequency);
                  fixSetTarget(node.detune);
                  return node;
                };
              }
            }
            if (window.hasOwnProperty("webkitOfflineAudioContext") && !window.hasOwnProperty("OfflineAudioContext")) {
              window.OfflineAudioContext = webkitOfflineAudioContext;
            }
          })();
        },
        function(module2, exports2) {
          if (!window.console) {
            window.console = {};
            window.console.log = window.console.assert = function() {
            };
            window.console.warn = window.console.assert = function() {
            };
          }
        },
        function(module2, exports2) {
          if (!Math.trunc) {
            Math.trunc = function trunc(x) {
              return x < 0 ? Math.ceil(x) : Math.floor(x);
            };
          }
        },
        function(module2, exports2) {
          (function() {
            if ("performance" in window === false) {
              window.performance = {};
            }
            Date.now = Date.now || function() {
              return new Date().getTime();
            };
            if ("now" in window.performance === false) {
              var nowOffset = Date.now();
              if (performance.timing && performance.timing.navigationStart) {
                nowOffset = performance.timing.navigationStart;
              }
              window.performance.now = function now() {
                return Date.now() - nowOffset;
              };
            }
          })();
        },
        function(module2, exports2) {
          var lastTime = Date.now();
          var vendors = ["ms", "moz", "webkit", "o"];
          for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {
            window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
            window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
          }
          if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function(callback) {
              if (typeof callback !== "function") {
                throw new TypeError(callback + "is not a function");
              }
              var currentTime = Date.now();
              var delay = 16 + lastTime - currentTime;
              if (delay < 0) {
                delay = 0;
              }
              lastTime = currentTime;
              return setTimeout(function() {
                lastTime = Date.now();
                callback(performance.now());
              }, delay);
            };
          }
          if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
          }
        },
        function(module2, exports2) {
          if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object") {
            var CheapArray = function(fakeType) {
              var proto = new Array();
              window[fakeType] = function(arg) {
                if (typeof arg === "number") {
                  Array.call(this, arg);
                  this.length = arg;
                  for (var i = 0; i < this.length; i++) {
                    this[i] = 0;
                  }
                } else {
                  Array.call(this, arg.length);
                  this.length = arg.length;
                  for (var i = 0; i < this.length; i++) {
                    this[i] = arg[i];
                  }
                }
              };
              window[fakeType].prototype = proto;
              window[fakeType].constructor = window[fakeType];
            };
            CheapArray("Float32Array");
            CheapArray("Uint32Array");
            CheapArray("Uint16Array");
            CheapArray("Int16Array");
            CheapArray("ArrayBuffer");
          }
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       samme
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var QuickSet = __webpack_require__(270);
          var AlignTo = function(items, position, offsetX, offsetY) {
            var target = items[0];
            for (var i = 1; i < items.length; i++) {
              var item = items[i];
              QuickSet(item, target, position, offsetX, offsetY);
              target = item;
            }
            return items;
          };
          module2.exports = AlignTo;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueInc = __webpack_require__(44);
          var Angle = function(items, value, step, index, direction) {
            return PropertyValueInc(items, "angle", value, step, index, direction);
          };
          module2.exports = Angle;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Call = function(items, callback, context) {
            for (var i = 0; i < items.length; i++) {
              var item = items[i];
              callback.call(context, item);
            }
            return items;
          };
          module2.exports = Call;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetFirst = function(items, compare, index) {
            if (index === void 0) {
              index = 0;
            }
            for (var i = index; i < items.length; i++) {
              var item = items[i];
              var match = true;
              for (var property in compare) {
                if (item[property] !== compare[property]) {
                  match = false;
                }
              }
              if (match) {
                return item;
              }
            }
            return null;
          };
          module2.exports = GetFirst;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetLast = function(items, compare, index) {
            if (index === void 0) {
              index = 0;
            }
            for (var i = index; i < items.length; i++) {
              var item = items[i];
              var match = true;
              for (var property in compare) {
                if (item[property] !== compare[property]) {
                  match = false;
                }
              }
              if (match) {
                return item;
              }
            }
            return null;
          };
          module2.exports = GetLast;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AlignIn = __webpack_require__(283);
          var CONST = __webpack_require__(122);
          var GetFastValue = __webpack_require__(2);
          var NOOP = __webpack_require__(1);
          var Zone = __webpack_require__(127);
          var tempZone = new Zone({sys: {queueDepthSort: NOOP, events: {once: NOOP}}}, 0, 0, 1, 1);
          var GridAlign = function(items, options) {
            if (options === void 0) {
              options = {};
            }
            var widthSet = options.hasOwnProperty("width");
            var heightSet = options.hasOwnProperty("height");
            var width = GetFastValue(options, "width", -1);
            var height = GetFastValue(options, "height", -1);
            var cellWidth = GetFastValue(options, "cellWidth", 1);
            var cellHeight = GetFastValue(options, "cellHeight", cellWidth);
            var position = GetFastValue(options, "position", CONST.TOP_LEFT);
            var x = GetFastValue(options, "x", 0);
            var y = GetFastValue(options, "y", 0);
            var cx = 0;
            var cy = 0;
            var w = width * cellWidth;
            var h = height * cellHeight;
            tempZone.setPosition(x, y);
            tempZone.setSize(cellWidth, cellHeight);
            for (var i = 0; i < items.length; i++) {
              AlignIn(items[i], tempZone, position);
              if (widthSet && width === -1) {
                tempZone.x += cellWidth;
              } else if (heightSet && height === -1) {
                tempZone.y += cellHeight;
              } else if (heightSet && !widthSet) {
                cy += cellHeight;
                tempZone.y += cellHeight;
                if (cy === h) {
                  cy = 0;
                  cx += cellWidth;
                  tempZone.y = y;
                  tempZone.x += cellWidth;
                  if (cx === w) {
                    break;
                  }
                }
              } else {
                cx += cellWidth;
                tempZone.x += cellWidth;
                if (cx === w) {
                  cx = 0;
                  cy += cellHeight;
                  tempZone.x = x;
                  tempZone.y += cellHeight;
                  if (cy === h) {
                    break;
                  }
                }
              }
            }
            return items;
          };
          module2.exports = GridAlign;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clamp = __webpack_require__(18);
          var _FLAG = 2;
          var Alpha = {
            _alpha: 1,
            _alphaTL: 1,
            _alphaTR: 1,
            _alphaBL: 1,
            _alphaBR: 1,
            clearAlpha: function() {
              return this.setAlpha(1);
            },
            setAlpha: function(topLeft, topRight, bottomLeft, bottomRight) {
              if (topLeft === void 0) {
                topLeft = 1;
              }
              if (topRight === void 0) {
                this.alpha = topLeft;
              } else {
                this._alphaTL = Clamp(topLeft, 0, 1);
                this._alphaTR = Clamp(topRight, 0, 1);
                this._alphaBL = Clamp(bottomLeft, 0, 1);
                this._alphaBR = Clamp(bottomRight, 0, 1);
              }
              return this;
            },
            alpha: {
              get: function() {
                return this._alpha;
              },
              set: function(value) {
                var v = Clamp(value, 0, 1);
                this._alpha = v;
                this._alphaTL = v;
                this._alphaTR = v;
                this._alphaBL = v;
                this._alphaBR = v;
                if (v === 0) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
              }
            },
            alphaTopLeft: {
              get: function() {
                return this._alphaTL;
              },
              set: function(value) {
                var v = Clamp(value, 0, 1);
                this._alphaTL = v;
                if (v !== 0) {
                  this.renderFlags |= _FLAG;
                }
              }
            },
            alphaTopRight: {
              get: function() {
                return this._alphaTR;
              },
              set: function(value) {
                var v = Clamp(value, 0, 1);
                this._alphaTR = v;
                if (v !== 0) {
                  this.renderFlags |= _FLAG;
                }
              }
            },
            alphaBottomLeft: {
              get: function() {
                return this._alphaBL;
              },
              set: function(value) {
                var v = Clamp(value, 0, 1);
                this._alphaBL = v;
                if (v !== 0) {
                  this.renderFlags |= _FLAG;
                }
              }
            },
            alphaBottomRight: {
              get: function() {
                return this._alphaBR;
              },
              set: function(value) {
                var v = Clamp(value, 0, 1);
                this._alphaBR = v;
                if (v !== 0) {
                  this.renderFlags |= _FLAG;
                }
              }
            }
          };
          module2.exports = Alpha;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ComputedSize = {
            width: 0,
            height: 0,
            displayWidth: {
              get: function() {
                return this.scaleX * this.width;
              },
              set: function(value) {
                this.scaleX = value / this.width;
              }
            },
            displayHeight: {
              get: function() {
                return this.scaleY * this.height;
              },
              set: function(value) {
                this.scaleY = value / this.height;
              }
            },
            setSize: function(width, height) {
              this.width = width;
              this.height = height;
              return this;
            },
            setDisplaySize: function(width, height) {
              this.displayWidth = width;
              this.displayHeight = height;
              return this;
            }
          };
          module2.exports = ComputedSize;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Crop = {
            texture: null,
            frame: null,
            isCropped: false,
            setCrop: function(x, y, width, height) {
              if (x === void 0) {
                this.isCropped = false;
              } else if (this.frame) {
                if (typeof x === "number") {
                  this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);
                } else {
                  var rect = x;
                  this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);
                }
                this.isCropped = true;
              }
              return this;
            },
            resetCropObject: function() {
              return {u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0};
            }
          };
          module2.exports = Crop;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Flip = {
            flipX: false,
            flipY: false,
            toggleFlipX: function() {
              this.flipX = !this.flipX;
              return this;
            },
            toggleFlipY: function() {
              this.flipY = !this.flipY;
              return this;
            },
            setFlipX: function(value) {
              this.flipX = value;
              return this;
            },
            setFlipY: function(value) {
              this.flipY = value;
              return this;
            },
            setFlip: function(x, y) {
              this.flipX = x;
              this.flipY = y;
              return this;
            },
            resetFlip: function() {
              this.flipX = false;
              this.flipY = false;
              return this;
            }
          };
          module2.exports = Flip;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rectangle = __webpack_require__(10);
          var RotateAround = __webpack_require__(302);
          var Vector29 = __webpack_require__(3);
          var GetBounds = {
            prepareBoundsOutput: function(output, includeParent) {
              if (includeParent === void 0) {
                includeParent = false;
              }
              if (this.rotation !== 0) {
                RotateAround(output, this.x, this.y, this.rotation);
              }
              if (includeParent && this.parentContainer) {
                var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
                parentMatrix.transformPoint(output.x, output.y, output);
              }
              return output;
            },
            getCenter: function(output) {
              if (output === void 0) {
                output = new Vector29();
              }
              output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
              output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
              return output;
            },
            getTopLeft: function(output, includeParent) {
              if (!output) {
                output = new Vector29();
              }
              output.x = this.x - this.displayWidth * this.originX;
              output.y = this.y - this.displayHeight * this.originY;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getTopCenter: function(output, includeParent) {
              if (!output) {
                output = new Vector29();
              }
              output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
              output.y = this.y - this.displayHeight * this.originY;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getTopRight: function(output, includeParent) {
              if (!output) {
                output = new Vector29();
              }
              output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
              output.y = this.y - this.displayHeight * this.originY;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getLeftCenter: function(output, includeParent) {
              if (!output) {
                output = new Vector29();
              }
              output.x = this.x - this.displayWidth * this.originX;
              output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getRightCenter: function(output, includeParent) {
              if (!output) {
                output = new Vector29();
              }
              output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
              output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getBottomLeft: function(output, includeParent) {
              if (!output) {
                output = new Vector29();
              }
              output.x = this.x - this.displayWidth * this.originX;
              output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getBottomCenter: function(output, includeParent) {
              if (!output) {
                output = new Vector29();
              }
              output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
              output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getBottomRight: function(output, includeParent) {
              if (!output) {
                output = new Vector29();
              }
              output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
              output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getBounds: function(output) {
              if (output === void 0) {
                output = new Rectangle();
              }
              var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;
              if (this.parentContainer) {
                var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
                this.getTopLeft(output);
                parentMatrix.transformPoint(output.x, output.y, output);
                TLx = output.x;
                TLy = output.y;
                this.getTopRight(output);
                parentMatrix.transformPoint(output.x, output.y, output);
                TRx = output.x;
                TRy = output.y;
                this.getBottomLeft(output);
                parentMatrix.transformPoint(output.x, output.y, output);
                BLx = output.x;
                BLy = output.y;
                this.getBottomRight(output);
                parentMatrix.transformPoint(output.x, output.y, output);
                BRx = output.x;
                BRy = output.y;
              } else {
                this.getTopLeft(output);
                TLx = output.x;
                TLy = output.y;
                this.getTopRight(output);
                TRx = output.x;
                TRy = output.y;
                this.getBottomLeft(output);
                BLx = output.x;
                BLy = output.y;
                this.getBottomRight(output);
                BRx = output.x;
                BRy = output.y;
              }
              output.x = Math.min(TLx, TRx, BLx, BRx);
              output.y = Math.min(TLy, TRy, BLy, BRy);
              output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;
              output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;
              return output;
            }
          };
          module2.exports = GetBounds;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "blur";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "boot";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "contextlost";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "contextrestored";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "destroy";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "focus";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "hidden";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pause";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "postrender";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "poststep";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "prerender";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "prestep";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "ready";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "resume";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "step";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "visible";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "postrender";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "prerender";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "render";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "resize";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Origin = {
            _originComponent: true,
            originX: 0.5,
            originY: 0.5,
            _displayOriginX: 0,
            _displayOriginY: 0,
            displayOriginX: {
              get: function() {
                return this._displayOriginX;
              },
              set: function(value) {
                this._displayOriginX = value;
                this.originX = value / this.width;
              }
            },
            displayOriginY: {
              get: function() {
                return this._displayOriginY;
              },
              set: function(value) {
                this._displayOriginY = value;
                this.originY = value / this.height;
              }
            },
            setOrigin: function(x, y) {
              if (x === void 0) {
                x = 0.5;
              }
              if (y === void 0) {
                y = x;
              }
              this.originX = x;
              this.originY = y;
              return this.updateDisplayOrigin();
            },
            setOriginFromFrame: function() {
              if (!this.frame || !this.frame.customPivot) {
                return this.setOrigin();
              } else {
                this.originX = this.frame.pivotX;
                this.originY = this.frame.pivotY;
              }
              return this.updateDisplayOrigin();
            },
            setDisplayOrigin: function(x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = x;
              }
              this.displayOriginX = x;
              this.displayOriginY = y;
              return this;
            },
            updateDisplayOrigin: function() {
              this._displayOriginX = this.originX * this.width;
              this._displayOriginY = this.originY * this.height;
              return this;
            }
          };
          module2.exports = Origin;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DegToRad = __webpack_require__(35);
          var GetBoolean = __webpack_require__(96);
          var GetValue = __webpack_require__(6);
          var TWEEN_CONST = __webpack_require__(97);
          var Vector29 = __webpack_require__(3);
          var PathFollower = {
            path: null,
            rotateToPath: false,
            pathRotationOffset: 0,
            pathOffset: null,
            pathVector: null,
            pathDelta: null,
            pathTween: null,
            pathConfig: null,
            _prevDirection: TWEEN_CONST.PLAYING_FORWARD,
            setPath: function(path, config2) {
              if (config2 === void 0) {
                config2 = this.pathConfig;
              }
              var tween = this.pathTween;
              if (tween && tween.isPlaying()) {
                tween.stop();
              }
              this.path = path;
              if (config2) {
                this.startFollow(config2);
              }
              return this;
            },
            setRotateToPath: function(value, offset) {
              if (offset === void 0) {
                offset = 0;
              }
              this.rotateToPath = value;
              this.pathRotationOffset = offset;
              return this;
            },
            isFollowing: function() {
              var tween = this.pathTween;
              return tween && tween.isPlaying();
            },
            startFollow: function(config2, startAt) {
              if (config2 === void 0) {
                config2 = {};
              }
              if (startAt === void 0) {
                startAt = 0;
              }
              var tween = this.pathTween;
              if (tween && tween.isPlaying()) {
                tween.stop();
              }
              if (typeof config2 === "number") {
                config2 = {duration: config2};
              }
              config2.from = GetValue(config2, "from", 0);
              config2.to = GetValue(config2, "to", 1);
              var positionOnPath = GetBoolean(config2, "positionOnPath", false);
              this.rotateToPath = GetBoolean(config2, "rotateToPath", false);
              this.pathRotationOffset = GetValue(config2, "rotationOffset", 0);
              var seek = GetValue(config2, "startAt", startAt);
              if (seek) {
                config2.onStart = function(tween2) {
                  var tweenData = tween2.data[0];
                  tweenData.progress = seek;
                  tweenData.elapsed = tweenData.duration * seek;
                  var v = tweenData.ease(tweenData.progress);
                  tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v;
                  tweenData.target[tweenData.key] = tweenData.current;
                };
              }
              if (!this.pathOffset) {
                this.pathOffset = new Vector29(this.x, this.y);
              }
              if (!this.pathVector) {
                this.pathVector = new Vector29();
              }
              if (!this.pathDelta) {
                this.pathDelta = new Vector29();
              }
              this.pathDelta.reset();
              this.pathTween = this.scene.sys.tweens.addCounter(config2);
              this.path.getStartPoint(this.pathOffset);
              if (positionOnPath) {
                this.x = this.pathOffset.x;
                this.y = this.pathOffset.y;
              }
              this.pathOffset.x = this.x - this.pathOffset.x;
              this.pathOffset.y = this.y - this.pathOffset.y;
              this._prevDirection = TWEEN_CONST.PLAYING_FORWARD;
              if (this.rotateToPath) {
                var nextPoint = this.path.getPoint(0.1);
                this.rotation = Math.atan2(nextPoint.y - this.y, nextPoint.x - this.x) + DegToRad(this.pathRotationOffset);
              }
              this.pathConfig = config2;
              return this;
            },
            pauseFollow: function() {
              var tween = this.pathTween;
              if (tween && tween.isPlaying()) {
                tween.pause();
              }
              return this;
            },
            resumeFollow: function() {
              var tween = this.pathTween;
              if (tween && tween.isPaused()) {
                tween.resume();
              }
              return this;
            },
            stopFollow: function() {
              var tween = this.pathTween;
              if (tween && tween.isPlaying()) {
                tween.stop();
              }
              return this;
            },
            pathUpdate: function() {
              var tween = this.pathTween;
              if (tween) {
                var tweenData = tween.data[0];
                var pathDelta = this.pathDelta;
                var pathVector = this.pathVector;
                pathDelta.copy(pathVector).negate();
                if (tweenData.state === TWEEN_CONST.COMPLETE) {
                  this.path.getPoint(1, pathVector);
                  pathDelta.add(pathVector);
                  pathVector.add(this.pathOffset);
                  this.setPosition(pathVector.x, pathVector.y);
                  return;
                } else if (tweenData.state !== TWEEN_CONST.PLAYING_FORWARD && tweenData.state !== TWEEN_CONST.PLAYING_BACKWARD) {
                  return;
                }
                this.path.getPoint(tween.getValue(), pathVector);
                pathDelta.add(pathVector);
                pathVector.add(this.pathOffset);
                var oldX = this.x;
                var oldY = this.y;
                this.setPosition(pathVector.x, pathVector.y);
                var speedX = this.x - oldX;
                var speedY = this.y - oldY;
                if (speedX === 0 && speedY === 0) {
                  return;
                }
                if (tweenData.state !== this._prevDirection) {
                  this._prevDirection = tweenData.state;
                  return;
                }
                if (this.rotateToPath) {
                  this.rotation = Math.atan2(speedY, speedX) + DegToRad(this.pathRotationOffset);
                }
              }
            }
          };
          module2.exports = PathFollower;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Size = {
            _sizeComponent: true,
            width: 0,
            height: 0,
            displayWidth: {
              get: function() {
                return Math.abs(this.scaleX * this.frame.realWidth);
              },
              set: function(value) {
                this.scaleX = value / this.frame.realWidth;
              }
            },
            displayHeight: {
              get: function() {
                return Math.abs(this.scaleY * this.frame.realHeight);
              },
              set: function(value) {
                this.scaleY = value / this.frame.realHeight;
              }
            },
            setSizeToFrame: function(frame) {
              if (frame === void 0) {
                frame = this.frame;
              }
              this.width = frame.realWidth;
              this.height = frame.realHeight;
              return this;
            },
            setSize: function(width, height) {
              this.width = width;
              this.height = height;
              return this;
            },
            setDisplaySize: function(width, height) {
              this.displayWidth = width;
              this.displayHeight = height;
              return this;
            }
          };
          module2.exports = Size;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var _FLAG = 8;
          var Texture = {
            texture: null,
            frame: null,
            isCropped: false,
            setTexture: function(key, frame) {
              this.texture = this.scene.sys.textures.get(key);
              return this.setFrame(frame);
            },
            setFrame: function(frame, updateSize, updateOrigin) {
              if (updateSize === void 0) {
                updateSize = true;
              }
              if (updateOrigin === void 0) {
                updateOrigin = true;
              }
              this.frame = this.texture.get(frame);
              if (!this.frame.cutWidth || !this.frame.cutHeight) {
                this.renderFlags &= ~_FLAG;
              } else {
                this.renderFlags |= _FLAG;
              }
              if (this._sizeComponent && updateSize) {
                this.setSizeToFrame();
              }
              if (this._originComponent && updateOrigin) {
                if (this.frame.customPivot) {
                  this.setOrigin(this.frame.pivotX, this.frame.pivotY);
                } else {
                  this.updateDisplayOrigin();
                }
              }
              return this;
            }
          };
          module2.exports = Texture;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var _FLAG = 8;
          var TextureCrop = {
            texture: null,
            frame: null,
            isCropped: false,
            setCrop: function(x, y, width, height) {
              if (x === void 0) {
                this.isCropped = false;
              } else if (this.frame) {
                if (typeof x === "number") {
                  this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);
                } else {
                  var rect = x;
                  this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);
                }
                this.isCropped = true;
              }
              return this;
            },
            setTexture: function(key, frame) {
              this.texture = this.scene.sys.textures.get(key);
              return this.setFrame(frame);
            },
            setFrame: function(frame, updateSize, updateOrigin) {
              if (updateSize === void 0) {
                updateSize = true;
              }
              if (updateOrigin === void 0) {
                updateOrigin = true;
              }
              this.frame = this.texture.get(frame);
              if (!this.frame.cutWidth || !this.frame.cutHeight) {
                this.renderFlags &= ~_FLAG;
              } else {
                this.renderFlags |= _FLAG;
              }
              if (this._sizeComponent && updateSize) {
                this.setSizeToFrame();
              }
              if (this._originComponent && updateOrigin) {
                if (this.frame.customPivot) {
                  this.setOrigin(this.frame.pivotX, this.frame.pivotY);
                } else {
                  this.updateDisplayOrigin();
                }
              }
              if (this.isCropped) {
                this.frame.updateCropUVs(this._crop, this.flipX, this.flipY);
              }
              return this;
            },
            resetCropObject: function() {
              return {u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0};
            }
          };
          module2.exports = TextureCrop;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Tint = {
            tintTopLeft: 16777215,
            tintTopRight: 16777215,
            tintBottomLeft: 16777215,
            tintBottomRight: 16777215,
            tintFill: false,
            clearTint: function() {
              this.setTint(16777215);
              return this;
            },
            setTint: function(topLeft, topRight, bottomLeft, bottomRight) {
              if (topLeft === void 0) {
                topLeft = 16777215;
              }
              if (topRight === void 0) {
                topRight = topLeft;
                bottomLeft = topLeft;
                bottomRight = topLeft;
              }
              this.tintTopLeft = topLeft;
              this.tintTopRight = topRight;
              this.tintBottomLeft = bottomLeft;
              this.tintBottomRight = bottomRight;
              this.tintFill = false;
              return this;
            },
            setTintFill: function(topLeft, topRight, bottomLeft, bottomRight) {
              this.setTint(topLeft, topRight, bottomLeft, bottomRight);
              this.tintFill = true;
              return this;
            },
            tint: {
              set: function(value) {
                this.setTint(value, value, value, value);
              }
            },
            isTinted: {
              get: function() {
                var white = 16777215;
                return this.tintFill || this.tintTopLeft !== white || this.tintTopRight !== white || this.tintBottomLeft !== white || this.tintBottomRight !== white;
              }
            }
          };
          module2.exports = Tint;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "changedata";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "changedata-";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "destroy";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "removedata";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "setdata";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "addedtoscene";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "destroy";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "removedfromscene";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "complete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "created";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "error";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "loop";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "play";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "seeked";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "seeking";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "stop";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "timeout";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "unlocked";
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueInc = __webpack_require__(44);
          var IncAlpha = function(items, value, step, index, direction) {
            return PropertyValueInc(items, "alpha", value, step, index, direction);
          };
          module2.exports = IncAlpha;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueInc = __webpack_require__(44);
          var IncX = function(items, value, step, index, direction) {
            return PropertyValueInc(items, "x", value, step, index, direction);
          };
          module2.exports = IncX;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueInc = __webpack_require__(44);
          var IncXY = function(items, x, y, stepX, stepY, index, direction) {
            if (y === void 0 || y === null) {
              y = x;
            }
            PropertyValueInc(items, "x", x, stepX, index, direction);
            return PropertyValueInc(items, "y", y, stepY, index, direction);
          };
          module2.exports = IncXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueInc = __webpack_require__(44);
          var IncY = function(items, value, step, index, direction) {
            return PropertyValueInc(items, "y", value, step, index, direction);
          };
          module2.exports = IncY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PlaceOnCircle = function(items, circle, startAngle, endAngle) {
            if (startAngle === void 0) {
              startAngle = 0;
            }
            if (endAngle === void 0) {
              endAngle = 6.28;
            }
            var angle = startAngle;
            var angleStep = (endAngle - startAngle) / items.length;
            for (var i = 0; i < items.length; i++) {
              items[i].x = circle.x + circle.radius * Math.cos(angle);
              items[i].y = circle.y + circle.radius * Math.sin(angle);
              angle += angleStep;
            }
            return items;
          };
          module2.exports = PlaceOnCircle;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PlaceOnEllipse = function(items, ellipse, startAngle, endAngle) {
            if (startAngle === void 0) {
              startAngle = 0;
            }
            if (endAngle === void 0) {
              endAngle = 6.28;
            }
            var angle = startAngle;
            var angleStep = (endAngle - startAngle) / items.length;
            var a = ellipse.width / 2;
            var b = ellipse.height / 2;
            for (var i = 0; i < items.length; i++) {
              items[i].x = ellipse.x + a * Math.cos(angle);
              items[i].y = ellipse.y + b * Math.sin(angle);
              angle += angleStep;
            }
            return items;
          };
          module2.exports = PlaceOnEllipse;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetPoints = __webpack_require__(168);
          var PlaceOnLine = function(items, line) {
            var points = GetPoints(line, items.length);
            for (var i = 0; i < items.length; i++) {
              var item = items[i];
              var point = points[i];
              item.x = point.x;
              item.y = point.y;
            }
            return items;
          };
          module2.exports = PlaceOnLine;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MarchingAnts = __webpack_require__(310);
          var RotateLeft = __webpack_require__(175);
          var RotateRight = __webpack_require__(176);
          var PlaceOnRectangle = function(items, rect, shift) {
            if (shift === void 0) {
              shift = 0;
            }
            var points = MarchingAnts(rect, false, items.length);
            if (shift > 0) {
              RotateLeft(points, shift);
            } else if (shift < 0) {
              RotateRight(points, Math.abs(shift));
            }
            for (var i = 0; i < items.length; i++) {
              items[i].x = points[i].x;
              items[i].y = points[i].y;
            }
            return items;
          };
          module2.exports = PlaceOnRectangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BresenhamPoints = __webpack_require__(311);
          var PlaceOnTriangle = function(items, triangle, stepRate) {
            var p1 = BresenhamPoints({x1: triangle.x1, y1: triangle.y1, x2: triangle.x2, y2: triangle.y2}, stepRate);
            var p2 = BresenhamPoints({x1: triangle.x2, y1: triangle.y2, x2: triangle.x3, y2: triangle.y3}, stepRate);
            var p3 = BresenhamPoints({x1: triangle.x3, y1: triangle.y3, x2: triangle.x1, y2: triangle.y1}, stepRate);
            p1.pop();
            p2.pop();
            p3.pop();
            p1 = p1.concat(p2, p3);
            var step = p1.length / items.length;
            var p = 0;
            for (var i = 0; i < items.length; i++) {
              var item = items[i];
              var point = p1[Math.floor(p)];
              item.x = point.x;
              item.y = point.y;
              p += step;
            }
            return items;
          };
          module2.exports = PlaceOnTriangle;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PlayAnimation = function(items, key, startFrame) {
            for (var i = 0; i < items.length; i++) {
              items[i].anims.play(key, startFrame);
            }
            return items;
          };
          module2.exports = PlayAnimation;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Random = __webpack_require__(166);
          var RandomCircle = function(items, circle) {
            for (var i = 0; i < items.length; i++) {
              Random(circle, items[i]);
            }
            return items;
          };
          module2.exports = RandomCircle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Random = __webpack_require__(177);
          var RandomEllipse = function(items, ellipse) {
            for (var i = 0; i < items.length; i++) {
              Random(ellipse, items[i]);
            }
            return items;
          };
          module2.exports = RandomEllipse;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Random = __webpack_require__(169);
          var RandomLine = function(items, line) {
            for (var i = 0; i < items.length; i++) {
              Random(line, items[i]);
            }
            return items;
          };
          module2.exports = RandomLine;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Random = __webpack_require__(170);
          var RandomRectangle = function(items, rect) {
            for (var i = 0; i < items.length; i++) {
              Random(rect, items[i]);
            }
            return items;
          };
          module2.exports = RandomRectangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Random = __webpack_require__(178);
          var RandomTriangle = function(items, triangle) {
            for (var i = 0; i < items.length; i++) {
              Random(triangle, items[i]);
            }
            return items;
          };
          module2.exports = RandomTriangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueInc = __webpack_require__(44);
          var Rotate = function(items, value, step, index, direction) {
            return PropertyValueInc(items, "rotation", value, step, index, direction);
          };
          module2.exports = Rotate;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateAroundDistance = __webpack_require__(179);
          var DistanceBetween = __webpack_require__(48);
          var RotateAround = function(items, point, angle) {
            var x = point.x;
            var y = point.y;
            for (var i = 0; i < items.length; i++) {
              var item = items[i];
              RotateAroundDistance(item, x, y, angle, Math.max(1, DistanceBetween(item.x, item.y, x, y)));
            }
            return items;
          };
          module2.exports = RotateAround;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MathRotateAroundDistance = __webpack_require__(179);
          var RotateAroundDistance = function(items, point, angle, distance) {
            var x = point.x;
            var y = point.y;
            if (distance === 0) {
              return items;
            }
            for (var i = 0; i < items.length; i++) {
              MathRotateAroundDistance(items[i], x, y, angle, distance);
            }
            return items;
          };
          module2.exports = RotateAroundDistance;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueInc = __webpack_require__(44);
          var ScaleX = function(items, value, step, index, direction) {
            return PropertyValueInc(items, "scaleX", value, step, index, direction);
          };
          module2.exports = ScaleX;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueInc = __webpack_require__(44);
          var ScaleXY = function(items, scaleX, scaleY, stepX, stepY, index, direction) {
            if (scaleY === void 0 || scaleY === null) {
              scaleY = scaleX;
            }
            PropertyValueInc(items, "scaleX", scaleX, stepX, index, direction);
            return PropertyValueInc(items, "scaleY", scaleY, stepY, index, direction);
          };
          module2.exports = ScaleXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueInc = __webpack_require__(44);
          var ScaleY = function(items, value, step, index, direction) {
            return PropertyValueInc(items, "scaleY", value, step, index, direction);
          };
          module2.exports = ScaleY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetAlpha = function(items, value, step, index, direction) {
            return PropertyValueSet(items, "alpha", value, step, index, direction);
          };
          module2.exports = SetAlpha;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetBlendMode = function(items, value, index, direction) {
            return PropertyValueSet(items, "blendMode", value, 0, index, direction);
          };
          module2.exports = SetBlendMode;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetDepth = function(items, value, step, index, direction) {
            return PropertyValueSet(items, "depth", value, step, index, direction);
          };
          module2.exports = SetDepth;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetHitArea = function(items, hitArea, hitAreaCallback) {
            for (var i = 0; i < items.length; i++) {
              items[i].setInteractive(hitArea, hitAreaCallback);
            }
            return items;
          };
          module2.exports = SetHitArea;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetOrigin = function(items, originX, originY, stepX, stepY, index, direction) {
            if (originY === void 0 || originY === null) {
              originY = originX;
            }
            PropertyValueSet(items, "originX", originX, stepX, index, direction);
            PropertyValueSet(items, "originY", originY, stepY, index, direction);
            items.forEach(function(item) {
              item.updateDisplayOrigin();
            });
            return items;
          };
          module2.exports = SetOrigin;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetRotation = function(items, value, step, index, direction) {
            return PropertyValueSet(items, "rotation", value, step, index, direction);
          };
          module2.exports = SetRotation;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetScale = function(items, scaleX, scaleY, stepX, stepY, index, direction) {
            if (scaleY === void 0 || scaleY === null) {
              scaleY = scaleX;
            }
            PropertyValueSet(items, "scaleX", scaleX, stepX, index, direction);
            return PropertyValueSet(items, "scaleY", scaleY, stepY, index, direction);
          };
          module2.exports = SetScale;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetScaleX = function(items, value, step, index, direction) {
            return PropertyValueSet(items, "scaleX", value, step, index, direction);
          };
          module2.exports = SetScaleX;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetScaleY = function(items, value, step, index, direction) {
            return PropertyValueSet(items, "scaleY", value, step, index, direction);
          };
          module2.exports = SetScaleY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetScrollFactor = function(items, scrollFactorX, scrollFactorY, stepX, stepY, index, direction) {
            if (scrollFactorY === void 0 || scrollFactorY === null) {
              scrollFactorY = scrollFactorX;
            }
            PropertyValueSet(items, "scrollFactorX", scrollFactorX, stepX, index, direction);
            return PropertyValueSet(items, "scrollFactorY", scrollFactorY, stepY, index, direction);
          };
          module2.exports = SetScrollFactor;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetScrollFactorX = function(items, value, step, index, direction) {
            return PropertyValueSet(items, "scrollFactorX", value, step, index, direction);
          };
          module2.exports = SetScrollFactorX;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetScrollFactorY = function(items, value, step, index, direction) {
            return PropertyValueSet(items, "scrollFactorY", value, step, index, direction);
          };
          module2.exports = SetScrollFactorY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetTint = function(items, topLeft, topRight, bottomLeft, bottomRight) {
            for (var i = 0; i < items.length; i++) {
              items[i].setTint(topLeft, topRight, bottomLeft, bottomRight);
            }
            return items;
          };
          module2.exports = SetTint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetVisible = function(items, value, index, direction) {
            return PropertyValueSet(items, "visible", value, 0, index, direction);
          };
          module2.exports = SetVisible;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetX = function(items, value, step, index, direction) {
            return PropertyValueSet(items, "x", value, step, index, direction);
          };
          module2.exports = SetX;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetXY = function(items, x, y, stepX, stepY, index, direction) {
            if (y === void 0 || y === null) {
              y = x;
            }
            PropertyValueSet(items, "x", x, stepX, index, direction);
            return PropertyValueSet(items, "y", y, stepY, index, direction);
          };
          module2.exports = SetXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PropertyValueSet = __webpack_require__(27);
          var SetY = function(items, value, step, index, direction) {
            return PropertyValueSet(items, "y", value, step, index, direction);
          };
          module2.exports = SetY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector29 = __webpack_require__(3);
          var ShiftPosition = function(items, x, y, direction, output) {
            if (direction === void 0) {
              direction = 0;
            }
            if (output === void 0) {
              output = new Vector29();
            }
            var px;
            var py;
            if (items.length > 1) {
              var i;
              var cx;
              var cy;
              var cur;
              if (direction === 0) {
                var len = items.length - 1;
                px = items[len].x;
                py = items[len].y;
                for (i = len - 1; i >= 0; i--) {
                  cur = items[i];
                  cx = cur.x;
                  cy = cur.y;
                  cur.x = px;
                  cur.y = py;
                  px = cx;
                  py = cy;
                }
                items[len].x = x;
                items[len].y = y;
              } else {
                px = items[0].x;
                py = items[0].y;
                for (i = 1; i < items.length; i++) {
                  cur = items[i];
                  cx = cur.x;
                  cy = cur.y;
                  cur.x = px;
                  cur.y = py;
                  px = cx;
                  py = cy;
                }
                items[0].x = x;
                items[0].y = y;
              }
            } else {
              px = items[0].x;
              py = items[0].y;
              items[0].x = x;
              items[0].y = y;
            }
            output.x = px;
            output.y = py;
            return output;
          };
          module2.exports = ShiftPosition;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ArrayShuffle = __webpack_require__(129);
          var Shuffle = function(items) {
            return ArrayShuffle(items);
          };
          module2.exports = Shuffle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MathSmootherStep = __webpack_require__(180);
          var SmootherStep = function(items, property, min, max, inc) {
            if (inc === void 0) {
              inc = false;
            }
            var step = Math.abs(max - min) / items.length;
            var i;
            if (inc) {
              for (i = 0; i < items.length; i++) {
                items[i][property] += MathSmootherStep(i * step, min, max);
              }
            } else {
              for (i = 0; i < items.length; i++) {
                items[i][property] = MathSmootherStep(i * step, min, max);
              }
            }
            return items;
          };
          module2.exports = SmootherStep;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MathSmoothStep = __webpack_require__(181);
          var SmoothStep = function(items, property, min, max, inc) {
            if (inc === void 0) {
              inc = false;
            }
            var step = Math.abs(max - min) / items.length;
            var i;
            if (inc) {
              for (i = 0; i < items.length; i++) {
                items[i][property] += MathSmoothStep(i * step, min, max);
              }
            } else {
              for (i = 0; i < items.length; i++) {
                items[i][property] = MathSmoothStep(i * step, min, max);
              }
            }
            return items;
          };
          module2.exports = SmoothStep;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Spread = function(items, property, min, max, inc) {
            if (inc === void 0) {
              inc = false;
            }
            var step = Math.abs(max - min) / items.length;
            var i;
            if (inc) {
              for (i = 0; i < items.length; i++) {
                items[i][property] += i * step + min;
              }
            } else {
              for (i = 0; i < items.length; i++) {
                items[i][property] = i * step + min;
              }
            }
            return items;
          };
          module2.exports = Spread;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ToggleVisible = function(items) {
            for (var i = 0; i < items.length; i++) {
              items[i].visible = !items[i].visible;
            }
            return items;
          };
          module2.exports = ToggleVisible;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       samme <samme.npm@gmail.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Wrap = __webpack_require__(66);
          var WrapInRectangle = function(items, rect, padding) {
            if (padding === void 0) {
              padding = 0;
            }
            for (var i = 0; i < items.length; i++) {
              var item = items[i];
              item.x = Wrap(item.x, rect.left - padding, rect.right + padding);
              item.y = Wrap(item.y, rect.top - padding, rect.bottom + padding);
            }
            return items;
          };
          module2.exports = WrapInRectangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Animation: __webpack_require__(182),
            AnimationFrame: __webpack_require__(313),
            AnimationManager: __webpack_require__(315),
            AnimationState: __webpack_require__(162),
            Events: __webpack_require__(130)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "add";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "animationcomplete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "animationcomplete-";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "animationrepeat";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "animationrestart";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "animationstart";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "animationstop";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "animationupdate";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pauseall";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "remove";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "resumeall";
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            BaseCache: __webpack_require__(317),
            CacheManager: __webpack_require__(319),
            Events: __webpack_require__(318)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "add";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "remove";
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Controls: __webpack_require__(715),
            Scene2D: __webpack_require__(718)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            FixedKeyControl: __webpack_require__(716),
            SmoothedKeyControl: __webpack_require__(717)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetValue = __webpack_require__(6);
          var FixedKeyControl = new Class({
            initialize: function FixedKeyControl2(config2) {
              this.camera = GetValue(config2, "camera", null);
              this.left = GetValue(config2, "left", null);
              this.right = GetValue(config2, "right", null);
              this.up = GetValue(config2, "up", null);
              this.down = GetValue(config2, "down", null);
              this.zoomIn = GetValue(config2, "zoomIn", null);
              this.zoomOut = GetValue(config2, "zoomOut", null);
              this.zoomSpeed = GetValue(config2, "zoomSpeed", 0.01);
              this.speedX = 0;
              this.speedY = 0;
              var speed = GetValue(config2, "speed", null);
              if (typeof speed === "number") {
                this.speedX = speed;
                this.speedY = speed;
              } else {
                this.speedX = GetValue(config2, "speed.x", 0);
                this.speedY = GetValue(config2, "speed.y", 0);
              }
              this._zoom = 0;
              this.active = this.camera !== null;
            },
            start: function() {
              this.active = this.camera !== null;
              return this;
            },
            stop: function() {
              this.active = false;
              return this;
            },
            setCamera: function(camera) {
              this.camera = camera;
              return this;
            },
            update: function(delta) {
              if (!this.active) {
                return;
              }
              if (delta === void 0) {
                delta = 1;
              }
              var cam = this.camera;
              if (this.up && this.up.isDown) {
                cam.scrollY -= this.speedY * delta | 0;
              } else if (this.down && this.down.isDown) {
                cam.scrollY += this.speedY * delta | 0;
              }
              if (this.left && this.left.isDown) {
                cam.scrollX -= this.speedX * delta | 0;
              } else if (this.right && this.right.isDown) {
                cam.scrollX += this.speedX * delta | 0;
              }
              if (this.zoomIn && this.zoomIn.isDown) {
                cam.zoom -= this.zoomSpeed;
                if (cam.zoom < 0.1) {
                  cam.zoom = 0.1;
                }
              } else if (this.zoomOut && this.zoomOut.isDown) {
                cam.zoom += this.zoomSpeed;
              }
            },
            destroy: function() {
              this.camera = null;
              this.left = null;
              this.right = null;
              this.up = null;
              this.down = null;
              this.zoomIn = null;
              this.zoomOut = null;
            }
          });
          module2.exports = FixedKeyControl;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var GetValue = __webpack_require__(6);
          var SmoothedKeyControl = new Class({
            initialize: function SmoothedKeyControl2(config2) {
              this.camera = GetValue(config2, "camera", null);
              this.left = GetValue(config2, "left", null);
              this.right = GetValue(config2, "right", null);
              this.up = GetValue(config2, "up", null);
              this.down = GetValue(config2, "down", null);
              this.zoomIn = GetValue(config2, "zoomIn", null);
              this.zoomOut = GetValue(config2, "zoomOut", null);
              this.zoomSpeed = GetValue(config2, "zoomSpeed", 0.01);
              this.accelX = 0;
              this.accelY = 0;
              var accel = GetValue(config2, "acceleration", null);
              if (typeof accel === "number") {
                this.accelX = accel;
                this.accelY = accel;
              } else {
                this.accelX = GetValue(config2, "acceleration.x", 0);
                this.accelY = GetValue(config2, "acceleration.y", 0);
              }
              this.dragX = 0;
              this.dragY = 0;
              var drag = GetValue(config2, "drag", null);
              if (typeof drag === "number") {
                this.dragX = drag;
                this.dragY = drag;
              } else {
                this.dragX = GetValue(config2, "drag.x", 0);
                this.dragY = GetValue(config2, "drag.y", 0);
              }
              this.maxSpeedX = 0;
              this.maxSpeedY = 0;
              var maxSpeed = GetValue(config2, "maxSpeed", null);
              if (typeof maxSpeed === "number") {
                this.maxSpeedX = maxSpeed;
                this.maxSpeedY = maxSpeed;
              } else {
                this.maxSpeedX = GetValue(config2, "maxSpeed.x", 0);
                this.maxSpeedY = GetValue(config2, "maxSpeed.y", 0);
              }
              this._speedX = 0;
              this._speedY = 0;
              this._zoom = 0;
              this.active = this.camera !== null;
            },
            start: function() {
              this.active = this.camera !== null;
              return this;
            },
            stop: function() {
              this.active = false;
              return this;
            },
            setCamera: function(camera) {
              this.camera = camera;
              return this;
            },
            update: function(delta) {
              if (!this.active) {
                return;
              }
              if (delta === void 0) {
                delta = 1;
              }
              var cam = this.camera;
              if (this._speedX > 0) {
                this._speedX -= this.dragX * delta;
                if (this._speedX < 0) {
                  this._speedX = 0;
                }
              } else if (this._speedX < 0) {
                this._speedX += this.dragX * delta;
                if (this._speedX > 0) {
                  this._speedX = 0;
                }
              }
              if (this._speedY > 0) {
                this._speedY -= this.dragY * delta;
                if (this._speedY < 0) {
                  this._speedY = 0;
                }
              } else if (this._speedY < 0) {
                this._speedY += this.dragY * delta;
                if (this._speedY > 0) {
                  this._speedY = 0;
                }
              }
              if (this.up && this.up.isDown) {
                this._speedY += this.accelY;
                if (this._speedY > this.maxSpeedY) {
                  this._speedY = this.maxSpeedY;
                }
              } else if (this.down && this.down.isDown) {
                this._speedY -= this.accelY;
                if (this._speedY < -this.maxSpeedY) {
                  this._speedY = -this.maxSpeedY;
                }
              }
              if (this.left && this.left.isDown) {
                this._speedX += this.accelX;
                if (this._speedX > this.maxSpeedX) {
                  this._speedX = this.maxSpeedX;
                }
              } else if (this.right && this.right.isDown) {
                this._speedX -= this.accelX;
                if (this._speedX < -this.maxSpeedX) {
                  this._speedX = -this.maxSpeedX;
                }
              }
              if (this.zoomIn && this.zoomIn.isDown) {
                this._zoom = -this.zoomSpeed;
              } else if (this.zoomOut && this.zoomOut.isDown) {
                this._zoom = this.zoomSpeed;
              } else {
                this._zoom = 0;
              }
              if (this._speedX !== 0) {
                cam.scrollX -= this._speedX * delta | 0;
              }
              if (this._speedY !== 0) {
                cam.scrollY -= this._speedY * delta | 0;
              }
              if (this._zoom !== 0) {
                cam.zoom += this._zoom;
                if (cam.zoom < 1e-3) {
                  cam.zoom = 1e-3;
                }
              }
            },
            destroy: function() {
              this.camera = null;
              this.left = null;
              this.right = null;
              this.up = null;
              this.down = null;
              this.zoomIn = null;
              this.zoomOut = null;
            }
          });
          module2.exports = SmoothedKeyControl;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Camera: __webpack_require__(320),
            BaseCamera: __webpack_require__(131),
            CameraManager: __webpack_require__(775),
            Effects: __webpack_require__(327),
            Events: __webpack_require__(36)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "cameradestroy";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "camerafadeincomplete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "camerafadeinstart";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "camerafadeoutcomplete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "camerafadeoutstart";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "cameraflashcomplete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "cameraflashstart";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "followupdate";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "camerapancomplete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "camerapanstart";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "postrender";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "prerender";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "camerarotatecomplete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "camerarotatestart";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "camerashakecomplete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "camerashakestart";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "camerazoomcomplete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "camerazoomstart";
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(36);
          var Fade = new Class({
            initialize: function Fade2(camera) {
              this.camera = camera;
              this.isRunning = false;
              this.isComplete = false;
              this.direction = true;
              this.duration = 0;
              this.red = 0;
              this.green = 0;
              this.blue = 0;
              this.alpha = 0;
              this.progress = 0;
              this._elapsed = 0;
              this._onUpdate;
              this._onUpdateScope;
            },
            start: function(direction, duration, red, green, blue, force, callback, context) {
              if (direction === void 0) {
                direction = true;
              }
              if (duration === void 0) {
                duration = 1e3;
              }
              if (red === void 0) {
                red = 0;
              }
              if (green === void 0) {
                green = 0;
              }
              if (blue === void 0) {
                blue = 0;
              }
              if (force === void 0) {
                force = false;
              }
              if (callback === void 0) {
                callback = null;
              }
              if (context === void 0) {
                context = this.camera.scene;
              }
              if (!force && this.isRunning) {
                return this.camera;
              }
              this.isRunning = true;
              this.isComplete = false;
              this.duration = duration;
              this.direction = direction;
              this.progress = 0;
              this.red = red;
              this.green = green;
              this.blue = blue;
              this.alpha = direction ? Number.MIN_VALUE : 1;
              this._elapsed = 0;
              this._onUpdate = callback;
              this._onUpdateScope = context;
              var eventName = direction ? Events.FADE_OUT_START : Events.FADE_IN_START;
              this.camera.emit(eventName, this.camera, this, duration, red, green, blue);
              return this.camera;
            },
            update: function(time, delta) {
              if (!this.isRunning) {
                return;
              }
              this._elapsed += delta;
              this.progress = Clamp(this._elapsed / this.duration, 0, 1);
              if (this._onUpdate) {
                this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
              }
              if (this._elapsed < this.duration) {
                this.alpha = this.direction ? this.progress : 1 - this.progress;
              } else {
                this.alpha = this.direction ? 1 : 0;
                this.effectComplete();
              }
            },
            postRenderCanvas: function(ctx) {
              if (!this.isRunning && !this.isComplete) {
                return false;
              }
              var camera = this.camera;
              ctx.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
              ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
              return true;
            },
            postRenderWebGL: function(pipeline, getTintFunction) {
              if (!this.isRunning && !this.isComplete) {
                return false;
              }
              var camera = this.camera;
              var red = this.red / 255;
              var green = this.green / 255;
              var blue = this.blue / 255;
              pipeline.drawFillRect(camera.x, camera.y, camera.width, camera.height, getTintFunction(blue, green, red, 1), this.alpha);
              return true;
            },
            effectComplete: function() {
              this._onUpdate = null;
              this._onUpdateScope = null;
              this.isRunning = false;
              this.isComplete = true;
              var eventName = this.direction ? Events.FADE_OUT_COMPLETE : Events.FADE_IN_COMPLETE;
              this.camera.emit(eventName, this.camera, this);
            },
            reset: function() {
              this.isRunning = false;
              this.isComplete = false;
              this._onUpdate = null;
              this._onUpdateScope = null;
            },
            destroy: function() {
              this.reset();
              this.camera = null;
            }
          });
          module2.exports = Fade;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(36);
          var Flash = new Class({
            initialize: function Flash2(camera) {
              this.camera = camera;
              this.isRunning = false;
              this.duration = 0;
              this.red = 0;
              this.green = 0;
              this.blue = 0;
              this.alpha = 0;
              this.progress = 0;
              this._elapsed = 0;
              this._onUpdate;
              this._onUpdateScope;
            },
            start: function(duration, red, green, blue, force, callback, context) {
              if (duration === void 0) {
                duration = 250;
              }
              if (red === void 0) {
                red = 255;
              }
              if (green === void 0) {
                green = 255;
              }
              if (blue === void 0) {
                blue = 255;
              }
              if (force === void 0) {
                force = false;
              }
              if (callback === void 0) {
                callback = null;
              }
              if (context === void 0) {
                context = this.camera.scene;
              }
              if (!force && this.isRunning) {
                return this.camera;
              }
              this.isRunning = true;
              this.duration = duration;
              this.progress = 0;
              this.red = red;
              this.green = green;
              this.blue = blue;
              this.alpha = 1;
              this._elapsed = 0;
              this._onUpdate = callback;
              this._onUpdateScope = context;
              this.camera.emit(Events.FLASH_START, this.camera, this, duration, red, green, blue);
              return this.camera;
            },
            update: function(time, delta) {
              if (!this.isRunning) {
                return;
              }
              this._elapsed += delta;
              this.progress = Clamp(this._elapsed / this.duration, 0, 1);
              if (this._onUpdate) {
                this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
              }
              if (this._elapsed < this.duration) {
                this.alpha = 1 - this.progress;
              } else {
                this.effectComplete();
              }
            },
            postRenderCanvas: function(ctx) {
              if (!this.isRunning) {
                return false;
              }
              var camera = this.camera;
              ctx.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
              ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
              return true;
            },
            postRenderWebGL: function(pipeline, getTintFunction) {
              if (!this.isRunning) {
                return false;
              }
              var camera = this.camera;
              var red = this.red / 255;
              var green = this.green / 255;
              var blue = this.blue / 255;
              pipeline.drawFillRect(camera.x, camera.y, camera.width, camera.height, getTintFunction(blue, green, red, 1), this.alpha);
              return true;
            },
            effectComplete: function() {
              this._onUpdate = null;
              this._onUpdateScope = null;
              this.isRunning = false;
              this.camera.emit(Events.FLASH_COMPLETE, this.camera, this);
            },
            reset: function() {
              this.isRunning = false;
              this._onUpdate = null;
              this._onUpdateScope = null;
            },
            destroy: function() {
              this.reset();
              this.camera = null;
            }
          });
          module2.exports = Flash;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var EaseMap = __webpack_require__(132);
          var Events = __webpack_require__(36);
          var Vector29 = __webpack_require__(3);
          var Pan = new Class({
            initialize: function Pan2(camera) {
              this.camera = camera;
              this.isRunning = false;
              this.duration = 0;
              this.source = new Vector29();
              this.current = new Vector29();
              this.destination = new Vector29();
              this.ease;
              this.progress = 0;
              this._elapsed = 0;
              this._onUpdate;
              this._onUpdateScope;
            },
            start: function(x, y, duration, ease, force, callback, context) {
              if (duration === void 0) {
                duration = 1e3;
              }
              if (ease === void 0) {
                ease = EaseMap.Linear;
              }
              if (force === void 0) {
                force = false;
              }
              if (callback === void 0) {
                callback = null;
              }
              if (context === void 0) {
                context = this.camera.scene;
              }
              var cam = this.camera;
              if (!force && this.isRunning) {
                return cam;
              }
              this.isRunning = true;
              this.duration = duration;
              this.progress = 0;
              this.source.set(cam.scrollX, cam.scrollY);
              this.destination.set(x, y);
              cam.getScroll(x, y, this.current);
              if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
                this.ease = EaseMap[ease];
              } else if (typeof ease === "function") {
                this.ease = ease;
              }
              this._elapsed = 0;
              this._onUpdate = callback;
              this._onUpdateScope = context;
              this.camera.emit(Events.PAN_START, this.camera, this, duration, x, y);
              return cam;
            },
            update: function(time, delta) {
              if (!this.isRunning) {
                return;
              }
              this._elapsed += delta;
              var progress = Clamp(this._elapsed / this.duration, 0, 1);
              this.progress = progress;
              var cam = this.camera;
              if (this._elapsed < this.duration) {
                var v = this.ease(progress);
                cam.getScroll(this.destination.x, this.destination.y, this.current);
                var x = this.source.x + (this.current.x - this.source.x) * v;
                var y = this.source.y + (this.current.y - this.source.y) * v;
                cam.setScroll(x, y);
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, cam, progress, x, y);
                }
              } else {
                cam.centerOn(this.destination.x, this.destination.y);
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, cam, progress, cam.scrollX, cam.scrollY);
                }
                this.effectComplete();
              }
            },
            effectComplete: function() {
              this._onUpdate = null;
              this._onUpdateScope = null;
              this.isRunning = false;
              this.camera.emit(Events.PAN_COMPLETE, this.camera, this);
            },
            reset: function() {
              this.isRunning = false;
              this._onUpdate = null;
              this._onUpdateScope = null;
            },
            destroy: function() {
              this.reset();
              this.camera = null;
              this.source = null;
              this.destination = null;
            }
          });
          module2.exports = Pan;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var In = function(v, overshoot) {
            if (overshoot === void 0) {
              overshoot = 1.70158;
            }
            return v * v * ((overshoot + 1) * v - overshoot);
          };
          module2.exports = In;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Out = function(v, overshoot) {
            if (overshoot === void 0) {
              overshoot = 1.70158;
            }
            return --v * v * ((overshoot + 1) * v + overshoot) + 1;
          };
          module2.exports = Out;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var InOut = function(v, overshoot) {
            if (overshoot === void 0) {
              overshoot = 1.70158;
            }
            var s = overshoot * 1.525;
            if ((v *= 2) < 1) {
              return 0.5 * (v * v * ((s + 1) * v - s));
            } else {
              return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);
            }
          };
          module2.exports = InOut;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var In = function(v) {
            v = 1 - v;
            if (v < 1 / 2.75) {
              return 1 - 7.5625 * v * v;
            } else if (v < 2 / 2.75) {
              return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);
            } else if (v < 2.5 / 2.75) {
              return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);
            } else {
              return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);
            }
          };
          module2.exports = In;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Out = function(v) {
            if (v < 1 / 2.75) {
              return 7.5625 * v * v;
            } else if (v < 2 / 2.75) {
              return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
            } else if (v < 2.5 / 2.75) {
              return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
            } else {
              return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
            }
          };
          module2.exports = Out;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var InOut = function(v) {
            var reverse = false;
            if (v < 0.5) {
              v = 1 - v * 2;
              reverse = true;
            } else {
              v = v * 2 - 1;
            }
            if (v < 1 / 2.75) {
              v = 7.5625 * v * v;
            } else if (v < 2 / 2.75) {
              v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
            } else if (v < 2.5 / 2.75) {
              v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
            } else {
              v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
            }
            if (reverse) {
              return (1 - v) * 0.5;
            } else {
              return v * 0.5 + 0.5;
            }
          };
          module2.exports = InOut;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var In = function(v) {
            return 1 - Math.sqrt(1 - v * v);
          };
          module2.exports = In;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Out = function(v) {
            return Math.sqrt(1 - --v * v);
          };
          module2.exports = Out;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var InOut = function(v) {
            if ((v *= 2) < 1) {
              return -0.5 * (Math.sqrt(1 - v * v) - 1);
            } else {
              return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);
            }
          };
          module2.exports = InOut;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var In = function(v) {
            return v * v * v;
          };
          module2.exports = In;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Out = function(v) {
            return --v * v * v + 1;
          };
          module2.exports = Out;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var InOut = function(v) {
            if ((v *= 2) < 1) {
              return 0.5 * v * v * v;
            } else {
              return 0.5 * ((v -= 2) * v * v + 2);
            }
          };
          module2.exports = InOut;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var In = function(v, amplitude, period) {
            if (amplitude === void 0) {
              amplitude = 0.1;
            }
            if (period === void 0) {
              period = 0.1;
            }
            if (v === 0) {
              return 0;
            } else if (v === 1) {
              return 1;
            } else {
              var s = period / 4;
              if (amplitude < 1) {
                amplitude = 1;
              } else {
                s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
              }
              return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
            }
          };
          module2.exports = In;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Out = function(v, amplitude, period) {
            if (amplitude === void 0) {
              amplitude = 0.1;
            }
            if (period === void 0) {
              period = 0.1;
            }
            if (v === 0) {
              return 0;
            } else if (v === 1) {
              return 1;
            } else {
              var s = period / 4;
              if (amplitude < 1) {
                amplitude = 1;
              } else {
                s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
              }
              return amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1;
            }
          };
          module2.exports = Out;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var InOut = function(v, amplitude, period) {
            if (amplitude === void 0) {
              amplitude = 0.1;
            }
            if (period === void 0) {
              period = 0.1;
            }
            if (v === 0) {
              return 0;
            } else if (v === 1) {
              return 1;
            } else {
              var s = period / 4;
              if (amplitude < 1) {
                amplitude = 1;
              } else {
                s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
              }
              if ((v *= 2) < 1) {
                return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
              } else {
                return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;
              }
            }
          };
          module2.exports = InOut;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var In = function(v) {
            return Math.pow(2, 10 * (v - 1)) - 1e-3;
          };
          module2.exports = In;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Out = function(v) {
            return 1 - Math.pow(2, -10 * v);
          };
          module2.exports = Out;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var InOut = function(v) {
            if ((v *= 2) < 1) {
              return 0.5 * Math.pow(2, 10 * (v - 1));
            } else {
              return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));
            }
          };
          module2.exports = InOut;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Linear = function(v) {
            return v;
          };
          module2.exports = Linear;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var In = function(v) {
            return v * v;
          };
          module2.exports = In;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Out = function(v) {
            return v * (2 - v);
          };
          module2.exports = Out;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var InOut = function(v) {
            if ((v *= 2) < 1) {
              return 0.5 * v * v;
            } else {
              return -0.5 * (--v * (v - 2) - 1);
            }
          };
          module2.exports = InOut;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var In = function(v) {
            return v * v * v * v;
          };
          module2.exports = In;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Out = function(v) {
            return 1 - --v * v * v * v;
          };
          module2.exports = Out;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var InOut = function(v) {
            if ((v *= 2) < 1) {
              return 0.5 * v * v * v * v;
            } else {
              return -0.5 * ((v -= 2) * v * v * v - 2);
            }
          };
          module2.exports = InOut;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var In = function(v) {
            return v * v * v * v * v;
          };
          module2.exports = In;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Out = function(v) {
            return --v * v * v * v * v + 1;
          };
          module2.exports = Out;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var InOut = function(v) {
            if ((v *= 2) < 1) {
              return 0.5 * v * v * v * v * v;
            } else {
              return 0.5 * ((v -= 2) * v * v * v * v + 2);
            }
          };
          module2.exports = InOut;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var In = function(v) {
            if (v === 0) {
              return 0;
            } else if (v === 1) {
              return 1;
            } else {
              return 1 - Math.cos(v * Math.PI / 2);
            }
          };
          module2.exports = In;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Out = function(v) {
            if (v === 0) {
              return 0;
            } else if (v === 1) {
              return 1;
            } else {
              return Math.sin(v * Math.PI / 2);
            }
          };
          module2.exports = Out;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var InOut = function(v) {
            if (v === 0) {
              return 0;
            } else if (v === 1) {
              return 1;
            } else {
              return 0.5 * (1 - Math.cos(Math.PI * v));
            }
          };
          module2.exports = InOut;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Stepped = function(v, steps) {
            if (steps === void 0) {
              steps = 1;
            }
            if (v <= 0) {
              return 0;
            } else if (v >= 1) {
              return 1;
            } else {
              return ((steps * v | 0) + 1) * (1 / steps);
            }
          };
          module2.exports = Stepped;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(36);
          var Vector29 = __webpack_require__(3);
          var Shake = new Class({
            initialize: function Shake2(camera) {
              this.camera = camera;
              this.isRunning = false;
              this.duration = 0;
              this.intensity = new Vector29();
              this.progress = 0;
              this._elapsed = 0;
              this._offsetX = 0;
              this._offsetY = 0;
              this._onUpdate;
              this._onUpdateScope;
            },
            start: function(duration, intensity, force, callback, context) {
              if (duration === void 0) {
                duration = 100;
              }
              if (intensity === void 0) {
                intensity = 0.05;
              }
              if (force === void 0) {
                force = false;
              }
              if (callback === void 0) {
                callback = null;
              }
              if (context === void 0) {
                context = this.camera.scene;
              }
              if (!force && this.isRunning) {
                return this.camera;
              }
              this.isRunning = true;
              this.duration = duration;
              this.progress = 0;
              if (typeof intensity === "number") {
                this.intensity.set(intensity);
              } else {
                this.intensity.set(intensity.x, intensity.y);
              }
              this._elapsed = 0;
              this._offsetX = 0;
              this._offsetY = 0;
              this._onUpdate = callback;
              this._onUpdateScope = context;
              this.camera.emit(Events.SHAKE_START, this.camera, this, duration, intensity);
              return this.camera;
            },
            preRender: function() {
              if (this.isRunning) {
                this.camera.matrix.translate(this._offsetX, this._offsetY);
              }
            },
            update: function(time, delta) {
              if (!this.isRunning) {
                return;
              }
              this._elapsed += delta;
              this.progress = Clamp(this._elapsed / this.duration, 0, 1);
              if (this._onUpdate) {
                this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
              }
              if (this._elapsed < this.duration) {
                var intensity = this.intensity;
                var width = this.camera.width;
                var height = this.camera.height;
                var zoom = this.camera.zoom;
                this._offsetX = (Math.random() * intensity.x * width * 2 - intensity.x * width) * zoom;
                this._offsetY = (Math.random() * intensity.y * height * 2 - intensity.y * height) * zoom;
                if (this.camera.roundPixels) {
                  this._offsetX = Math.round(this._offsetX);
                  this._offsetY = Math.round(this._offsetY);
                }
              } else {
                this.effectComplete();
              }
            },
            effectComplete: function() {
              this._offsetX = 0;
              this._offsetY = 0;
              this._onUpdate = null;
              this._onUpdateScope = null;
              this.isRunning = false;
              this.camera.emit(Events.SHAKE_COMPLETE, this.camera, this);
            },
            reset: function() {
              this.isRunning = false;
              this._offsetX = 0;
              this._offsetY = 0;
              this._onUpdate = null;
              this._onUpdateScope = null;
            },
            destroy: function() {
              this.reset();
              this.camera = null;
              this.intensity = null;
            }
          });
          module2.exports = Shake;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Jason Nicholls <nicholls.jason@gmail.com>
           * @copyright    2018 Photon Storm Ltd.
           * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
           */
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(36);
          var EaseMap = __webpack_require__(132);
          var RotateTo = new Class({
            initialize: function RotateTo2(camera) {
              this.camera = camera;
              this.isRunning = false;
              this.duration = 0;
              this.source = 0;
              this.current = 0;
              this.destination = 0;
              this.ease;
              this.progress = 0;
              this._elapsed = 0;
              this._onUpdate;
              this._onUpdateScope;
              this.clockwise = true;
              this.shortestPath = false;
            },
            start: function(radians, shortestPath, duration, ease, force, callback, context) {
              if (duration === void 0) {
                duration = 1e3;
              }
              if (ease === void 0) {
                ease = EaseMap.Linear;
              }
              if (force === void 0) {
                force = false;
              }
              if (callback === void 0) {
                callback = null;
              }
              if (context === void 0) {
                context = this.camera.scene;
              }
              if (shortestPath === void 0) {
                shortestPath = false;
              }
              this.shortestPath = shortestPath;
              var tmpDestination = radians;
              if (radians < 0) {
                tmpDestination = -1 * radians;
                this.clockwise = false;
              } else {
                this.clockwise = true;
              }
              var maxRad = 360 * Math.PI / 180;
              tmpDestination = tmpDestination - Math.floor(tmpDestination / maxRad) * maxRad;
              var cam = this.camera;
              if (!force && this.isRunning) {
                return cam;
              }
              this.isRunning = true;
              this.duration = duration;
              this.progress = 0;
              this.source = cam.rotation;
              this.destination = tmpDestination;
              if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
                this.ease = EaseMap[ease];
              } else if (typeof ease === "function") {
                this.ease = ease;
              }
              this._elapsed = 0;
              this._onUpdate = callback;
              this._onUpdateScope = context;
              if (this.shortestPath) {
                var cwDist = 0;
                var acwDist = 0;
                if (this.destination > this.source) {
                  cwDist = Math.abs(this.destination - this.source);
                } else {
                  cwDist = Math.abs(this.destination + maxRad) - this.source;
                }
                if (this.source > this.destination) {
                  acwDist = Math.abs(this.source - this.destination);
                } else {
                  acwDist = Math.abs(this.source + maxRad) - this.destination;
                }
                if (cwDist < acwDist) {
                  this.clockwise = true;
                } else if (cwDist > acwDist) {
                  this.clockwise = false;
                }
              }
              this.camera.emit(Events.ROTATE_START, this.camera, this, duration, tmpDestination);
              return cam;
            },
            update: function(time, delta) {
              if (!this.isRunning) {
                return;
              }
              this._elapsed += delta;
              var progress = Clamp(this._elapsed / this.duration, 0, 1);
              this.progress = progress;
              var cam = this.camera;
              if (this._elapsed < this.duration) {
                var v = this.ease(progress);
                this.current = cam.rotation;
                var distance = 0;
                var maxRad = 360 * Math.PI / 180;
                var target = this.destination;
                var current = this.current;
                if (this.clockwise === false) {
                  target = this.current;
                  current = this.destination;
                }
                if (target >= current) {
                  distance = Math.abs(target - current);
                } else {
                  distance = Math.abs(target + maxRad) - current;
                }
                var r = 0;
                if (this.clockwise) {
                  r = cam.rotation + distance * v;
                } else {
                  r = cam.rotation - distance * v;
                }
                cam.rotation = r;
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, cam, progress, r);
                }
              } else {
                cam.rotation = this.destination;
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, cam, progress, this.destination);
                }
                this.effectComplete();
              }
            },
            effectComplete: function() {
              this._onUpdate = null;
              this._onUpdateScope = null;
              this.isRunning = false;
              this.camera.emit(Events.ROTATE_COMPLETE, this.camera, this);
            },
            reset: function() {
              this.isRunning = false;
              this._onUpdate = null;
              this._onUpdateScope = null;
            },
            destroy: function() {
              this.reset();
              this.camera = null;
              this.source = null;
              this.destination = null;
            }
          });
          module2.exports = RotateTo;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var EaseMap = __webpack_require__(132);
          var Events = __webpack_require__(36);
          var Zoom = new Class({
            initialize: function Zoom2(camera) {
              this.camera = camera;
              this.isRunning = false;
              this.duration = 0;
              this.source = 1;
              this.destination = 1;
              this.ease;
              this.progress = 0;
              this._elapsed = 0;
              this._onUpdate;
              this._onUpdateScope;
            },
            start: function(zoom, duration, ease, force, callback, context) {
              if (duration === void 0) {
                duration = 1e3;
              }
              if (ease === void 0) {
                ease = EaseMap.Linear;
              }
              if (force === void 0) {
                force = false;
              }
              if (callback === void 0) {
                callback = null;
              }
              if (context === void 0) {
                context = this.camera.scene;
              }
              var cam = this.camera;
              if (!force && this.isRunning) {
                return cam;
              }
              this.isRunning = true;
              this.duration = duration;
              this.progress = 0;
              this.source = cam.zoom;
              this.destination = zoom;
              if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
                this.ease = EaseMap[ease];
              } else if (typeof ease === "function") {
                this.ease = ease;
              }
              this._elapsed = 0;
              this._onUpdate = callback;
              this._onUpdateScope = context;
              this.camera.emit(Events.ZOOM_START, this.camera, this, duration, zoom);
              return cam;
            },
            update: function(time, delta) {
              if (!this.isRunning) {
                return;
              }
              this._elapsed += delta;
              this.progress = Clamp(this._elapsed / this.duration, 0, 1);
              if (this._elapsed < this.duration) {
                this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress);
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom);
                }
              } else {
                this.camera.zoom = this.destination;
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination);
                }
                this.effectComplete();
              }
            },
            effectComplete: function() {
              this._onUpdate = null;
              this._onUpdateScope = null;
              this.isRunning = false;
              this.camera.emit(Events.ZOOM_COMPLETE, this.camera, this);
            },
            reset: function() {
              this.isRunning = false;
              this._onUpdate = null;
              this._onUpdateScope = null;
            },
            destroy: function() {
              this.reset();
              this.camera = null;
            }
          });
          module2.exports = Zoom;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Camera = __webpack_require__(320);
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var PluginCache = __webpack_require__(24);
          var RectangleContains = __webpack_require__(56);
          var ScaleEvents = __webpack_require__(101);
          var SceneEvents = __webpack_require__(21);
          var CameraManager = new Class({
            initialize: function CameraManager2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.roundPixels = scene.sys.game.config.roundPixels;
              this.cameras = [];
              this.main;
              this.default;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function() {
              var sys = this.systems;
              if (sys.settings.cameras) {
                this.fromJSON(sys.settings.cameras);
              } else {
                this.add();
              }
              this.main = this.cameras[0];
              this.default = new Camera(0, 0, sys.scale.width, sys.scale.height).setScene(this.scene);
              sys.game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function() {
              if (!this.main) {
                var sys = this.systems;
                if (sys.settings.cameras) {
                  this.fromJSON(sys.settings.cameras);
                } else {
                  this.add();
                }
                this.main = this.cameras[0];
              }
              var eventEmitter = this.systems.events;
              eventEmitter.on(SceneEvents.UPDATE, this.update, this);
              eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            add: function(x, y, width, height, makeMain, name) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = this.scene.sys.scale.width;
              }
              if (height === void 0) {
                height = this.scene.sys.scale.height;
              }
              if (makeMain === void 0) {
                makeMain = false;
              }
              if (name === void 0) {
                name = "";
              }
              var camera = new Camera(x, y, width, height);
              camera.setName(name);
              camera.setScene(this.scene);
              camera.setRoundPixels(this.roundPixels);
              camera.id = this.getNextID();
              this.cameras.push(camera);
              if (makeMain) {
                this.main = camera;
              }
              return camera;
            },
            addExisting: function(camera, makeMain) {
              if (makeMain === void 0) {
                makeMain = false;
              }
              var index = this.cameras.indexOf(camera);
              if (index === -1) {
                camera.id = this.getNextID();
                camera.setRoundPixels(this.roundPixels);
                this.cameras.push(camera);
                if (makeMain) {
                  this.main = camera;
                }
                return camera;
              }
              return null;
            },
            getNextID: function() {
              var cameras = this.cameras;
              var testID = 1;
              for (var t = 0; t < 32; t++) {
                var found = false;
                for (var i = 0; i < cameras.length; i++) {
                  var camera = cameras[i];
                  if (camera && camera.id === testID) {
                    found = true;
                    continue;
                  }
                }
                if (found) {
                  testID = testID << 1;
                } else {
                  return testID;
                }
              }
              return 0;
            },
            getTotal: function(isVisible) {
              if (isVisible === void 0) {
                isVisible = false;
              }
              var total = 0;
              var cameras = this.cameras;
              for (var i = 0; i < cameras.length; i++) {
                var camera = cameras[i];
                if (!isVisible || isVisible && camera.visible) {
                  total++;
                }
              }
              return total;
            },
            fromJSON: function(config2) {
              if (!Array.isArray(config2)) {
                config2 = [config2];
              }
              var gameWidth = this.scene.sys.scale.width;
              var gameHeight = this.scene.sys.scale.height;
              for (var i = 0; i < config2.length; i++) {
                var cameraConfig = config2[i];
                var x = GetFastValue(cameraConfig, "x", 0);
                var y = GetFastValue(cameraConfig, "y", 0);
                var width = GetFastValue(cameraConfig, "width", gameWidth);
                var height = GetFastValue(cameraConfig, "height", gameHeight);
                var camera = this.add(x, y, width, height);
                camera.name = GetFastValue(cameraConfig, "name", "");
                camera.zoom = GetFastValue(cameraConfig, "zoom", 1);
                camera.rotation = GetFastValue(cameraConfig, "rotation", 0);
                camera.scrollX = GetFastValue(cameraConfig, "scrollX", 0);
                camera.scrollY = GetFastValue(cameraConfig, "scrollY", 0);
                camera.roundPixels = GetFastValue(cameraConfig, "roundPixels", false);
                camera.visible = GetFastValue(cameraConfig, "visible", true);
                var backgroundColor = GetFastValue(cameraConfig, "backgroundColor", false);
                if (backgroundColor) {
                  camera.setBackgroundColor(backgroundColor);
                }
                var boundsConfig = GetFastValue(cameraConfig, "bounds", null);
                if (boundsConfig) {
                  var bx = GetFastValue(boundsConfig, "x", 0);
                  var by = GetFastValue(boundsConfig, "y", 0);
                  var bwidth = GetFastValue(boundsConfig, "width", gameWidth);
                  var bheight = GetFastValue(boundsConfig, "height", gameHeight);
                  camera.setBounds(bx, by, bwidth, bheight);
                }
              }
              return this;
            },
            getCamera: function(name) {
              var cameras = this.cameras;
              for (var i = 0; i < cameras.length; i++) {
                if (cameras[i].name === name) {
                  return cameras[i];
                }
              }
              return null;
            },
            getCamerasBelowPointer: function(pointer) {
              var cameras = this.cameras;
              var x = pointer.x;
              var y = pointer.y;
              var output = [];
              for (var i = 0; i < cameras.length; i++) {
                var camera = cameras[i];
                if (camera.visible && camera.inputEnabled && RectangleContains(camera, x, y)) {
                  output.unshift(camera);
                }
              }
              return output;
            },
            remove: function(camera, runDestroy) {
              if (runDestroy === void 0) {
                runDestroy = true;
              }
              if (!Array.isArray(camera)) {
                camera = [camera];
              }
              var total = 0;
              var cameras = this.cameras;
              for (var i = 0; i < camera.length; i++) {
                var index = cameras.indexOf(camera[i]);
                if (index !== -1) {
                  if (runDestroy) {
                    cameras[index].destroy();
                  } else {
                    cameras[index].renderList = [];
                  }
                  cameras.splice(index, 1);
                  total++;
                }
              }
              if (!this.main && cameras[0]) {
                this.main = cameras[0];
              }
              return total;
            },
            render: function(renderer, displayList) {
              var scene = this.scene;
              var cameras = this.cameras;
              for (var i = 0; i < this.cameras.length; i++) {
                var camera = cameras[i];
                if (camera.visible && camera.alpha > 0) {
                  camera.preRender();
                  var visibleChildren = this.getVisibleChildren(displayList.getChildren(), camera);
                  renderer.render(scene, visibleChildren, camera);
                }
              }
            },
            getVisibleChildren: function(children, camera) {
              var visible = [];
              for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child.willRender(camera)) {
                  visible.push(child);
                }
              }
              return visible;
            },
            resetAll: function() {
              for (var i = 0; i < this.cameras.length; i++) {
                this.cameras[i].destroy();
              }
              this.cameras = [];
              this.main = this.add();
              return this.main;
            },
            update: function(time, delta) {
              for (var i = 0; i < this.cameras.length; i++) {
                this.cameras[i].update(time, delta);
              }
            },
            onResize: function(gameSize, baseSize, displaySize, previousWidth, previousHeight) {
              for (var i = 0; i < this.cameras.length; i++) {
                var cam = this.cameras[i];
                if (cam._x === 0 && cam._y === 0 && cam._width === previousWidth && cam._height === previousHeight) {
                  cam.setSize(baseSize.width, baseSize.height);
                }
              }
            },
            resize: function(width, height) {
              for (var i = 0; i < this.cameras.length; i++) {
                this.cameras[i].setSize(width, height);
              }
            },
            shutdown: function() {
              this.main = void 0;
              for (var i = 0; i < this.cameras.length; i++) {
                this.cameras[i].destroy();
              }
              this.cameras = [];
              var eventEmitter = this.systems.events;
              eventEmitter.off(SceneEvents.UPDATE, this.update, this);
              eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function() {
              this.shutdown();
              this.default.destroy();
              this.scene.sys.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
            }
          });
          PluginCache.register("CameraManager", CameraManager, "cameras");
          module2.exports = CameraManager;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "enterfullscreen";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "fullscreenfailed";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "fullscreenunsupported";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "leavefullscreen";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "orientationchange";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "resize";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "addedtoscene";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "boot";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "create";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "destroy";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pause";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "postupdate";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "preupdate";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "ready";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "removedfromscene";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "render";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "resume";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "shutdown";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "sleep";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "start";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "transitioncomplete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "transitioninit";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "transitionout";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "transitionstart";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "transitionwake";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "update";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "wake";
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Config: __webpack_require__(340),
            CreateRenderer: __webpack_require__(360),
            DebugHeader: __webpack_require__(378),
            Events: __webpack_require__(22),
            TimeStep: __webpack_require__(379),
            VisibilityHandler: __webpack_require__(381)
          };
        },
        function(module2, exports2) {
          var process = module2.exports = {};
          var cachedSetTimeout;
          var cachedClearTimeout;
          function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
          }
          function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
          }
          (function() {
            try {
              if (typeof setTimeout === "function") {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === "function") {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e2) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              return cachedClearTimeout(marker);
            } catch (e) {
              try {
                return cachedClearTimeout.call(null, marker);
              } catch (e2) {
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;
          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }
          process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function() {
            this.fun.apply(null, this.array);
          };
          process.title = "browser";
          process.browser = true;
          process.env = {};
          process.argv = [];
          process.version = "";
          process.versions = {};
          function noop() {
          }
          process.on = noop;
          process.addListener = noop;
          process.once = noop;
          process.off = noop;
          process.removeListener = noop;
          process.removeAllListeners = noop;
          process.emit = noop;
          process.prependListener = noop;
          process.prependOnceListener = noop;
          process.listeners = function(name) {
            return [];
          };
          process.binding = function(name) {
            throw new Error("process.binding is not supported");
          };
          process.cwd = function() {
            return "/";
          };
          process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
          };
          process.umask = function() {
            return 0;
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Browser = __webpack_require__(134);
          var Input = {
            gamepads: false,
            mspointer: false,
            touch: false,
            wheelEvent: null
          };
          function init() {
            if ("ontouchstart" in document.documentElement || navigator.maxTouchPoints && navigator.maxTouchPoints >= 1) {
              Input.touch = true;
            }
            if (navigator.msPointerEnabled || navigator.pointerEnabled) {
              Input.mspointer = true;
            }
            if (navigator.getGamepads) {
              Input.gamepads = true;
            }
            if ("onwheel" in window || Browser.ie && "WheelEvent" in window) {
              Input.wheelEvent = "wheel";
            } else if ("onmousewheel" in window) {
              Input.wheelEvent = "mousewheel";
            } else if (Browser.firefox && "MouseScrollEvent" in window) {
              Input.wheelEvent = "DOMMouseScroll";
            }
            return Input;
          }
          module2.exports = init();
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Browser = __webpack_require__(134);
          var Audio2 = {
            audioData: false,
            dolby: false,
            m4a: false,
            mp3: false,
            ogg: false,
            opus: false,
            wav: false,
            webAudio: false,
            webm: false
          };
          function init() {
            Audio2.audioData = !!window["Audio"];
            Audio2.webAudio = !!(window["AudioContext"] || window["webkitAudioContext"]);
            var audioElement = document.createElement("audio");
            var result = !!audioElement.canPlayType;
            try {
              if (result) {
                if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "")) {
                  Audio2.ogg = true;
                }
                if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || audioElement.canPlayType("audio/opus;").replace(/^no$/, "")) {
                  Audio2.opus = true;
                }
                if (audioElement.canPlayType("audio/mpeg;").replace(/^no$/, "")) {
                  Audio2.mp3 = true;
                }
                if (audioElement.canPlayType("audio/wav").replace(/^no$/, "")) {
                  Audio2.wav = true;
                }
                if (audioElement.canPlayType("audio/x-m4a;") || audioElement.canPlayType("audio/aac;").replace(/^no$/, "")) {
                  Audio2.m4a = true;
                }
                if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")) {
                  Audio2.webm = true;
                }
                if (audioElement.canPlayType('audio/mp4;codecs="ec-3"') !== "") {
                  if (Browser.edge) {
                    Audio2.dolby = true;
                  } else if (Browser.safari && Browser.safariVersion >= 9) {
                    if (/Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                      var major = parseInt(RegExp.$1, 10);
                      var minor = parseInt(RegExp.$2, 10);
                      if (major === 10 && minor >= 11 || major > 10) {
                        Audio2.dolby = true;
                      }
                    }
                  }
                }
              }
            } catch (e) {
            }
            return Audio2;
          }
          module2.exports = init();
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Video = {
            h264: false,
            hls: false,
            mp4: false,
            ogg: false,
            vp9: false,
            webm: false
          };
          function init() {
            var videoElement = document.createElement("video");
            var result = !!videoElement.canPlayType;
            try {
              if (result) {
                if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "")) {
                  Video.ogg = true;
                }
                if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "")) {
                  Video.h264 = true;
                  Video.mp4 = true;
                }
                if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "")) {
                  Video.webm = true;
                }
                if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "")) {
                  Video.vp9 = true;
                }
                if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "")) {
                  Video.hls = true;
                }
              }
            } catch (e) {
            }
            return Video;
          }
          module2.exports = init();
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Fullscreen = {
            available: false,
            cancel: "",
            keyboard: false,
            request: ""
          };
          function init() {
            var i;
            var suffix1 = "Fullscreen";
            var suffix2 = "FullScreen";
            var fs = [
              "request" + suffix1,
              "request" + suffix2,
              "webkitRequest" + suffix1,
              "webkitRequest" + suffix2,
              "msRequest" + suffix1,
              "msRequest" + suffix2,
              "mozRequest" + suffix2,
              "mozRequest" + suffix1
            ];
            for (i = 0; i < fs.length; i++) {
              if (document.documentElement[fs[i]]) {
                Fullscreen.available = true;
                Fullscreen.request = fs[i];
                break;
              }
            }
            var cfs = [
              "cancel" + suffix2,
              "exit" + suffix1,
              "webkitCancel" + suffix2,
              "webkitExit" + suffix1,
              "msCancel" + suffix2,
              "msExit" + suffix1,
              "mozCancel" + suffix2,
              "mozExit" + suffix1
            ];
            if (Fullscreen.available) {
              for (i = 0; i < cfs.length; i++) {
                if (document[cfs[i]]) {
                  Fullscreen.cancel = cfs[i];
                  break;
                }
              }
            }
            if (window["Element"] && Element["ALLOW_KEYBOARD_INPUT"] && !/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent)) {
              Fullscreen.keyboard = true;
            }
            Object.defineProperty(Fullscreen, "active", {get: function() {
              return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
            }});
            return Fullscreen;
          }
          module2.exports = init();
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Between: __webpack_require__(343),
            BetweenPoints: __webpack_require__(344),
            BetweenPointsY: __webpack_require__(810),
            BetweenY: __webpack_require__(811),
            CounterClockwise: __webpack_require__(812),
            Normalize: __webpack_require__(345),
            Random: __webpack_require__(813),
            RandomDegrees: __webpack_require__(814),
            Reverse: __webpack_require__(815),
            RotateTo: __webpack_require__(816),
            ShortestBetween: __webpack_require__(817),
            Wrap: __webpack_require__(265),
            WrapDegrees: __webpack_require__(266)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BetweenPointsY = function(point1, point2) {
            return Math.atan2(point2.x - point1.x, point2.y - point1.y);
          };
          module2.exports = BetweenPointsY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BetweenY = function(x1, y1, x2, y2) {
            return Math.atan2(x2 - x1, y2 - y1);
          };
          module2.exports = BetweenY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(14);
          var CounterClockwise = function(angle) {
            if (angle > Math.PI) {
              angle -= CONST.PI2;
            }
            return Math.abs(((angle + CONST.TAU) % CONST.PI2 - CONST.PI2) % CONST.PI2);
          };
          module2.exports = CounterClockwise;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       @samme
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FloatBetween = __webpack_require__(135);
          var Random = function() {
            return FloatBetween(-Math.PI, Math.PI);
          };
          module2.exports = Random;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       @samme
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FloatBetween = __webpack_require__(135);
          var RandomDegrees = function() {
            return FloatBetween(-180, 180);
          };
          module2.exports = RandomDegrees;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Normalize = __webpack_require__(345);
          var Reverse = function(angle) {
            return Normalize(angle + Math.PI);
          };
          module2.exports = Reverse;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MATH_CONST = __webpack_require__(14);
          var RotateTo = function(currentAngle, targetAngle, lerp) {
            if (lerp === void 0) {
              lerp = 0.05;
            }
            if (currentAngle === targetAngle) {
              return currentAngle;
            }
            if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= MATH_CONST.PI2 - lerp) {
              currentAngle = targetAngle;
            } else {
              if (Math.abs(targetAngle - currentAngle) > Math.PI) {
                if (targetAngle < currentAngle) {
                  targetAngle += MATH_CONST.PI2;
                } else {
                  targetAngle -= MATH_CONST.PI2;
                }
              }
              if (targetAngle > currentAngle) {
                currentAngle += lerp;
              } else if (targetAngle < currentAngle) {
                currentAngle -= lerp;
              }
            }
            return currentAngle;
          };
          module2.exports = RotateTo;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ShortestBetween = function(angle1, angle2) {
            var difference = angle2 - angle1;
            if (difference === 0) {
              return 0;
            }
            var times = Math.floor((difference - -180) / 360);
            return difference - times * 360;
          };
          module2.exports = ShortestBetween;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Between: __webpack_require__(48),
            BetweenPoints: __webpack_require__(346),
            BetweenPointsSquared: __webpack_require__(819),
            Chebyshev: __webpack_require__(820),
            Power: __webpack_require__(821),
            Snake: __webpack_require__(822),
            Squared: __webpack_require__(347)
          };
        },
        function(module2, exports2) {
          /**
           * @author       samme
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DistanceBetweenPointsSquared = function(a, b) {
            var dx = a.x - b.x;
            var dy = a.y - b.y;
            return dx * dx + dy * dy;
          };
          module2.exports = DistanceBetweenPointsSquared;
        },
        function(module2, exports2) {
          /**
           * @author       samme
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ChebyshevDistance = function(x1, y1, x2, y2) {
            return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
          };
          module2.exports = ChebyshevDistance;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DistancePower = function(x1, y1, x2, y2, pow) {
            if (pow === void 0) {
              pow = 2;
            }
            return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
          };
          module2.exports = DistancePower;
        },
        function(module2, exports2) {
          /**
           * @author       samme
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SnakeDistance = function(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
          };
          module2.exports = SnakeDistance;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Back: __webpack_require__(328),
            Bounce: __webpack_require__(329),
            Circular: __webpack_require__(330),
            Cubic: __webpack_require__(331),
            Elastic: __webpack_require__(332),
            Expo: __webpack_require__(333),
            Linear: __webpack_require__(334),
            Quadratic: __webpack_require__(335),
            Quartic: __webpack_require__(336),
            Quintic: __webpack_require__(337),
            Sine: __webpack_require__(338),
            Stepped: __webpack_require__(339)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Ceil: __webpack_require__(825),
            Equal: __webpack_require__(123),
            Floor: __webpack_require__(826),
            GreaterThan: __webpack_require__(348),
            LessThan: __webpack_require__(349)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Ceil = function(value, epsilon) {
            if (epsilon === void 0) {
              epsilon = 1e-4;
            }
            return Math.ceil(value - epsilon);
          };
          module2.exports = Ceil;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Floor = function(value, epsilon) {
            if (epsilon === void 0) {
              epsilon = 1e-4;
            }
            return Math.floor(value + epsilon);
          };
          module2.exports = Floor;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Bezier: __webpack_require__(828),
            CatmullRom: __webpack_require__(829),
            CubicBezier: __webpack_require__(352),
            Linear: __webpack_require__(830),
            QuadraticBezier: __webpack_require__(353),
            SmoothStep: __webpack_require__(354),
            SmootherStep: __webpack_require__(831)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Bernstein = __webpack_require__(350);
          var BezierInterpolation = function(v, k) {
            var b = 0;
            var n = v.length - 1;
            for (var i = 0; i <= n; i++) {
              b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);
            }
            return b;
          };
          module2.exports = BezierInterpolation;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CatmullRom = __webpack_require__(191);
          var CatmullRomInterpolation = function(v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            if (v[0] === v[m]) {
              if (k < 0) {
                i = Math.floor(f = m * (1 + k));
              }
              return CatmullRom(f - i, v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m]);
            } else {
              if (k < 0) {
                return v[0] - (CatmullRom(-f, v[0], v[0], v[1], v[1]) - v[0]);
              }
              if (k > 1) {
                return v[m] - (CatmullRom(f - m, v[m], v[m], v[m - 1], v[m - 1]) - v[m]);
              }
              return CatmullRom(f - i, v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2]);
            }
          };
          module2.exports = CatmullRomInterpolation;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Linear = __webpack_require__(133);
          var LinearInterpolation = function(v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            if (k < 0) {
              return Linear(v[0], v[1], f);
            } else if (k > 1) {
              return Linear(v[m], v[m - 1], m - f);
            } else {
              return Linear(v[i], v[i + 1 > m ? m : i + 1], f - i);
            }
          };
          module2.exports = LinearInterpolation;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SmootherStep = __webpack_require__(180);
          var SmootherStepInterpolation = function(t, min, max) {
            return min + (max - min) * SmootherStep(t, 0, 1);
          };
          module2.exports = SmootherStepInterpolation;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            GetNext: __webpack_require__(355),
            IsSize: __webpack_require__(136),
            IsValue: __webpack_require__(833)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var IsValuePowerOfTwo = function(value) {
            return value > 0 && (value & value - 1) === 0;
          };
          module2.exports = IsValuePowerOfTwo;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Ceil: __webpack_require__(137),
            Floor: __webpack_require__(76),
            To: __webpack_require__(835)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SnapTo = function(value, gap, start, divide) {
            if (start === void 0) {
              start = 0;
            }
            if (gap === 0) {
              return value;
            }
            value -= start;
            value = gap * Math.round(value / gap);
            return divide ? (start + value) / gap : start + value;
          };
          module2.exports = SnapTo;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var RandomDataGenerator = new Class({
            initialize: function RandomDataGenerator2(seeds) {
              if (seeds === void 0) {
                seeds = [(Date.now() * Math.random()).toString()];
              }
              this.c = 1;
              this.s0 = 0;
              this.s1 = 0;
              this.s2 = 0;
              this.n = 0;
              this.signs = [-1, 1];
              if (seeds) {
                this.init(seeds);
              }
            },
            rnd: function() {
              var t = 2091639 * this.s0 + this.c * 23283064365386963e-26;
              this.c = t | 0;
              this.s0 = this.s1;
              this.s1 = this.s2;
              this.s2 = t - this.c;
              return this.s2;
            },
            hash: function(data) {
              var h;
              var n = this.n;
              data = data.toString();
              for (var i = 0; i < data.length; i++) {
                n += data.charCodeAt(i);
                h = 0.02519603282416938 * n;
                n = h >>> 0;
                h -= n;
                h *= n;
                n = h >>> 0;
                h -= n;
                n += h * 4294967296;
              }
              this.n = n;
              return (n >>> 0) * 23283064365386963e-26;
            },
            init: function(seeds) {
              if (typeof seeds === "string") {
                this.state(seeds);
              } else {
                this.sow(seeds);
              }
            },
            sow: function(seeds) {
              this.n = 4022871197;
              this.s0 = this.hash(" ");
              this.s1 = this.hash(" ");
              this.s2 = this.hash(" ");
              this.c = 1;
              if (!seeds) {
                return;
              }
              for (var i = 0; i < seeds.length && seeds[i] != null; i++) {
                var seed = seeds[i];
                this.s0 -= this.hash(seed);
                this.s0 += ~~(this.s0 < 0);
                this.s1 -= this.hash(seed);
                this.s1 += ~~(this.s1 < 0);
                this.s2 -= this.hash(seed);
                this.s2 += ~~(this.s2 < 0);
              }
            },
            integer: function() {
              return this.rnd() * 4294967296;
            },
            frac: function() {
              return this.rnd() + (this.rnd() * 2097152 | 0) * 11102230246251565e-32;
            },
            real: function() {
              return this.integer() + this.frac();
            },
            integerInRange: function(min, max) {
              return Math.floor(this.realInRange(0, max - min + 1) + min);
            },
            between: function(min, max) {
              return Math.floor(this.realInRange(0, max - min + 1) + min);
            },
            realInRange: function(min, max) {
              return this.frac() * (max - min) + min;
            },
            normal: function() {
              return 1 - 2 * this.frac();
            },
            uuid: function() {
              var a = "";
              var b = "";
              for (b = a = ""; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
              }
              return b;
            },
            pick: function(array) {
              return array[this.integerInRange(0, array.length - 1)];
            },
            sign: function() {
              return this.pick(this.signs);
            },
            weightedPick: function(array) {
              return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];
            },
            timestamp: function(min, max) {
              return this.realInRange(min || 9466848e5, max || 1577862e6);
            },
            angle: function() {
              return this.integerInRange(-180, 180);
            },
            rotation: function() {
              return this.realInRange(-3.1415926, 3.1415926);
            },
            state: function(state) {
              if (typeof state === "string" && state.match(/^!rnd/)) {
                state = state.split(",");
                this.c = parseFloat(state[1]);
                this.s0 = parseFloat(state[2]);
                this.s1 = parseFloat(state[3]);
                this.s2 = parseFloat(state[4]);
              }
              return ["!rnd", this.c, this.s0, this.s1, this.s2].join(",");
            },
            shuffle: function(array) {
              var len = array.length - 1;
              for (var i = len; i > 0; i--) {
                var randomIndex = Math.floor(this.frac() * (i + 1));
                var itemAtIndex = array[randomIndex];
                array[randomIndex] = array[i];
                array[i] = itemAtIndex;
              }
              return array;
            }
          });
          module2.exports = RandomDataGenerator;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Average = function(values) {
            var sum = 0;
            for (var i = 0; i < values.length; i++) {
              sum += +values[i];
            }
            return sum / values.length;
          };
          module2.exports = Average;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CeilTo = function(value, place, base) {
            if (place === void 0) {
              place = 0;
            }
            if (base === void 0) {
              base = 10;
            }
            var p = Math.pow(base, -place);
            return Math.ceil(value * p) / p;
          };
          module2.exports = CeilTo;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Difference = function(a, b) {
            return Math.abs(a - b);
          };
          module2.exports = Difference;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Matrix4 = __webpack_require__(67);
          var NOOP = __webpack_require__(1);
          var tempMatrix = new Matrix4();
          var Euler = new Class({
            initialize: function Euler2(x, y, z, order) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (z === void 0) {
                z = 0;
              }
              if (order === void 0) {
                order = Euler2.DefaultOrder;
              }
              this._x = x;
              this._y = y;
              this._z = z;
              this._order = order;
              this.onChangeCallback = NOOP;
            },
            x: {
              get: function() {
                return this._x;
              },
              set: function(value) {
                this._x = value;
                this.onChangeCallback(this);
              }
            },
            y: {
              get: function() {
                return this._y;
              },
              set: function(value) {
                this._y = value;
                this.onChangeCallback(this);
              }
            },
            z: {
              get: function() {
                return this._z;
              },
              set: function(value) {
                this._z = value;
                this.onChangeCallback(this);
              }
            },
            order: {
              get: function() {
                return this._order;
              },
              set: function(value) {
                this._order = value;
                this.onChangeCallback(this);
              }
            },
            set: function(x, y, z, order) {
              if (order === void 0) {
                order = this._order;
              }
              this._x = x;
              this._y = y;
              this._z = z;
              this._order = order;
              this.onChangeCallback(this);
              return this;
            },
            copy: function(euler) {
              return this.set(euler.x, euler.y, euler.z, euler.order);
            },
            setFromQuaternion: function(quaternion, order, update) {
              if (order === void 0) {
                order = this._order;
              }
              if (update === void 0) {
                update = false;
              }
              tempMatrix.fromQuat(quaternion);
              return this.setFromRotationMatrix(tempMatrix, order, update);
            },
            setFromRotationMatrix: function(matrix, order, update) {
              if (order === void 0) {
                order = this._order;
              }
              if (update === void 0) {
                update = false;
              }
              var elements = matrix.val;
              var m11 = elements[0];
              var m12 = elements[4];
              var m13 = elements[8];
              var m21 = elements[1];
              var m22 = elements[5];
              var m23 = elements[9];
              var m31 = elements[2];
              var m32 = elements[6];
              var m33 = elements[10];
              var x = 0;
              var y = 0;
              var z = 0;
              var epsilon = 0.99999;
              switch (order) {
                case "XYZ": {
                  y = Math.asin(Clamp(m13, -1, 1));
                  if (Math.abs(m13) < epsilon) {
                    x = Math.atan2(-m23, m33);
                    z = Math.atan2(-m12, m11);
                  } else {
                    x = Math.atan2(m32, m22);
                  }
                  break;
                }
                case "YXZ": {
                  x = Math.asin(-Clamp(m23, -1, 1));
                  if (Math.abs(m23) < epsilon) {
                    y = Math.atan2(m13, m33);
                    z = Math.atan2(m21, m22);
                  } else {
                    y = Math.atan2(-m31, m11);
                  }
                  break;
                }
                case "ZXY": {
                  x = Math.asin(Clamp(m32, -1, 1));
                  if (Math.abs(m32) < epsilon) {
                    y = Math.atan2(-m31, m33);
                    z = Math.atan2(-m12, m22);
                  } else {
                    z = Math.atan2(m21, m11);
                  }
                  break;
                }
                case "ZYX": {
                  y = Math.asin(-Clamp(m31, -1, 1));
                  if (Math.abs(m31) < epsilon) {
                    x = Math.atan2(m32, m33);
                    z = Math.atan2(m21, m11);
                  } else {
                    z = Math.atan2(-m12, m22);
                  }
                  break;
                }
                case "YZX": {
                  z = Math.asin(Clamp(m21, -1, 1));
                  if (Math.abs(m21) < epsilon) {
                    x = Math.atan2(-m23, m22);
                    y = Math.atan2(-m31, m11);
                  } else {
                    y = Math.atan2(m13, m33);
                  }
                  break;
                }
                case "XZY": {
                  z = Math.asin(-Clamp(m12, -1, 1));
                  if (Math.abs(m12) < epsilon) {
                    x = Math.atan2(m32, m22);
                    y = Math.atan2(m13, m11);
                  } else {
                    x = Math.atan2(-m23, m33);
                  }
                  break;
                }
              }
              this._x = x;
              this._y = y;
              this._z = z;
              this._order = order;
              if (update) {
                this.onChangeCallback(this);
              }
              return this;
            }
          });
          Euler.RotationOrders = ["XYZ", "YXZ", "ZXY", "ZYX", "YZX", "XZY"];
          Euler.DefaultOrder = "XYZ";
          module2.exports = Euler;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FloorTo = function(value, place, base) {
            if (place === void 0) {
              place = 0;
            }
            if (base === void 0) {
              base = 10;
            }
            var p = Math.pow(base, -place);
            return Math.floor(value * p) / p;
          };
          module2.exports = FloorTo;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetSpeed = function(distance, time) {
            return distance / time / 1e3;
          };
          module2.exports = GetSpeed;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var IsEven = function(value) {
            return value == parseFloat(value) ? !(value % 2) : void 0;
          };
          module2.exports = IsEven;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var IsEvenStrict = function(value) {
            return value === parseFloat(value) ? !(value % 2) : void 0;
          };
          module2.exports = IsEvenStrict;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MaxAdd = function(value, amount, max) {
            return Math.min(value + amount, max);
          };
          module2.exports = MaxAdd;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MinSub = function(value, amount, min) {
            return Math.max(value - amount, min);
          };
          module2.exports = MinSub;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Percent = function(value, min, max, upperMax) {
            if (max === void 0) {
              max = min + 1;
            }
            var percentage = (value - min) / (max - min);
            if (percentage > 1) {
              if (upperMax !== void 0) {
                percentage = (upperMax - value) / (upperMax - max);
                if (percentage < 0) {
                  percentage = 0;
                }
              } else {
                percentage = 1;
              }
            } else if (percentage < 0) {
              percentage = 0;
            }
            return percentage;
          };
          module2.exports = Percent;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RandomXY = function(vector, scale) {
            if (scale === void 0) {
              scale = 1;
            }
            var r = Math.random() * 2 * Math.PI;
            vector.x = Math.cos(r) * scale;
            vector.y = Math.sin(r) * scale;
            return vector;
          };
          module2.exports = RandomXY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RandomXYZ = function(vec3, radius) {
            if (radius === void 0) {
              radius = 1;
            }
            var r = Math.random() * 2 * Math.PI;
            var z = Math.random() * 2 - 1;
            var zScale = Math.sqrt(1 - z * z) * radius;
            vec3.x = Math.cos(r) * zScale;
            vec3.y = Math.sin(r) * zScale;
            vec3.z = z * radius;
            return vec3;
          };
          module2.exports = RandomXYZ;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RandomXYZW = function(vec4, scale) {
            if (scale === void 0) {
              scale = 1;
            }
            vec4.x = (Math.random() * 2 - 1) * scale;
            vec4.y = (Math.random() * 2 - 1) * scale;
            vec4.z = (Math.random() * 2 - 1) * scale;
            vec4.w = (Math.random() * 2 - 1) * scale;
            return vec4;
          };
          module2.exports = RandomXYZW;
        },
        function(module2, exports2) {
          /**
           * @author       samme
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateTo = function(point, x, y, angle, distance) {
            point.x = x + distance * Math.cos(angle);
            point.y = y + distance * Math.sin(angle);
            return point;
          };
          module2.exports = RotateTo;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RoundTo = function(value, place, base) {
            if (place === void 0) {
              place = 0;
            }
            if (base === void 0) {
              base = 10;
            }
            var p = Math.pow(base, -place);
            return Math.round(value * p) / p;
          };
          module2.exports = RoundTo;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SinCosTableGenerator = function(length, sinAmp, cosAmp, frequency) {
            if (sinAmp === void 0) {
              sinAmp = 1;
            }
            if (cosAmp === void 0) {
              cosAmp = 1;
            }
            if (frequency === void 0) {
              frequency = 1;
            }
            frequency *= Math.PI / length;
            var cos = [];
            var sin = [];
            for (var c = 0; c < length; c++) {
              cosAmp -= sinAmp * frequency;
              sinAmp += cosAmp * frequency;
              cos[c] = cosAmp;
              sin[c] = sinAmp;
            }
            return {
              sin,
              cos,
              length
            };
          };
          module2.exports = SinCosTableGenerator;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector29 = __webpack_require__(3);
          var ToXY = function(index, width, height, out) {
            if (out === void 0) {
              out = new Vector29();
            }
            var x = 0;
            var y = 0;
            var total = width * height;
            if (index > 0 && index <= total) {
              if (index > width - 1) {
                y = Math.floor(index / width);
                x = index - y * width;
              } else {
                x = index;
              }
              out.set(x, y);
            }
            return out;
          };
          module2.exports = ToXY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Within = function(a, b, tolerance) {
            return Math.abs(a - b) <= tolerance;
          };
          module2.exports = Within;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector3 = __webpack_require__(38);
          var Matrix4 = __webpack_require__(67);
          var Quaternion = __webpack_require__(359);
          var tmpMat4 = new Matrix4();
          var tmpQuat = new Quaternion();
          var tmpVec3 = new Vector3();
          var RotateVec3 = function(vec, axis, radians) {
            tmpQuat.setAxisAngle(axis, radians);
            tmpMat4.fromRotationTranslation(tmpQuat, tmpVec3.set(0, 0, 0));
            return vec.transformMat4(tmpMat4);
          };
          module2.exports = RotateVec3;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "addtexture";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "onerror";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "onload";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "ready";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "removetexture";
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_BITMAP_MASK_FS",
            "",
            "precision mediump float;",
            "",
            "uniform vec2 uResolution;",
            "uniform sampler2D uMainSampler;",
            "uniform sampler2D uMaskSampler;",
            "uniform bool uInvertMaskAlpha;",
            "",
            "void main ()",
            "{",
            "    vec2 uv = gl_FragCoord.xy / uResolution;",
            "    vec4 mainColor = texture2D(uMainSampler, uv);",
            "    vec4 maskColor = texture2D(uMaskSampler, uv);",
            "    float alpha = mainColor.a;",
            "",
            "    if (!uInvertMaskAlpha)",
            "    {",
            "        alpha *= (maskColor.a);",
            "    }",
            "    else",
            "    {",
            "        alpha *= (1.0 - maskColor.a);",
            "    }",
            "",
            "    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_BITMAP_MASK_VS",
            "",
            "precision mediump float;",
            "",
            "attribute vec2 inPosition;",
            "",
            "void main ()",
            "{",
            "    gl_Position = vec4(inPosition, 0.0, 1.0);",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pipelineafterflush";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pipelinebeforeflush";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pipelinebind";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pipelineboot";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pipelinedestroy";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pipelinerebind";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pipelineresize";
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_GRAPHICS_FS",
            "",
            "precision mediump float;",
            "",
            "varying vec4 outColor;",
            "",
            "void main ()",
            "{",
            "    gl_FragColor = vec4(outColor.bgr * outColor.a, outColor.a);",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_GRAPHICS_VS",
            "",
            "precision mediump float;",
            "",
            "uniform mat4 uProjectionMatrix;",
            "",
            "attribute vec2 inPosition;",
            "attribute vec4 inColor;",
            "",
            "varying vec4 outColor;",
            "",
            "void main ()",
            "{",
            "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
            "",
            "    outColor = inColor;",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_LIGHT_FS",
            "",
            "precision mediump float;",
            "",
            "struct Light",
            "{",
            "    vec2 position;",
            "    vec3 color;",
            "    float intensity;",
            "    float radius;",
            "};",
            "",
            "const int kMaxLights = %LIGHT_COUNT%;",
            "",
            "uniform vec4 uCamera; /* x, y, rotation, zoom */",
            "uniform vec2 uResolution;",
            "uniform sampler2D uMainSampler;",
            "uniform sampler2D uNormSampler;",
            "uniform vec3 uAmbientLightColor;",
            "uniform Light uLights[kMaxLights];",
            "uniform mat3 uInverseRotationMatrix;",
            "",
            "varying vec2 outTexCoord;",
            "varying vec4 outTint;",
            "",
            "void main()",
            "{",
            "    vec3 finalColor = vec3(0.0, 0.0, 0.0);",
            "    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.bgr * outTint.a, outTint.a);",
            "    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;",
            "    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));",
            "    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;",
            "",
            "    for (int index = 0; index < kMaxLights; ++index)",
            "    {",
            "        Light light = uLights[index];",
            "        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);",
            "        vec3 lightNormal = normalize(lightDir);",
            "        float distToSurf = length(lightDir) * uCamera.w;",
            "        float diffuseFactor = max(dot(normal, lightNormal), 0.0);",
            "        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;",
            "        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);",
            "        vec3 diffuse = light.color * diffuseFactor;",
            "        finalColor += (attenuation * diffuse) * light.intensity;",
            "    }",
            "",
            "    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);",
            "",
            "    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_MULTI_FS",
            "",
            "precision mediump float;",
            "",
            "uniform sampler2D uMainSampler[%count%];",
            "",
            "varying vec2 outTexCoord;",
            "varying float outTexId;",
            "varying float outTintEffect;",
            "varying vec4 outTint;",
            "",
            "void main ()",
            "{",
            "    vec4 texture;",
            "",
            "    %forloop%",
            "",
            "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);",
            "",
            "    //  Multiply texture tint",
            "    vec4 color = texture * texel;",
            "",
            "    if (outTintEffect == 1.0)",
            "    {",
            "        //  Solid color + texture alpha",
            "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);",
            "    }",
            "    else if (outTintEffect == 2.0)",
            "    {",
            "        //  Solid color, no texture",
            "        color = texel;",
            "    }",
            "",
            "    gl_FragColor = color;",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_MULTI_VS",
            "",
            "precision mediump float;",
            "",
            "uniform mat4 uProjectionMatrix;",
            "",
            "attribute vec2 inPosition;",
            "attribute vec2 inTexCoord;",
            "attribute float inTexId;",
            "attribute float inTintEffect;",
            "attribute vec4 inTint;",
            "",
            "varying vec2 outTexCoord;",
            "varying float outTexId;",
            "varying float outTintEffect;",
            "varying vec4 outTint;",
            "",
            "void main ()",
            "{",
            "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
            "",
            "    outTexCoord = inTexCoord;",
            "    outTexId = inTexId;",
            "    outTint = inTint;",
            "    outTintEffect = inTintEffect;",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_POINTLIGHT_FS",
            "",
            "precision mediump float;",
            "",
            "uniform vec2 uResolution;",
            "uniform float uCameraZoom;",
            "",
            "varying vec4 lightPosition;",
            "varying vec4 lightColor;",
            "varying float lightRadius;",
            "varying float lightAttenuation;",
            "",
            "void main ()",
            "{",
            "    vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);",
            "",
            "    float distToSurf = length(center - gl_FragCoord.xy);",
            "",
            "    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);",
            "",
            "    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);",
            "",
            "    vec4 color = vec4(intensity, intensity, intensity, 0.0) * lightColor;",
            "",
            "    gl_FragColor = vec4(color.rgb * lightColor.a, color.a);",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_POINTLIGHT_VS",
            "",
            "precision mediump float;",
            "",
            "uniform mat4 uProjectionMatrix;",
            "",
            "attribute vec2 inPosition;",
            "attribute vec2 inLightPosition;",
            "attribute vec4 inLightColor;",
            "attribute float inLightRadius;",
            "attribute float inLightAttenuation;",
            "",
            "varying vec4 lightPosition;",
            "varying vec4 lightColor;",
            "varying float lightRadius;",
            "varying float lightAttenuation;",
            "",
            "void main ()",
            "{",
            "    lightColor = inLightColor;",
            "    lightRadius = inLightRadius;",
            "    lightAttenuation = inLightAttenuation;",
            "    lightPosition = uProjectionMatrix * vec4(inLightPosition, 1.0, 1.0);",
            "",
            "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_SINGLE_FS",
            "",
            "precision mediump float;",
            "",
            "uniform sampler2D uMainSampler;",
            "",
            "varying vec2 outTexCoord;",
            "varying float outTintEffect;",
            "varying vec4 outTint;",
            "",
            "void main ()",
            "{",
            "    vec4 texture = texture2D(uMainSampler, outTexCoord);",
            "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);",
            "",
            "    //  Multiply texture tint",
            "    vec4 color = texture * texel;",
            "",
            "    if (outTintEffect == 1.0)",
            "    {",
            "        //  Solid color + texture alpha",
            "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);",
            "    }",
            "    else if (outTintEffect == 2.0)",
            "    {",
            "        //  Solid color, no texture",
            "        color = texel;",
            "    }",
            "",
            "    gl_FragColor = color;",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_SINGLE_VS",
            "",
            "precision mediump float;",
            "",
            "uniform mat4 uProjectionMatrix;",
            "",
            "attribute vec2 inPosition;",
            "attribute vec2 inTexCoord;",
            "attribute float inTexId;",
            "attribute float inTintEffect;",
            "attribute vec4 inTint;",
            "",
            "varying vec2 outTexCoord;",
            "varying float outTintEffect;",
            "varying vec4 outTint;",
            "",
            "void main ()",
            "{",
            "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
            "",
            "    outTexCoord = inTexCoord;",
            "    outTint = inTint;",
            "    outTintEffect = inTintEffect;",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_ADD_BLEND_FS",
            "",
            "precision mediump float;",
            "",
            "uniform sampler2D uMainSampler1;",
            "uniform sampler2D uMainSampler2;",
            "uniform float uStrength;",
            "",
            "varying vec2 outTexCoord;",
            "",
            "void main ()",
            "{",
            "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);",
            "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);",
            "",
            "    gl_FragColor = frame1 + frame2 * uStrength;",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_COLORMATRIX_FS",
            "",
            "precision mediump float;",
            "",
            "uniform sampler2D uMainSampler;",
            "uniform float uColorMatrix[20];",
            "uniform float uAlpha;",
            "",
            "varying vec2 outTexCoord;",
            "",
            "void main ()",
            "{",
            "    vec4 c = texture2D(uMainSampler, outTexCoord);",
            "",
            "    if (uAlpha == 0.0)",
            "    {",
            "        gl_FragColor = c;",
            "",
            "        return;",
            "    }",
            "",
            "    if (c.a > 0.0)",
            "    {",
            "        c.rgb /= c.a;",
            "    }",
            "",
            "    vec4 result;",
            "",
            "    result.r = (uColorMatrix[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMatrix[4];",
            "    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b) + (uColorMatrix[8] * c.a) + uColorMatrix[9];",
            "    result.b = (uColorMatrix[10] * c.r) + (uColorMatrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];",
            "    result.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMatrix[18] * c.a) + uColorMatrix[19];",
            "",
            "    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);",
            "",
            "    rgb *= result.a;",
            "",
            "    gl_FragColor = vec4(rgb, result.a);",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_COPY_FS",
            "",
            "precision mediump float;",
            "",
            "uniform sampler2D uMainSampler;",
            "uniform float uBrightness;",
            "",
            "varying vec2 outTexCoord;",
            "",
            "void main ()",
            "{",
            "    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_LINEAR_BLEND_FS",
            "",
            "precision mediump float;",
            "",
            "uniform sampler2D uMainSampler1;",
            "uniform sampler2D uMainSampler2;",
            "uniform float uStrength;",
            "",
            "varying vec2 outTexCoord;",
            "",
            "void main ()",
            "{",
            "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);",
            "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);",
            "",
            "    gl_FragColor = mix(frame1, frame2 * uStrength, 0.5);",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            GenerateTexture: __webpack_require__(382),
            Palettes: __webpack_require__(885)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            ARNE16: __webpack_require__(383),
            C64: __webpack_require__(886),
            CGA: __webpack_require__(887),
            JMP: __webpack_require__(888),
            MSX: __webpack_require__(889)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            0: "#000",
            1: "#fff",
            2: "#8b4131",
            3: "#7bbdc5",
            4: "#8b41ac",
            5: "#6aac41",
            6: "#3931a4",
            7: "#d5de73",
            8: "#945a20",
            9: "#5a4100",
            A: "#bd736a",
            B: "#525252",
            C: "#838383",
            D: "#acee8b",
            E: "#7b73de",
            F: "#acacac"
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            0: "#000",
            1: "#2234d1",
            2: "#0c7e45",
            3: "#44aacc",
            4: "#8a3622",
            5: "#5c2e78",
            6: "#aa5c3d",
            7: "#b5b5b5",
            8: "#5e606e",
            9: "#4c81fb",
            A: "#6cd947",
            B: "#7be2f9",
            C: "#eb8a60",
            D: "#e23d69",
            E: "#ffd93f",
            F: "#fff"
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            0: "#000",
            1: "#191028",
            2: "#46af45",
            3: "#a1d685",
            4: "#453e78",
            5: "#7664fe",
            6: "#833129",
            7: "#9ec2e8",
            8: "#dc534b",
            9: "#e18d79",
            A: "#d6b97b",
            B: "#e9d8a1",
            C: "#216c4b",
            D: "#d365c8",
            E: "#afaab9",
            F: "#f5f4eb"
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            0: "#000",
            1: "#191028",
            2: "#46af45",
            3: "#a1d685",
            4: "#453e78",
            5: "#7664fe",
            6: "#833129",
            7: "#9ec2e8",
            8: "#dc534b",
            9: "#e18d79",
            A: "#d6b97b",
            B: "#e9d8a1",
            C: "#216c4b",
            D: "#d365c8",
            E: "#afaab9",
            F: "#fff"
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Path: __webpack_require__(891),
            MoveTo: __webpack_require__(387),
            CubicBezier: __webpack_require__(384),
            Curve: __webpack_require__(90),
            Ellipse: __webpack_require__(385),
            Line: __webpack_require__(386),
            QuadraticBezier: __webpack_require__(388),
            Spline: __webpack_require__(389)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CubicBezierCurve = __webpack_require__(384);
          var EllipseCurve = __webpack_require__(385);
          var GameObjectFactory = __webpack_require__(5);
          var LineCurve = __webpack_require__(386);
          var MovePathTo = __webpack_require__(387);
          var QuadraticBezierCurve = __webpack_require__(388);
          var Rectangle = __webpack_require__(10);
          var SplineCurve = __webpack_require__(389);
          var Vector29 = __webpack_require__(3);
          var MATH_CONST = __webpack_require__(14);
          var Path = new Class({
            initialize: function Path2(x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              this.name = "";
              this.curves = [];
              this.cacheLengths = [];
              this.autoClose = false;
              this.startPoint = new Vector29();
              this._tmpVec2A = new Vector29();
              this._tmpVec2B = new Vector29();
              if (typeof x === "object") {
                this.fromJSON(x);
              } else {
                this.startPoint.set(x, y);
              }
            },
            add: function(curve) {
              this.curves.push(curve);
              return this;
            },
            circleTo: function(radius, clockwise, rotation) {
              if (clockwise === void 0) {
                clockwise = false;
              }
              return this.ellipseTo(radius, radius, 0, 360, clockwise, rotation);
            },
            closePath: function() {
              var startPoint = this.curves[0].getPoint(0);
              var endPoint = this.curves[this.curves.length - 1].getPoint(1);
              if (!startPoint.equals(endPoint)) {
                this.curves.push(new LineCurve(endPoint, startPoint));
              }
              return this;
            },
            cubicBezierTo: function(x, y, control1X, control1Y, control2X, control2Y) {
              var p0 = this.getEndPoint();
              var p1;
              var p2;
              var p3;
              if (x instanceof Vector29) {
                p1 = x;
                p2 = y;
                p3 = control1X;
              } else {
                p1 = new Vector29(control1X, control1Y);
                p2 = new Vector29(control2X, control2Y);
                p3 = new Vector29(x, y);
              }
              return this.add(new CubicBezierCurve(p0, p1, p2, p3));
            },
            quadraticBezierTo: function(x, y, controlX, controlY) {
              var p0 = this.getEndPoint();
              var p1;
              var p2;
              if (x instanceof Vector29) {
                p1 = x;
                p2 = y;
              } else {
                p1 = new Vector29(controlX, controlY);
                p2 = new Vector29(x, y);
              }
              return this.add(new QuadraticBezierCurve(p0, p1, p2));
            },
            draw: function(graphics, pointsTotal) {
              for (var i = 0; i < this.curves.length; i++) {
                var curve = this.curves[i];
                if (!curve.active) {
                  continue;
                }
                curve.draw(graphics, pointsTotal);
              }
              return graphics;
            },
            ellipseTo: function(xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {
              var ellipse = new EllipseCurve(0, 0, xRadius, yRadius, startAngle, endAngle, clockwise, rotation);
              var end = this.getEndPoint(this._tmpVec2A);
              var start = ellipse.getStartPoint(this._tmpVec2B);
              end.subtract(start);
              ellipse.x = end.x;
              ellipse.y = end.y;
              return this.add(ellipse);
            },
            fromJSON: function(data) {
              this.curves = [];
              this.cacheLengths = [];
              this.startPoint.set(data.x, data.y);
              this.autoClose = data.autoClose;
              for (var i = 0; i < data.curves.length; i++) {
                var curve = data.curves[i];
                switch (curve.type) {
                  case "LineCurve":
                    this.add(LineCurve.fromJSON(curve));
                    break;
                  case "EllipseCurve":
                    this.add(EllipseCurve.fromJSON(curve));
                    break;
                  case "SplineCurve":
                    this.add(SplineCurve.fromJSON(curve));
                    break;
                  case "CubicBezierCurve":
                    this.add(CubicBezierCurve.fromJSON(curve));
                    break;
                  case "QuadraticBezierCurve":
                    this.add(QuadraticBezierCurve.fromJSON(curve));
                    break;
                }
              }
              return this;
            },
            getBounds: function(out, accuracy) {
              if (out === void 0) {
                out = new Rectangle();
              }
              if (accuracy === void 0) {
                accuracy = 16;
              }
              out.x = Number.MAX_VALUE;
              out.y = Number.MAX_VALUE;
              var bounds = new Rectangle();
              var maxRight = MATH_CONST.MIN_SAFE_INTEGER;
              var maxBottom = MATH_CONST.MIN_SAFE_INTEGER;
              for (var i = 0; i < this.curves.length; i++) {
                var curve = this.curves[i];
                if (!curve.active) {
                  continue;
                }
                curve.getBounds(bounds, accuracy);
                out.x = Math.min(out.x, bounds.x);
                out.y = Math.min(out.y, bounds.y);
                maxRight = Math.max(maxRight, bounds.right);
                maxBottom = Math.max(maxBottom, bounds.bottom);
              }
              out.right = maxRight;
              out.bottom = maxBottom;
              return out;
            },
            getCurveLengths: function() {
              if (this.cacheLengths.length === this.curves.length) {
                return this.cacheLengths;
              }
              var lengths = [];
              var sums = 0;
              for (var i = 0; i < this.curves.length; i++) {
                sums += this.curves[i].getLength();
                lengths.push(sums);
              }
              this.cacheLengths = lengths;
              return lengths;
            },
            getEndPoint: function(out) {
              if (out === void 0) {
                out = new Vector29();
              }
              if (this.curves.length > 0) {
                this.curves[this.curves.length - 1].getPoint(1, out);
              } else {
                out.copy(this.startPoint);
              }
              return out;
            },
            getLength: function() {
              var lens = this.getCurveLengths();
              return lens[lens.length - 1];
            },
            getPoint: function(t, out) {
              if (out === void 0) {
                out = new Vector29();
              }
              var d = t * this.getLength();
              var curveLengths = this.getCurveLengths();
              var i = 0;
              while (i < curveLengths.length) {
                if (curveLengths[i] >= d) {
                  var diff = curveLengths[i] - d;
                  var curve = this.curves[i];
                  var segmentLength = curve.getLength();
                  var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                  return curve.getPointAt(u, out);
                }
                i++;
              }
              return null;
            },
            getPoints: function(divisions) {
              if (divisions === void 0) {
                divisions = 12;
              }
              var points = [];
              var last;
              for (var i = 0; i < this.curves.length; i++) {
                var curve = this.curves[i];
                if (!curve.active) {
                  continue;
                }
                var resolution = curve.getResolution(divisions);
                var pts = curve.getPoints(resolution);
                for (var j = 0; j < pts.length; j++) {
                  var point = pts[j];
                  if (last && last.equals(point)) {
                    continue;
                  }
                  points.push(point);
                  last = point;
                }
              }
              if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                points.push(points[0]);
              }
              return points;
            },
            getRandomPoint: function(out) {
              if (out === void 0) {
                out = new Vector29();
              }
              return this.getPoint(Math.random(), out);
            },
            getSpacedPoints: function(divisions) {
              if (divisions === void 0) {
                divisions = 40;
              }
              var points = [];
              for (var i = 0; i <= divisions; i++) {
                points.push(this.getPoint(i / divisions));
              }
              if (this.autoClose) {
                points.push(points[0]);
              }
              return points;
            },
            getStartPoint: function(out) {
              if (out === void 0) {
                out = new Vector29();
              }
              return out.copy(this.startPoint);
            },
            getTangent: function(t, out) {
              if (out === void 0) {
                out = new Vector29();
              }
              var d = t * this.getLength();
              var curveLengths = this.getCurveLengths();
              var i = 0;
              while (i < curveLengths.length) {
                if (curveLengths[i] >= d) {
                  var diff = curveLengths[i] - d;
                  var curve = this.curves[i];
                  var segmentLength = curve.getLength();
                  var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                  return curve.getTangentAt(u, out);
                }
                i++;
              }
              return null;
            },
            lineTo: function(x, y) {
              if (x instanceof Vector29) {
                this._tmpVec2B.copy(x);
              } else {
                this._tmpVec2B.set(x, y);
              }
              var end = this.getEndPoint(this._tmpVec2A);
              return this.add(new LineCurve([end.x, end.y, this._tmpVec2B.x, this._tmpVec2B.y]));
            },
            splineTo: function(points) {
              points.unshift(this.getEndPoint());
              return this.add(new SplineCurve(points));
            },
            moveTo: function(x, y) {
              if (x instanceof Vector29) {
                return this.add(new MovePathTo(x.x, x.y));
              } else {
                return this.add(new MovePathTo(x, y));
              }
            },
            toJSON: function() {
              var out = [];
              for (var i = 0; i < this.curves.length; i++) {
                out.push(this.curves[i].toJSON());
              }
              return {
                type: "Path",
                x: this.startPoint.x,
                y: this.startPoint.y,
                autoClose: this.autoClose,
                curves: out
              };
            },
            updateArcLengths: function() {
              this.cacheLengths = [];
              this.getCurveLengths();
            },
            destroy: function() {
              this.curves.length = 0;
              this.cacheLengths.length = 0;
              this.startPoint = void 0;
            }
          });
          GameObjectFactory.register("path", function(x, y) {
            return new Path(x, y);
          });
          module2.exports = Path;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            DataManager: __webpack_require__(98),
            DataManagerPlugin: __webpack_require__(893),
            Events: __webpack_require__(309)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var DataManager = __webpack_require__(98);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(21);
          var DataManagerPlugin = new Class({
            Extends: DataManager,
            initialize: function DataManagerPlugin2(scene) {
              DataManager.call(this, scene, scene.sys.events);
              this.scene = scene;
              this.systems = scene.sys;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function() {
              this.events = this.systems.events;
              this.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function() {
              this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            shutdown: function() {
              this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function() {
              DataManager.prototype.destroy.call(this);
              this.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
            }
          });
          PluginCache.register("DataManagerPlugin", DataManagerPlugin, "data");
          module2.exports = DataManagerPlugin;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Align: __webpack_require__(895),
            BaseShader: __webpack_require__(390),
            Bounds: __webpack_require__(898),
            Canvas: __webpack_require__(902),
            Color: __webpack_require__(391),
            ColorMatrix: __webpack_require__(195),
            Masks: __webpack_require__(912),
            RGB: __webpack_require__(197)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(122);
          var Extend = __webpack_require__(17);
          var Align = {
            In: __webpack_require__(896),
            To: __webpack_require__(897)
          };
          Align = Extend(false, Align, CONST);
          module2.exports = Align;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            BottomCenter: __webpack_require__(284),
            BottomLeft: __webpack_require__(285),
            BottomRight: __webpack_require__(286),
            Center: __webpack_require__(287),
            LeftCenter: __webpack_require__(289),
            QuickSet: __webpack_require__(283),
            RightCenter: __webpack_require__(290),
            TopCenter: __webpack_require__(291),
            TopLeft: __webpack_require__(292),
            TopRight: __webpack_require__(293)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            BottomCenter: __webpack_require__(271),
            BottomLeft: __webpack_require__(272),
            BottomRight: __webpack_require__(273),
            LeftBottom: __webpack_require__(274),
            LeftCenter: __webpack_require__(275),
            LeftTop: __webpack_require__(276),
            QuickSet: __webpack_require__(270),
            RightBottom: __webpack_require__(277),
            RightCenter: __webpack_require__(278),
            RightTop: __webpack_require__(279),
            TopCenter: __webpack_require__(280),
            TopLeft: __webpack_require__(281),
            TopRight: __webpack_require__(282)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            CenterOn: __webpack_require__(288),
            GetBottom: __webpack_require__(40),
            GetBounds: __webpack_require__(899),
            GetCenterX: __webpack_require__(84),
            GetCenterY: __webpack_require__(86),
            GetLeft: __webpack_require__(41),
            GetOffsetX: __webpack_require__(900),
            GetOffsetY: __webpack_require__(901),
            GetRight: __webpack_require__(42),
            GetTop: __webpack_require__(43),
            SetBottom: __webpack_require__(54),
            SetCenterX: __webpack_require__(85),
            SetCenterY: __webpack_require__(87),
            SetLeft: __webpack_require__(52),
            SetRight: __webpack_require__(53),
            SetTop: __webpack_require__(51)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       samme
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetBottom = __webpack_require__(40);
          var GetLeft = __webpack_require__(41);
          var GetRight = __webpack_require__(42);
          var GetTop = __webpack_require__(43);
          var GetBounds = function(gameObject, output) {
            if (output === void 0) {
              output = {};
            }
            var left = GetLeft(gameObject);
            var top = GetTop(gameObject);
            output.x = left;
            output.y = top;
            output.width = GetRight(gameObject) - left;
            output.height = GetBottom(gameObject) - top;
            return output;
          };
          module2.exports = GetBounds;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetOffsetX = function(gameObject) {
            return gameObject.width * gameObject.originX;
          };
          module2.exports = GetOffsetX;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetOffsetY = function(gameObject) {
            return gameObject.height * gameObject.originY;
          };
          module2.exports = GetOffsetY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            CanvasInterpolation: __webpack_require__(361),
            CanvasPool: __webpack_require__(31),
            Smoothing: __webpack_require__(189),
            TouchAction: __webpack_require__(903),
            UserSelect: __webpack_require__(904)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TouchAction = function(canvas, value) {
            if (value === void 0) {
              value = "none";
            }
            canvas.style["msTouchAction"] = value;
            canvas.style["ms-touch-action"] = value;
            canvas.style["touch-action"] = value;
            return canvas;
          };
          module2.exports = TouchAction;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var UserSelect = function(canvas, value) {
            if (value === void 0) {
              value = "none";
            }
            var vendors = [
              "-webkit-",
              "-khtml-",
              "-moz-",
              "-ms-",
              ""
            ];
            vendors.forEach(function(vendor) {
              canvas.style[vendor + "user-select"] = value;
            });
            canvas.style["-webkit-touch-callout"] = value;
            canvas.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
            return canvas;
          };
          module2.exports = UserSelect;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetColor = __webpack_require__(100);
          var ColorSpectrum = function(limit) {
            if (limit === void 0) {
              limit = 1024;
            }
            var colors = [];
            var range = 255;
            var i;
            var r = 255;
            var g = 0;
            var b = 0;
            for (i = 0; i <= range; i++) {
              colors.push({r, g: i, b, color: GetColor(r, i, b)});
            }
            g = 255;
            for (i = range; i >= 0; i--) {
              colors.push({r: i, g, b, color: GetColor(i, g, b)});
            }
            r = 0;
            for (i = 0; i <= range; i++, g--) {
              colors.push({r, g, b: i, color: GetColor(r, g, i)});
            }
            g = 0;
            b = 255;
            for (i = 0; i <= range; i++, b--, r++) {
              colors.push({r, g, b, color: GetColor(r, g, b)});
            }
            if (limit === 1024) {
              return colors;
            } else {
              var out = [];
              var t = 0;
              var inc = 1024 / limit;
              for (i = 0; i < limit; i++) {
                out.push(colors[Math.floor(t)]);
                t += inc;
              }
              return out;
            }
          };
          module2.exports = ColorSpectrum;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ColorToRGBA = function(color) {
            var output = {
              r: color >> 16 & 255,
              g: color >> 8 & 255,
              b: color & 255,
              a: 255
            };
            if (color > 16777215) {
              output.a = color >>> 24;
            }
            return output;
          };
          module2.exports = ColorToRGBA;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Color = __webpack_require__(37);
          var HueToComponent = __webpack_require__(393);
          var HSLToColor = function(h, s, l) {
            var r = l;
            var g = l;
            var b = l;
            if (s !== 0) {
              var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
              var p = 2 * l - q;
              r = HueToComponent(p, q, h + 1 / 3);
              g = HueToComponent(p, q, h);
              b = HueToComponent(p, q, h - 1 / 3);
            }
            var color = new Color();
            return color.setGLTo(r, g, b, 1);
          };
          module2.exports = HSLToColor;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var HSVToRGB = __webpack_require__(185);
          var HSVColorWheel = function(s, v) {
            if (s === void 0) {
              s = 1;
            }
            if (v === void 0) {
              v = 1;
            }
            var colors = [];
            for (var c = 0; c <= 359; c++) {
              colors.push(HSVToRGB(c / 359, s, v));
            }
            return colors;
          };
          module2.exports = HSVColorWheel;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Linear = __webpack_require__(133);
          var RGBWithRGB = function(r1, g1, b1, r2, g2, b2, length, index) {
            if (length === void 0) {
              length = 100;
            }
            if (index === void 0) {
              index = 0;
            }
            var t = index / length;
            return {
              r: Linear(r1, r2, t),
              g: Linear(g1, g2, t),
              b: Linear(b1, b2, t)
            };
          };
          var ColorWithColor = function(color1, color2, length, index) {
            if (length === void 0) {
              length = 100;
            }
            if (index === void 0) {
              index = 0;
            }
            return RGBWithRGB(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b, length, index);
          };
          var ColorWithRGB = function(color, r, g, b, length, index) {
            if (length === void 0) {
              length = 100;
            }
            if (index === void 0) {
              index = 0;
            }
            return RGBWithRGB(color.r, color.g, color.b, r, g, b, length, index);
          };
          module2.exports = {
            RGBWithRGB,
            ColorWithRGB,
            ColorWithColor
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Between = __webpack_require__(192);
          var Color = __webpack_require__(37);
          var RandomRGB = function(min, max) {
            if (min === void 0) {
              min = 0;
            }
            if (max === void 0) {
              max = 255;
            }
            return new Color(Between(min, max), Between(min, max), Between(min, max));
          };
          module2.exports = RandomRGB;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ComponentToHex = __webpack_require__(392);
          var RGBToString = function(r, g, b, a, prefix) {
            if (a === void 0) {
              a = 255;
            }
            if (prefix === void 0) {
              prefix = "#";
            }
            if (prefix === "#") {
              return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            } else {
              return "0x" + ComponentToHex(a) + ComponentToHex(r) + ComponentToHex(g) + ComponentToHex(b);
            }
          };
          module2.exports = RGBToString;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            BitmapMask: __webpack_require__(304),
            GeometryMask: __webpack_require__(305)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Dom = {
            AddToDOM: __webpack_require__(140),
            DOMContentLoaded: __webpack_require__(394),
            GetInnerHeight: __webpack_require__(395),
            GetScreenOrientation: __webpack_require__(396),
            GetTarget: __webpack_require__(401),
            ParseXML: __webpack_require__(402),
            RemoveFromDOM: __webpack_require__(199),
            RequestAnimationFrame: __webpack_require__(380)
          };
          module2.exports = Dom;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {EventEmitter: __webpack_require__(915)};
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var EE = __webpack_require__(9);
          var PluginCache = __webpack_require__(24);
          var EventEmitter = new Class({
            Extends: EE,
            initialize: function EventEmitter2() {
              EE.call(this);
            },
            shutdown: function() {
              this.removeAllListeners();
            },
            destroy: function() {
              this.removeAllListeners();
            }
          });
          PluginCache.register("EventEmitter", EventEmitter, "events");
          module2.exports = EventEmitter;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AddToDOM = __webpack_require__(140);
          var AnimationManager = __webpack_require__(315);
          var CacheManager = __webpack_require__(319);
          var CanvasPool = __webpack_require__(31);
          var Class = __webpack_require__(0);
          var Config = __webpack_require__(340);
          var CreateDOMContainer = __webpack_require__(917);
          var CreateRenderer = __webpack_require__(360);
          var DataManager = __webpack_require__(98);
          var DebugHeader = __webpack_require__(378);
          var Device = __webpack_require__(341);
          var DOMContentLoaded = __webpack_require__(394);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(22);
          var InputManager = __webpack_require__(403);
          var PluginCache = __webpack_require__(24);
          var PluginManager = __webpack_require__(408);
          var ScaleManager = __webpack_require__(409);
          var SceneManager = __webpack_require__(411);
          var TextureEvents = __webpack_require__(103);
          var TextureManager = __webpack_require__(416);
          var TimeStep = __webpack_require__(379);
          var VisibilityHandler = __webpack_require__(381);
          if (true) {
            var SoundManagerCreator = __webpack_require__(420);
          }
          if (false) {
            var FacebookInstantGamesPlugin;
          }
          var Game = new Class({
            initialize: function Game2(config2) {
              this.config = new Config(config2);
              this.renderer = null;
              this.domContainer = null;
              this.canvas = null;
              this.context = null;
              this.isBooted = false;
              this.isRunning = false;
              this.events = new EventEmitter();
              this.anims = new AnimationManager(this);
              this.textures = new TextureManager(this);
              this.cache = new CacheManager(this);
              this.registry = new DataManager(this);
              this.input = new InputManager(this, this.config);
              this.scene = new SceneManager(this, this.config.sceneConfig);
              this.device = Device;
              this.scale = new ScaleManager(this, this.config);
              this.sound = null;
              if (true) {
                this.sound = SoundManagerCreator.create(this);
              }
              this.loop = new TimeStep(this, this.config.fps);
              this.plugins = new PluginManager(this, this.config);
              if (false) {
              }
              this.pendingDestroy = false;
              this.removeCanvas = false;
              this.noReturn = false;
              this.hasFocus = false;
              DOMContentLoaded(this.boot.bind(this));
            },
            boot: function() {
              if (!PluginCache.hasCore("EventEmitter")) {
                console.warn("Aborting. Core Plugins missing.");
                return;
              }
              this.isBooted = true;
              this.config.preBoot(this);
              this.scale.preBoot();
              CreateRenderer(this);
              CreateDOMContainer(this);
              DebugHeader(this);
              AddToDOM(this.canvas, this.config.parent);
              this.textures.once(TextureEvents.READY, this.texturesReady, this);
              this.events.emit(Events.BOOT);
            },
            texturesReady: function() {
              this.events.emit(Events.READY);
              this.start();
            },
            start: function() {
              this.isRunning = true;
              this.config.postBoot(this);
              if (this.renderer) {
                this.loop.start(this.step.bind(this));
              } else {
                this.loop.start(this.headlessStep.bind(this));
              }
              VisibilityHandler(this);
              var eventEmitter = this.events;
              eventEmitter.on(Events.HIDDEN, this.onHidden, this);
              eventEmitter.on(Events.VISIBLE, this.onVisible, this);
              eventEmitter.on(Events.BLUR, this.onBlur, this);
              eventEmitter.on(Events.FOCUS, this.onFocus, this);
            },
            step: function(time, delta) {
              if (this.pendingDestroy) {
                return this.runDestroy();
              }
              var eventEmitter = this.events;
              eventEmitter.emit(Events.PRE_STEP, time, delta);
              eventEmitter.emit(Events.STEP, time, delta);
              this.scene.update(time, delta);
              eventEmitter.emit(Events.POST_STEP, time, delta);
              var renderer = this.renderer;
              renderer.preRender();
              eventEmitter.emit(Events.PRE_RENDER, renderer, time, delta);
              this.scene.render(renderer);
              renderer.postRender();
              eventEmitter.emit(Events.POST_RENDER, renderer, time, delta);
            },
            headlessStep: function(time, delta) {
              if (this.pendingDestroy) {
                return this.runDestroy();
              }
              var eventEmitter = this.events;
              eventEmitter.emit(Events.PRE_STEP, time, delta);
              eventEmitter.emit(Events.STEP, time, delta);
              this.scene.update(time, delta);
              eventEmitter.emit(Events.POST_STEP, time, delta);
              eventEmitter.emit(Events.PRE_RENDER);
              eventEmitter.emit(Events.POST_RENDER);
            },
            onHidden: function() {
              this.loop.pause();
              this.events.emit(Events.PAUSE);
            },
            onVisible: function() {
              this.loop.resume();
              this.events.emit(Events.RESUME);
            },
            onBlur: function() {
              this.hasFocus = false;
              this.loop.blur();
            },
            onFocus: function() {
              this.hasFocus = true;
              this.loop.focus();
            },
            getFrame: function() {
              return this.loop.frame;
            },
            getTime: function() {
              return this.loop.now;
            },
            destroy: function(removeCanvas, noReturn) {
              if (noReturn === void 0) {
                noReturn = false;
              }
              this.pendingDestroy = true;
              this.removeCanvas = removeCanvas;
              this.noReturn = noReturn;
            },
            runDestroy: function() {
              this.scene.destroy();
              this.events.emit(Events.DESTROY);
              this.events.removeAllListeners();
              if (this.renderer) {
                this.renderer.destroy();
              }
              if (this.removeCanvas && this.canvas) {
                CanvasPool.remove(this.canvas);
                if (this.canvas.parentNode) {
                  this.canvas.parentNode.removeChild(this.canvas);
                }
              }
              if (this.domContainer) {
                this.domContainer.parentNode.removeChild(this.domContainer);
              }
              this.loop.destroy();
              this.pendingDestroy = false;
            }
          });
          module2.exports = Game;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AddToDOM = __webpack_require__(140);
          var CreateDOMContainer = function(game) {
            var config2 = game.config;
            if (!config2.parent || !config2.domCreateContainer) {
              return;
            }
            var div = document.createElement("div");
            div.style.cssText = [
              "display: block;",
              "width: " + game.scale.width + "px;",
              "height: " + game.scale.height + "px;",
              "padding: 0; margin: 0;",
              "position: absolute;",
              "overflow: hidden;",
              "pointer-events: none;",
              "transform: scale(1);",
              "transform-origin: left top;"
            ].join(" ");
            game.domContainer = div;
            AddToDOM(div, config2.parent);
          };
          module2.exports = CreateDOMContainer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "boot";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "destroy";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "dragend";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "dragenter";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "drag";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "dragleave";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "dragover";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "dragstart";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "drop";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "gameout";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "gameover";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "gameobjectdown";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "dragend";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "dragenter";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "drag";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "dragleave";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "dragover";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "dragstart";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "drop";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "gameobjectmove";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "gameobjectout";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "gameobjectover";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pointerdown";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pointermove";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pointerout";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pointerover";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pointerup";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "wheel";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "gameobjectup";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "gameobjectwheel";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "boot";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "process";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "update";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pointerdown";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pointerdownoutside";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pointermove";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pointerout";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pointerover";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pointerup";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pointerupoutside";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "wheel";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pointerlockchange";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "preupdate";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "shutdown";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "start";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "update";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "addfile";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "complete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "filecomplete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "filecomplete-";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "loaderror";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "load";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "fileprogress";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "postprocess";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "progress";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "start";
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var InjectionMap = {
            game: "game",
            renderer: "renderer",
            anims: "anims",
            cache: "cache",
            plugins: "plugins",
            registry: "registry",
            scale: "scale",
            sound: "sound",
            textures: "textures",
            events: "events",
            cameras: "cameras",
            add: "add",
            make: "make",
            scenePlugin: "scene",
            displayList: "children",
            lights: "lights",
            data: "data",
            input: "input",
            load: "load",
            time: "time",
            tweens: "tweens",
            arcadePhysics: "physics",
            impactPhysics: "impact",
            matterPhysics: "matter"
          };
          if (false) {
          }
          if (false) {
          }
          module2.exports = InjectionMap;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AtlasXML = function(texture, sourceIndex, xml) {
            if (!xml.getElementsByTagName("TextureAtlas")) {
              console.warn("Invalid Texture Atlas XML given");
              return;
            }
            var source = texture.source[sourceIndex];
            texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
            var frames = xml.getElementsByTagName("SubTexture");
            var newFrame;
            for (var i = 0; i < frames.length; i++) {
              var frame = frames[i].attributes;
              var name = frame.name.value;
              var x = parseInt(frame.x.value, 10);
              var y = parseInt(frame.y.value, 10);
              var width = parseInt(frame.width.value, 10);
              var height = parseInt(frame.height.value, 10);
              newFrame = texture.add(name, sourceIndex, x, y, width, height);
              if (frame.frameX) {
                var frameX = Math.abs(parseInt(frame.frameX.value, 10));
                var frameY = Math.abs(parseInt(frame.frameY.value, 10));
                var frameWidth = parseInt(frame.frameWidth.value, 10);
                var frameHeight = parseInt(frame.frameHeight.value, 10);
                newFrame.setTrim(width, height, frameX, frameY, frameWidth, frameHeight);
              }
            }
            return texture;
          };
          module2.exports = AtlasXML;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Canvas = function(texture, sourceIndex) {
            var source = texture.source[sourceIndex];
            texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
            return texture;
          };
          module2.exports = Canvas;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Image2 = function(texture, sourceIndex) {
            var source = texture.source[sourceIndex];
            texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
            return texture;
          };
          module2.exports = Image2;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clone = __webpack_require__(77);
          var JSONArray = function(texture, sourceIndex, json) {
            if (!json["frames"] && !json["textures"]) {
              console.warn("Invalid Texture Atlas JSON Array");
              return;
            }
            var source = texture.source[sourceIndex];
            texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
            var frames = Array.isArray(json.textures) ? json.textures[sourceIndex].frames : json.frames;
            var newFrame;
            for (var i = 0; i < frames.length; i++) {
              var src = frames[i];
              newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);
              if (src.trimmed) {
                newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);
              }
              if (src.rotated) {
                newFrame.rotated = true;
                newFrame.updateUVsInverted();
              }
              var pivot = src.anchor || src.pivot;
              if (pivot) {
                newFrame.customPivot = true;
                newFrame.pivotX = pivot.x;
                newFrame.pivotY = pivot.y;
              }
              newFrame.customData = Clone(src);
            }
            for (var dataKey in json) {
              if (dataKey === "frames") {
                continue;
              }
              if (Array.isArray(json[dataKey])) {
                texture.customData[dataKey] = json[dataKey].slice(0);
              } else {
                texture.customData[dataKey] = json[dataKey];
              }
            }
            return texture;
          };
          module2.exports = JSONArray;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clone = __webpack_require__(77);
          var JSONHash = function(texture, sourceIndex, json) {
            if (!json["frames"]) {
              console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object");
              return;
            }
            var source = texture.source[sourceIndex];
            texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
            var frames = json.frames;
            var newFrame;
            for (var key in frames) {
              if (!frames.hasOwnProperty(key)) {
                continue;
              }
              var src = frames[key];
              newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);
              if (src.trimmed) {
                newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);
              }
              if (src.rotated) {
                newFrame.rotated = true;
                newFrame.updateUVsInverted();
              }
              var pivot = src.anchor || src.pivot;
              if (pivot) {
                newFrame.customPivot = true;
                newFrame.pivotX = pivot.x;
                newFrame.pivotY = pivot.y;
              }
              newFrame.customData = Clone(src);
            }
            for (var dataKey in json) {
              if (dataKey === "frames") {
                continue;
              }
              if (Array.isArray(json[dataKey])) {
                texture.customData[dataKey] = json[dataKey].slice(0);
              } else {
                texture.customData[dataKey] = json[dataKey];
              }
            }
            return texture;
          };
          module2.exports = JSONHash;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetFastValue = __webpack_require__(2);
          var SpriteSheet = function(texture, sourceIndex, x, y, width, height, config2) {
            var frameWidth = GetFastValue(config2, "frameWidth", null);
            var frameHeight = GetFastValue(config2, "frameHeight", frameWidth);
            if (frameWidth === null) {
              throw new Error("TextureManager.SpriteSheet: Invalid frameWidth given.");
            }
            var source = texture.source[sourceIndex];
            texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
            var startFrame = GetFastValue(config2, "startFrame", 0);
            var endFrame = GetFastValue(config2, "endFrame", -1);
            var margin = GetFastValue(config2, "margin", 0);
            var spacing = GetFastValue(config2, "spacing", 0);
            var row = Math.floor((width - margin + spacing) / (frameWidth + spacing));
            var column = Math.floor((height - margin + spacing) / (frameHeight + spacing));
            var total = row * column;
            if (total === 0) {
              console.warn("SpriteSheet frame dimensions will result in zero frames for texture:", texture.key);
            }
            if (startFrame > total || startFrame < -total) {
              startFrame = 0;
            }
            if (startFrame < 0) {
              startFrame = total + startFrame;
            }
            if (endFrame !== -1) {
              total = startFrame + (endFrame + 1);
            }
            var fx = margin;
            var fy = margin;
            var ax = 0;
            var ay = 0;
            for (var i = 0; i < total; i++) {
              ax = 0;
              ay = 0;
              var w = fx + frameWidth;
              var h = fy + frameHeight;
              if (w > width) {
                ax = w - width;
              }
              if (h > height) {
                ay = h - height;
              }
              texture.add(i, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);
              fx += frameWidth + spacing;
              if (fx + frameWidth > width) {
                fx = margin;
                fy += frameHeight + spacing;
              }
            }
            return texture;
          };
          module2.exports = SpriteSheet;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetFastValue = __webpack_require__(2);
          var SpriteSheetFromAtlas = function(texture, frame, config2) {
            var frameWidth = GetFastValue(config2, "frameWidth", null);
            var frameHeight = GetFastValue(config2, "frameHeight", frameWidth);
            if (!frameWidth) {
              throw new Error("TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.");
            }
            var source = texture.source[0];
            texture.add("__BASE", 0, 0, 0, source.width, source.height);
            var startFrame = GetFastValue(config2, "startFrame", 0);
            var endFrame = GetFastValue(config2, "endFrame", -1);
            var margin = GetFastValue(config2, "margin", 0);
            var spacing = GetFastValue(config2, "spacing", 0);
            var x = frame.cutX;
            var y = frame.cutY;
            var cutWidth = frame.cutWidth;
            var cutHeight = frame.cutHeight;
            var sheetWidth = frame.realWidth;
            var sheetHeight = frame.realHeight;
            var row = Math.floor((sheetWidth - margin + spacing) / (frameWidth + spacing));
            var column = Math.floor((sheetHeight - margin + spacing) / (frameHeight + spacing));
            var total = row * column;
            var leftPad = frame.x;
            var leftWidth = frameWidth - leftPad;
            var rightWidth = frameWidth - (sheetWidth - cutWidth - leftPad);
            var topPad = frame.y;
            var topHeight = frameHeight - topPad;
            var bottomHeight = frameHeight - (sheetHeight - cutHeight - topPad);
            if (startFrame > total || startFrame < -total) {
              startFrame = 0;
            }
            if (startFrame < 0) {
              startFrame = total + startFrame;
            }
            if (endFrame !== -1) {
              total = startFrame + (endFrame + 1);
            }
            var sheetFrame;
            var frameX = margin;
            var frameY = margin;
            var frameIndex = 0;
            var sourceIndex = frame.sourceIndex;
            for (var sheetY = 0; sheetY < column; sheetY++) {
              var topRow = sheetY === 0;
              var bottomRow = sheetY === column - 1;
              for (var sheetX = 0; sheetX < row; sheetX++) {
                var leftRow = sheetX === 0;
                var rightRow = sheetX === row - 1;
                sheetFrame = texture.add(frameIndex, sourceIndex, x + frameX, y + frameY, frameWidth, frameHeight);
                if (leftRow || topRow || rightRow || bottomRow) {
                  var destX = leftRow ? leftPad : 0;
                  var destY = topRow ? topPad : 0;
                  var trimWidth = 0;
                  var trimHeight = 0;
                  if (leftRow) {
                    trimWidth += frameWidth - leftWidth;
                  }
                  if (rightRow) {
                    trimWidth += frameWidth - rightWidth;
                  }
                  if (topRow) {
                    trimHeight += frameHeight - topHeight;
                  }
                  if (bottomRow) {
                    trimHeight += frameHeight - bottomHeight;
                  }
                  var destWidth = frameWidth - trimWidth;
                  var destHeight = frameHeight - trimHeight;
                  sheetFrame.cutWidth = destWidth;
                  sheetFrame.cutHeight = destHeight;
                  sheetFrame.setTrim(frameWidth, frameHeight, destX, destY, destWidth, destHeight);
                }
                frameX += spacing;
                if (leftRow) {
                  frameX += leftWidth;
                } else if (rightRow) {
                  frameX += rightWidth;
                } else {
                  frameX += frameWidth;
                }
                frameIndex++;
              }
              frameX = margin;
              frameY += spacing;
              if (topRow) {
                frameY += topHeight;
              } else if (bottomRow) {
                frameY += bottomHeight;
              } else {
                frameY += frameHeight;
              }
            }
            return texture;
          };
          module2.exports = SpriteSheetFromAtlas;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var imageHeight = 0;
          var addFrame = function(texture, sourceIndex, name, frame) {
            var y = imageHeight - frame.y - frame.height;
            texture.add(name, sourceIndex, frame.x, y, frame.width, frame.height);
          };
          var UnityYAML = function(texture, sourceIndex, yaml) {
            var source = texture.source[sourceIndex];
            texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
            imageHeight = source.height;
            var data = yaml.split("\n");
            var lineRegExp = /^[ ]*(- )*(\w+)+[: ]+(.*)/;
            var prevSprite = "";
            var currentSprite = "";
            var rect = {x: 0, y: 0, width: 0, height: 0};
            for (var i = 0; i < data.length; i++) {
              var results = data[i].match(lineRegExp);
              if (!results) {
                continue;
              }
              var isList = results[1] === "- ";
              var key = results[2];
              var value = results[3];
              if (isList) {
                if (currentSprite !== prevSprite) {
                  addFrame(texture, sourceIndex, currentSprite, rect);
                  prevSprite = currentSprite;
                }
                rect = {x: 0, y: 0, width: 0, height: 0};
              }
              if (key === "name") {
                currentSprite = value;
                continue;
              }
              switch (key) {
                case "x":
                case "y":
                case "width":
                case "height":
                  rect[key] = parseInt(value, 10);
                  break;
              }
            }
            if (currentSprite !== prevSprite) {
              addFrame(texture, sourceIndex, currentSprite, rect);
            }
            return texture;
          };
          module2.exports = UnityYAML;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "complete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "decoded";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "decodedall";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "destroy";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "detune";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "detune";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "mute";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "rate";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "volume";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "loop";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "looped";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "mute";
        },
        function(module2, exports2) {
          /**
           * @author       pi-kei
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pan";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pauseall";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pause";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "play";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "rate";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "resumeall";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "resume";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "seek";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "stopall";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "stop";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "unlocked";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "volume";
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjects = {
            Events: __webpack_require__(75),
            DisplayList: __webpack_require__(1008),
            GameObjectCreator: __webpack_require__(16),
            GameObjectFactory: __webpack_require__(5),
            UpdateList: __webpack_require__(1034),
            Components: __webpack_require__(11),
            GetCalcMatrix: __webpack_require__(19),
            BuildGameObject: __webpack_require__(28),
            BuildGameObjectAnimation: __webpack_require__(433),
            GameObject: __webpack_require__(15),
            BitmapText: __webpack_require__(147),
            Blitter: __webpack_require__(210),
            Bob: __webpack_require__(434),
            Container: __webpack_require__(211),
            DOMElement: __webpack_require__(436),
            DynamicBitmapText: __webpack_require__(212),
            Extern: __webpack_require__(438),
            Graphics: __webpack_require__(213),
            Group: __webpack_require__(110),
            Image: __webpack_require__(124),
            Layer: __webpack_require__(216),
            Particles: __webpack_require__(1068),
            PathFollower: __webpack_require__(451),
            RenderTexture: __webpack_require__(218),
            RetroFont: __webpack_require__(1076),
            Rope: __webpack_require__(220),
            Sprite: __webpack_require__(73),
            Text: __webpack_require__(221),
            GetTextSize: __webpack_require__(452),
            MeasureText: __webpack_require__(454),
            TextStyle: __webpack_require__(453),
            TileSprite: __webpack_require__(222),
            Zone: __webpack_require__(127),
            Video: __webpack_require__(223),
            Shape: __webpack_require__(33),
            Arc: __webpack_require__(455),
            Curve: __webpack_require__(456),
            Ellipse: __webpack_require__(457),
            Grid: __webpack_require__(458),
            IsoBox: __webpack_require__(459),
            IsoTriangle: __webpack_require__(460),
            Line: __webpack_require__(461),
            Polygon: __webpack_require__(462),
            Rectangle: __webpack_require__(467),
            Star: __webpack_require__(468),
            Triangle: __webpack_require__(469),
            Factories: {
              Blitter: __webpack_require__(1124),
              Container: __webpack_require__(1125),
              DOMElement: __webpack_require__(1126),
              DynamicBitmapText: __webpack_require__(1127),
              Extern: __webpack_require__(1128),
              Graphics: __webpack_require__(1129),
              Group: __webpack_require__(1130),
              Image: __webpack_require__(1131),
              Layer: __webpack_require__(1132),
              Particles: __webpack_require__(1133),
              PathFollower: __webpack_require__(1134),
              RenderTexture: __webpack_require__(1135),
              Rope: __webpack_require__(1136),
              Sprite: __webpack_require__(1137),
              StaticBitmapText: __webpack_require__(1138),
              Text: __webpack_require__(1139),
              TileSprite: __webpack_require__(1140),
              Zone: __webpack_require__(1141),
              Video: __webpack_require__(1142),
              Arc: __webpack_require__(1143),
              Curve: __webpack_require__(1144),
              Ellipse: __webpack_require__(1145),
              Grid: __webpack_require__(1146),
              IsoBox: __webpack_require__(1147),
              IsoTriangle: __webpack_require__(1148),
              Line: __webpack_require__(1149),
              Polygon: __webpack_require__(1150),
              Rectangle: __webpack_require__(1151),
              Star: __webpack_require__(1152),
              Triangle: __webpack_require__(1153)
            },
            Creators: {
              Blitter: __webpack_require__(1154),
              Container: __webpack_require__(1155),
              DynamicBitmapText: __webpack_require__(1156),
              Graphics: __webpack_require__(1157),
              Group: __webpack_require__(1158),
              Image: __webpack_require__(1159),
              Layer: __webpack_require__(1160),
              Particles: __webpack_require__(1161),
              RenderTexture: __webpack_require__(1162),
              Rope: __webpack_require__(1163),
              Sprite: __webpack_require__(1164),
              StaticBitmapText: __webpack_require__(1165),
              Text: __webpack_require__(1166),
              TileSprite: __webpack_require__(1167),
              Zone: __webpack_require__(1168),
              Video: __webpack_require__(1169)
            }
          };
          if (true) {
            GameObjects.Shader = __webpack_require__(226);
            GameObjects.Mesh = __webpack_require__(227);
            GameObjects.PointLight = __webpack_require__(149);
            GameObjects.Factories.Shader = __webpack_require__(1178);
            GameObjects.Factories.Mesh = __webpack_require__(1179);
            GameObjects.Factories.PointLight = __webpack_require__(1180);
            GameObjects.Creators.Shader = __webpack_require__(1181);
            GameObjects.Creators.Mesh = __webpack_require__(1182);
            GameObjects.Creators.PointLight = __webpack_require__(1183);
            GameObjects.Light = __webpack_require__(475);
            GameObjects.LightsManager = __webpack_require__(476);
            GameObjects.LightsPlugin = __webpack_require__(1184);
          }
          module2.exports = GameObjects;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var List = __webpack_require__(107);
          var PluginCache = __webpack_require__(24);
          var GameObjectEvents = __webpack_require__(75);
          var SceneEvents = __webpack_require__(21);
          var StableSort = __webpack_require__(79);
          var DisplayList = new Class({
            Extends: List,
            initialize: function DisplayList2(scene) {
              List.call(this, scene);
              this.sortChildrenFlag = false;
              this.scene = scene;
              this.systems = scene.sys;
              this.events = scene.sys.events;
              this.addCallback = this.addChildCallback;
              this.removeCallback = this.removeChildCallback;
              this.events.once(SceneEvents.BOOT, this.boot, this);
              this.events.on(SceneEvents.START, this.start, this);
            },
            boot: function() {
              this.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            addChildCallback: function(gameObject) {
              gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);
              if (gameObject.displayList) {
                gameObject.displayList.remove(gameObject);
              }
              gameObject.displayList = this;
              this.queueDepthSort();
              this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);
            },
            removeChildCallback: function(gameObject) {
              gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
              gameObject.displayList = null;
              this.queueDepthSort();
              this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
            },
            start: function() {
              this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            queueDepthSort: function() {
              this.sortChildrenFlag = true;
            },
            depthSort: function() {
              if (this.sortChildrenFlag) {
                StableSort(this.list, this.sortByDepth);
                this.sortChildrenFlag = false;
              }
            },
            sortByDepth: function(childA, childB) {
              return childA._depth - childB._depth;
            },
            getChildren: function() {
              return this.list;
            },
            shutdown: function() {
              var list = this.list;
              var i = list.length;
              while (i--) {
                list[i].destroy(true);
              }
              list.length = 0;
              this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function() {
              this.shutdown();
              this.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
              this.events = null;
            }
          });
          PluginCache.register("DisplayList", DisplayList, "displayList");
          module2.exports = DisplayList;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            CheckMatrix: __webpack_require__(206),
            MatrixToString: __webpack_require__(1010),
            ReverseColumns: __webpack_require__(1011),
            ReverseRows: __webpack_require__(1012),
            Rotate180: __webpack_require__(1013),
            RotateLeft: __webpack_require__(1014),
            RotateMatrix: __webpack_require__(146),
            RotateRight: __webpack_require__(1015),
            Translate: __webpack_require__(1016),
            TransposeMatrix: __webpack_require__(429)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Pad = __webpack_require__(183);
          var CheckMatrix = __webpack_require__(206);
          var MatrixToString = function(matrix) {
            var str = "";
            if (!CheckMatrix(matrix)) {
              return str;
            }
            for (var r = 0; r < matrix.length; r++) {
              for (var c = 0; c < matrix[r].length; c++) {
                var cell = matrix[r][c].toString();
                if (cell !== "undefined") {
                  str += Pad(cell, 2);
                } else {
                  str += "?";
                }
                if (c < matrix[r].length - 1) {
                  str += " |";
                }
              }
              if (r < matrix.length - 1) {
                str += "\n";
                for (var i = 0; i < matrix[r].length; i++) {
                  str += "---";
                  if (i < matrix[r].length - 1) {
                    str += "+";
                  }
                }
                str += "\n";
              }
            }
            return str;
          };
          module2.exports = MatrixToString;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ReverseColumns = function(matrix) {
            return matrix.reverse();
          };
          module2.exports = ReverseColumns;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ReverseRows = function(matrix) {
            for (var i = 0; i < matrix.length; i++) {
              matrix[i].reverse();
            }
            return matrix;
          };
          module2.exports = ReverseRows;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateMatrix = __webpack_require__(146);
          var Rotate180 = function(matrix) {
            return RotateMatrix(matrix, 180);
          };
          module2.exports = Rotate180;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateMatrix = __webpack_require__(146);
          var RotateLeft = function(matrix) {
            return RotateMatrix(matrix, 90);
          };
          module2.exports = RotateLeft;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateMatrix = __webpack_require__(146);
          var RotateRight = function(matrix) {
            return RotateMatrix(matrix, -90);
          };
          module2.exports = RotateRight;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateLeft = __webpack_require__(175);
          var RotateRight = __webpack_require__(176);
          var TranslateMatrix = function(matrix, x, y) {
            if (x === void 0) {
              x = 0;
            }
            if (y === void 0) {
              y = 0;
            }
            if (y !== 0) {
              if (y < 0) {
                RotateLeft(matrix, Math.abs(y));
              } else {
                RotateRight(matrix, y);
              }
            }
            if (x !== 0) {
              for (var i = 0; i < matrix.length; i++) {
                var row = matrix[i];
                if (x < 0) {
                  RotateLeft(row, Math.abs(x));
                } else {
                  RotateRight(row, x);
                }
              }
            }
            return matrix;
          };
          module2.exports = TranslateMatrix;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Add = function(array, item, limit, callback, context) {
            if (context === void 0) {
              context = array;
            }
            if (limit > 0) {
              var remaining = limit - array.length;
              if (remaining <= 0) {
                return null;
              }
            }
            if (!Array.isArray(item)) {
              if (array.indexOf(item) === -1) {
                array.push(item);
                if (callback) {
                  callback.call(context, item);
                }
                return item;
              } else {
                return null;
              }
            }
            var itemLength = item.length - 1;
            while (itemLength >= 0) {
              if (array.indexOf(item[itemLength]) !== -1) {
                item.splice(itemLength, 1);
              }
              itemLength--;
            }
            itemLength = item.length;
            if (itemLength === 0) {
              return null;
            }
            if (limit > 0 && itemLength > remaining) {
              item.splice(remaining);
              itemLength = remaining;
            }
            for (var i = 0; i < itemLength; i++) {
              var entry = item[i];
              array.push(entry);
              if (callback) {
                callback.call(context, entry);
              }
            }
            return item;
          };
          module2.exports = Add;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AddAt = function(array, item, index, limit, callback, context) {
            if (index === void 0) {
              index = 0;
            }
            if (context === void 0) {
              context = array;
            }
            if (limit > 0) {
              var remaining = limit - array.length;
              if (remaining <= 0) {
                return null;
              }
            }
            if (!Array.isArray(item)) {
              if (array.indexOf(item) === -1) {
                array.splice(index, 0, item);
                if (callback) {
                  callback.call(context, item);
                }
                return item;
              } else {
                return null;
              }
            }
            var itemLength = item.length - 1;
            while (itemLength >= 0) {
              if (array.indexOf(item[itemLength]) !== -1) {
                item.pop();
              }
              itemLength--;
            }
            itemLength = item.length;
            if (itemLength === 0) {
              return null;
            }
            if (limit > 0 && itemLength > remaining) {
              item.splice(remaining);
              itemLength = remaining;
            }
            for (var i = itemLength - 1; i >= 0; i--) {
              var entry = item[i];
              array.splice(index, 0, entry);
              if (callback) {
                callback.call(context, entry);
              }
            }
            return item;
          };
          module2.exports = AddAt;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BringToTop = function(array, item) {
            var currentIndex = array.indexOf(item);
            if (currentIndex !== -1 && currentIndex < array.length) {
              array.splice(currentIndex, 1);
              array.push(item);
            }
            return item;
          };
          module2.exports = BringToTop;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SafeRange = __webpack_require__(78);
          var CountAllMatching = function(array, property, value, startIndex, endIndex) {
            if (startIndex === void 0) {
              startIndex = 0;
            }
            if (endIndex === void 0) {
              endIndex = array.length;
            }
            var total = 0;
            if (SafeRange(array, startIndex, endIndex)) {
              for (var i = startIndex; i < endIndex; i++) {
                var child = array[i];
                if (child[property] === value) {
                  total++;
                }
              }
            }
            return total;
          };
          module2.exports = CountAllMatching;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Each = function(array, callback, context) {
            var i;
            var args = [null];
            for (i = 3; i < arguments.length; i++) {
              args.push(arguments[i]);
            }
            for (i = 0; i < array.length; i++) {
              args[0] = array[i];
              callback.apply(context, args);
            }
            return array;
          };
          module2.exports = Each;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SafeRange = __webpack_require__(78);
          var EachInRange = function(array, callback, context, startIndex, endIndex) {
            if (startIndex === void 0) {
              startIndex = 0;
            }
            if (endIndex === void 0) {
              endIndex = array.length;
            }
            if (SafeRange(array, startIndex, endIndex)) {
              var i;
              var args = [null];
              for (i = 5; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (i = startIndex; i < endIndex; i++) {
                args[0] = array[i];
                callback.apply(context, args);
              }
            }
            return array;
          };
          module2.exports = EachInRange;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MoveDown = function(array, item) {
            var currentIndex = array.indexOf(item);
            if (currentIndex > 0) {
              var item2 = array[currentIndex - 1];
              var index2 = array.indexOf(item2);
              array[currentIndex] = item2;
              array[index2] = item;
            }
            return array;
          };
          module2.exports = MoveDown;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MoveTo = function(array, item, index) {
            var currentIndex = array.indexOf(item);
            if (currentIndex === -1 || index < 0 || index >= array.length) {
              throw new Error("Supplied index out of bounds");
            }
            if (currentIndex !== index) {
              array.splice(currentIndex, 1);
              array.splice(index, 0, item);
            }
            return item;
          };
          module2.exports = MoveTo;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MoveUp = function(array, item) {
            var currentIndex = array.indexOf(item);
            if (currentIndex !== -1 && currentIndex < array.length - 1) {
              var item2 = array[currentIndex + 1];
              var index2 = array.indexOf(item2);
              array[currentIndex] = item2;
              array[index2] = item;
            }
            return array;
          };
          module2.exports = MoveUp;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RoundAwayFromZero = __webpack_require__(357);
          var NumberArrayStep = function(start, end, step) {
            if (start === void 0) {
              start = 0;
            }
            if (end === void 0) {
              end = null;
            }
            if (step === void 0) {
              step = 1;
            }
            if (end === null) {
              end = start;
              start = 0;
            }
            var result = [];
            var total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0);
            for (var i = 0; i < total; i++) {
              result.push(start);
              start += step;
            }
            return result;
          };
          module2.exports = NumberArrayStep;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SpliceOne = __webpack_require__(74);
          var RemoveAt = function(array, index, callback, context) {
            if (context === void 0) {
              context = array;
            }
            if (index < 0 || index > array.length - 1) {
              throw new Error("Index out of bounds");
            }
            var item = SpliceOne(array, index);
            if (callback) {
              callback.call(context, item);
            }
            return item;
          };
          module2.exports = RemoveAt;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SafeRange = __webpack_require__(78);
          var RemoveBetween = function(array, startIndex, endIndex, callback, context) {
            if (startIndex === void 0) {
              startIndex = 0;
            }
            if (endIndex === void 0) {
              endIndex = array.length;
            }
            if (context === void 0) {
              context = array;
            }
            if (SafeRange(array, startIndex, endIndex)) {
              var size = endIndex - startIndex;
              var removed = array.splice(startIndex, size);
              if (callback) {
                for (var i = 0; i < removed.length; i++) {
                  var entry = removed[i];
                  callback.call(context, entry);
                }
              }
              return removed;
            } else {
              return [];
            }
          };
          module2.exports = RemoveBetween;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SpliceOne = __webpack_require__(74);
          var RemoveRandomElement = function(array, start, length) {
            if (start === void 0) {
              start = 0;
            }
            if (length === void 0) {
              length = array.length;
            }
            var randomIndex = start + Math.floor(Math.random() * length);
            return SpliceOne(array, randomIndex);
          };
          module2.exports = RemoveRandomElement;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Replace = function(array, oldChild, newChild) {
            var index1 = array.indexOf(oldChild);
            var index2 = array.indexOf(newChild);
            if (index1 !== -1 && index2 === -1) {
              array[index1] = newChild;
              return true;
            } else {
              return false;
            }
          };
          module2.exports = Replace;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SendToBack = function(array, item) {
            var currentIndex = array.indexOf(item);
            if (currentIndex !== -1 && currentIndex > 0) {
              array.splice(currentIndex, 1);
              array.unshift(item);
            }
            return item;
          };
          module2.exports = SendToBack;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SafeRange = __webpack_require__(78);
          var SetAll = function(array, property, value, startIndex, endIndex) {
            if (startIndex === void 0) {
              startIndex = 0;
            }
            if (endIndex === void 0) {
              endIndex = array.length;
            }
            if (SafeRange(array, startIndex, endIndex)) {
              for (var i = startIndex; i < endIndex; i++) {
                var entry = array[i];
                if (entry.hasOwnProperty(property)) {
                  entry[property] = value;
                }
              }
            }
            return array;
          };
          module2.exports = SetAll;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Swap = function(array, item1, item2) {
            if (item1 === item2) {
              return;
            }
            var index1 = array.indexOf(item1);
            var index2 = array.indexOf(item2);
            if (index1 < 0 || index2 < 0) {
              throw new Error("Supplied items must be elements of the same array");
            }
            array[index1] = item2;
            array[index2] = item1;
            return array;
          };
          module2.exports = Swap;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var ProcessQueue = __webpack_require__(208);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(21);
          var UpdateList = new Class({
            Extends: ProcessQueue,
            initialize: function UpdateList2(scene) {
              ProcessQueue.call(this);
              this.checkQueue = true;
              this.scene = scene;
              this.systems = scene.sys;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function() {
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function() {
              var eventEmitter = this.systems.events;
              eventEmitter.on(SceneEvents.PRE_UPDATE, this.update, this);
              eventEmitter.on(SceneEvents.UPDATE, this.sceneUpdate, this);
              eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            sceneUpdate: function(time, delta) {
              var list = this._active;
              var length = list.length;
              for (var i = 0; i < length; i++) {
                var gameObject = list[i];
                if (gameObject.active) {
                  gameObject.preUpdate.call(gameObject, time, delta);
                }
              }
            },
            shutdown: function() {
              var i = this._active.length;
              while (i--) {
                this._active[i].destroy(true);
              }
              i = this._pending.length;
              while (i--) {
                this._pending[i].destroy(true);
              }
              i = this._destroy.length;
              while (i--) {
                this._destroy[i].destroy(true);
              }
              this._toProcess = 0;
              this._pending = [];
              this._active = [];
              this._destroy = [];
              this.removeAllListeners();
              var eventEmitter = this.systems.events;
              eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
              eventEmitter.off(SceneEvents.UPDATE, this.sceneUpdate, this);
              eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function() {
              this.shutdown();
              this.systems.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
            }
          });
          PluginCache.register("UpdateList", UpdateList, "updateList");
          module2.exports = UpdateList;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "add";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "remove";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetBitmapTextSize = function(src, round, updateOrigin, out) {
            if (updateOrigin === void 0) {
              updateOrigin = false;
            }
            if (out === void 0) {
              out = {
                local: {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                },
                global: {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                },
                lines: {
                  shortest: 0,
                  longest: 0,
                  lengths: null,
                  height: 0
                },
                wrappedText: "",
                words: [],
                characters: [],
                scaleX: 0,
                scaleY: 0
              };
              return out;
            }
            var text = src.text;
            var textLength = text.length;
            var maxWidth = src.maxWidth;
            var wordWrapCharCode = src.wordWrapCharCode;
            var bx = Number.MAX_VALUE;
            var by = Number.MAX_VALUE;
            var bw = 0;
            var bh = 0;
            var chars = src.fontData.chars;
            var lineHeight = src.fontData.lineHeight;
            var letterSpacing = src.letterSpacing;
            var xAdvance = 0;
            var yAdvance = 0;
            var charCode = 0;
            var glyph = null;
            var align = src._align;
            var x = 0;
            var y = 0;
            var scale = src.fontSize / src.fontData.size;
            var sx = scale * src.scaleX;
            var sy = scale * src.scaleY;
            var lastGlyph = null;
            var lastCharCode = 0;
            var lineWidths = [];
            var shortestLine = Number.MAX_VALUE;
            var longestLine = 0;
            var currentLine = 0;
            var currentLineWidth = 0;
            var i;
            var words = [];
            var characters = [];
            var current = null;
            if (maxWidth > 0) {
              for (i = 0; i < textLength; i++) {
                charCode = text.charCodeAt(i);
                if (charCode === 10) {
                  if (current !== null) {
                    words.push({
                      word: current.word,
                      i: current.i,
                      x: current.x * sx,
                      y: current.y * sy,
                      w: current.w * sx,
                      h: current.h * sy,
                      cr: true
                    });
                    current = null;
                  }
                  xAdvance = 0;
                  yAdvance += lineHeight;
                  lastGlyph = null;
                  continue;
                }
                glyph = chars[charCode];
                if (!glyph) {
                  continue;
                }
                if (lastGlyph !== null) {
                  var glyphKerningOffset = glyph.kerning[lastCharCode];
                }
                if (charCode === wordWrapCharCode) {
                  if (current !== null) {
                    words.push({
                      word: current.word,
                      i: current.i,
                      x: current.x * sx,
                      y: current.y * sy,
                      w: current.w * sx,
                      h: current.h * sy,
                      cr: false
                    });
                    current = null;
                  }
                } else {
                  if (current === null) {
                    current = {word: "", i, x: xAdvance, y: yAdvance, w: 0, h: lineHeight, cr: false};
                  }
                  current.word = current.word.concat(text[i]);
                  current.w += glyph.xOffset + glyph.xAdvance + (glyphKerningOffset !== void 0 ? glyphKerningOffset : 0);
                }
                xAdvance += glyph.xAdvance + letterSpacing;
                lastGlyph = glyph;
                lastCharCode = charCode;
              }
              if (current !== null) {
                words.push({
                  word: current.word,
                  i: current.i,
                  x: current.x * sx,
                  y: current.y * sy,
                  w: current.w * sx,
                  h: current.h * sy,
                  cr: false
                });
              }
              xAdvance = 0;
              yAdvance = 0;
              lastGlyph = null;
              lastCharCode = 0;
              var prev;
              var offset = 0;
              var crs = [];
              for (i = 0; i < words.length; i++) {
                var entry = words[i];
                var left = entry.x;
                var right = entry.x + entry.w;
                if (prev) {
                  var diff = left - (prev.x + prev.w);
                  offset = left - (diff + prev.w);
                  prev = null;
                }
                var checkLeft = left - offset;
                var checkRight = right - offset;
                if (checkLeft > maxWidth || checkRight > maxWidth) {
                  crs.push(entry.i - 1);
                  if (entry.cr) {
                    crs.push(entry.i + entry.word.length);
                    offset = 0;
                    prev = null;
                  } else {
                    prev = entry;
                  }
                } else if (entry.cr) {
                  crs.push(entry.i + entry.word.length);
                  offset = 0;
                  prev = null;
                }
              }
              var stringInsert = function(str, index, value) {
                return str.substr(0, index) + value + str.substr(index + 1);
              };
              for (i = crs.length - 1; i >= 0; i--) {
                text = stringInsert(text, crs[i], "\n");
              }
              out.wrappedText = text;
              textLength = text.length;
              words = [];
              current = null;
            }
            var charIndex = 0;
            for (i = 0; i < textLength; i++) {
              charCode = text.charCodeAt(i);
              if (charCode === 10) {
                if (current !== null) {
                  words.push({
                    word: current.word,
                    i: current.i,
                    x: current.x * sx,
                    y: current.y * sy,
                    w: current.w * sx,
                    h: current.h * sy
                  });
                  current = null;
                }
                xAdvance = 0;
                yAdvance += lineHeight;
                lastGlyph = null;
                lineWidths[currentLine] = currentLineWidth;
                if (currentLineWidth > longestLine) {
                  longestLine = currentLineWidth;
                }
                if (currentLineWidth < shortestLine) {
                  shortestLine = currentLineWidth;
                }
                currentLine++;
                currentLineWidth = 0;
                continue;
              }
              glyph = chars[charCode];
              if (!glyph) {
                continue;
              }
              x = xAdvance;
              y = yAdvance;
              if (lastGlyph !== null) {
                var kerningOffset = glyph.kerning[lastCharCode];
                x += kerningOffset !== void 0 ? kerningOffset : 0;
              }
              if (bx > x) {
                bx = x;
              }
              if (by > y) {
                by = y;
              }
              var gw = x + glyph.xAdvance;
              var gh = y + lineHeight;
              if (bw < gw) {
                bw = gw;
              }
              if (bh < gh) {
                bh = gh;
              }
              var charWidth = glyph.xOffset + glyph.xAdvance + (kerningOffset !== void 0 ? kerningOffset : 0);
              if (charCode === wordWrapCharCode) {
                if (current !== null) {
                  words.push({
                    word: current.word,
                    i: current.i,
                    x: current.x * sx,
                    y: current.y * sy,
                    w: current.w * sx,
                    h: current.h * sy
                  });
                  current = null;
                }
              } else {
                if (current === null) {
                  current = {word: "", i: charIndex, x: xAdvance, y: yAdvance, w: 0, h: lineHeight};
                }
                current.word = current.word.concat(text[i]);
                current.w += charWidth;
              }
              characters.push({
                i: charIndex,
                char: text[i],
                code: charCode,
                x: (glyph.xOffset + xAdvance) * scale,
                y: (glyph.yOffset + yAdvance) * scale,
                w: glyph.width * scale,
                h: glyph.height * scale,
                t: yAdvance * scale,
                r: gw * scale,
                b: lineHeight * scale,
                line: currentLine,
                glyph
              });
              xAdvance += glyph.xAdvance + letterSpacing;
              lastGlyph = glyph;
              lastCharCode = charCode;
              currentLineWidth = gw * scale;
              charIndex++;
            }
            if (current !== null) {
              words.push({
                word: current.word,
                i: current.i,
                x: current.x * sx,
                y: current.y * sy,
                w: current.w * sx,
                h: current.h * sy
              });
            }
            lineWidths[currentLine] = currentLineWidth;
            if (currentLineWidth > longestLine) {
              longestLine = currentLineWidth;
            }
            if (currentLineWidth < shortestLine) {
              shortestLine = currentLineWidth;
            }
            if (align > 0) {
              for (var c = 0; c < characters.length; c++) {
                var currentChar = characters[c];
                if (align === 1) {
                  var ax1 = (longestLine - lineWidths[currentChar.line]) / 2;
                  currentChar.x += ax1;
                  currentChar.r += ax1;
                } else if (align === 2) {
                  var ax2 = longestLine - lineWidths[currentChar.line];
                  currentChar.x += ax2;
                  currentChar.r += ax2;
                }
              }
            }
            var local = out.local;
            var global2 = out.global;
            var lines = out.lines;
            local.x = bx * scale;
            local.y = by * scale;
            local.width = bw * scale;
            local.height = bh * scale;
            global2.x = src.x - src._displayOriginX + bx * sx;
            global2.y = src.y - src._displayOriginY + by * sy;
            global2.width = bw * sx;
            global2.height = bh * sy;
            lines.shortest = shortestLine;
            lines.longest = longestLine;
            lines.lengths = lineWidths;
            if (round) {
              local.x = Math.ceil(local.x);
              local.y = Math.ceil(local.y);
              local.width = Math.ceil(local.width);
              local.height = Math.ceil(local.height);
              global2.x = Math.ceil(global2.x);
              global2.y = Math.ceil(global2.y);
              global2.width = Math.ceil(global2.width);
              global2.height = Math.ceil(global2.height);
              lines.shortest = Math.ceil(shortestLine);
              lines.longest = Math.ceil(longestLine);
            }
            if (updateOrigin) {
              src._displayOriginX = src.originX * local.width;
              src._displayOriginY = src.originY * local.height;
              global2.x = src.x - src._displayOriginX * src.scaleX;
              global2.y = src.y - src._displayOriginY * src.scaleY;
              if (round) {
                global2.x = Math.ceil(global2.x);
                global2.y = Math.ceil(global2.y);
              }
            }
            out.words = words;
            out.characters = characters;
            out.lines.height = lineHeight;
            out.scale = scale;
            out.scaleX = src.scaleX;
            out.scaleY = src.scaleY;
            return out;
          };
          module2.exports = GetBitmapTextSize;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ParseXMLBitmapFont = __webpack_require__(209);
          var ParseFromAtlas = function(scene, fontName, textureKey, frameKey, xmlKey, xSpacing, ySpacing) {
            var texture = scene.sys.textures.get(textureKey);
            var frame = texture.get(frameKey);
            var xml = scene.sys.cache.xml.get(xmlKey);
            if (frame && xml) {
              var data = ParseXMLBitmapFont(xml, frame, xSpacing, ySpacing, texture);
              scene.sys.cache.bitmapFont.add(fontName, {data, texture: textureKey, frame: frameKey});
              return true;
            } else {
              return false;
            }
          };
          module2.exports = ParseFromAtlas;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1040);
          }
          if (true) {
            renderCanvas = __webpack_require__(1042);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BatchChar = __webpack_require__(1041);
          var GetCalcMatrix = __webpack_require__(19);
          var Utils = __webpack_require__(12);
          var BitmapTextWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            var text = src._text;
            var textLength = text.length;
            if (textLength === 0) {
              return;
            }
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            var roundPixels = camera.roundPixels;
            var cameraAlpha = camera.alpha;
            var charColors = src.charColors;
            var tintEffect = src.tintFill;
            var getTint = Utils.getTintAppendFloatAlpha;
            var tintTL = getTint(src.tintTopLeft, cameraAlpha * src._alphaTL);
            var tintTR = getTint(src.tintTopRight, cameraAlpha * src._alphaTR);
            var tintBL = getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL);
            var tintBR = getTint(src.tintBottomRight, cameraAlpha * src._alphaBR);
            var texture = src.frame.glTexture;
            var textureUnit = pipeline.setGameObject(src);
            var bounds = src.getTextBounds(false);
            var i;
            var char;
            var glyph;
            var characters = bounds.characters;
            var dropShadowX = src.dropShadowX;
            var dropShadowY = src.dropShadowY;
            var dropShadow = dropShadowX !== 0 || dropShadowY !== 0;
            renderer.pipelines.preBatch(src);
            if (dropShadow) {
              var srcShadowColor = src.dropShadowColor;
              var srcShadowAlpha = src.dropShadowAlpha;
              var shadowTL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTL);
              var shadowTR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTR);
              var shadowBL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBL);
              var shadowBR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBR);
              for (i = 0; i < characters.length; i++) {
                char = characters[i];
                glyph = char.glyph;
                if (char.code === 32 || glyph.width === 0 || glyph.height === 0) {
                  continue;
                }
                BatchChar(pipeline, src, char, glyph, dropShadowX, dropShadowY, calcMatrix, roundPixels, shadowTL, shadowTR, shadowBL, shadowBR, 1, texture, textureUnit);
              }
            }
            for (i = 0; i < characters.length; i++) {
              char = characters[i];
              glyph = char.glyph;
              if (char.code === 32 || glyph.width === 0 || glyph.height === 0) {
                continue;
              }
              if (charColors[char.i]) {
                var color = charColors[char.i];
                var charTintEffect = color.tintEffect;
                var charTintTL = getTint(color.tintTL, cameraAlpha * src._alphaTL);
                var charTintTR = getTint(color.tintTR, cameraAlpha * src._alphaTR);
                var charTintBL = getTint(color.tintBL, cameraAlpha * src._alphaBL);
                var charTintBR = getTint(color.tintBR, cameraAlpha * src._alphaBR);
                BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, charTintTL, charTintTR, charTintBL, charTintBR, charTintEffect, texture, textureUnit);
              } else {
                BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
              }
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = BitmapTextWebGLRenderer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BatchChar = function(pipeline, src, char, glyph, offsetX, offsetY, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit) {
            var x = char.x - src.displayOriginX + offsetX;
            var y = char.y - src.displayOriginY + offsetY;
            var xw = x + char.w;
            var yh = y + char.h;
            var tx0 = calcMatrix.getXRound(x, y, roundPixels);
            var ty0 = calcMatrix.getYRound(x, y, roundPixels);
            var tx1 = calcMatrix.getXRound(x, yh, roundPixels);
            var ty1 = calcMatrix.getYRound(x, yh, roundPixels);
            var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);
            var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);
            var tx3 = calcMatrix.getXRound(xw, y, roundPixels);
            var ty3 = calcMatrix.getYRound(xw, y, roundPixels);
            pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, glyph.u0, glyph.v0, glyph.u1, glyph.v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
          };
          module2.exports = BatchChar;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetTransform = __webpack_require__(30);
          var BitmapTextCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            var text = src._text;
            var textLength = text.length;
            var ctx = renderer.currentContext;
            if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              return;
            }
            camera.addToRenderList(src);
            var textureFrame = src.texture.frames["__BASE"];
            var chars = src.fontData.chars;
            var lineHeight = src.fontData.lineHeight;
            var letterSpacing = src._letterSpacing;
            var xAdvance = 0;
            var yAdvance = 0;
            var charCode = 0;
            var glyph = null;
            var glyphX = 0;
            var glyphY = 0;
            var glyphW = 0;
            var glyphH = 0;
            var x = 0;
            var y = 0;
            var lastGlyph = null;
            var lastCharCode = 0;
            var image = textureFrame.source.image;
            var textureX = textureFrame.cutX;
            var textureY = textureFrame.cutY;
            var scale = src._fontSize / src.fontData.size;
            var align = src._align;
            var currentLine = 0;
            var lineOffsetX = 0;
            var bounds = src.getTextBounds(false);
            if (src.maxWidth > 0) {
              text = bounds.wrappedText;
              textLength = text.length;
            }
            var lineData = src._bounds.lines;
            if (align === 1) {
              lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
            } else if (align === 2) {
              lineOffsetX = lineData.longest - lineData.lengths[0];
            }
            ctx.translate(-src.displayOriginX, -src.displayOriginY);
            var roundPixels = camera.roundPixels;
            for (var i = 0; i < textLength; i++) {
              charCode = text.charCodeAt(i);
              if (charCode === 10) {
                currentLine++;
                if (align === 1) {
                  lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
                } else if (align === 2) {
                  lineOffsetX = lineData.longest - lineData.lengths[currentLine];
                }
                xAdvance = 0;
                yAdvance += lineHeight;
                lastGlyph = null;
                continue;
              }
              glyph = chars[charCode];
              if (!glyph) {
                continue;
              }
              glyphX = textureX + glyph.x;
              glyphY = textureY + glyph.y;
              glyphW = glyph.width;
              glyphH = glyph.height;
              x = glyph.xOffset + xAdvance;
              y = glyph.yOffset + yAdvance;
              if (lastGlyph !== null) {
                var kerningOffset = glyph.kerning[lastCharCode];
                x += kerningOffset !== void 0 ? kerningOffset : 0;
              }
              x *= scale;
              y *= scale;
              x += lineOffsetX;
              xAdvance += glyph.xAdvance + letterSpacing;
              lastGlyph = glyph;
              lastCharCode = charCode;
              if (glyphW === 0 || glyphH === 0 || charCode === 32) {
                continue;
              }
              if (roundPixels) {
                x = Math.round(x);
                y = Math.round(y);
              }
              ctx.save();
              ctx.translate(x, y);
              ctx.scale(scale, scale);
              ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
              ctx.restore();
            }
            ctx.restore();
          };
          module2.exports = BitmapTextCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1044);
          }
          if (true) {
            renderCanvas = __webpack_require__(1045);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TransformMatrix = __webpack_require__(25);
          var Utils = __webpack_require__(12);
          var tempMatrix = new TransformMatrix();
          var BlitterWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            var list = src.getRenderList();
            if (list.length === 0) {
              return src.clearRenderDepth(camera);
            }
            src.setRenderDepth(camera);
            var pipeline = renderer.pipelines.set(this.pipeline, src);
            var cameraScrollX = camera.scrollX * src.scrollFactorX;
            var cameraScrollY = camera.scrollY * src.scrollFactorY;
            var calcMatrix = tempMatrix.copyFrom(camera.matrix);
            if (parentMatrix) {
              calcMatrix.multiplyWithOffset(parentMatrix, -cameraScrollX, -cameraScrollY);
              cameraScrollX = 0;
              cameraScrollY = 0;
            }
            var blitterX = src.x - cameraScrollX;
            var blitterY = src.y - cameraScrollY;
            var prevTextureSourceIndex = -1;
            var tintEffect = false;
            var alpha = camera.alpha * src.alpha;
            var roundPixels = camera.roundPixels;
            renderer.pipelines.preBatch(src);
            for (var index = 0; index < list.length; index++) {
              var bob = list[index];
              var frame = bob.frame;
              var bobAlpha = bob.alpha * alpha;
              if (bobAlpha === 0) {
                continue;
              }
              var width = frame.width;
              var height = frame.height;
              var x = blitterX + bob.x + frame.x;
              var y = blitterY + bob.y + frame.y;
              if (bob.flipX) {
                width *= -1;
                x += frame.width;
              }
              if (bob.flipY) {
                height *= -1;
                y += frame.height;
              }
              var xw = x + width;
              var yh = y + height;
              var tx0 = calcMatrix.getX(x, y);
              var ty0 = calcMatrix.getY(x, y);
              var tx1 = calcMatrix.getX(xw, yh);
              var ty1 = calcMatrix.getY(xw, yh);
              var tint = Utils.getTintAppendFloatAlpha(bob.tint, bobAlpha);
              if (frame.sourceIndex !== prevTextureSourceIndex) {
                var textureUnit = pipeline.setGameObject(src, frame);
                prevTextureSourceIndex = frame.sourceIndex;
              }
              if (roundPixels) {
                tx0 = Math.round(tx0);
                ty0 = Math.round(ty0);
                tx1 = Math.round(tx1);
                ty1 = Math.round(ty1);
              }
              if (pipeline.batchQuad(src, tx0, ty0, tx0, ty1, tx1, ty1, tx1, ty0, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, frame.glTexture, textureUnit)) {
                prevTextureSourceIndex = -1;
              }
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = BlitterWebGLRenderer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BlitterCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            var list = src.getRenderList();
            if (list.length === 0) {
              return;
            }
            var ctx = renderer.currentContext;
            var alpha = camera.alpha * src.alpha;
            if (alpha === 0) {
              return;
            }
            camera.addToRenderList(src);
            ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
            ctx.imageSmoothingEnabled = !(!renderer.antialias || src.frame.source.scaleMode);
            var cameraScrollX = src.x - camera.scrollX * src.scrollFactorX;
            var cameraScrollY = src.y - camera.scrollY * src.scrollFactorY;
            ctx.save();
            if (parentMatrix) {
              parentMatrix.copyToContext(ctx);
            }
            var roundPixels = camera.roundPixels;
            for (var i = 0; i < list.length; i++) {
              var bob = list[i];
              var flip = bob.flipX || bob.flipY;
              var frame = bob.frame;
              var cd = frame.canvasData;
              var dx = frame.x;
              var dy = frame.y;
              var fx = 1;
              var fy = 1;
              var bobAlpha = bob.alpha * alpha;
              if (bobAlpha === 0) {
                continue;
              }
              ctx.globalAlpha = bobAlpha;
              if (!flip) {
                if (roundPixels) {
                  dx = Math.round(dx);
                  dy = Math.round(dy);
                }
                ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, dx + bob.x + cameraScrollX, dy + bob.y + cameraScrollY, cd.width, cd.height);
              } else {
                if (bob.flipX) {
                  fx = -1;
                  dx -= cd.width;
                }
                if (bob.flipY) {
                  fy = -1;
                  dy -= cd.height;
                }
                ctx.save();
                ctx.translate(bob.x + cameraScrollX, bob.y + cameraScrollY);
                ctx.scale(fx, fy);
                ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, dx, dy, cd.width, cd.height);
                ctx.restore();
              }
            }
            ctx.restore();
          };
          module2.exports = BlitterCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Felipe Alfonso <@bitnenfer>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1047);
          }
          if (true) {
            renderCanvas = __webpack_require__(1048);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Felipe Alfonso <@bitnenfer>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ContainerWebGLRenderer = function(renderer, container, camera, parentMatrix) {
            var children = container.list;
            var childCount = children.length;
            if (childCount === 0) {
              return;
            }
            var transformMatrix = container.localTransform;
            if (parentMatrix) {
              transformMatrix.loadIdentity();
              transformMatrix.multiply(parentMatrix);
              transformMatrix.translate(container.x, container.y);
              transformMatrix.rotate(container.rotation);
              transformMatrix.scale(container.scaleX, container.scaleY);
            } else {
              transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
            }
            renderer.pipelines.preBatch(container);
            var containerHasBlendMode = container.blendMode !== -1;
            if (!containerHasBlendMode) {
              renderer.setBlendMode(0);
            }
            var alpha = container.alpha;
            var scrollFactorX = container.scrollFactorX;
            var scrollFactorY = container.scrollFactorY;
            for (var i = 0; i < childCount; i++) {
              var child = children[i];
              if (!child.willRender(camera)) {
                continue;
              }
              var childAlphaTopLeft;
              var childAlphaTopRight;
              var childAlphaBottomLeft;
              var childAlphaBottomRight;
              if (child.alphaTopLeft !== void 0) {
                childAlphaTopLeft = child.alphaTopLeft;
                childAlphaTopRight = child.alphaTopRight;
                childAlphaBottomLeft = child.alphaBottomLeft;
                childAlphaBottomRight = child.alphaBottomRight;
              } else {
                var childAlpha = child.alpha;
                childAlphaTopLeft = childAlpha;
                childAlphaTopRight = childAlpha;
                childAlphaBottomLeft = childAlpha;
                childAlphaBottomRight = childAlpha;
              }
              var childScrollFactorX = child.scrollFactorX;
              var childScrollFactorY = child.scrollFactorY;
              if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
                renderer.setBlendMode(child.blendMode);
              }
              var mask = child.mask;
              if (mask) {
                mask.preRenderWebGL(renderer, child, camera);
              }
              var type = child.type;
              if (type !== renderer.currentType) {
                renderer.newType = true;
                renderer.currentType = type;
              }
              renderer.nextTypeMatch = i < childCount - 1 ? children[i + 1].type === renderer.currentType : false;
              child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);
              child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);
              child.renderWebGL(renderer, child, camera, transformMatrix);
              child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);
              child.setScrollFactor(childScrollFactorX, childScrollFactorY);
              if (mask) {
                mask.postRenderWebGL(renderer, camera);
              }
              renderer.newType = false;
            }
            renderer.pipelines.postBatch(container);
          };
          module2.exports = ContainerWebGLRenderer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Felipe Alfonso <@bitnenfer>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ContainerCanvasRenderer = function(renderer, container, camera, parentMatrix) {
            var children = container.list;
            if (children.length === 0) {
              return;
            }
            var transformMatrix = container.localTransform;
            if (parentMatrix) {
              transformMatrix.loadIdentity();
              transformMatrix.multiply(parentMatrix);
              transformMatrix.translate(container.x, container.y);
              transformMatrix.rotate(container.rotation);
              transformMatrix.scale(container.scaleX, container.scaleY);
            } else {
              transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
            }
            var containerHasBlendMode = container.blendMode !== -1;
            if (!containerHasBlendMode) {
              renderer.setBlendMode(0);
            }
            var alpha = container._alpha;
            var scrollFactorX = container.scrollFactorX;
            var scrollFactorY = container.scrollFactorY;
            if (container.mask) {
              container.mask.preRenderCanvas(renderer, null, camera);
            }
            for (var i = 0; i < children.length; i++) {
              var child = children[i];
              if (!child.willRender(camera)) {
                continue;
              }
              var childAlpha = child.alpha;
              var childScrollFactorX = child.scrollFactorX;
              var childScrollFactorY = child.scrollFactorY;
              if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
                renderer.setBlendMode(child.blendMode);
              }
              child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);
              child.setAlpha(childAlpha * alpha);
              child.renderCanvas(renderer, child, camera, transformMatrix);
              child.setAlpha(childAlpha);
              child.setScrollFactor(childScrollFactorX, childScrollFactorY);
            }
            if (container.mask) {
              container.mask.postRenderCanvas(renderer);
            }
          };
          module2.exports = ContainerCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(437);
          }
          if (true) {
            renderCanvas = __webpack_require__(437);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = [
            "normal",
            "multiply",
            "multiply",
            "screen",
            "overlay",
            "darken",
            "lighten",
            "color-dodge",
            "color-burn",
            "hard-light",
            "soft-light",
            "difference",
            "exclusion",
            "hue",
            "saturation",
            "color",
            "luminosity"
          ];
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1052);
          }
          if (true) {
            renderCanvas = __webpack_require__(1053);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCalcMatrix = __webpack_require__(19);
          var TransformMatrix = __webpack_require__(25);
          var Utils = __webpack_require__(12);
          var tempMatrix = new TransformMatrix();
          var DynamicBitmapTextWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            var text = src.text;
            var textLength = text.length;
            if (textLength === 0) {
              return;
            }
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var spriteMatrix = result.sprite;
            var calcMatrix = result.calc;
            var fontMatrix = tempMatrix;
            var crop = src.cropWidth > 0 || src.cropHeight > 0;
            if (crop) {
              pipeline.flush();
              renderer.pushScissor(calcMatrix.tx, calcMatrix.ty, src.cropWidth * calcMatrix.scaleX, src.cropHeight * calcMatrix.scaleY);
            }
            var frame = src.frame;
            var texture = frame.glTexture;
            var tintEffect = src.tintFill;
            var tintTL = Utils.getTintAppendFloatAlpha(src.tintTopLeft, camera.alpha * src._alphaTL);
            var tintTR = Utils.getTintAppendFloatAlpha(src.tintTopRight, camera.alpha * src._alphaTR);
            var tintBL = Utils.getTintAppendFloatAlpha(src.tintBottomLeft, camera.alpha * src._alphaBL);
            var tintBR = Utils.getTintAppendFloatAlpha(src.tintBottomRight, camera.alpha * src._alphaBR);
            var textureUnit = pipeline.setGameObject(src);
            var xAdvance = 0;
            var yAdvance = 0;
            var charCode = 0;
            var lastCharCode = 0;
            var letterSpacing = src.letterSpacing;
            var glyph;
            var glyphW = 0;
            var glyphH = 0;
            var lastGlyph;
            var scrollX = src.scrollX;
            var scrollY = src.scrollY;
            var fontData = src.fontData;
            var chars = fontData.chars;
            var lineHeight = fontData.lineHeight;
            var scale = src.fontSize / fontData.size;
            var rotation = 0;
            var align = src._align;
            var currentLine = 0;
            var lineOffsetX = 0;
            var bounds = src.getTextBounds(false);
            if (src.maxWidth > 0) {
              text = bounds.wrappedText;
              textLength = text.length;
            }
            var lineData = src._bounds.lines;
            if (align === 1) {
              lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
            } else if (align === 2) {
              lineOffsetX = lineData.longest - lineData.lengths[0];
            }
            var roundPixels = camera.roundPixels;
            var displayCallback = src.displayCallback;
            var callbackData = src.callbackData;
            renderer.pipelines.preBatch(src);
            for (var i = 0; i < textLength; i++) {
              charCode = text.charCodeAt(i);
              if (charCode === 10) {
                currentLine++;
                if (align === 1) {
                  lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
                } else if (align === 2) {
                  lineOffsetX = lineData.longest - lineData.lengths[currentLine];
                }
                xAdvance = 0;
                yAdvance += lineHeight;
                lastGlyph = null;
                continue;
              }
              glyph = chars[charCode];
              if (!glyph) {
                continue;
              }
              glyphW = glyph.width;
              glyphH = glyph.height;
              var x = glyph.xOffset + xAdvance - scrollX;
              var y = glyph.yOffset + yAdvance - scrollY;
              if (lastGlyph !== null) {
                var kerningOffset = glyph.kerning[lastCharCode];
                x += kerningOffset !== void 0 ? kerningOffset : 0;
              }
              xAdvance += glyph.xAdvance + letterSpacing;
              lastGlyph = glyph;
              lastCharCode = charCode;
              if (glyphW === 0 || glyphH === 0 || charCode === 32) {
                continue;
              }
              scale = src.fontSize / src.fontData.size;
              rotation = 0;
              if (displayCallback) {
                callbackData.color = 0;
                callbackData.tint.topLeft = tintTL;
                callbackData.tint.topRight = tintTR;
                callbackData.tint.bottomLeft = tintBL;
                callbackData.tint.bottomRight = tintBR;
                callbackData.index = i;
                callbackData.charCode = charCode;
                callbackData.x = x;
                callbackData.y = y;
                callbackData.scale = scale;
                callbackData.rotation = rotation;
                callbackData.data = glyph.data;
                var output = displayCallback(callbackData);
                x = output.x;
                y = output.y;
                scale = output.scale;
                rotation = output.rotation;
                if (output.color) {
                  tintTL = output.color;
                  tintTR = output.color;
                  tintBL = output.color;
                  tintBR = output.color;
                } else {
                  tintTL = output.tint.topLeft;
                  tintTR = output.tint.topRight;
                  tintBL = output.tint.bottomLeft;
                  tintBR = output.tint.bottomRight;
                }
                tintTL = Utils.getTintAppendFloatAlpha(tintTL, camera.alpha * src._alphaTL);
                tintTR = Utils.getTintAppendFloatAlpha(tintTR, camera.alpha * src._alphaTR);
                tintBL = Utils.getTintAppendFloatAlpha(tintBL, camera.alpha * src._alphaBL);
                tintBR = Utils.getTintAppendFloatAlpha(tintBR, camera.alpha * src._alphaBR);
              }
              x *= scale;
              y *= scale;
              x -= src.displayOriginX;
              y -= src.displayOriginY;
              x += lineOffsetX;
              fontMatrix.applyITRS(x, y, rotation, scale, scale);
              calcMatrix.multiply(fontMatrix, spriteMatrix);
              var u0 = glyph.u0;
              var v0 = glyph.v0;
              var u1 = glyph.u1;
              var v1 = glyph.v1;
              var xw = glyphW;
              var yh = glyphH;
              var tx0 = spriteMatrix.e;
              var ty0 = spriteMatrix.f;
              var tx1 = yh * spriteMatrix.c + spriteMatrix.e;
              var ty1 = yh * spriteMatrix.d + spriteMatrix.f;
              var tx2 = xw * spriteMatrix.a + yh * spriteMatrix.c + spriteMatrix.e;
              var ty2 = xw * spriteMatrix.b + yh * spriteMatrix.d + spriteMatrix.f;
              var tx3 = xw * spriteMatrix.a + spriteMatrix.e;
              var ty3 = xw * spriteMatrix.b + spriteMatrix.f;
              if (roundPixels) {
                tx0 = Math.round(tx0);
                ty0 = Math.round(ty0);
                tx1 = Math.round(tx1);
                ty1 = Math.round(ty1);
                tx2 = Math.round(tx2);
                ty2 = Math.round(ty2);
                tx3 = Math.round(tx3);
                ty3 = Math.round(ty3);
              }
              pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
            }
            if (crop) {
              pipeline.flush();
              renderer.popScissor();
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = DynamicBitmapTextWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetTransform = __webpack_require__(30);
          var DynamicBitmapTextCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            var text = src._text;
            var textLength = text.length;
            var ctx = renderer.currentContext;
            if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              return;
            }
            camera.addToRenderList(src);
            var textureFrame = src.frame;
            var displayCallback = src.displayCallback;
            var callbackData = src.callbackData;
            var chars = src.fontData.chars;
            var lineHeight = src.fontData.lineHeight;
            var letterSpacing = src._letterSpacing;
            var xAdvance = 0;
            var yAdvance = 0;
            var charCode = 0;
            var glyph = null;
            var glyphX = 0;
            var glyphY = 0;
            var glyphW = 0;
            var glyphH = 0;
            var x = 0;
            var y = 0;
            var lastGlyph = null;
            var lastCharCode = 0;
            var image = src.frame.source.image;
            var textureX = textureFrame.cutX;
            var textureY = textureFrame.cutY;
            var rotation = 0;
            var scale = 0;
            var baseScale = src._fontSize / src.fontData.size;
            var align = src._align;
            var currentLine = 0;
            var lineOffsetX = 0;
            src.getTextBounds(false);
            var lineData = src._bounds.lines;
            if (align === 1) {
              lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
            } else if (align === 2) {
              lineOffsetX = lineData.longest - lineData.lengths[0];
            }
            ctx.translate(-src.displayOriginX, -src.displayOriginY);
            var roundPixels = camera.roundPixels;
            if (src.cropWidth > 0 && src.cropHeight > 0) {
              ctx.beginPath();
              ctx.rect(0, 0, src.cropWidth, src.cropHeight);
              ctx.clip();
            }
            for (var i = 0; i < textLength; i++) {
              scale = baseScale;
              rotation = 0;
              charCode = text.charCodeAt(i);
              if (charCode === 10) {
                currentLine++;
                if (align === 1) {
                  lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
                } else if (align === 2) {
                  lineOffsetX = lineData.longest - lineData.lengths[currentLine];
                }
                xAdvance = 0;
                yAdvance += lineHeight;
                lastGlyph = null;
                continue;
              }
              glyph = chars[charCode];
              if (!glyph) {
                continue;
              }
              glyphX = textureX + glyph.x;
              glyphY = textureY + glyph.y;
              glyphW = glyph.width;
              glyphH = glyph.height;
              x = glyph.xOffset + xAdvance - src.scrollX;
              y = glyph.yOffset + yAdvance - src.scrollY;
              if (lastGlyph !== null) {
                var kerningOffset = glyph.kerning[lastCharCode];
                x += kerningOffset !== void 0 ? kerningOffset : 0;
              }
              if (displayCallback) {
                callbackData.index = i;
                callbackData.charCode = charCode;
                callbackData.x = x;
                callbackData.y = y;
                callbackData.scale = scale;
                callbackData.rotation = rotation;
                callbackData.data = glyph.data;
                var output = displayCallback(callbackData);
                x = output.x;
                y = output.y;
                scale = output.scale;
                rotation = output.rotation;
              }
              x *= scale;
              y *= scale;
              x += lineOffsetX;
              xAdvance += glyph.xAdvance + letterSpacing;
              lastGlyph = glyph;
              lastCharCode = charCode;
              if (glyphW === 0 || glyphH === 0 || charCode === 32) {
                continue;
              }
              if (roundPixels) {
                x = Math.round(x);
                y = Math.round(y);
              }
              ctx.save();
              ctx.translate(x, y);
              ctx.rotate(rotation);
              ctx.scale(scale, scale);
              ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
              ctx.restore();
            }
            ctx.restore();
          };
          module2.exports = DynamicBitmapTextCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1055);
          }
          if (true) {
            renderCanvas = __webpack_require__(1056);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCalcMatrix = __webpack_require__(19);
          var ExternWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            renderer.pipelines.clear();
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            src.render.call(src, renderer, camera, calcMatrix);
            renderer.pipelines.rebind();
          };
          module2.exports = ExternWebGLRenderer;
        },
        function(module2, exports2) {
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1058);
            renderCanvas = __webpack_require__(442);
          }
          if (true) {
            renderCanvas = __webpack_require__(442);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Commands = __webpack_require__(214);
          var GetCalcMatrix = __webpack_require__(19);
          var TransformMatrix = __webpack_require__(25);
          var Utils = __webpack_require__(12);
          var Point = function(x, y, width) {
            this.x = x;
            this.y = y;
            this.width = width;
          };
          var Path = function(x, y, width) {
            this.points = [];
            this.pointsLength = 1;
            this.points[0] = new Point(x, y, width);
          };
          var matrixStack = [];
          var tempMatrix = new TransformMatrix();
          var GraphicsWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            if (src.commandBuffer.length === 0) {
              return;
            }
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            renderer.pipelines.preBatch(src);
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            var currentMatrix = tempMatrix.loadIdentity();
            var commands = src.commandBuffer;
            var alpha = camera.alpha * src.alpha;
            var lineWidth = 1;
            var fillTint = pipeline.fillTint;
            var strokeTint = pipeline.strokeTint;
            var tx = 0;
            var ty = 0;
            var ta = 0;
            var iterStep = 0.01;
            var PI2 = Math.PI * 2;
            var cmd;
            var path = [];
            var pathIndex = 0;
            var pathOpen = true;
            var lastPath = null;
            var getTint = Utils.getTintAppendFloatAlpha;
            for (var cmdIndex = 0; cmdIndex < commands.length; cmdIndex++) {
              cmd = commands[cmdIndex];
              switch (cmd) {
                case Commands.BEGIN_PATH: {
                  path.length = 0;
                  lastPath = null;
                  pathOpen = true;
                  break;
                }
                case Commands.CLOSE_PATH: {
                  pathOpen = false;
                  if (lastPath && lastPath.points.length) {
                    lastPath.points.push(lastPath.points[0]);
                  }
                  break;
                }
                case Commands.FILL_PATH: {
                  for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                    pipeline.batchFillPath(path[pathIndex].points, currentMatrix, calcMatrix);
                  }
                  break;
                }
                case Commands.STROKE_PATH: {
                  for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                    pipeline.batchStrokePath(path[pathIndex].points, lineWidth, pathOpen, currentMatrix, calcMatrix);
                  }
                  break;
                }
                case Commands.LINE_STYLE: {
                  lineWidth = commands[++cmdIndex];
                  var strokeColor = commands[++cmdIndex];
                  var strokeAlpha = commands[++cmdIndex] * alpha;
                  var strokeTintColor = getTint(strokeColor, strokeAlpha);
                  strokeTint.TL = strokeTintColor;
                  strokeTint.TR = strokeTintColor;
                  strokeTint.BL = strokeTintColor;
                  strokeTint.BR = strokeTintColor;
                  break;
                }
                case Commands.FILL_STYLE: {
                  var fillColor = commands[++cmdIndex];
                  var fillAlpha = commands[++cmdIndex] * alpha;
                  var fillTintColor = getTint(fillColor, fillAlpha);
                  fillTint.TL = fillTintColor;
                  fillTint.TR = fillTintColor;
                  fillTint.BL = fillTintColor;
                  fillTint.BR = fillTintColor;
                  break;
                }
                case Commands.GRADIENT_FILL_STYLE: {
                  var alphaTL = commands[++cmdIndex] * alpha;
                  var alphaTR = commands[++cmdIndex] * alpha;
                  var alphaBL = commands[++cmdIndex] * alpha;
                  var alphaBR = commands[++cmdIndex] * alpha;
                  fillTint.TL = getTint(commands[++cmdIndex], alphaTL);
                  fillTint.TR = getTint(commands[++cmdIndex], alphaTR);
                  fillTint.BL = getTint(commands[++cmdIndex], alphaBL);
                  fillTint.BR = getTint(commands[++cmdIndex], alphaBR);
                  break;
                }
                case Commands.GRADIENT_LINE_STYLE: {
                  lineWidth = commands[++cmdIndex];
                  var gradientLineAlpha = commands[++cmdIndex] * alpha;
                  strokeTint.TL = getTint(commands[++cmdIndex], gradientLineAlpha);
                  strokeTint.TR = getTint(commands[++cmdIndex], gradientLineAlpha);
                  strokeTint.BL = getTint(commands[++cmdIndex], gradientLineAlpha);
                  strokeTint.BR = getTint(commands[++cmdIndex], gradientLineAlpha);
                  break;
                }
                case Commands.ARC: {
                  var iteration = 0;
                  var x = commands[++cmdIndex];
                  var y = commands[++cmdIndex];
                  var radius = commands[++cmdIndex];
                  var startAngle = commands[++cmdIndex];
                  var endAngle = commands[++cmdIndex];
                  var anticlockwise = commands[++cmdIndex];
                  var overshoot = commands[++cmdIndex];
                  endAngle -= startAngle;
                  if (anticlockwise) {
                    if (endAngle < -PI2) {
                      endAngle = -PI2;
                    } else if (endAngle > 0) {
                      endAngle = -PI2 + endAngle % PI2;
                    }
                  } else if (endAngle > PI2) {
                    endAngle = PI2;
                  } else if (endAngle < 0) {
                    endAngle = PI2 + endAngle % PI2;
                  }
                  if (lastPath === null) {
                    lastPath = new Path(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius, lineWidth);
                    path.push(lastPath);
                    iteration += iterStep;
                  }
                  while (iteration < 1 + overshoot) {
                    ta = endAngle * iteration + startAngle;
                    tx = x + Math.cos(ta) * radius;
                    ty = y + Math.sin(ta) * radius;
                    lastPath.points.push(new Point(tx, ty, lineWidth));
                    iteration += iterStep;
                  }
                  ta = endAngle + startAngle;
                  tx = x + Math.cos(ta) * radius;
                  ty = y + Math.sin(ta) * radius;
                  lastPath.points.push(new Point(tx, ty, lineWidth));
                  break;
                }
                case Commands.FILL_RECT: {
                  pipeline.batchFillRect(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, calcMatrix);
                  break;
                }
                case Commands.FILL_TRIANGLE: {
                  pipeline.batchFillTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, calcMatrix);
                  break;
                }
                case Commands.STROKE_TRIANGLE: {
                  pipeline.batchStrokeTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], lineWidth, currentMatrix, calcMatrix);
                  break;
                }
                case Commands.LINE_TO: {
                  if (lastPath !== null) {
                    lastPath.points.push(new Point(commands[++cmdIndex], commands[++cmdIndex], lineWidth));
                  } else {
                    lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);
                    path.push(lastPath);
                  }
                  break;
                }
                case Commands.MOVE_TO: {
                  lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);
                  path.push(lastPath);
                  break;
                }
                case Commands.SAVE: {
                  matrixStack.push(currentMatrix.copyToArray());
                  break;
                }
                case Commands.RESTORE: {
                  currentMatrix.copyFromArray(matrixStack.pop());
                  break;
                }
                case Commands.TRANSLATE: {
                  x = commands[++cmdIndex];
                  y = commands[++cmdIndex];
                  currentMatrix.translate(x, y);
                  break;
                }
                case Commands.SCALE: {
                  x = commands[++cmdIndex];
                  y = commands[++cmdIndex];
                  currentMatrix.scale(x, y);
                  break;
                }
                case Commands.ROTATE: {
                  currentMatrix.rotate(commands[++cmdIndex]);
                  break;
                }
              }
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = GraphicsWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1060);
          }
          if (true) {
            renderCanvas = __webpack_require__(1061);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SpriteWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            src.pipeline.batchSprite(src, camera, parentMatrix);
          };
          module2.exports = SpriteWebGLRenderer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SpriteCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            renderer.batchSprite(src, src.frame, camera, parentMatrix);
          };
          module2.exports = SpriteCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1063);
          }
          if (true) {
            renderCanvas = __webpack_require__(1064);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ImageWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            this.pipeline.batchSprite(src, camera, parentMatrix);
          };
          module2.exports = ImageWebGLRenderer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ImageCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            renderer.batchSprite(src, src.frame, camera, parentMatrix);
          };
          module2.exports = ImageCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1066);
          }
          if (true) {
            renderCanvas = __webpack_require__(1067);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var LayerWebGLRenderer = function(renderer, layer, camera) {
            var children = layer.list;
            var childCount = children.length;
            if (childCount === 0) {
              return;
            }
            layer.depthSort();
            renderer.pipelines.preBatch(layer);
            var layerHasBlendMode = layer.blendMode !== -1;
            if (!layerHasBlendMode) {
              renderer.setBlendMode(0);
            }
            var alpha = layer.alpha;
            for (var i = 0; i < childCount; i++) {
              var child = children[i];
              if (!child.willRender(camera)) {
                continue;
              }
              var childAlphaTopLeft;
              var childAlphaTopRight;
              var childAlphaBottomLeft;
              var childAlphaBottomRight;
              if (child.alphaTopLeft !== void 0) {
                childAlphaTopLeft = child.alphaTopLeft;
                childAlphaTopRight = child.alphaTopRight;
                childAlphaBottomLeft = child.alphaBottomLeft;
                childAlphaBottomRight = child.alphaBottomRight;
              } else {
                var childAlpha = child.alpha;
                childAlphaTopLeft = childAlpha;
                childAlphaTopRight = childAlpha;
                childAlphaBottomLeft = childAlpha;
                childAlphaBottomRight = childAlpha;
              }
              if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
                renderer.setBlendMode(child.blendMode);
              }
              var mask = child.mask;
              if (mask) {
                mask.preRenderWebGL(renderer, child, camera);
              }
              var type = child.type;
              if (type !== renderer.currentType) {
                renderer.newType = true;
                renderer.currentType = type;
              }
              renderer.nextTypeMatch = i < childCount - 1 ? children[i + 1].type === renderer.currentType : false;
              child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);
              child.renderWebGL(renderer, child, camera);
              child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);
              if (mask) {
                mask.postRenderWebGL(renderer, camera);
              }
              renderer.newType = false;
            }
            renderer.pipelines.postBatch(layer);
          };
          module2.exports = LayerWebGLRenderer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var LayerCanvasRenderer = function(renderer, layer, camera) {
            var children = layer.list;
            if (children.length === 0) {
              return;
            }
            layer.depthSort();
            var layerHasBlendMode = layer.blendMode !== -1;
            if (!layerHasBlendMode) {
              renderer.setBlendMode(0);
            }
            var alpha = layer._alpha;
            if (layer.mask) {
              layer.mask.preRenderCanvas(renderer, null, camera);
            }
            for (var i = 0; i < children.length; i++) {
              var child = children[i];
              if (!child.willRender(camera)) {
                continue;
              }
              var childAlpha = child.alpha;
              if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
                renderer.setBlendMode(child.blendMode);
              }
              child.setAlpha(childAlpha * alpha);
              child.renderCanvas(renderer, child, camera);
              child.setAlpha(childAlpha);
            }
            if (layer.mask) {
              layer.mask.postRenderCanvas(renderer);
            }
          };
          module2.exports = LayerCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            EmitterOp: __webpack_require__(443),
            GravityWell: __webpack_require__(444),
            Particle: __webpack_require__(445),
            ParticleEmitter: __webpack_require__(446),
            ParticleEmitterManager: __webpack_require__(217),
            Zones: __webpack_require__(1072)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1070);
          }
          if (true) {
            renderCanvas = __webpack_require__(1071);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TransformMatrix = __webpack_require__(25);
          var Utils = __webpack_require__(12);
          var tempMatrix1 = new TransformMatrix();
          var tempMatrix2 = new TransformMatrix();
          var tempMatrix3 = new TransformMatrix();
          var tempMatrix4 = new TransformMatrix();
          var ParticleManagerWebGLRenderer = function(renderer, emitterManager, camera, parentMatrix) {
            var emitters = emitterManager.emitters.list;
            var emittersLength = emitters.length;
            if (emittersLength === 0) {
              return;
            }
            var pipeline = renderer.pipelines.set(emitterManager.pipeline);
            var camMatrix = tempMatrix1;
            var calcMatrix = tempMatrix2;
            var particleMatrix = tempMatrix3;
            var managerMatrix = tempMatrix4;
            if (parentMatrix) {
              managerMatrix.loadIdentity();
              managerMatrix.multiply(parentMatrix);
              managerMatrix.translate(emitterManager.x, emitterManager.y);
              managerMatrix.rotate(emitterManager.rotation);
              managerMatrix.scale(emitterManager.scaleX, emitterManager.scaleY);
            } else {
              managerMatrix.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);
            }
            var roundPixels = camera.roundPixels;
            var texture = emitterManager.defaultFrame.glTexture;
            var getTint = Utils.getTintAppendFloatAlpha;
            var textureUnit = pipeline.setGameObject(emitterManager, emitterManager.defaultFrame);
            renderer.pipelines.preBatch(emitterManager);
            for (var e = 0; e < emittersLength; e++) {
              var emitter = emitters[e];
              var particles = emitter.alive;
              var particleCount = particles.length;
              if (!emitter.visible || particleCount === 0) {
                continue;
              }
              camera.addToRenderList(emitter);
              var scrollFactorX = emitter.scrollFactorX;
              var scrollFactorY = emitter.scrollFactorY;
              renderer.setBlendMode(emitter.blendMode);
              if (emitter.mask) {
                emitter.mask.preRenderWebGL(renderer, emitter, camera);
                renderer.pipelines.set(emitterManager.pipeline);
              }
              var tintEffect = 0;
              for (var i = 0; i < particleCount; i++) {
                var particle = particles[i];
                var alpha = particle.alpha * camera.alpha;
                if (alpha <= 0) {
                  continue;
                }
                particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);
                camMatrix.copyFrom(camera.matrix);
                camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
                particleMatrix.e = particle.x;
                particleMatrix.f = particle.y;
                camMatrix.multiply(particleMatrix, calcMatrix);
                var frame = particle.frame;
                var x = -frame.halfWidth;
                var y = -frame.halfHeight;
                var xw = x + frame.width;
                var yh = y + frame.height;
                var tx0 = calcMatrix.getXRound(x, y, roundPixels);
                var ty0 = calcMatrix.getYRound(x, y, roundPixels);
                var tx1 = calcMatrix.getXRound(x, yh, roundPixels);
                var ty1 = calcMatrix.getYRound(x, yh, roundPixels);
                var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);
                var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);
                var tx3 = calcMatrix.getXRound(xw, y, roundPixels);
                var ty3 = calcMatrix.getYRound(xw, y, roundPixels);
                var tint = getTint(particle.tint, alpha);
                pipeline.batchQuad(emitter, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, texture, textureUnit);
              }
              if (emitter.mask) {
                emitter.mask.postRenderWebGL(renderer, camera);
              }
            }
            renderer.pipelines.postBatch(emitterManager);
          };
          module2.exports = ParticleManagerWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TransformMatrix = __webpack_require__(25);
          var tempMatrix1 = new TransformMatrix();
          var tempMatrix2 = new TransformMatrix();
          var tempMatrix3 = new TransformMatrix();
          var tempMatrix4 = new TransformMatrix();
          var ParticleManagerCanvasRenderer = function(renderer, emitterManager, camera, parentMatrix) {
            var emitters = emitterManager.emitters.list;
            var emittersLength = emitters.length;
            if (emittersLength === 0) {
              return;
            }
            var camMatrix = tempMatrix1.copyFrom(camera.matrix);
            var calcMatrix = tempMatrix2;
            var particleMatrix = tempMatrix3;
            var managerMatrix = tempMatrix4;
            if (parentMatrix) {
              managerMatrix.loadIdentity();
              managerMatrix.multiply(parentMatrix);
              managerMatrix.translate(emitterManager.x, emitterManager.y);
              managerMatrix.rotate(emitterManager.rotation);
              managerMatrix.scale(emitterManager.scaleX, emitterManager.scaleY);
            } else {
              managerMatrix.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);
            }
            var ctx = renderer.currentContext;
            var roundPixels = camera.roundPixels;
            for (var e = 0; e < emittersLength; e++) {
              var emitter = emitters[e];
              var particles = emitter.alive;
              var particleCount = particles.length;
              if (!emitter.visible || particleCount === 0) {
                continue;
              }
              camera.addToRenderList(emitter);
              var followX = emitter.follow ? emitter.follow.x + emitter.followOffset.x : 0;
              var followY = emitter.follow ? emitter.follow.y + emitter.followOffset.y : 0;
              var scrollFactorX = emitter.scrollFactorX;
              var scrollFactorY = emitter.scrollFactorY;
              ctx.save();
              ctx.globalCompositeOperation = renderer.blendModes[emitter.blendMode];
              for (var i = 0; i < particleCount; i++) {
                var particle = particles[i];
                var alpha = particle.alpha * camera.alpha;
                if (alpha <= 0) {
                  continue;
                }
                particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);
                camMatrix.copyFrom(camera.matrix);
                camMatrix.multiplyWithOffset(managerMatrix, followX + -camera.scrollX * scrollFactorX, followY + -camera.scrollY * scrollFactorY);
                particleMatrix.e = particle.x;
                particleMatrix.f = particle.y;
                camMatrix.multiply(particleMatrix, calcMatrix);
                var frame = particle.frame;
                var cd = frame.canvasData;
                var x = -frame.halfWidth;
                var y = -frame.halfHeight;
                ctx.globalAlpha = alpha;
                ctx.save();
                calcMatrix.setToContext(ctx);
                if (roundPixels) {
                  x = Math.round(x);
                  y = Math.round(y);
                }
                ctx.imageSmoothingEnabled = !(!renderer.antialias || frame.source.scaleMode);
                ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);
                ctx.restore();
              }
              ctx.restore();
            }
          };
          module2.exports = ParticleManagerCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            DeathZone: __webpack_require__(447),
            EdgeZone: __webpack_require__(448),
            RandomZone: __webpack_require__(450)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1074);
          }
          if (true) {
            renderCanvas = __webpack_require__(1075);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Utils = __webpack_require__(12);
          var RenderTextureWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var cameraAlpha = camera.alpha;
            var renderTarget = src.renderTarget;
            var width = renderTarget.width;
            var height = renderTarget.height;
            var getTint = Utils.getTintAppendFloatAlpha;
            var pipeline = renderer.pipelines.set(src.pipeline);
            var textureUnit = pipeline.setTexture2D(renderTarget.texture);
            renderer.pipelines.preBatch(src);
            pipeline.batchTexture(src, renderTarget.texture, width, height, src.x, src.y, width, height, src.scaleX, src.scaleY, src.rotation, src.flipX, !src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, cameraAlpha * src._alphaTL), getTint(src.tintTopRight, cameraAlpha * src._alphaTR), getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL), getTint(src.tintBottomRight, cameraAlpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, true, textureUnit);
            renderer.resetTextures();
            renderer.pipelines.postBatch(src);
          };
          module2.exports = RenderTextureWebGLRenderer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RenderTextureCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            renderer.batchSprite(src, src.frame, camera, parentMatrix);
          };
          module2.exports = RenderTextureCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RETRO_FONT_CONST = __webpack_require__(1077);
          var Extend = __webpack_require__(17);
          var RetroFont = {Parse: __webpack_require__(1078)};
          RetroFont = Extend(false, RetroFont, RETRO_FONT_CONST);
          module2.exports = RetroFont;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RETRO_FONT_CONST = {
            TEXT_SET1: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
            TEXT_SET2: ` !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ`,
            TEXT_SET3: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ",
            TEXT_SET4: "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789",
            TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789",
            TEXT_SET6: `ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.' `,
            TEXT_SET7: `AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-'39`,
            TEXT_SET8: "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ",
            TEXT_SET9: `ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'"?!`,
            TEXT_SET10: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
            TEXT_SET11: `ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()':;0123456789`
          };
          module2.exports = RETRO_FONT_CONST;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetValue = __webpack_require__(6);
          var ParseRetroFont = function(scene, config2) {
            var w = config2.width;
            var h = config2.height;
            var cx = Math.floor(w / 2);
            var cy = Math.floor(h / 2);
            var letters = GetValue(config2, "chars", "");
            if (letters === "") {
              return;
            }
            var key = GetValue(config2, "image", "");
            var frame = scene.sys.textures.getFrame(key);
            var textureX = frame.cutX;
            var textureY = frame.cutY;
            var textureWidth = frame.source.width;
            var textureHeight = frame.source.height;
            var offsetX = GetValue(config2, "offset.x", 0);
            var offsetY = GetValue(config2, "offset.y", 0);
            var spacingX = GetValue(config2, "spacing.x", 0);
            var spacingY = GetValue(config2, "spacing.y", 0);
            var lineSpacing = GetValue(config2, "lineSpacing", 0);
            var charsPerRow = GetValue(config2, "charsPerRow", null);
            if (charsPerRow === null) {
              charsPerRow = textureWidth / w;
              if (charsPerRow > letters.length) {
                charsPerRow = letters.length;
              }
            }
            var x = offsetX;
            var y = offsetY;
            var data = {
              retroFont: true,
              font: key,
              size: w,
              lineHeight: h + lineSpacing,
              chars: {}
            };
            var r = 0;
            for (var i = 0; i < letters.length; i++) {
              var charCode = letters.charCodeAt(i);
              var u0 = (textureX + x) / textureWidth;
              var v0 = (textureY + y) / textureHeight;
              var u1 = (textureX + x + w) / textureWidth;
              var v1 = (textureY + y + h) / textureHeight;
              data.chars[charCode] = {
                x,
                y,
                width: w,
                height: h,
                centerX: cx,
                centerY: cy,
                xOffset: 0,
                yOffset: 0,
                xAdvance: w,
                data: {},
                kerning: {},
                u0,
                v0,
                u1,
                v1
              };
              r++;
              if (r === charsPerRow) {
                r = 0;
                x = offsetX;
                y += h + spacingY;
              } else {
                x += w + spacingX;
              }
            }
            var entry = {
              data,
              frame: null,
              texture: key
            };
            return entry;
          };
          module2.exports = ParseRetroFont;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1080);
          }
          if (true) {
            renderCanvas = __webpack_require__(1081);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCalcMatrix = __webpack_require__(19);
          var Utils = __webpack_require__(12);
          var RopeWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            var vertices = src.vertices;
            var uvs = src.uv;
            var colors = src.colors;
            var alphas = src.alphas;
            var alpha = src.alpha;
            var getTint = Utils.getTintAppendFloatAlpha;
            var roundPixels = camera.roundPixels;
            var meshVerticesLength = vertices.length;
            var vertexCount = Math.floor(meshVerticesLength * 0.5);
            pipeline.flush();
            renderer.pipelines.preBatch(src);
            var textureUnit = pipeline.setGameObject(src);
            var vertexViewF32 = pipeline.vertexViewF32;
            var vertexViewU32 = pipeline.vertexViewU32;
            var vertexOffset = pipeline.vertexCount * pipeline.currentShader.vertexComponentCount - 1;
            var colorIndex = 0;
            var tintEffect = src.tintFill;
            if (src.dirty) {
              src.updateVertices();
            }
            var debugCallback = src.debugCallback;
            var debugVerts = [];
            for (var i = 0; i < meshVerticesLength; i += 2) {
              var x = vertices[i + 0];
              var y = vertices[i + 1];
              var tx = x * calcMatrix.a + y * calcMatrix.c + calcMatrix.e;
              var ty = x * calcMatrix.b + y * calcMatrix.d + calcMatrix.f;
              if (roundPixels) {
                tx = Math.round(tx);
                ty = Math.round(ty);
              }
              vertexViewF32[++vertexOffset] = tx;
              vertexViewF32[++vertexOffset] = ty;
              vertexViewF32[++vertexOffset] = uvs[i + 0];
              vertexViewF32[++vertexOffset] = uvs[i + 1];
              vertexViewF32[++vertexOffset] = textureUnit;
              vertexViewF32[++vertexOffset] = tintEffect;
              vertexViewU32[++vertexOffset] = getTint(colors[colorIndex], camera.alpha * (alphas[colorIndex] * alpha));
              colorIndex++;
              if (debugCallback) {
                debugVerts[i + 0] = tx;
                debugVerts[i + 1] = ty;
              }
            }
            if (debugCallback) {
              debugCallback.call(src, src, meshVerticesLength, debugVerts);
            }
            pipeline.vertexCount += vertexCount;
            renderer.pipelines.postBatch(src);
          };
          module2.exports = RopeWebGLRenderer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RopeCanvasRenderer = function() {
          };
          module2.exports = RopeCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1083);
          }
          if (true) {
            renderCanvas = __webpack_require__(1084);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Utils = __webpack_require__(12);
          var TextWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            if (src.width === 0 || src.height === 0) {
              return;
            }
            camera.addToRenderList(src);
            var frame = src.frame;
            var width = frame.width;
            var height = frame.height;
            var getTint = Utils.getTintAppendFloatAlpha;
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
            renderer.pipelines.preBatch(src);
            pipeline.batchTexture(src, frame.glTexture, width, height, src.x, src.y, width / src.style.resolution, height / src.style.resolution, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, false, textureUnit);
            renderer.pipelines.postBatch(src);
          };
          module2.exports = TextWebGLRenderer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TextCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            if (src.width === 0 || src.height === 0) {
              return;
            }
            camera.addToRenderList(src);
            renderer.batchSprite(src, src.frame, camera, parentMatrix);
          };
          module2.exports = TextCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1086);
          }
          if (true) {
            renderCanvas = __webpack_require__(1087);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Utils = __webpack_require__(12);
          var TileSpriteWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            src.updateCanvas();
            var width = src.width;
            var height = src.height;
            if (width === 0 || height === 0) {
              return;
            }
            camera.addToRenderList(src);
            renderer.pipelines.preBatch(src);
            var getTint = Utils.getTintAppendFloatAlpha;
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            var textureUnit = pipeline.setTexture2D(src.fillPattern, src);
            pipeline.batchTexture(src, src.fillPattern, src.displayFrame.width * src.tileScaleX, src.displayFrame.height * src.tileScaleY, src.x, src.y, width, height, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.originX * width, src.originY * height, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, src.tilePositionX % src.displayFrame.width / src.displayFrame.width, src.tilePositionY % src.displayFrame.height / src.displayFrame.height, camera, parentMatrix, false, textureUnit);
            renderer.pipelines.postBatch(src);
          };
          module2.exports = TileSpriteWebGLRenderer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TileSpriteCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            src.updateCanvas();
            camera.addToRenderList(src);
            renderer.batchSprite(src, src.frame, camera, parentMatrix);
          };
          module2.exports = TileSpriteCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1089);
          }
          if (true) {
            renderCanvas = __webpack_require__(1090);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var VideoWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            if (src.videoTexture) {
              camera.addToRenderList(src);
              src.pipeline.batchSprite(src, camera, parentMatrix);
            }
          };
          module2.exports = VideoWebGLRenderer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var VideoCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            if (src.videoTexture) {
              camera.addToRenderList(src);
              renderer.batchSprite(src, src.frame, camera, parentMatrix);
            }
          };
          module2.exports = VideoCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1092);
          }
          if (true) {
            renderCanvas = __webpack_require__(1093);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCalcMatrix = __webpack_require__(19);
          var FillPathWebGL = __webpack_require__(111);
          var StrokePathWebGL = __webpack_require__(81);
          var ArcWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isFilled) {
              FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
            }
            if (src.isStroked) {
              StrokePathWebGL(pipeline, src, alpha, dx, dy);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = ArcWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DegToRad = __webpack_require__(35);
          var FillStyleCanvas = __webpack_require__(46);
          var LineStyleCanvas = __webpack_require__(58);
          var SetTransform = __webpack_require__(30);
          var ArcCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var radius = src.radius;
              ctx.beginPath();
              ctx.arc(radius - src.originX * (radius * 2), radius - src.originY * (radius * 2), radius, DegToRad(src._startAngle), DegToRad(src._endAngle), src.anticlockwise);
              if (src.closePath) {
                ctx.closePath();
              }
              if (src.isFilled) {
                FillStyleCanvas(ctx, src);
                ctx.fill();
              }
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = ArcCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1095);
          }
          if (true) {
            renderCanvas = __webpack_require__(1096);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FillPathWebGL = __webpack_require__(111);
          var GetCalcMatrix = __webpack_require__(19);
          var StrokePathWebGL = __webpack_require__(81);
          var CurveWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX + src._curveBounds.x;
            var dy = src._displayOriginY + src._curveBounds.y;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isFilled) {
              FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
            }
            if (src.isStroked) {
              StrokePathWebGL(pipeline, src, alpha, dx, dy);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = CurveWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FillStyleCanvas = __webpack_require__(46);
          var LineStyleCanvas = __webpack_require__(58);
          var SetTransform = __webpack_require__(30);
          var CurveCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = src._displayOriginX + src._curveBounds.x;
              var dy = src._displayOriginY + src._curveBounds.y;
              var path = src.pathData;
              var pathLength = path.length - 1;
              var px1 = path[0] - dx;
              var py1 = path[1] - dy;
              ctx.beginPath();
              ctx.moveTo(px1, py1);
              if (!src.closePath) {
                pathLength -= 2;
              }
              for (var i = 2; i < pathLength; i += 2) {
                var px2 = path[i] - dx;
                var py2 = path[i + 1] - dy;
                ctx.lineTo(px2, py2);
              }
              if (src.closePath) {
                ctx.closePath();
              }
              if (src.isFilled) {
                FillStyleCanvas(ctx, src);
                ctx.fill();
              }
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = CurveCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1098);
          }
          if (true) {
            renderCanvas = __webpack_require__(1099);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FillPathWebGL = __webpack_require__(111);
          var GetCalcMatrix = __webpack_require__(19);
          var StrokePathWebGL = __webpack_require__(81);
          var EllipseWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isFilled) {
              FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
            }
            if (src.isStroked) {
              StrokePathWebGL(pipeline, src, alpha, dx, dy);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = EllipseWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FillStyleCanvas = __webpack_require__(46);
          var LineStyleCanvas = __webpack_require__(58);
          var SetTransform = __webpack_require__(30);
          var EllipseCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var path = src.pathData;
              var pathLength = path.length - 1;
              var px1 = path[0] - dx;
              var py1 = path[1] - dy;
              ctx.beginPath();
              ctx.moveTo(px1, py1);
              if (!src.closePath) {
                pathLength -= 2;
              }
              for (var i = 2; i < pathLength; i += 2) {
                var px2 = path[i] - dx;
                var py2 = path[i + 1] - dy;
                ctx.lineTo(px2, py2);
              }
              ctx.closePath();
              if (src.isFilled) {
                FillStyleCanvas(ctx, src);
                ctx.fill();
              }
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = EllipseCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1101);
          }
          if (true) {
            renderCanvas = __webpack_require__(1102);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCalcMatrix = __webpack_require__(19);
          var Utils = __webpack_require__(12);
          var GridWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            calcMatrix.translate(-src._displayOriginX, -src._displayOriginY);
            var alpha = camera.alpha * src.alpha;
            var width = src.width;
            var height = src.height;
            var cellWidth = src.cellWidth;
            var cellHeight = src.cellHeight;
            var gridWidth = Math.ceil(width / cellWidth);
            var gridHeight = Math.ceil(height / cellHeight);
            var cellWidthA = cellWidth;
            var cellHeightA = cellHeight;
            var cellWidthB = cellWidth - (gridWidth * cellWidth - width);
            var cellHeightB = cellHeight - (gridHeight * cellHeight - height);
            var fillTint;
            var fillTintColor;
            var showCells = src.showCells;
            var showAltCells = src.showAltCells;
            var showOutline = src.showOutline;
            var x = 0;
            var y = 0;
            var r = 0;
            var cw = 0;
            var ch = 0;
            if (showOutline) {
              cellWidthA--;
              cellHeightA--;
              if (cellWidthB === cellWidth) {
                cellWidthB--;
              }
              if (cellHeightB === cellHeight) {
                cellHeightB--;
              }
            }
            renderer.pipelines.preBatch(src);
            if (showCells && src.fillAlpha > 0) {
              fillTint = pipeline.fillTint;
              fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
              fillTint.TL = fillTintColor;
              fillTint.TR = fillTintColor;
              fillTint.BL = fillTintColor;
              fillTint.BR = fillTintColor;
              for (y = 0; y < gridHeight; y++) {
                if (showAltCells) {
                  r = y % 2;
                }
                for (x = 0; x < gridWidth; x++) {
                  if (showAltCells && r) {
                    r = 0;
                    continue;
                  }
                  r++;
                  cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
                  ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
                  pipeline.batchFillRect(x * cellWidth, y * cellHeight, cw, ch);
                }
              }
            }
            if (showAltCells && src.altFillAlpha > 0) {
              fillTint = pipeline.fillTint;
              fillTintColor = Utils.getTintAppendFloatAlpha(src.altFillColor, src.altFillAlpha * alpha);
              fillTint.TL = fillTintColor;
              fillTint.TR = fillTintColor;
              fillTint.BL = fillTintColor;
              fillTint.BR = fillTintColor;
              for (y = 0; y < gridHeight; y++) {
                if (showAltCells) {
                  r = y % 2;
                }
                for (x = 0; x < gridWidth; x++) {
                  if (showAltCells && !r) {
                    r = 1;
                    continue;
                  }
                  r = 0;
                  cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
                  ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
                  pipeline.batchFillRect(x * cellWidth, y * cellHeight, cw, ch);
                }
              }
            }
            if (showOutline && src.outlineFillAlpha > 0) {
              var strokeTint = pipeline.strokeTint;
              var color = Utils.getTintAppendFloatAlpha(src.outlineFillColor, src.outlineFillAlpha * alpha);
              strokeTint.TL = color;
              strokeTint.TR = color;
              strokeTint.BL = color;
              strokeTint.BR = color;
              for (x = 1; x < gridWidth; x++) {
                var x1 = x * cellWidth;
                pipeline.batchLine(x1, 0, x1, height, 1, 1, 1, 0, false);
              }
              for (y = 1; y < gridHeight; y++) {
                var y1 = y * cellHeight;
                pipeline.batchLine(0, y1, width, y1, 1, 1, 1, 0, false);
              }
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = GridWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FillStyleCanvas = __webpack_require__(46);
          var LineStyleCanvas = __webpack_require__(58);
          var SetTransform = __webpack_require__(30);
          var GridCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = -src._displayOriginX;
              var dy = -src._displayOriginY;
              var alpha = camera.alpha * src.alpha;
              var width = src.width;
              var height = src.height;
              var cellWidth = src.cellWidth;
              var cellHeight = src.cellHeight;
              var gridWidth = Math.ceil(width / cellWidth);
              var gridHeight = Math.ceil(height / cellHeight);
              var cellWidthA = cellWidth;
              var cellHeightA = cellHeight;
              var cellWidthB = cellWidth - (gridWidth * cellWidth - width);
              var cellHeightB = cellHeight - (gridHeight * cellHeight - height);
              var showCells = src.showCells;
              var showAltCells = src.showAltCells;
              var showOutline = src.showOutline;
              var x = 0;
              var y = 0;
              var r = 0;
              var cw = 0;
              var ch = 0;
              if (showOutline) {
                cellWidthA--;
                cellHeightA--;
                if (cellWidthB === cellWidth) {
                  cellWidthB--;
                }
                if (cellHeightB === cellHeight) {
                  cellHeightB--;
                }
              }
              if (showCells && src.fillAlpha > 0) {
                FillStyleCanvas(ctx, src);
                for (y = 0; y < gridHeight; y++) {
                  if (showAltCells) {
                    r = y % 2;
                  }
                  for (x = 0; x < gridWidth; x++) {
                    if (showAltCells && r) {
                      r = 0;
                      continue;
                    }
                    r++;
                    cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
                    ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
                    ctx.fillRect(dx + x * cellWidth, dy + y * cellHeight, cw, ch);
                  }
                }
              }
              if (showAltCells && src.altFillAlpha > 0) {
                FillStyleCanvas(ctx, src, src.altFillColor, src.altFillAlpha * alpha);
                for (y = 0; y < gridHeight; y++) {
                  if (showAltCells) {
                    r = y % 2;
                  }
                  for (x = 0; x < gridWidth; x++) {
                    if (showAltCells && !r) {
                      r = 1;
                      continue;
                    }
                    r = 0;
                    cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
                    ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
                    ctx.fillRect(dx + x * cellWidth, dy + y * cellHeight, cw, ch);
                  }
                }
              }
              if (showOutline && src.outlineFillAlpha > 0) {
                LineStyleCanvas(ctx, src, src.outlineFillColor, src.outlineFillAlpha * alpha);
                for (x = 1; x < gridWidth; x++) {
                  var x1 = x * cellWidth;
                  ctx.beginPath();
                  ctx.moveTo(x1 + dx, dy);
                  ctx.lineTo(x1 + dx, height + dy);
                  ctx.stroke();
                }
                for (y = 1; y < gridHeight; y++) {
                  var y1 = y * cellHeight;
                  ctx.beginPath();
                  ctx.moveTo(dx, y1 + dy);
                  ctx.lineTo(dx + width, y1 + dy);
                  ctx.stroke();
                }
              }
              ctx.restore();
            }
          };
          module2.exports = GridCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1104);
          }
          if (true) {
            renderCanvas = __webpack_require__(1105);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCalcMatrix = __webpack_require__(19);
          var Utils = __webpack_require__(12);
          var IsoBoxWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            var size = src.width;
            var height = src.height;
            var sizeA = size / 2;
            var sizeB = size / src.projection;
            var alpha = camera.alpha * src.alpha;
            if (!src.isFilled) {
              return;
            }
            var tint;
            var x0;
            var y0;
            var x1;
            var y1;
            var x2;
            var y2;
            var x3;
            var y3;
            renderer.pipelines.preBatch(src);
            if (src.showTop) {
              tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);
              x0 = calcMatrix.getX(-sizeA, -height);
              y0 = calcMatrix.getY(-sizeA, -height);
              x1 = calcMatrix.getX(0, -sizeB - height);
              y1 = calcMatrix.getY(0, -sizeB - height);
              x2 = calcMatrix.getX(sizeA, -height);
              y2 = calcMatrix.getY(sizeA, -height);
              x3 = calcMatrix.getX(0, sizeB - height);
              y3 = calcMatrix.getY(0, sizeB - height);
              pipeline.batchQuad(x0, y0, x1, y1, x2, y2, x3, y3, tint, tint, tint, tint);
            }
            if (src.showLeft) {
              tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);
              x0 = calcMatrix.getX(-sizeA, 0);
              y0 = calcMatrix.getY(-sizeA, 0);
              x1 = calcMatrix.getX(0, sizeB);
              y1 = calcMatrix.getY(0, sizeB);
              x2 = calcMatrix.getX(0, sizeB - height);
              y2 = calcMatrix.getY(0, sizeB - height);
              x3 = calcMatrix.getX(-sizeA, -height);
              y3 = calcMatrix.getY(-sizeA, -height);
              pipeline.batchQuad(x0, y0, x1, y1, x2, y2, x3, y3, tint, tint, tint, tint);
            }
            if (src.showRight) {
              tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);
              x0 = calcMatrix.getX(sizeA, 0);
              y0 = calcMatrix.getY(sizeA, 0);
              x1 = calcMatrix.getX(0, sizeB);
              y1 = calcMatrix.getY(0, sizeB);
              x2 = calcMatrix.getX(0, sizeB - height);
              y2 = calcMatrix.getY(0, sizeB - height);
              x3 = calcMatrix.getX(sizeA, -height);
              y3 = calcMatrix.getY(sizeA, -height);
              pipeline.batchQuad(x0, y0, x1, y1, x2, y2, x3, y3, tint, tint, tint, tint);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = IsoBoxWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FillStyleCanvas = __webpack_require__(46);
          var SetTransform = __webpack_require__(30);
          var IsoBoxCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled) {
              var size = src.width;
              var height = src.height;
              var sizeA = size / 2;
              var sizeB = size / src.projection;
              if (src.showTop) {
                FillStyleCanvas(ctx, src, src.fillTop);
                ctx.beginPath();
                ctx.moveTo(-sizeA, -height);
                ctx.lineTo(0, -sizeB - height);
                ctx.lineTo(sizeA, -height);
                ctx.lineTo(sizeA, -1);
                ctx.lineTo(0, sizeB - 1);
                ctx.lineTo(-sizeA, -1);
                ctx.lineTo(-sizeA, -height);
                ctx.fill();
              }
              if (src.showLeft) {
                FillStyleCanvas(ctx, src, src.fillLeft);
                ctx.beginPath();
                ctx.moveTo(-sizeA, 0);
                ctx.lineTo(0, sizeB);
                ctx.lineTo(0, sizeB - height);
                ctx.lineTo(-sizeA, -height);
                ctx.lineTo(-sizeA, 0);
                ctx.fill();
              }
              if (src.showRight) {
                FillStyleCanvas(ctx, src, src.fillRight);
                ctx.beginPath();
                ctx.moveTo(sizeA, 0);
                ctx.lineTo(0, sizeB);
                ctx.lineTo(0, sizeB - height);
                ctx.lineTo(sizeA, -height);
                ctx.lineTo(sizeA, 0);
                ctx.fill();
              }
              ctx.restore();
            }
          };
          module2.exports = IsoBoxCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1107);
          }
          if (true) {
            renderCanvas = __webpack_require__(1108);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCalcMatrix = __webpack_require__(19);
          var Utils = __webpack_require__(12);
          var IsoTriangleWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            var size = src.width;
            var height = src.height;
            var sizeA = size / 2;
            var sizeB = size / src.projection;
            var reversed = src.isReversed;
            var alpha = camera.alpha * src.alpha;
            if (!src.isFilled) {
              return;
            }
            renderer.pipelines.preBatch(src);
            var tint;
            var x0;
            var y0;
            var x1;
            var y1;
            var x2;
            var y2;
            if (src.showTop && reversed) {
              tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);
              x0 = calcMatrix.getX(-sizeA, -height);
              y0 = calcMatrix.getY(-sizeA, -height);
              x1 = calcMatrix.getX(0, -sizeB - height);
              y1 = calcMatrix.getY(0, -sizeB - height);
              x2 = calcMatrix.getX(sizeA, -height);
              y2 = calcMatrix.getY(sizeA, -height);
              var x3 = calcMatrix.getX(0, sizeB - height);
              var y3 = calcMatrix.getY(0, sizeB - height);
              pipeline.batchQuad(x0, y0, x1, y1, x2, y2, x3, y3, tint, tint, tint, tint);
            }
            if (src.showLeft) {
              tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);
              if (reversed) {
                x0 = calcMatrix.getX(-sizeA, -height);
                y0 = calcMatrix.getY(-sizeA, -height);
                x1 = calcMatrix.getX(0, sizeB);
                y1 = calcMatrix.getY(0, sizeB);
                x2 = calcMatrix.getX(0, sizeB - height);
                y2 = calcMatrix.getY(0, sizeB - height);
              } else {
                x0 = calcMatrix.getX(-sizeA, 0);
                y0 = calcMatrix.getY(-sizeA, 0);
                x1 = calcMatrix.getX(0, sizeB);
                y1 = calcMatrix.getY(0, sizeB);
                x2 = calcMatrix.getX(0, sizeB - height);
                y2 = calcMatrix.getY(0, sizeB - height);
              }
              pipeline.batchTri(x0, y0, x1, y1, x2, y2, tint, tint, tint);
            }
            if (src.showRight) {
              tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);
              if (reversed) {
                x0 = calcMatrix.getX(sizeA, -height);
                y0 = calcMatrix.getY(sizeA, -height);
                x1 = calcMatrix.getX(0, sizeB);
                y1 = calcMatrix.getY(0, sizeB);
                x2 = calcMatrix.getX(0, sizeB - height);
                y2 = calcMatrix.getY(0, sizeB - height);
              } else {
                x0 = calcMatrix.getX(sizeA, 0);
                y0 = calcMatrix.getY(sizeA, 0);
                x1 = calcMatrix.getX(0, sizeB);
                y1 = calcMatrix.getY(0, sizeB);
                x2 = calcMatrix.getX(0, sizeB - height);
                y2 = calcMatrix.getY(0, sizeB - height);
              }
              pipeline.batchTri(x0, y0, x1, y1, x2, y2, tint, tint, tint);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = IsoTriangleWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FillStyleCanvas = __webpack_require__(46);
          var SetTransform = __webpack_require__(30);
          var IsoTriangleCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled) {
              var size = src.width;
              var height = src.height;
              var sizeA = size / 2;
              var sizeB = size / src.projection;
              var reversed = src.isReversed;
              if (src.showTop && reversed) {
                FillStyleCanvas(ctx, src, src.fillTop);
                ctx.beginPath();
                ctx.moveTo(-sizeA, -height);
                ctx.lineTo(0, -sizeB - height);
                ctx.lineTo(sizeA, -height);
                ctx.lineTo(0, sizeB - height);
                ctx.fill();
              }
              if (src.showLeft) {
                FillStyleCanvas(ctx, src, src.fillLeft);
                ctx.beginPath();
                if (reversed) {
                  ctx.moveTo(-sizeA, -height);
                  ctx.lineTo(0, sizeB);
                  ctx.lineTo(0, sizeB - height);
                } else {
                  ctx.moveTo(-sizeA, 0);
                  ctx.lineTo(0, sizeB);
                  ctx.lineTo(0, sizeB - height);
                }
                ctx.fill();
              }
              if (src.showRight) {
                FillStyleCanvas(ctx, src, src.fillRight);
                ctx.beginPath();
                if (reversed) {
                  ctx.moveTo(sizeA, -height);
                  ctx.lineTo(0, sizeB);
                  ctx.lineTo(0, sizeB - height);
                } else {
                  ctx.moveTo(sizeA, 0);
                  ctx.lineTo(0, sizeB);
                  ctx.lineTo(0, sizeB - height);
                }
                ctx.fill();
              }
              ctx.restore();
            }
          };
          module2.exports = IsoTriangleCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1110);
          }
          if (true) {
            renderCanvas = __webpack_require__(1111);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCalcMatrix = __webpack_require__(19);
          var Utils = __webpack_require__(12);
          var LineWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isStroked) {
              var strokeTint = pipeline.strokeTint;
              var color = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
              strokeTint.TL = color;
              strokeTint.TR = color;
              strokeTint.BL = color;
              strokeTint.BR = color;
              var startWidth = src._startWidth;
              var endWidth = src._endWidth;
              pipeline.batchLine(src.geom.x1 - dx, src.geom.y1 - dy, src.geom.x2 - dx, src.geom.y2 - dy, startWidth, endWidth, 1, 0, false, result.sprite, result.camera);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = LineWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var LineStyleCanvas = __webpack_require__(58);
          var SetTransform = __webpack_require__(30);
          var LineCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.beginPath();
                ctx.moveTo(src.geom.x1 - dx, src.geom.y1 - dy);
                ctx.lineTo(src.geom.x2 - dx, src.geom.y2 - dy);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = LineCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1113);
          }
          if (true) {
            renderCanvas = __webpack_require__(1114);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FillPathWebGL = __webpack_require__(111);
          var GetCalcMatrix = __webpack_require__(19);
          var StrokePathWebGL = __webpack_require__(81);
          var PolygonWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isFilled) {
              FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
            }
            if (src.isStroked) {
              StrokePathWebGL(pipeline, src, alpha, dx, dy);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = PolygonWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FillStyleCanvas = __webpack_require__(46);
          var LineStyleCanvas = __webpack_require__(58);
          var SetTransform = __webpack_require__(30);
          var PolygonCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var path = src.pathData;
              var pathLength = path.length - 1;
              var px1 = path[0] - dx;
              var py1 = path[1] - dy;
              ctx.beginPath();
              ctx.moveTo(px1, py1);
              if (!src.closePath) {
                pathLength -= 2;
              }
              for (var i = 2; i < pathLength; i += 2) {
                var px2 = path[i] - dx;
                var py2 = path[i + 1] - dy;
                ctx.lineTo(px2, py2);
              }
              ctx.closePath();
              if (src.isFilled) {
                FillStyleCanvas(ctx, src);
                ctx.fill();
              }
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = PolygonCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1116);
          }
          if (true) {
            renderCanvas = __webpack_require__(1117);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCalcMatrix = __webpack_require__(19);
          var StrokePathWebGL = __webpack_require__(81);
          var Utils = __webpack_require__(12);
          var RectangleWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isFilled) {
              var fillTint = pipeline.fillTint;
              var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
              fillTint.TL = fillTintColor;
              fillTint.TR = fillTintColor;
              fillTint.BL = fillTintColor;
              fillTint.BR = fillTintColor;
              pipeline.batchFillRect(-dx, -dy, src.width, src.height);
            }
            if (src.isStroked) {
              StrokePathWebGL(pipeline, src, alpha, dx, dy);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = RectangleWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FillStyleCanvas = __webpack_require__(46);
          var LineStyleCanvas = __webpack_require__(58);
          var SetTransform = __webpack_require__(30);
          var RectangleCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              if (src.isFilled) {
                FillStyleCanvas(ctx, src);
                ctx.fillRect(-dx, -dy, src.width, src.height);
              }
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.beginPath();
                ctx.rect(-dx, -dy, src.width, src.height);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = RectangleCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1119);
          }
          if (true) {
            renderCanvas = __webpack_require__(1120);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FillPathWebGL = __webpack_require__(111);
          var GetCalcMatrix = __webpack_require__(19);
          var StrokePathWebGL = __webpack_require__(81);
          var StarWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isFilled) {
              FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
            }
            if (src.isStroked) {
              StrokePathWebGL(pipeline, src, alpha, dx, dy);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = StarWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FillStyleCanvas = __webpack_require__(46);
          var LineStyleCanvas = __webpack_require__(58);
          var SetTransform = __webpack_require__(30);
          var StarCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var path = src.pathData;
              var pathLength = path.length - 1;
              var px1 = path[0] - dx;
              var py1 = path[1] - dy;
              ctx.beginPath();
              ctx.moveTo(px1, py1);
              if (!src.closePath) {
                pathLength -= 2;
              }
              for (var i = 2; i < pathLength; i += 2) {
                var px2 = path[i] - dx;
                var py2 = path[i + 1] - dy;
                ctx.lineTo(px2, py2);
              }
              ctx.closePath();
              if (src.isFilled) {
                FillStyleCanvas(ctx, src);
                ctx.fill();
              }
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = StarCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1122);
          }
          if (true) {
            renderCanvas = __webpack_require__(1123);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCalcMatrix = __webpack_require__(19);
          var StrokePathWebGL = __webpack_require__(81);
          var Utils = __webpack_require__(12);
          var TriangleWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isFilled) {
              var fillTint = pipeline.fillTint;
              var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
              fillTint.TL = fillTintColor;
              fillTint.TR = fillTintColor;
              fillTint.BL = fillTintColor;
              fillTint.BR = fillTintColor;
              var x1 = src.geom.x1 - dx;
              var y1 = src.geom.y1 - dy;
              var x2 = src.geom.x2 - dx;
              var y2 = src.geom.y2 - dy;
              var x3 = src.geom.x3 - dx;
              var y3 = src.geom.y3 - dy;
              pipeline.batchFillTriangle(x1, y1, x2, y2, x3, y3, result.sprite, result.camera);
            }
            if (src.isStroked) {
              StrokePathWebGL(pipeline, src, alpha, dx, dy);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = TriangleWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FillStyleCanvas = __webpack_require__(46);
          var LineStyleCanvas = __webpack_require__(58);
          var SetTransform = __webpack_require__(30);
          var TriangleCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var x1 = src.geom.x1 - dx;
              var y1 = src.geom.y1 - dy;
              var x2 = src.geom.x2 - dx;
              var y2 = src.geom.y2 - dy;
              var x3 = src.geom.x3 - dx;
              var y3 = src.geom.y3 - dy;
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.lineTo(x3, y3);
              ctx.closePath();
              if (src.isFilled) {
                FillStyleCanvas(ctx, src);
                ctx.fill();
              }
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = TriangleCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Blitter = __webpack_require__(210);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("blitter", function(x, y, key, frame) {
            return this.displayList.add(new Blitter(this.scene, x, y, key, frame));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Felipe Alfonso <@bitnenfer>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Container = __webpack_require__(211);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("container", function(x, y, children) {
            return this.displayList.add(new Container(this.scene, x, y, children));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DOMElement = __webpack_require__(436);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("dom", function(x, y, element, style, innerText) {
            var gameObject = new DOMElement(this.scene, x, y, element, style, innerText);
            this.displayList.add(gameObject);
            return gameObject;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DynamicBitmapText = __webpack_require__(212);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("dynamicBitmapText", function(x, y, font, text, size) {
            return this.displayList.add(new DynamicBitmapText(this.scene, x, y, font, text, size));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Extern = __webpack_require__(438);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("extern", function() {
            var extern = new Extern(this.scene);
            this.displayList.add(extern);
            return extern;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Graphics = __webpack_require__(213);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("graphics", function(config2) {
            return this.displayList.add(new Graphics(this.scene, config2));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Group = __webpack_require__(110);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("group", function(children, config2) {
            return this.updateList.add(new Group(this.scene, children, config2));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Image2 = __webpack_require__(124);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("image", function(x, y, key, frame) {
            return this.displayList.add(new Image2(this.scene, x, y, key, frame));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Layer = __webpack_require__(216);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("layer", function(children) {
            return this.displayList.add(new Layer(this.scene, children));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectFactory = __webpack_require__(5);
          var ParticleEmitterManager = __webpack_require__(217);
          GameObjectFactory.register("particles", function(key, frame, emitters) {
            return this.displayList.add(new ParticleEmitterManager(this.scene, key, frame, emitters));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectFactory = __webpack_require__(5);
          var PathFollower = __webpack_require__(451);
          GameObjectFactory.register("follower", function(path, x, y, key, frame) {
            var sprite = new PathFollower(this.scene, path, x, y, key, frame);
            this.displayList.add(sprite);
            this.updateList.add(sprite);
            return sprite;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectFactory = __webpack_require__(5);
          var RenderTexture = __webpack_require__(218);
          GameObjectFactory.register("renderTexture", function(x, y, width, height, key, frame) {
            return this.displayList.add(new RenderTexture(this.scene, x, y, width, height, key, frame));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rope = __webpack_require__(220);
          var GameObjectFactory = __webpack_require__(5);
          if (true) {
            GameObjectFactory.register("rope", function(x, y, texture, frame, points, horizontal, colors, alphas) {
              return this.displayList.add(new Rope(this.scene, x, y, texture, frame, points, horizontal, colors, alphas));
            });
          }
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectFactory = __webpack_require__(5);
          var Sprite = __webpack_require__(73);
          GameObjectFactory.register("sprite", function(x, y, key, frame) {
            var sprite = new Sprite(this.scene, x, y, key, frame);
            this.displayList.add(sprite);
            return sprite;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BitmapText = __webpack_require__(147);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("bitmapText", function(x, y, font, text, size, align) {
            return this.displayList.add(new BitmapText(this.scene, x, y, font, text, size, align));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Text = __webpack_require__(221);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("text", function(x, y, text, style) {
            return this.displayList.add(new Text(this.scene, x, y, text, style));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TileSprite = __webpack_require__(222);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("tileSprite", function(x, y, width, height, key, frame) {
            return this.displayList.add(new TileSprite(this.scene, x, y, width, height, key, frame));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Zone = __webpack_require__(127);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("zone", function(x, y, width, height) {
            return this.displayList.add(new Zone(this.scene, x, y, width, height));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Video = __webpack_require__(223);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("video", function(x, y, key) {
            return this.displayList.add(new Video(this.scene, x, y, key));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Arc = __webpack_require__(455);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("arc", function(x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha) {
            return this.displayList.add(new Arc(this.scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha));
          });
          GameObjectFactory.register("circle", function(x, y, radius, fillColor, fillAlpha) {
            return this.displayList.add(new Arc(this.scene, x, y, radius, 0, 360, false, fillColor, fillAlpha));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectFactory = __webpack_require__(5);
          var Curve = __webpack_require__(456);
          GameObjectFactory.register("curve", function(x, y, curve, fillColor, fillAlpha) {
            return this.displayList.add(new Curve(this.scene, x, y, curve, fillColor, fillAlpha));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Ellipse = __webpack_require__(457);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("ellipse", function(x, y, width, height, fillColor, fillAlpha) {
            return this.displayList.add(new Ellipse(this.scene, x, y, width, height, fillColor, fillAlpha));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectFactory = __webpack_require__(5);
          var Grid = __webpack_require__(458);
          GameObjectFactory.register("grid", function(x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha) {
            return this.displayList.add(new Grid(this.scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectFactory = __webpack_require__(5);
          var IsoBox = __webpack_require__(459);
          GameObjectFactory.register("isobox", function(x, y, size, height, fillTop, fillLeft, fillRight) {
            return this.displayList.add(new IsoBox(this.scene, x, y, size, height, fillTop, fillLeft, fillRight));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectFactory = __webpack_require__(5);
          var IsoTriangle = __webpack_require__(460);
          GameObjectFactory.register("isotriangle", function(x, y, size, height, reversed, fillTop, fillLeft, fillRight) {
            return this.displayList.add(new IsoTriangle(this.scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectFactory = __webpack_require__(5);
          var Line = __webpack_require__(461);
          GameObjectFactory.register("line", function(x, y, x1, y1, x2, y2, strokeColor, strokeAlpha) {
            return this.displayList.add(new Line(this.scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectFactory = __webpack_require__(5);
          var Polygon = __webpack_require__(462);
          GameObjectFactory.register("polygon", function(x, y, points, fillColor, fillAlpha) {
            return this.displayList.add(new Polygon(this.scene, x, y, points, fillColor, fillAlpha));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectFactory = __webpack_require__(5);
          var Rectangle = __webpack_require__(467);
          GameObjectFactory.register("rectangle", function(x, y, width, height, fillColor, fillAlpha) {
            return this.displayList.add(new Rectangle(this.scene, x, y, width, height, fillColor, fillAlpha));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Star = __webpack_require__(468);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("star", function(x, y, points, innerRadius, outerRadius, fillColor, fillAlpha) {
            return this.displayList.add(new Star(this.scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectFactory = __webpack_require__(5);
          var Triangle = __webpack_require__(469);
          GameObjectFactory.register("triangle", function(x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha) {
            return this.displayList.add(new Triangle(this.scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Blitter = __webpack_require__(210);
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          GameObjectCreator.register("blitter", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var key = GetAdvancedValue(config2, "key", null);
            var frame = GetAdvancedValue(config2, "frame", null);
            var blitter = new Blitter(this.scene, 0, 0, key, frame);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, blitter, config2);
            return blitter;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Felipe Alfonso <@bitnenfer>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BuildGameObject = __webpack_require__(28);
          var Container = __webpack_require__(211);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          GameObjectCreator.register("container", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var x = GetAdvancedValue(config2, "x", 0);
            var y = GetAdvancedValue(config2, "y", 0);
            var children = GetAdvancedValue(config2, "children", null);
            var container = new Container(this.scene, x, y, children);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, container, config2);
            return container;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BitmapText = __webpack_require__(212);
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          GameObjectCreator.register("dynamicBitmapText", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var font = GetAdvancedValue(config2, "font", "");
            var text = GetAdvancedValue(config2, "text", "");
            var size = GetAdvancedValue(config2, "size", false);
            var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, bitmapText, config2);
            return bitmapText;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectCreator = __webpack_require__(16);
          var Graphics = __webpack_require__(213);
          GameObjectCreator.register("graphics", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            var graphics = new Graphics(this.scene, config2);
            if (config2.add) {
              this.scene.sys.displayList.add(graphics);
            }
            return graphics;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectCreator = __webpack_require__(16);
          var Group = __webpack_require__(110);
          GameObjectCreator.register("group", function(config2) {
            return new Group(this.scene, null, config2);
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var Image2 = __webpack_require__(124);
          GameObjectCreator.register("image", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var key = GetAdvancedValue(config2, "key", null);
            var frame = GetAdvancedValue(config2, "frame", null);
            var image = new Image2(this.scene, 0, 0, key, frame);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, image, config2);
            return image;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BuildGameObject = __webpack_require__(28);
          var Layer = __webpack_require__(216);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          GameObjectCreator.register("layer", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var children = GetAdvancedValue(config2, "children", null);
            var layer = new Layer(this.scene, children);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, layer, config2);
            return layer;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var GetFastValue = __webpack_require__(2);
          var ParticleEmitterManager = __webpack_require__(217);
          GameObjectCreator.register("particles", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var key = GetAdvancedValue(config2, "key", null);
            var frame = GetAdvancedValue(config2, "frame", null);
            var emitters = GetFastValue(config2, "emitters", null);
            var manager = new ParticleEmitterManager(this.scene, key, frame, emitters);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            var add = GetFastValue(config2, "add", false);
            if (add) {
              this.displayList.add(manager);
            } else {
              this.updateList.add(manager);
            }
            return manager;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var RenderTexture = __webpack_require__(218);
          GameObjectCreator.register("renderTexture", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var x = GetAdvancedValue(config2, "x", 0);
            var y = GetAdvancedValue(config2, "y", 0);
            var width = GetAdvancedValue(config2, "width", 32);
            var height = GetAdvancedValue(config2, "height", 32);
            var key = GetAdvancedValue(config2, "key", void 0);
            var frame = GetAdvancedValue(config2, "frame", void 0);
            var renderTexture = new RenderTexture(this.scene, x, y, width, height, key, frame);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, renderTexture, config2);
            return renderTexture;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var GetValue = __webpack_require__(6);
          var Rope = __webpack_require__(220);
          GameObjectCreator.register("rope", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var key = GetAdvancedValue(config2, "key", null);
            var frame = GetAdvancedValue(config2, "frame", null);
            var horizontal = GetAdvancedValue(config2, "horizontal", true);
            var points = GetValue(config2, "points", void 0);
            var colors = GetValue(config2, "colors", void 0);
            var alphas = GetValue(config2, "alphas", void 0);
            var rope = new Rope(this.scene, 0, 0, key, frame, points, horizontal, colors, alphas);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, rope, config2);
            if (!config2.add) {
              this.updateList.add(rope);
            }
            return rope;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BuildGameObject = __webpack_require__(28);
          var BuildGameObjectAnimation = __webpack_require__(433);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var Sprite = __webpack_require__(73);
          GameObjectCreator.register("sprite", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var key = GetAdvancedValue(config2, "key", null);
            var frame = GetAdvancedValue(config2, "frame", null);
            var sprite = new Sprite(this.scene, 0, 0, key, frame);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, sprite, config2);
            BuildGameObjectAnimation(sprite, config2);
            return sprite;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BitmapText = __webpack_require__(147);
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var GetValue = __webpack_require__(6);
          GameObjectCreator.register("bitmapText", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var font = GetValue(config2, "font", "");
            var text = GetAdvancedValue(config2, "text", "");
            var size = GetAdvancedValue(config2, "size", false);
            var align = GetValue(config2, "align", 0);
            var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size, align);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, bitmapText, config2);
            return bitmapText;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var Text = __webpack_require__(221);
          GameObjectCreator.register("text", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var content = GetAdvancedValue(config2, "text", "");
            var style = GetAdvancedValue(config2, "style", null);
            var padding = GetAdvancedValue(config2, "padding", null);
            if (padding !== null) {
              style.padding = padding;
            }
            var text = new Text(this.scene, 0, 0, content, style);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, text, config2);
            text.autoRound = GetAdvancedValue(config2, "autoRound", true);
            text.resolution = GetAdvancedValue(config2, "resolution", 1);
            return text;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var TileSprite = __webpack_require__(222);
          GameObjectCreator.register("tileSprite", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var x = GetAdvancedValue(config2, "x", 0);
            var y = GetAdvancedValue(config2, "y", 0);
            var width = GetAdvancedValue(config2, "width", 512);
            var height = GetAdvancedValue(config2, "height", 512);
            var key = GetAdvancedValue(config2, "key", "");
            var frame = GetAdvancedValue(config2, "frame", "");
            var tile = new TileSprite(this.scene, x, y, width, height, key, frame);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, tile, config2);
            return tile;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var Zone = __webpack_require__(127);
          GameObjectCreator.register("zone", function(config2) {
            var x = GetAdvancedValue(config2, "x", 0);
            var y = GetAdvancedValue(config2, "y", 0);
            var width = GetAdvancedValue(config2, "width", 1);
            var height = GetAdvancedValue(config2, "height", width);
            return new Zone(this.scene, x, y, width, height);
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var Video = __webpack_require__(223);
          GameObjectCreator.register("video", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var key = GetAdvancedValue(config2, "key", null);
            var video = new Video(this.scene, 0, 0, key);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, video, config2);
            if (!config2.add) {
              this.updateList.add(video);
            }
            return video;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1171);
          }
          if (true) {
            renderCanvas = __webpack_require__(1172);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCalcMatrix = __webpack_require__(19);
          var ShaderWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            if (!src.shader) {
              return;
            }
            camera.addToRenderList(src);
            renderer.pipelines.clear();
            if (src.renderToTexture) {
              src.load();
              src.flush();
            } else {
              var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
              if (renderer.width !== src._rendererWidth || renderer.height !== src._rendererHeight) {
                src.projOrtho(0, renderer.width, renderer.height, 0);
              }
              src.load(calcMatrix.matrix);
              src.flush();
            }
            renderer.pipelines.rebind();
          };
          module2.exports = ShaderWebGLRenderer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ShaderCanvasRenderer = function() {
          };
          module2.exports = ShaderCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1174);
          }
          if (true) {
            renderCanvas = __webpack_require__(1175);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCalcMatrix = __webpack_require__(19);
          var MeshWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            var faces = src.faces;
            var totalFaces = faces.length;
            if (totalFaces === 0) {
              return;
            }
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            var textureUnit = pipeline.setGameObject(src);
            var F32 = pipeline.vertexViewF32;
            var U32 = pipeline.vertexViewU32;
            var vertexOffset = pipeline.vertexCount * pipeline.currentShader.vertexComponentCount - 1;
            var tintEffect = src.tintFill;
            var debugFaces = [];
            var debugCallback = src.debugCallback;
            var a = calcMatrix.a;
            var b = calcMatrix.b;
            var c = calcMatrix.c;
            var d = calcMatrix.d;
            var e = calcMatrix.e;
            var f = calcMatrix.f;
            var z = src.viewPosition.z;
            var hideCCW = src.hideCCW;
            var roundPixels = camera.roundPixels;
            var alpha = camera.alpha * src.alpha;
            var totalFacesRendered = 0;
            renderer.pipelines.preBatch(src);
            for (var i = 0; i < totalFaces; i++) {
              var face = faces[i];
              if (!face.isInView(camera, hideCCW, z, alpha, a, b, c, d, e, f, roundPixels)) {
                continue;
              }
              if (pipeline.shouldFlush(3)) {
                pipeline.flush();
                vertexOffset = 0;
              }
              vertexOffset = face.load(F32, U32, vertexOffset, textureUnit, tintEffect);
              totalFacesRendered++;
              pipeline.vertexCount += 3;
              if (debugCallback) {
                debugFaces.push(face);
              }
            }
            src.totalFrame += totalFacesRendered;
            if (debugCallback) {
              debugCallback.call(src, src, debugFaces);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = MeshWebGLRenderer;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MeshCanvasRenderer = function() {
          };
          module2.exports = MeshCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1177);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetCalcMatrix = __webpack_require__(19);
          var PointLightWebGLRenderer = function(renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            var width = src.width;
            var height = src.height;
            var x = -src._radius;
            var y = -src._radius;
            var xw = x + width;
            var yh = y + height;
            var lightX = calcMatrix.getX(0, 0);
            var lightY = calcMatrix.getY(0, 0);
            var tx0 = calcMatrix.getX(x, y);
            var ty0 = calcMatrix.getY(x, y);
            var tx1 = calcMatrix.getX(x, yh);
            var ty1 = calcMatrix.getY(x, yh);
            var tx2 = calcMatrix.getX(xw, yh);
            var ty2 = calcMatrix.getY(xw, yh);
            var tx3 = calcMatrix.getX(xw, y);
            var ty3 = calcMatrix.getY(xw, y);
            renderer.pipelines.preBatch(src);
            pipeline.batchPointLight(src, camera, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, lightX, lightY);
            renderer.pipelines.postBatch(src);
          };
          module2.exports = PointLightWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Shader = __webpack_require__(226);
          var GameObjectFactory = __webpack_require__(5);
          if (true) {
            GameObjectFactory.register("shader", function(key, x, y, width, height, textures, textureData) {
              return this.displayList.add(new Shader(this.scene, key, x, y, width, height, textures, textureData));
            });
          }
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Mesh = __webpack_require__(227);
          var GameObjectFactory = __webpack_require__(5);
          if (true) {
            GameObjectFactory.register("mesh", function(x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas) {
              return this.displayList.add(new Mesh(this.scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas));
            });
          }
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectFactory = __webpack_require__(5);
          var PointLight = __webpack_require__(149);
          GameObjectFactory.register("pointlight", function(x, y, color, radius, intensity, attenuation) {
            return this.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var Shader = __webpack_require__(226);
          GameObjectCreator.register("shader", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var key = GetAdvancedValue(config2, "key", null);
            var x = GetAdvancedValue(config2, "x", 0);
            var y = GetAdvancedValue(config2, "y", 0);
            var width = GetAdvancedValue(config2, "width", 128);
            var height = GetAdvancedValue(config2, "height", 128);
            var shader = new Shader(this.scene, key, x, y, width, height);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, shader, config2);
            return shader;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var GetValue = __webpack_require__(6);
          var Mesh = __webpack_require__(227);
          GameObjectCreator.register("mesh", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var key = GetAdvancedValue(config2, "key", null);
            var frame = GetAdvancedValue(config2, "frame", null);
            var vertices = GetValue(config2, "vertices", []);
            var uvs = GetValue(config2, "uvs", []);
            var indicies = GetValue(config2, "indicies", []);
            var containsZ = GetValue(config2, "containsZ", false);
            var normals = GetValue(config2, "normals", []);
            var colors = GetValue(config2, "colors", 16777215);
            var alphas = GetValue(config2, "alphas", 1);
            var mesh = new Mesh(this.scene, 0, 0, key, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, mesh, config2);
            return mesh;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var PointLight = __webpack_require__(149);
          GameObjectCreator.register("pointlight", function(config2, addToScene) {
            if (config2 === void 0) {
              config2 = {};
            }
            var color = GetAdvancedValue(config2, "color", 16777215);
            var radius = GetAdvancedValue(config2, "radius", 128);
            var intensity = GetAdvancedValue(config2, "intensity", 1);
            var attenuation = GetAdvancedValue(config2, "attenuation", 0.1);
            var layer = new PointLight(this.scene, 0, 0, color, radius, intensity, attenuation);
            if (addToScene !== void 0) {
              config2.add = addToScene;
            }
            BuildGameObject(this.scene, layer, config2);
            return layer;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var LightsManager = __webpack_require__(476);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(21);
          var LightsPlugin = new Class({
            Extends: LightsManager,
            initialize: function LightsPlugin2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              if (!scene.sys.settings.isBooted) {
                scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              }
              LightsManager.call(this);
            },
            boot: function() {
              var eventEmitter = this.systems.events;
              eventEmitter.on(SceneEvents.SHUTDOWN, this.shutdown, this);
              eventEmitter.on(SceneEvents.DESTROY, this.destroy, this);
            },
            destroy: function() {
              this.shutdown();
              this.scene = void 0;
              this.systems = void 0;
            }
          });
          PluginCache.register("LightsPlugin", LightsPlugin, "lights");
          module2.exports = LightsPlugin;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Circle = __webpack_require__(62);
          Circle.Area = __webpack_require__(1186);
          Circle.Circumference = __webpack_require__(296);
          Circle.CircumferencePoint = __webpack_require__(165);
          Circle.Clone = __webpack_require__(1187);
          Circle.Contains = __webpack_require__(63);
          Circle.ContainsPoint = __webpack_require__(1188);
          Circle.ContainsRect = __webpack_require__(1189);
          Circle.CopyFrom = __webpack_require__(1190);
          Circle.Equals = __webpack_require__(1191);
          Circle.GetBounds = __webpack_require__(1192);
          Circle.GetPoint = __webpack_require__(294);
          Circle.GetPoints = __webpack_require__(295);
          Circle.Offset = __webpack_require__(1193);
          Circle.OffsetPoint = __webpack_require__(1194);
          Circle.Random = __webpack_require__(166);
          module2.exports = Circle;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Area = function(circle) {
            return circle.radius > 0 ? Math.PI * circle.radius * circle.radius : 0;
          };
          module2.exports = Area;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Circle = __webpack_require__(62);
          var Clone = function(source) {
            return new Circle(source.x, source.y, source.radius);
          };
          module2.exports = Clone;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Contains = __webpack_require__(63);
          var ContainsPoint = function(circle, point) {
            return Contains(circle, point.x, point.y);
          };
          module2.exports = ContainsPoint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Contains = __webpack_require__(63);
          var ContainsRect = function(circle, rect) {
            return Contains(circle, rect.x, rect.y) && Contains(circle, rect.right, rect.y) && Contains(circle, rect.x, rect.bottom) && Contains(circle, rect.right, rect.bottom);
          };
          module2.exports = ContainsRect;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CopyFrom = function(source, dest) {
            return dest.setTo(source.x, source.y, source.radius);
          };
          module2.exports = CopyFrom;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Equals = function(circle, toCompare) {
            return circle.x === toCompare.x && circle.y === toCompare.y && circle.radius === toCompare.radius;
          };
          module2.exports = Equals;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rectangle = __webpack_require__(10);
          var GetBounds = function(circle, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            out.x = circle.left;
            out.y = circle.top;
            out.width = circle.diameter;
            out.height = circle.diameter;
            return out;
          };
          module2.exports = GetBounds;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Offset = function(circle, x, y) {
            circle.x += x;
            circle.y += y;
            return circle;
          };
          module2.exports = Offset;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var OffsetPoint = function(circle, point) {
            circle.x += point.x;
            circle.y += point.y;
            return circle;
          };
          module2.exports = OffsetPoint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Ellipse = __webpack_require__(108);
          Ellipse.Area = __webpack_require__(1196);
          Ellipse.Circumference = __webpack_require__(441);
          Ellipse.CircumferencePoint = __webpack_require__(215);
          Ellipse.Clone = __webpack_require__(1197);
          Ellipse.Contains = __webpack_require__(109);
          Ellipse.ContainsPoint = __webpack_require__(1198);
          Ellipse.ContainsRect = __webpack_require__(1199);
          Ellipse.CopyFrom = __webpack_require__(1200);
          Ellipse.Equals = __webpack_require__(1201);
          Ellipse.GetBounds = __webpack_require__(1202);
          Ellipse.GetPoint = __webpack_require__(439);
          Ellipse.GetPoints = __webpack_require__(440);
          Ellipse.Offset = __webpack_require__(1203);
          Ellipse.OffsetPoint = __webpack_require__(1204);
          Ellipse.Random = __webpack_require__(177);
          module2.exports = Ellipse;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Area = function(ellipse) {
            if (ellipse.isEmpty()) {
              return 0;
            }
            return ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI;
          };
          module2.exports = Area;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Ellipse = __webpack_require__(108);
          var Clone = function(source) {
            return new Ellipse(source.x, source.y, source.width, source.height);
          };
          module2.exports = Clone;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Contains = __webpack_require__(109);
          var ContainsPoint = function(ellipse, point) {
            return Contains(ellipse, point.x, point.y);
          };
          module2.exports = ContainsPoint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Contains = __webpack_require__(109);
          var ContainsRect = function(ellipse, rect) {
            return Contains(ellipse, rect.x, rect.y) && Contains(ellipse, rect.right, rect.y) && Contains(ellipse, rect.x, rect.bottom) && Contains(ellipse, rect.right, rect.bottom);
          };
          module2.exports = ContainsRect;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CopyFrom = function(source, dest) {
            return dest.setTo(source.x, source.y, source.width, source.height);
          };
          module2.exports = CopyFrom;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Equals = function(ellipse, toCompare) {
            return ellipse.x === toCompare.x && ellipse.y === toCompare.y && ellipse.width === toCompare.width && ellipse.height === toCompare.height;
          };
          module2.exports = Equals;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rectangle = __webpack_require__(10);
          var GetBounds = function(ellipse, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            out.x = ellipse.left;
            out.y = ellipse.top;
            out.width = ellipse.width;
            out.height = ellipse.height;
            return out;
          };
          module2.exports = GetBounds;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Offset = function(ellipse, x, y) {
            ellipse.x += x;
            ellipse.y += y;
            return ellipse;
          };
          module2.exports = Offset;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var OffsetPoint = function(ellipse, point) {
            ellipse.x += point.x;
            ellipse.y += point.y;
            return ellipse;
          };
          module2.exports = OffsetPoint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Florian Vazelle
           * @author       Geoffrey Glaive
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var CircleToCircle = __webpack_require__(228);
          var GetCircleToCircle = function(circleA, circleB, out) {
            if (out === void 0) {
              out = [];
            }
            if (CircleToCircle(circleA, circleB)) {
              var x0 = circleA.x;
              var y0 = circleA.y;
              var r0 = circleA.radius;
              var x1 = circleB.x;
              var y1 = circleB.y;
              var r1 = circleB.radius;
              var coefficientA, coefficientB, coefficientC, lambda, x;
              if (y0 === y1) {
                x = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0) / (2 * (x0 - x1));
                coefficientA = 1;
                coefficientB = -2 * y1;
                coefficientC = x1 * x1 + x * x - 2 * x1 * x + y1 * y1 - r1 * r1;
                lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
                if (lambda === 0) {
                  out.push(new Point(x, -coefficientB / (2 * coefficientA)));
                } else if (lambda > 0) {
                  out.push(new Point(x, (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA)));
                  out.push(new Point(x, (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA)));
                }
              } else {
                var v1 = (x0 - x1) / (y0 - y1);
                var n = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0 - y1 * y1 + y0 * y0) / (2 * (y0 - y1));
                coefficientA = v1 * v1 + 1;
                coefficientB = 2 * y0 * v1 - 2 * n * v1 - 2 * x0;
                coefficientC = x0 * x0 + y0 * y0 + n * n - r0 * r0 - 2 * y0 * n;
                lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
                if (lambda === 0) {
                  x = -coefficientB / (2 * coefficientA);
                  out.push(new Point(x, n - x * v1));
                } else if (lambda > 0) {
                  x = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);
                  out.push(new Point(x, n - x * v1));
                  x = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);
                  out.push(new Point(x, n - x * v1));
                }
              }
            }
            return out;
          };
          module2.exports = GetCircleToCircle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Florian Vazelle
           * @author       Geoffrey Glaive
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetLineToCircle = __webpack_require__(229);
          var CircleToRectangle = __webpack_require__(150);
          var GetCircleToRectangle = function(circle, rect, out) {
            if (out === void 0) {
              out = [];
            }
            if (CircleToRectangle(circle, rect)) {
              var lineA = rect.getLineA();
              var lineB = rect.getLineB();
              var lineC = rect.getLineC();
              var lineD = rect.getLineD();
              GetLineToCircle(lineA, circle, out);
              GetLineToCircle(lineB, circle, out);
              GetLineToCircle(lineC, circle, out);
              GetLineToCircle(lineD, circle, out);
            }
            return out;
          };
          module2.exports = GetCircleToRectangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector4 = __webpack_require__(138);
          var GetLineToPolygon = __webpack_require__(481);
          var Line = __webpack_require__(45);
          var segment = new Line();
          function CheckIntersects(angle, x, y, polygons, intersects) {
            var dx = Math.cos(angle);
            var dy = Math.sin(angle);
            segment.setTo(x, y, x + dx, y + dy);
            var closestIntersect = GetLineToPolygon(segment, polygons);
            if (closestIntersect) {
              intersects.push(new Vector4(closestIntersect.x, closestIntersect.y, angle, closestIntersect.w));
            }
          }
          function SortIntersects(a, b) {
            return a.z - b.z;
          }
          var GetRaysFromPointToPolygon = function(x, y, polygons) {
            if (!Array.isArray(polygons)) {
              polygons = [polygons];
            }
            var intersects = [];
            var angles = [];
            for (var i = 0; i < polygons.length; i++) {
              var points = polygons[i].points;
              for (var p = 0; p < points.length; p++) {
                var angle = Math.atan2(points[p].y - y, points[p].x - x);
                if (angles.indexOf(angle) === -1) {
                  CheckIntersects(angle, x, y, polygons, intersects);
                  CheckIntersects(angle - 1e-5, x, y, polygons, intersects);
                  CheckIntersects(angle + 1e-5, x, y, polygons, intersects);
                  angles.push(angle);
                }
              }
            }
            return intersects.sort(SortIntersects);
          };
          module2.exports = GetRaysFromPointToPolygon;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rectangle = __webpack_require__(10);
          var RectangleToRectangle = __webpack_require__(114);
          var GetRectangleIntersection = function(rectA, rectB, output) {
            if (output === void 0) {
              output = new Rectangle();
            }
            if (RectangleToRectangle(rectA, rectB)) {
              output.x = Math.max(rectA.x, rectB.x);
              output.y = Math.max(rectA.y, rectB.y);
              output.width = Math.min(rectA.right, rectB.right) - output.x;
              output.height = Math.min(rectA.bottom, rectB.bottom) - output.y;
            }
            return output;
          };
          module2.exports = GetRectangleIntersection;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Florian Vazelle
           * @author       Geoffrey Glaive
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetLineToRectangle = __webpack_require__(231);
          var RectangleToRectangle = __webpack_require__(114);
          var GetRectangleToRectangle = function(rectA, rectB, out) {
            if (out === void 0) {
              out = [];
            }
            if (RectangleToRectangle(rectA, rectB)) {
              var lineA = rectA.getLineA();
              var lineB = rectA.getLineB();
              var lineC = rectA.getLineC();
              var lineD = rectA.getLineD();
              GetLineToRectangle(lineA, rectB, out);
              GetLineToRectangle(lineB, rectB, out);
              GetLineToRectangle(lineC, rectB, out);
              GetLineToRectangle(lineD, rectB, out);
            }
            return out;
          };
          module2.exports = GetRectangleToRectangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Florian Vazelle
           * @author       Geoffrey Glaive
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RectangleToTriangle = __webpack_require__(483);
          var GetLineToRectangle = __webpack_require__(231);
          var GetRectangleToTriangle = function(rect, triangle, out) {
            if (out === void 0) {
              out = [];
            }
            if (RectangleToTriangle(rect, triangle)) {
              var lineA = triangle.getLineA();
              var lineB = triangle.getLineB();
              var lineC = triangle.getLineC();
              GetLineToRectangle(lineA, rect, out);
              GetLineToRectangle(lineB, rect, out);
              GetLineToRectangle(lineC, rect, out);
            }
            return out;
          };
          module2.exports = GetRectangleToTriangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Florian Vazelle
           * @author       Geoffrey Glaive
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetLineToCircle = __webpack_require__(229);
          var TriangleToCircle = __webpack_require__(485);
          var GetTriangleToCircle = function(triangle, circle, out) {
            if (out === void 0) {
              out = [];
            }
            if (TriangleToCircle(triangle, circle)) {
              var lineA = triangle.getLineA();
              var lineB = triangle.getLineB();
              var lineC = triangle.getLineC();
              GetLineToCircle(lineA, circle, out);
              GetLineToCircle(lineB, circle, out);
              GetLineToCircle(lineC, circle, out);
            }
            return out;
          };
          module2.exports = GetTriangleToCircle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Florian Vazelle
           * @author       Geoffrey Glaive
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TriangleToTriangle = __webpack_require__(488);
          var GetTriangleToLine = __webpack_require__(486);
          var GetTriangleToTriangle = function(triangleA, triangleB, out) {
            if (out === void 0) {
              out = [];
            }
            if (TriangleToTriangle(triangleA, triangleB)) {
              var lineA = triangleB.getLineA();
              var lineB = triangleB.getLineB();
              var lineC = triangleB.getLineC();
              GetTriangleToLine(triangleA, lineA, out);
              GetTriangleToLine(triangleA, lineB, out);
              GetTriangleToLine(triangleA, lineC, out);
            }
            return out;
          };
          module2.exports = GetTriangleToTriangle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PointToLine = __webpack_require__(490);
          var PointToLineSegment = function(point, line) {
            if (!PointToLine(point, line)) {
              return false;
            }
            var xMin = Math.min(line.x1, line.x2);
            var xMax = Math.max(line.x1, line.x2);
            var yMin = Math.min(line.y1, line.y2);
            var yMax = Math.max(line.y1, line.y2);
            return point.x >= xMin && point.x <= xMax && (point.y >= yMin && point.y <= yMax);
          };
          module2.exports = PointToLineSegment;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RectangleToValues = function(rect, left, right, top, bottom, tolerance) {
            if (tolerance === void 0) {
              tolerance = 0;
            }
            return !(left > rect.right + tolerance || right < rect.left - tolerance || top > rect.bottom + tolerance || bottom < rect.top - tolerance);
          };
          module2.exports = RectangleToValues;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Line = __webpack_require__(45);
          Line.Angle = __webpack_require__(93);
          Line.BresenhamPoints = __webpack_require__(311);
          Line.CenterOn = __webpack_require__(1216);
          Line.Clone = __webpack_require__(1217);
          Line.CopyFrom = __webpack_require__(1218);
          Line.Equals = __webpack_require__(1219);
          Line.Extend = __webpack_require__(1220);
          Line.GetEasedPoints = __webpack_require__(1221);
          Line.GetMidPoint = __webpack_require__(1222);
          Line.GetNearestPoint = __webpack_require__(1223);
          Line.GetNormal = __webpack_require__(1224);
          Line.GetPoint = __webpack_require__(301);
          Line.GetPoints = __webpack_require__(168);
          Line.GetShortestDistance = __webpack_require__(1225);
          Line.Height = __webpack_require__(1226);
          Line.Length = __webpack_require__(64);
          Line.NormalAngle = __webpack_require__(491);
          Line.NormalX = __webpack_require__(1227);
          Line.NormalY = __webpack_require__(1228);
          Line.Offset = __webpack_require__(1229);
          Line.PerpSlope = __webpack_require__(1230);
          Line.Random = __webpack_require__(169);
          Line.ReflectAngle = __webpack_require__(1231);
          Line.Rotate = __webpack_require__(1232);
          Line.RotateAroundPoint = __webpack_require__(1233);
          Line.RotateAroundXY = __webpack_require__(233);
          Line.SetToAngle = __webpack_require__(1234);
          Line.Slope = __webpack_require__(1235);
          Line.Width = __webpack_require__(1236);
          module2.exports = Line;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CenterOn = function(line, x, y) {
            var tx = x - (line.x1 + line.x2) / 2;
            var ty = y - (line.y1 + line.y2) / 2;
            line.x1 += tx;
            line.y1 += ty;
            line.x2 += tx;
            line.y2 += ty;
            return line;
          };
          module2.exports = CenterOn;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Line = __webpack_require__(45);
          var Clone = function(source) {
            return new Line(source.x1, source.y1, source.x2, source.y2);
          };
          module2.exports = Clone;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CopyFrom = function(source, dest) {
            return dest.setTo(source.x1, source.y1, source.x2, source.y2);
          };
          module2.exports = CopyFrom;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Equals = function(line, toCompare) {
            return line.x1 === toCompare.x1 && line.y1 === toCompare.y1 && line.x2 === toCompare.x2 && line.y2 === toCompare.y2;
          };
          module2.exports = Equals;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Length = __webpack_require__(64);
          var Extend = function(line, left, right) {
            if (right === void 0) {
              right = left;
            }
            var length = Length(line);
            var slopX = line.x2 - line.x1;
            var slopY = line.y2 - line.y1;
            if (left) {
              line.x1 = line.x1 - slopX / length * left;
              line.y1 = line.y1 - slopY / length * left;
            }
            if (right) {
              line.x2 = line.x2 + slopX / length * right;
              line.y2 = line.y2 + slopY / length * right;
            }
            return line;
          };
          module2.exports = Extend;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DistanceBetweenPoints = __webpack_require__(346);
          var GetEaseFunction = __webpack_require__(80);
          var Point = __webpack_require__(4);
          var GetEasedPoints = function(line, ease, quantity, collinearThreshold, easeParams) {
            if (collinearThreshold === void 0) {
              collinearThreshold = 0;
            }
            if (easeParams === void 0) {
              easeParams = [];
            }
            var results = [];
            var x1 = line.x1;
            var y1 = line.y1;
            var spaceX = line.x2 - x1;
            var spaceY = line.y2 - y1;
            var easeFunc = GetEaseFunction(ease, easeParams);
            var i;
            var v;
            var q = quantity - 1;
            for (i = 0; i < q; i++) {
              v = easeFunc(i / q);
              results.push(new Point(x1 + spaceX * v, y1 + spaceY * v));
            }
            v = easeFunc(1);
            results.push(new Point(x1 + spaceX * v, y1 + spaceY * v));
            if (collinearThreshold > 0) {
              var prevPoint = results[0];
              var sortedResults = [prevPoint];
              for (i = 1; i < results.length - 1; i++) {
                var point = results[i];
                if (DistanceBetweenPoints(prevPoint, point) >= collinearThreshold) {
                  sortedResults.push(point);
                  prevPoint = point;
                }
              }
              var endPoint = results[results.length - 1];
              if (DistanceBetweenPoints(prevPoint, endPoint) < collinearThreshold) {
                sortedResults.pop();
              }
              sortedResults.push(endPoint);
              return sortedResults;
            } else {
              return results;
            }
          };
          module2.exports = GetEasedPoints;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var GetMidPoint = function(line, out) {
            if (out === void 0) {
              out = new Point();
            }
            out.x = (line.x1 + line.x2) / 2;
            out.y = (line.y1 + line.y2) / 2;
            return out;
          };
          module2.exports = GetMidPoint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Florian Mertens
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var GetNearestPoint = function(line, point, out) {
            if (out === void 0) {
              out = new Point();
            }
            var x1 = line.x1;
            var y1 = line.y1;
            var x2 = line.x2;
            var y2 = line.y2;
            var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            if (L2 === 0) {
              return out;
            }
            var r = ((point.x - x1) * (x2 - x1) + (point.y - y1) * (y2 - y1)) / L2;
            out.x = x1 + r * (x2 - x1);
            out.y = y1 + r * (y2 - y1);
            return out;
          };
          module2.exports = GetNearestPoint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MATH_CONST = __webpack_require__(14);
          var Angle = __webpack_require__(93);
          var Point = __webpack_require__(4);
          var GetNormal = function(line, out) {
            if (out === void 0) {
              out = new Point();
            }
            var a = Angle(line) - MATH_CONST.TAU;
            out.x = Math.cos(a);
            out.y = Math.sin(a);
            return out;
          };
          module2.exports = GetNormal;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Florian Mertens
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetShortestDistance = function(line, point) {
            var x1 = line.x1;
            var y1 = line.y1;
            var x2 = line.x2;
            var y2 = line.y2;
            var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            if (L2 === 0) {
              return false;
            }
            var s = ((y1 - point.y) * (x2 - x1) - (x1 - point.x) * (y2 - y1)) / L2;
            return Math.abs(s) * Math.sqrt(L2);
          };
          module2.exports = GetShortestDistance;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Height = function(line) {
            return Math.abs(line.y1 - line.y2);
          };
          module2.exports = Height;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MATH_CONST = __webpack_require__(14);
          var Angle = __webpack_require__(93);
          var NormalX = function(line) {
            return Math.cos(Angle(line) - MATH_CONST.TAU);
          };
          module2.exports = NormalX;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MATH_CONST = __webpack_require__(14);
          var Angle = __webpack_require__(93);
          var NormalY = function(line) {
            return Math.sin(Angle(line) - MATH_CONST.TAU);
          };
          module2.exports = NormalY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Offset = function(line, x, y) {
            line.x1 += x;
            line.y1 += y;
            line.x2 += x;
            line.y2 += y;
            return line;
          };
          module2.exports = Offset;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PerpSlope = function(line) {
            return -((line.x2 - line.x1) / (line.y2 - line.y1));
          };
          module2.exports = PerpSlope;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Angle = __webpack_require__(93);
          var NormalAngle = __webpack_require__(491);
          var ReflectAngle = function(lineA, lineB) {
            return 2 * NormalAngle(lineB) - Math.PI - Angle(lineA);
          };
          module2.exports = ReflectAngle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateAroundXY = __webpack_require__(233);
          var Rotate = function(line, angle) {
            var x = (line.x1 + line.x2) / 2;
            var y = (line.y1 + line.y2) / 2;
            return RotateAroundXY(line, x, y, angle);
          };
          module2.exports = Rotate;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateAroundXY = __webpack_require__(233);
          var RotateAroundPoint = function(line, point, angle) {
            return RotateAroundXY(line, point.x, point.y, angle);
          };
          module2.exports = RotateAroundPoint;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetToAngle = function(line, x, y, angle, length) {
            line.x1 = x;
            line.y1 = y;
            line.x2 = x + Math.cos(angle) * length;
            line.y2 = y + Math.sin(angle) * length;
            return line;
          };
          module2.exports = SetToAngle;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Slope = function(line) {
            return (line.y2 - line.y1) / (line.x2 - line.x1);
          };
          module2.exports = Slope;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Width = function(line) {
            return Math.abs(line.x1 - line.x2);
          };
          module2.exports = Width;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Mesh = {
            Face: __webpack_require__(113),
            GenerateGridVerts: __webpack_require__(1238),
            GenerateObjVerts: __webpack_require__(474),
            GenerateVerts: __webpack_require__(473),
            ParseObj: __webpack_require__(492),
            ParseObjMaterial: __webpack_require__(493),
            RotateFace: __webpack_require__(1239),
            Vertex: __webpack_require__(115)
          };
          module2.exports = Mesh;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Face = __webpack_require__(113);
          var GetFastValue = __webpack_require__(2);
          var Matrix4 = __webpack_require__(67);
          var Vector3 = __webpack_require__(38);
          var Vertex = __webpack_require__(115);
          var tempPosition = new Vector3();
          var tempRotation = new Vector3();
          var tempMatrix = new Matrix4();
          var GenerateGridVerts = function(config2) {
            var mesh = GetFastValue(config2, "mesh");
            var texture = GetFastValue(config2, "texture", null);
            var frame = GetFastValue(config2, "frame");
            var width = GetFastValue(config2, "width", 1);
            var height = GetFastValue(config2, "height", width);
            var widthSegments = GetFastValue(config2, "widthSegments", 1);
            var heightSegments = GetFastValue(config2, "heightSegments", widthSegments);
            var posX = GetFastValue(config2, "x", 0);
            var posY = GetFastValue(config2, "y", 0);
            var posZ = GetFastValue(config2, "z", 0);
            var rotateX = GetFastValue(config2, "rotateX", 0);
            var rotateY = GetFastValue(config2, "rotateY", 0);
            var rotateZ = GetFastValue(config2, "rotateZ", 0);
            var zIsUp = GetFastValue(config2, "zIsUp", true);
            var isOrtho = GetFastValue(config2, "isOrtho", mesh ? mesh.dirtyCache[11] : false);
            var colors = GetFastValue(config2, "colors", [16777215]);
            var alphas = GetFastValue(config2, "alphas", [1]);
            var tile = GetFastValue(config2, "tile", false);
            var flipY = GetFastValue(config2, "flipY", false);
            var widthSet = GetFastValue(config2, "width", null);
            var result = {
              faces: [],
              verts: []
            };
            tempPosition.set(posX, posY, posZ);
            tempRotation.set(rotateX, rotateY, rotateZ);
            tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);
            if (!texture && mesh) {
              texture = mesh.texture;
            } else if (mesh && typeof texture === "string") {
              texture = mesh.scene.sys.textures.get(texture);
            } else {
              return result;
            }
            var textureFrame = texture.get(frame);
            if (!widthSet && isOrtho && texture && mesh) {
              width = textureFrame.width / mesh.height;
              height = textureFrame.height / mesh.height;
            }
            var halfWidth = width / 2;
            var halfHeight = height / 2;
            var gridX = Math.floor(widthSegments);
            var gridY = Math.floor(heightSegments);
            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;
            var segmentWidth = width / gridX;
            var segmentHeight = height / gridY;
            var uvs = [];
            var vertices = [];
            var ix;
            var iy;
            var frameU0 = 0;
            var frameU1 = 1;
            var frameV0 = 0;
            var frameV1 = 1;
            if (textureFrame) {
              frameU0 = textureFrame.u0;
              frameU1 = textureFrame.u1;
              if (!flipY) {
                frameV0 = textureFrame.v0;
                frameV1 = textureFrame.v1;
              } else {
                frameV0 = textureFrame.v1;
                frameV1 = textureFrame.v0;
              }
            }
            var frameU = frameU1 - frameU0;
            var frameV = frameV1 - frameV0;
            for (iy = 0; iy < gridY1; iy++) {
              var y = iy * segmentHeight - halfHeight;
              for (ix = 0; ix < gridX1; ix++) {
                var x = ix * segmentWidth - halfWidth;
                vertices.push(x, -y);
                var tu = frameU0 + frameU * (ix / gridX);
                var tv = frameV0 + frameV * (iy / gridY);
                uvs.push(tu, tv);
              }
            }
            if (!Array.isArray(colors)) {
              colors = [colors];
            }
            if (!Array.isArray(alphas)) {
              alphas = [alphas];
            }
            var alphaIndex = 0;
            var colorIndex = 0;
            for (iy = 0; iy < gridY; iy++) {
              for (ix = 0; ix < gridX; ix++) {
                var a = (ix + gridX1 * iy) * 2;
                var b = (ix + gridX1 * (iy + 1)) * 2;
                var c = (ix + 1 + gridX1 * (iy + 1)) * 2;
                var d = (ix + 1 + gridX1 * iy) * 2;
                var color = colors[colorIndex];
                var alpha = alphas[alphaIndex];
                var vert1 = new Vertex(vertices[a], vertices[a + 1], 0, uvs[a], uvs[a + 1], color, alpha).transformMat4(tempMatrix);
                var vert2 = new Vertex(vertices[b], vertices[b + 1], 0, uvs[b], uvs[b + 1], color, alpha).transformMat4(tempMatrix);
                var vert3 = new Vertex(vertices[d], vertices[d + 1], 0, uvs[d], uvs[d + 1], color, alpha).transformMat4(tempMatrix);
                var vert4 = new Vertex(vertices[b], vertices[b + 1], 0, uvs[b], uvs[b + 1], color, alpha).transformMat4(tempMatrix);
                var vert5 = new Vertex(vertices[c], vertices[c + 1], 0, uvs[c], uvs[c + 1], color, alpha).transformMat4(tempMatrix);
                var vert6 = new Vertex(vertices[d], vertices[d + 1], 0, uvs[d], uvs[d + 1], color, alpha).transformMat4(tempMatrix);
                if (tile) {
                  vert1.setUVs(frameU0, frameV1);
                  vert2.setUVs(frameU0, frameV0);
                  vert3.setUVs(frameU1, frameV1);
                  vert4.setUVs(frameU0, frameV0);
                  vert5.setUVs(frameU1, frameV0);
                  vert6.setUVs(frameU1, frameV1);
                }
                colorIndex++;
                if (colorIndex === colors.length) {
                  colorIndex = 0;
                }
                alphaIndex++;
                if (alphaIndex === alphas.length) {
                  alphaIndex = 0;
                }
                result.verts.push(vert1, vert2, vert3, vert4, vert5, vert6);
                result.faces.push(new Face(vert1, vert2, vert3), new Face(vert4, vert5, vert6));
              }
            }
            if (mesh) {
              mesh.faces = mesh.faces.concat(result.faces);
              mesh.vertices = mesh.vertices.concat(result.verts);
            }
            return result;
          };
          module2.exports = GenerateGridVerts;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateFace = function(face, angle, cx, cy) {
            var x;
            var y;
            if (cx === void 0 && cy === void 0) {
              var inCenter = face.getInCenter();
              x = inCenter.x;
              y = inCenter.y;
            }
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var v1 = face.vertex1;
            var v2 = face.vertex2;
            var v3 = face.vertex3;
            var tx = v1.x - x;
            var ty = v1.y - y;
            v1.set(tx * c - ty * s + x, tx * s + ty * c + y);
            tx = v2.x - x;
            ty = v2.y - y;
            v2.set(tx * c - ty * s + x, tx * s + ty * c + y);
            tx = v3.x - x;
            ty = v3.y - y;
            v3.set(tx * c - ty * s + x, tx * s + ty * c + y);
          };
          module2.exports = RotateFace;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          Point.Ceil = __webpack_require__(1241);
          Point.Clone = __webpack_require__(1242);
          Point.CopyFrom = __webpack_require__(1243);
          Point.Equals = __webpack_require__(1244);
          Point.Floor = __webpack_require__(1245);
          Point.GetCentroid = __webpack_require__(1246);
          Point.GetMagnitude = __webpack_require__(494);
          Point.GetMagnitudeSq = __webpack_require__(495);
          Point.GetRectangleFromPoints = __webpack_require__(1247);
          Point.Interpolate = __webpack_require__(1248);
          Point.Invert = __webpack_require__(1249);
          Point.Negative = __webpack_require__(1250);
          Point.Project = __webpack_require__(1251);
          Point.ProjectUnit = __webpack_require__(1252);
          Point.SetMagnitude = __webpack_require__(1253);
          module2.exports = Point;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Ceil = function(point) {
            return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
          };
          module2.exports = Ceil;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var Clone = function(source) {
            return new Point(source.x, source.y);
          };
          module2.exports = Clone;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CopyFrom = function(source, dest) {
            return dest.setTo(source.x, source.y);
          };
          module2.exports = CopyFrom;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Equals = function(point, toCompare) {
            return point.x === toCompare.x && point.y === toCompare.y;
          };
          module2.exports = Equals;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Floor = function(point) {
            return point.setTo(Math.floor(point.x), Math.floor(point.y));
          };
          module2.exports = Floor;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var GetCentroid = function(points, out) {
            if (out === void 0) {
              out = new Point();
            }
            if (!Array.isArray(points)) {
              throw new Error("GetCentroid points argument must be an array");
            }
            var len = points.length;
            if (len < 1) {
              throw new Error("GetCentroid points array must not be empty");
            } else if (len === 1) {
              out.x = points[0].x;
              out.y = points[0].y;
            } else {
              for (var i = 0; i < len; i++) {
                out.x += points[i].x;
                out.y += points[i].y;
              }
              out.x /= len;
              out.y /= len;
            }
            return out;
          };
          module2.exports = GetCentroid;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rectangle = __webpack_require__(10);
          var GetRectangleFromPoints = function(points, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            var xMax = Number.NEGATIVE_INFINITY;
            var xMin = Number.POSITIVE_INFINITY;
            var yMax = Number.NEGATIVE_INFINITY;
            var yMin = Number.POSITIVE_INFINITY;
            for (var i = 0; i < points.length; i++) {
              var point = points[i];
              if (point.x > xMax) {
                xMax = point.x;
              }
              if (point.x < xMin) {
                xMin = point.x;
              }
              if (point.y > yMax) {
                yMax = point.y;
              }
              if (point.y < yMin) {
                yMin = point.y;
              }
            }
            out.x = xMin;
            out.y = yMin;
            out.width = xMax - xMin;
            out.height = yMax - yMin;
            return out;
          };
          module2.exports = GetRectangleFromPoints;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var Interpolate = function(pointA, pointB, t, out) {
            if (t === void 0) {
              t = 0;
            }
            if (out === void 0) {
              out = new Point();
            }
            out.x = pointA.x + (pointB.x - pointA.x) * t;
            out.y = pointA.y + (pointB.y - pointA.y) * t;
            return out;
          };
          module2.exports = Interpolate;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Invert = function(point) {
            return point.setTo(point.y, point.x);
          };
          module2.exports = Invert;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var Negative = function(point, out) {
            if (out === void 0) {
              out = new Point();
            }
            return out.setTo(-point.x, -point.y);
          };
          module2.exports = Negative;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var GetMagnitudeSq = __webpack_require__(495);
          var Project = function(pointA, pointB, out) {
            if (out === void 0) {
              out = new Point();
            }
            var dot = pointA.x * pointB.x + pointA.y * pointB.y;
            var amt = dot / GetMagnitudeSq(pointB);
            if (amt !== 0) {
              out.x = amt * pointB.x;
              out.y = amt * pointB.y;
            }
            return out;
          };
          module2.exports = Project;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var ProjectUnit = function(pointA, pointB, out) {
            if (out === void 0) {
              out = new Point();
            }
            var amt = pointA.x * pointB.x + pointA.y * pointB.y;
            if (amt !== 0) {
              out.x = amt * pointB.x;
              out.y = amt * pointB.y;
            }
            return out;
          };
          module2.exports = ProjectUnit;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetMagnitude = __webpack_require__(494);
          var SetMagnitude = function(point, magnitude) {
            if (point.x !== 0 || point.y !== 0) {
              var m = GetMagnitude(point);
              point.x /= m;
              point.y /= m;
            }
            point.x *= magnitude;
            point.y *= magnitude;
            return point;
          };
          module2.exports = SetMagnitude;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Polygon = __webpack_require__(224);
          Polygon.Clone = __webpack_require__(1255);
          Polygon.Contains = __webpack_require__(225);
          Polygon.ContainsPoint = __webpack_require__(1256);
          Polygon.Earcut = __webpack_require__(68);
          Polygon.GetAABB = __webpack_require__(463);
          Polygon.GetNumberArray = __webpack_require__(1257);
          Polygon.GetPoints = __webpack_require__(464);
          Polygon.Perimeter = __webpack_require__(465);
          Polygon.Reverse = __webpack_require__(1258);
          Polygon.Simplify = __webpack_require__(1259);
          Polygon.Smooth = __webpack_require__(466);
          Polygon.Translate = __webpack_require__(1260);
          module2.exports = Polygon;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Polygon = __webpack_require__(224);
          var Clone = function(polygon) {
            return new Polygon(polygon.points);
          };
          module2.exports = Clone;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Contains = __webpack_require__(225);
          var ContainsPoint = function(polygon, point) {
            return Contains(polygon, point.x, point.y);
          };
          module2.exports = ContainsPoint;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetNumberArray = function(polygon, output) {
            if (output === void 0) {
              output = [];
            }
            for (var i = 0; i < polygon.points.length; i++) {
              output.push(polygon.points[i].x);
              output.push(polygon.points[i].y);
            }
            return output;
          };
          module2.exports = GetNumberArray;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Reverse = function(polygon) {
            polygon.points.reverse();
            return polygon;
          };
          module2.exports = Reverse;
        },
        function(module2, exports2) {
          function getSqDist(p1, p2) {
            var dx = p1.x - p2.x, dy = p1.y - p2.y;
            return dx * dx + dy * dy;
          }
          function getSqSegDist(p, p1, p2) {
            var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y;
            if (dx !== 0 || dy !== 0) {
              var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);
              if (t > 1) {
                x = p2.x;
                y = p2.y;
              } else if (t > 0) {
                x += dx * t;
                y += dy * t;
              }
            }
            dx = p.x - x;
            dy = p.y - y;
            return dx * dx + dy * dy;
          }
          function simplifyRadialDist(points, sqTolerance) {
            var prevPoint = points[0], newPoints = [prevPoint], point;
            for (var i = 1, len = points.length; i < len; i++) {
              point = points[i];
              if (getSqDist(point, prevPoint) > sqTolerance) {
                newPoints.push(point);
                prevPoint = point;
              }
            }
            if (prevPoint !== point) {
              newPoints.push(point);
            }
            return newPoints;
          }
          function simplifyDPStep(points, first, last, sqTolerance, simplified) {
            var maxSqDist = sqTolerance, index;
            for (var i = first + 1; i < last; i++) {
              var sqDist = getSqSegDist(points[i], points[first], points[last]);
              if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
              }
            }
            if (maxSqDist > sqTolerance) {
              if (index - first > 1) {
                simplifyDPStep(points, first, index, sqTolerance, simplified);
              }
              simplified.push(points[index]);
              if (last - index > 1) {
                simplifyDPStep(points, index, last, sqTolerance, simplified);
              }
            }
          }
          function simplifyDouglasPeucker(points, sqTolerance) {
            var last = points.length - 1;
            var simplified = [points[0]];
            simplifyDPStep(points, 0, last, sqTolerance, simplified);
            simplified.push(points[last]);
            return simplified;
          }
          var Simplify = function(polygon, tolerance, highestQuality) {
            if (tolerance === void 0) {
              tolerance = 1;
            }
            if (highestQuality === void 0) {
              highestQuality = false;
            }
            var points = polygon.points;
            if (points.length > 2) {
              var sqTolerance = tolerance * tolerance;
              if (!highestQuality) {
                points = simplifyRadialDist(points, sqTolerance);
              }
              polygon.setTo(simplifyDouglasPeucker(points, sqTolerance));
            }
            return polygon;
          };
          module2.exports = Simplify;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Translate = function(polygon, x, y) {
            var points = polygon.points;
            for (var i = 0; i < points.length; i++) {
              points[i].x += x;
              points[i].y += y;
            }
            return polygon;
          };
          module2.exports = Translate;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Area = function(rect) {
            return rect.width * rect.height;
          };
          module2.exports = Area;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Ceil = function(rect) {
            rect.x = Math.ceil(rect.x);
            rect.y = Math.ceil(rect.y);
            return rect;
          };
          module2.exports = Ceil;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CeilAll = function(rect) {
            rect.x = Math.ceil(rect.x);
            rect.y = Math.ceil(rect.y);
            rect.width = Math.ceil(rect.width);
            rect.height = Math.ceil(rect.height);
            return rect;
          };
          module2.exports = CeilAll;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rectangle = __webpack_require__(10);
          var Clone = function(source) {
            return new Rectangle(source.x, source.y, source.width, source.height);
          };
          module2.exports = Clone;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Contains = __webpack_require__(56);
          var ContainsPoint = function(rect, point) {
            return Contains(rect, point.x, point.y);
          };
          module2.exports = ContainsPoint;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CopyFrom = function(source, dest) {
            return dest.setTo(source.x, source.y, source.width, source.height);
          };
          module2.exports = CopyFrom;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Equals = function(rect, toCompare) {
            return rect.x === toCompare.x && rect.y === toCompare.y && rect.width === toCompare.width && rect.height === toCompare.height;
          };
          module2.exports = Equals;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetAspectRatio = __webpack_require__(234);
          var FitInside = function(target, source) {
            var ratio = GetAspectRatio(target);
            if (ratio < GetAspectRatio(source)) {
              target.setSize(source.height * ratio, source.height);
            } else {
              target.setSize(source.width, source.width / ratio);
            }
            return target.setPosition(source.centerX - target.width / 2, source.centerY - target.height / 2);
          };
          module2.exports = FitInside;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetAspectRatio = __webpack_require__(234);
          var FitOutside = function(target, source) {
            var ratio = GetAspectRatio(target);
            if (ratio > GetAspectRatio(source)) {
              target.setSize(source.height * ratio, source.height);
            } else {
              target.setSize(source.width, source.width / ratio);
            }
            return target.setPosition(source.centerX - target.width / 2, source.centerY - target.height / 2);
          };
          module2.exports = FitOutside;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Floor = function(rect) {
            rect.x = Math.floor(rect.x);
            rect.y = Math.floor(rect.y);
            return rect;
          };
          module2.exports = Floor;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FloorAll = function(rect) {
            rect.x = Math.floor(rect.x);
            rect.y = Math.floor(rect.y);
            rect.width = Math.floor(rect.width);
            rect.height = Math.floor(rect.height);
            return rect;
          };
          module2.exports = FloorAll;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       samme
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rectangle = __webpack_require__(10);
          var FromXY = function(x1, y1, x2, y2, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            return out.setTo(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));
          };
          module2.exports = FromXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var GetCenter = function(rect, out) {
            if (out === void 0) {
              out = new Point();
            }
            out.x = rect.centerX;
            out.y = rect.centerY;
            return out;
          };
          module2.exports = GetCenter;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var GetSize = function(rect, out) {
            if (out === void 0) {
              out = new Point();
            }
            out.x = rect.width;
            out.y = rect.height;
            return out;
          };
          module2.exports = GetSize;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CenterOn = __webpack_require__(187);
          var Inflate = function(rect, x, y) {
            var cx = rect.centerX;
            var cy = rect.centerY;
            rect.setSize(rect.width + x * 2, rect.height + y * 2);
            return CenterOn(rect, cx, cy);
          };
          module2.exports = Inflate;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Rectangle = __webpack_require__(10);
          var Intersects = __webpack_require__(114);
          var Intersection = function(rectA, rectB, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            if (Intersects(rectA, rectB)) {
              out.x = Math.max(rectA.x, rectB.x);
              out.y = Math.max(rectA.y, rectB.y);
              out.width = Math.min(rectA.right, rectB.right) - out.x;
              out.height = Math.min(rectA.bottom, rectB.bottom) - out.y;
            } else {
              out.setEmpty();
            }
            return out;
          };
          module2.exports = Intersection;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MergePoints = function(target, points) {
            var minX = target.x;
            var maxX = target.right;
            var minY = target.y;
            var maxY = target.bottom;
            for (var i = 0; i < points.length; i++) {
              minX = Math.min(minX, points[i].x);
              maxX = Math.max(maxX, points[i].x);
              minY = Math.min(minY, points[i].y);
              maxY = Math.max(maxY, points[i].y);
            }
            target.x = minX;
            target.y = minY;
            target.width = maxX - minX;
            target.height = maxY - minY;
            return target;
          };
          module2.exports = MergePoints;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MergeRect = function(target, source) {
            var minX = Math.min(target.x, source.x);
            var maxX = Math.max(target.right, source.right);
            target.x = minX;
            target.width = maxX - minX;
            var minY = Math.min(target.y, source.y);
            var maxY = Math.max(target.bottom, source.bottom);
            target.y = minY;
            target.height = maxY - minY;
            return target;
          };
          module2.exports = MergeRect;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MergeXY = function(target, x, y) {
            var minX = Math.min(target.x, x);
            var maxX = Math.max(target.right, x);
            target.x = minX;
            target.width = maxX - minX;
            var minY = Math.min(target.y, y);
            var maxY = Math.max(target.bottom, y);
            target.y = minY;
            target.height = maxY - minY;
            return target;
          };
          module2.exports = MergeXY;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Offset = function(rect, x, y) {
            rect.x += x;
            rect.y += y;
            return rect;
          };
          module2.exports = Offset;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var OffsetPoint = function(rect, point) {
            rect.x += point.x;
            rect.y += point.y;
            return rect;
          };
          module2.exports = OffsetPoint;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Overlaps = function(rectA, rectB) {
            return rectA.x < rectB.right && rectA.right > rectB.x && rectA.y < rectB.bottom && rectA.bottom > rectB.y;
          };
          module2.exports = Overlaps;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Point = __webpack_require__(4);
          var DegToRad = __webpack_require__(35);
          var PerimeterPoint = function(rectangle, angle, out) {
            if (out === void 0) {
              out = new Point();
            }
            angle = DegToRad(angle);
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            var dx = c > 0 ? rectangle.width / 2 : rectangle.width / -2;
            var dy = s > 0 ? rectangle.height / 2 : rectangle.height / -2;
            if (Math.abs(dx * s) < Math.abs(dy * c)) {
              dy = dx * s / c;
            } else {
              dx = dy * c / s;
            }
            out.x = dx + rectangle.centerX;
            out.y = dy + rectangle.centerY;
            return out;
          };
          module2.exports = PerimeterPoint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Between = __webpack_require__(192);
          var ContainsRect = __webpack_require__(497);
          var Point = __webpack_require__(4);
          var RandomOutside = function(outer, inner, out) {
            if (out === void 0) {
              out = new Point();
            }
            if (ContainsRect(outer, inner)) {
              switch (Between(0, 3)) {
                case 0:
                  out.x = outer.x + Math.random() * (inner.right - outer.x);
                  out.y = outer.y + Math.random() * (inner.top - outer.y);
                  break;
                case 1:
                  out.x = inner.x + Math.random() * (outer.right - inner.x);
                  out.y = inner.bottom + Math.random() * (outer.bottom - inner.bottom);
                  break;
                case 2:
                  out.x = outer.x + Math.random() * (inner.x - outer.x);
                  out.y = inner.y + Math.random() * (outer.bottom - inner.y);
                  break;
                case 3:
                  out.x = inner.right + Math.random() * (outer.right - inner.right);
                  out.y = outer.y + Math.random() * (inner.bottom - outer.y);
                  break;
              }
            }
            return out;
          };
          module2.exports = RandomOutside;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SameDimensions = function(rect, toCompare) {
            return rect.width === toCompare.width && rect.height === toCompare.height;
          };
          module2.exports = SameDimensions;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Scale = function(rect, x, y) {
            if (y === void 0) {
              y = x;
            }
            rect.width *= x;
            rect.height *= y;
            return rect;
          };
          module2.exports = Scale;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Triangle = __webpack_require__(82);
          Triangle.Area = __webpack_require__(1288);
          Triangle.BuildEquilateral = __webpack_require__(1289);
          Triangle.BuildFromPolygon = __webpack_require__(1290);
          Triangle.BuildRight = __webpack_require__(1291);
          Triangle.CenterOn = __webpack_require__(1292);
          Triangle.Centroid = __webpack_require__(498);
          Triangle.CircumCenter = __webpack_require__(1293);
          Triangle.CircumCircle = __webpack_require__(1294);
          Triangle.Clone = __webpack_require__(1295);
          Triangle.Contains = __webpack_require__(112);
          Triangle.ContainsArray = __webpack_require__(232);
          Triangle.ContainsPoint = __webpack_require__(1296);
          Triangle.CopyFrom = __webpack_require__(1297);
          Triangle.Decompose = __webpack_require__(489);
          Triangle.Equals = __webpack_require__(1298);
          Triangle.GetPoint = __webpack_require__(470);
          Triangle.GetPoints = __webpack_require__(471);
          Triangle.InCenter = __webpack_require__(500);
          Triangle.Perimeter = __webpack_require__(1299);
          Triangle.Offset = __webpack_require__(499);
          Triangle.Random = __webpack_require__(178);
          Triangle.Rotate = __webpack_require__(1300);
          Triangle.RotateAroundPoint = __webpack_require__(1301);
          Triangle.RotateAroundXY = __webpack_require__(235);
          module2.exports = Triangle;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Area = function(triangle) {
            var x1 = triangle.x1;
            var y1 = triangle.y1;
            var x2 = triangle.x2;
            var y2 = triangle.y2;
            var x3 = triangle.x3;
            var y3 = triangle.y3;
            return Math.abs(((x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)) / 2);
          };
          module2.exports = Area;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Triangle = __webpack_require__(82);
          var BuildEquilateral = function(x, y, length) {
            var height = length * (Math.sqrt(3) / 2);
            var x1 = x;
            var y1 = y;
            var x2 = x + length / 2;
            var y2 = y + height;
            var x3 = x - length / 2;
            var y3 = y + height;
            return new Triangle(x1, y1, x2, y2, x3, y3);
          };
          module2.exports = BuildEquilateral;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var EarCut = __webpack_require__(68);
          var Triangle = __webpack_require__(82);
          var BuildFromPolygon = function(data, holes, scaleX, scaleY, out) {
            if (holes === void 0) {
              holes = null;
            }
            if (scaleX === void 0) {
              scaleX = 1;
            }
            if (scaleY === void 0) {
              scaleY = 1;
            }
            if (out === void 0) {
              out = [];
            }
            var tris = EarCut(data, holes);
            var a;
            var b;
            var c;
            var x1;
            var y1;
            var x2;
            var y2;
            var x3;
            var y3;
            for (var i = 0; i < tris.length; i += 3) {
              a = tris[i];
              b = tris[i + 1];
              c = tris[i + 2];
              x1 = data[a * 2] * scaleX;
              y1 = data[a * 2 + 1] * scaleY;
              x2 = data[b * 2] * scaleX;
              y2 = data[b * 2 + 1] * scaleY;
              x3 = data[c * 2] * scaleX;
              y3 = data[c * 2 + 1] * scaleY;
              out.push(new Triangle(x1, y1, x2, y2, x3, y3));
            }
            return out;
          };
          module2.exports = BuildFromPolygon;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Triangle = __webpack_require__(82);
          var BuildRight = function(x, y, width, height) {
            if (height === void 0) {
              height = width;
            }
            var x1 = x;
            var y1 = y;
            var x2 = x;
            var y2 = y - height;
            var x3 = x + width;
            var y3 = y;
            return new Triangle(x1, y1, x2, y2, x3, y3);
          };
          module2.exports = BuildRight;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Centroid = __webpack_require__(498);
          var Offset = __webpack_require__(499);
          var CenterOn = function(triangle, x, y, centerFunc) {
            if (centerFunc === void 0) {
              centerFunc = Centroid;
            }
            var center = centerFunc(triangle);
            var diffX = x - center.x;
            var diffY = y - center.y;
            return Offset(triangle, diffX, diffY);
          };
          module2.exports = CenterOn;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Vector29 = __webpack_require__(3);
          function det(m00, m01, m10, m11) {
            return m00 * m11 - m01 * m10;
          }
          var CircumCenter = function(triangle, out) {
            if (out === void 0) {
              out = new Vector29();
            }
            var cx = triangle.x3;
            var cy = triangle.y3;
            var ax = triangle.x1 - cx;
            var ay = triangle.y1 - cy;
            var bx = triangle.x2 - cx;
            var by = triangle.y2 - cy;
            var denom = 2 * det(ax, ay, bx, by);
            var numx = det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
            var numy = det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
            out.x = cx - numx / denom;
            out.y = cy + numy / denom;
            return out;
          };
          module2.exports = CircumCenter;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Circle = __webpack_require__(62);
          var CircumCircle = function(triangle, out) {
            if (out === void 0) {
              out = new Circle();
            }
            var x1 = triangle.x1;
            var y1 = triangle.y1;
            var x2 = triangle.x2;
            var y2 = triangle.y2;
            var x3 = triangle.x3;
            var y3 = triangle.y3;
            var A = x2 - x1;
            var B = y2 - y1;
            var C = x3 - x1;
            var D = y3 - y1;
            var E = A * (x1 + x2) + B * (y1 + y2);
            var F = C * (x1 + x3) + D * (y1 + y3);
            var G = 2 * (A * (y3 - y2) - B * (x3 - x2));
            var dx;
            var dy;
            if (Math.abs(G) < 1e-6) {
              var minX = Math.min(x1, x2, x3);
              var minY = Math.min(y1, y2, y3);
              dx = (Math.max(x1, x2, x3) - minX) * 0.5;
              dy = (Math.max(y1, y2, y3) - minY) * 0.5;
              out.x = minX + dx;
              out.y = minY + dy;
              out.radius = Math.sqrt(dx * dx + dy * dy);
            } else {
              out.x = (D * E - B * F) / G;
              out.y = (A * F - C * E) / G;
              dx = out.x - x1;
              dy = out.y - y1;
              out.radius = Math.sqrt(dx * dx + dy * dy);
            }
            return out;
          };
          module2.exports = CircumCircle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Triangle = __webpack_require__(82);
          var Clone = function(source) {
            return new Triangle(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
          };
          module2.exports = Clone;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Contains = __webpack_require__(112);
          var ContainsPoint = function(triangle, point) {
            return Contains(triangle, point.x, point.y);
          };
          module2.exports = ContainsPoint;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CopyFrom = function(source, dest) {
            return dest.setTo(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
          };
          module2.exports = CopyFrom;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Equals = function(triangle, toCompare) {
            return triangle.x1 === toCompare.x1 && triangle.y1 === toCompare.y1 && triangle.x2 === toCompare.x2 && triangle.y2 === toCompare.y2 && triangle.x3 === toCompare.x3 && triangle.y3 === toCompare.y3;
          };
          module2.exports = Equals;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Length = __webpack_require__(64);
          var Perimeter = function(triangle) {
            var line1 = triangle.getLineA();
            var line2 = triangle.getLineB();
            var line3 = triangle.getLineC();
            return Length(line1) + Length(line2) + Length(line3);
          };
          module2.exports = Perimeter;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateAroundXY = __webpack_require__(235);
          var InCenter = __webpack_require__(500);
          var Rotate = function(triangle, angle) {
            var point = InCenter(triangle);
            return RotateAroundXY(triangle, point.x, point.y, angle);
          };
          module2.exports = Rotate;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RotateAroundXY = __webpack_require__(235);
          var RotateAroundPoint = function(triangle, point, angle) {
            return RotateAroundXY(triangle, point.x, point.y, angle);
          };
          module2.exports = RotateAroundPoint;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(200);
          var Extend = __webpack_require__(17);
          var Input = {
            CreatePixelPerfectHandler: __webpack_require__(501),
            CreateInteractiveObject: __webpack_require__(502),
            Events: __webpack_require__(49),
            Gamepad: __webpack_require__(1303),
            InputManager: __webpack_require__(403),
            InputPlugin: __webpack_require__(1315),
            InputPluginCache: __webpack_require__(151),
            Keyboard: __webpack_require__(1316),
            Mouse: __webpack_require__(1330),
            Pointer: __webpack_require__(406),
            Touch: __webpack_require__(1331)
          };
          Input = Extend(false, Input, CONST);
          module2.exports = Input;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Axis: __webpack_require__(503),
            Button: __webpack_require__(504),
            Events: __webpack_require__(236),
            Gamepad: __webpack_require__(505),
            GamepadPlugin: __webpack_require__(1310),
            Configs: __webpack_require__(1311)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "down";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "up";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "connected";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "disconnected";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "down";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "up";
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(236);
          var Gamepad = __webpack_require__(505);
          var GetValue = __webpack_require__(6);
          var InputPluginCache = __webpack_require__(151);
          var InputEvents = __webpack_require__(49);
          var GamepadPlugin = new Class({
            Extends: EventEmitter,
            initialize: function GamepadPlugin2(sceneInputPlugin) {
              EventEmitter.call(this);
              this.scene = sceneInputPlugin.scene;
              this.settings = this.scene.sys.settings;
              this.sceneInputPlugin = sceneInputPlugin;
              this.enabled = true;
              this.target;
              this.gamepads = [];
              this.queue = [];
              this.onGamepadHandler;
              this._pad1;
              this._pad2;
              this._pad3;
              this._pad4;
              sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);
              sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
            },
            boot: function() {
              var game = this.scene.sys.game;
              var settings = this.settings.input;
              var config2 = game.config;
              this.enabled = GetValue(settings, "gamepad", config2.inputGamepad) && game.device.input.gamepads;
              this.target = GetValue(settings, "gamepad.target", config2.inputGamepadEventTarget);
              this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
            },
            start: function() {
              if (this.enabled) {
                this.startListeners();
                this.refreshPads();
              }
              this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);
            },
            isActive: function() {
              return this.enabled && this.scene.sys.isActive();
            },
            startListeners: function() {
              var _this = this;
              var target = this.target;
              var handler = function(event) {
                if (event.defaultPrevented || !_this.isActive()) {
                  return;
                }
                _this.refreshPads();
                _this.queue.push(event);
              };
              this.onGamepadHandler = handler;
              target.addEventListener("gamepadconnected", handler, false);
              target.addEventListener("gamepaddisconnected", handler, false);
              this.sceneInputPlugin.pluginEvents.on(InputEvents.UPDATE, this.update, this);
            },
            stopListeners: function() {
              this.target.removeEventListener("gamepadconnected", this.onGamepadHandler);
              this.target.removeEventListener("gamepaddisconnected", this.onGamepadHandler);
              this.sceneInputPlugin.pluginEvents.off(InputEvents.UPDATE, this.update);
              for (var i = 0; i < this.gamepads.length; i++) {
                this.gamepads[i].removeAllListeners();
              }
            },
            disconnectAll: function() {
              for (var i = 0; i < this.gamepads.length; i++) {
                this.gamepads[i].pad.connected = false;
              }
            },
            refreshPads: function() {
              var connectedPads = navigator.getGamepads();
              if (!connectedPads) {
                this.disconnectAll();
              } else {
                var currentPads = this.gamepads;
                for (var i = 0; i < connectedPads.length; i++) {
                  var livePad = connectedPads[i];
                  if (!livePad) {
                    continue;
                  }
                  var id = livePad.id;
                  var index = livePad.index;
                  var currentPad = currentPads[index];
                  if (!currentPad) {
                    var newPad = new Gamepad(this, livePad);
                    currentPads[index] = newPad;
                    if (!this._pad1) {
                      this._pad1 = newPad;
                    } else if (!this._pad2) {
                      this._pad2 = newPad;
                    } else if (!this._pad3) {
                      this._pad3 = newPad;
                    } else if (!this._pad4) {
                      this._pad4 = newPad;
                    }
                  } else if (currentPad.id !== id) {
                    currentPad.destroy();
                    currentPads[index] = new Gamepad(this, livePad);
                  } else {
                    currentPad.update(livePad);
                  }
                }
              }
            },
            getAll: function() {
              var out = [];
              var pads = this.gamepads;
              for (var i = 0; i < pads.length; i++) {
                if (pads[i]) {
                  out.push(pads[i]);
                }
              }
              return out;
            },
            getPad: function(index) {
              var pads = this.gamepads;
              for (var i = 0; i < pads.length; i++) {
                if (pads[i] && pads[i].index === index) {
                  return pads[i];
                }
              }
            },
            update: function() {
              if (!this.enabled) {
                return;
              }
              this.refreshPads();
              var len = this.queue.length;
              if (len === 0) {
                return;
              }
              var queue = this.queue.splice(0, len);
              for (var i = 0; i < len; i++) {
                var event = queue[i];
                var pad = this.getPad(event.gamepad.index);
                if (event.type === "gamepadconnected") {
                  this.emit(Events.CONNECTED, pad, event);
                } else if (event.type === "gamepaddisconnected") {
                  this.emit(Events.DISCONNECTED, pad, event);
                }
              }
            },
            shutdown: function() {
              this.stopListeners();
              this.removeAllListeners();
            },
            destroy: function() {
              this.shutdown();
              for (var i = 0; i < this.gamepads.length; i++) {
                if (this.gamepads[i]) {
                  this.gamepads[i].destroy();
                }
              }
              this.gamepads = [];
              this.scene = null;
              this.settings = null;
              this.sceneInputPlugin = null;
              this.target = null;
            },
            total: {
              get: function() {
                return this.gamepads.length;
              }
            },
            pad1: {
              get: function() {
                return this._pad1;
              }
            },
            pad2: {
              get: function() {
                return this._pad2;
              }
            },
            pad3: {
              get: function() {
                return this._pad3;
              }
            },
            pad4: {
              get: function() {
                return this._pad4;
              }
            }
          });
          InputPluginCache.register("GamepadPlugin", GamepadPlugin, "gamepad", "gamepad", "inputGamepad");
          module2.exports = GamepadPlugin;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            DUALSHOCK_4: __webpack_require__(1312),
            SNES_USB: __webpack_require__(1313),
            XBOX_360: __webpack_require__(1314)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            UP: 12,
            DOWN: 13,
            LEFT: 14,
            RIGHT: 15,
            SHARE: 8,
            OPTIONS: 9,
            PS: 16,
            TOUCHBAR: 17,
            X: 0,
            CIRCLE: 1,
            SQUARE: 2,
            TRIANGLE: 3,
            L1: 4,
            R1: 5,
            L2: 6,
            R2: 7,
            L3: 10,
            R3: 11,
            LEFT_STICK_H: 0,
            LEFT_STICK_V: 1,
            RIGHT_STICK_H: 2,
            RIGHT_STICK_V: 3
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            UP: 12,
            DOWN: 13,
            LEFT: 14,
            RIGHT: 15,
            SELECT: 8,
            START: 9,
            B: 0,
            A: 1,
            Y: 2,
            X: 3,
            LEFT_SHOULDER: 4,
            RIGHT_SHOULDER: 5
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            UP: 12,
            DOWN: 13,
            LEFT: 14,
            RIGHT: 15,
            MENU: 16,
            A: 0,
            B: 1,
            X: 2,
            Y: 3,
            LB: 4,
            RB: 5,
            LT: 6,
            RT: 7,
            BACK: 8,
            START: 9,
            LS: 10,
            RS: 11,
            LEFT_STICK_H: 0,
            LEFT_STICK_V: 1,
            RIGHT_STICK_H: 2,
            RIGHT_STICK_V: 3
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Circle = __webpack_require__(62);
          var CircleContains = __webpack_require__(63);
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(200);
          var CreateInteractiveObject = __webpack_require__(502);
          var CreatePixelPerfectHandler = __webpack_require__(501);
          var DistanceBetween = __webpack_require__(48);
          var Ellipse = __webpack_require__(108);
          var EllipseContains = __webpack_require__(109);
          var Events = __webpack_require__(49);
          var EventEmitter = __webpack_require__(9);
          var GetFastValue = __webpack_require__(2);
          var GEOM_CONST = __webpack_require__(55);
          var InputPluginCache = __webpack_require__(151);
          var IsPlainObject = __webpack_require__(7);
          var PluginCache = __webpack_require__(24);
          var Rectangle = __webpack_require__(10);
          var RectangleContains = __webpack_require__(56);
          var SceneEvents = __webpack_require__(21);
          var Triangle = __webpack_require__(82);
          var TriangleContains = __webpack_require__(112);
          var InputPlugin = new Class({
            Extends: EventEmitter,
            initialize: function InputPlugin2(scene) {
              EventEmitter.call(this);
              this.scene = scene;
              this.systems = scene.sys;
              this.settings = scene.sys.settings;
              this.manager = scene.sys.game.input;
              this.pluginEvents = new EventEmitter();
              this.enabled = true;
              this.displayList;
              this.cameras;
              InputPluginCache.install(this);
              this.mouse = this.manager.mouse;
              this.topOnly = true;
              this.pollRate = -1;
              this._pollTimer = 0;
              var _eventData = {cancelled: false};
              this._eventContainer = {
                stopPropagation: function() {
                  _eventData.cancelled = true;
                }
              };
              this._eventData = _eventData;
              this.dragDistanceThreshold = 0;
              this.dragTimeThreshold = 0;
              this._temp = [];
              this._tempZones = [];
              this._list = [];
              this._pendingInsertion = [];
              this._pendingRemoval = [];
              this._draggable = [];
              this._drag = {0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: []};
              this._dragState = [];
              this._over = {0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: []};
              this._validTypes = ["onDown", "onUp", "onOver", "onOut", "onMove", "onDragStart", "onDrag", "onDragEnd", "onDragEnter", "onDragLeave", "onDragOver", "onDrop"];
              this._updatedThisFrame = false;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function() {
              this.cameras = this.systems.cameras;
              this.displayList = this.systems.displayList;
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
              this.pluginEvents.emit(Events.BOOT);
            },
            start: function() {
              var eventEmitter = this.systems.events;
              eventEmitter.on(SceneEvents.TRANSITION_START, this.transitionIn, this);
              eventEmitter.on(SceneEvents.TRANSITION_OUT, this.transitionOut, this);
              eventEmitter.on(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);
              eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
              eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              this.manager.events.on(Events.GAME_OUT, this.onGameOut, this);
              this.manager.events.on(Events.GAME_OVER, this.onGameOver, this);
              this.enabled = true;
              this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              this.pluginEvents.emit(Events.START);
            },
            onGameOver: function(event) {
              if (this.isActive()) {
                this.emit(Events.GAME_OVER, event.timeStamp, event);
              }
            },
            onGameOut: function(event) {
              if (this.isActive()) {
                this.emit(Events.GAME_OUT, event.timeStamp, event);
              }
            },
            preUpdate: function() {
              this.pluginEvents.emit(Events.PRE_UPDATE);
              var removeList = this._pendingRemoval;
              var insertList = this._pendingInsertion;
              var toRemove = removeList.length;
              var toInsert = insertList.length;
              if (toRemove === 0 && toInsert === 0) {
                return;
              }
              var current = this._list;
              for (var i = 0; i < toRemove; i++) {
                var gameObject = removeList[i];
                var index = current.indexOf(gameObject);
                if (index > -1) {
                  current.splice(index, 1);
                  this.clear(gameObject, true);
                }
              }
              removeList.length = 0;
              this._pendingRemoval.length = 0;
              this._list = current.concat(insertList.splice(0));
            },
            isActive: function() {
              return this.enabled && this.scene.sys.isActive();
            },
            updatePoll: function(time, delta) {
              if (!this.isActive()) {
                return false;
              }
              this.pluginEvents.emit(Events.UPDATE, time, delta);
              if (this._updatedThisFrame) {
                this._updatedThisFrame = false;
                return false;
              }
              var i;
              var manager = this.manager;
              var pointers = manager.pointers;
              var pointersTotal = manager.pointersTotal;
              for (i = 0; i < pointersTotal; i++) {
                pointers[i].updateMotion();
              }
              if (this._list.length === 0) {
                return false;
              }
              var rate = this.pollRate;
              if (rate === -1) {
                return false;
              } else if (rate > 0) {
                this._pollTimer -= delta;
                if (this._pollTimer < 0) {
                  this._pollTimer = this.pollRate;
                } else {
                  return false;
                }
              }
              var captured = false;
              for (i = 0; i < pointersTotal; i++) {
                var total = 0;
                var pointer = pointers[i];
                this._tempZones = [];
                this._temp = this.hitTestPointer(pointer);
                this.sortGameObjects(this._temp, pointer);
                this.sortDropZones(this._tempZones);
                if (this.topOnly) {
                  if (this._temp.length) {
                    this._temp.splice(1);
                  }
                  if (this._tempZones.length) {
                    this._tempZones.splice(1);
                  }
                }
                total += this.processOverOutEvents(pointer);
                if (this.getDragState(pointer) === 2) {
                  this.processDragThresholdEvent(pointer, time);
                }
                if (total > 0) {
                  captured = true;
                }
              }
              return captured;
            },
            update: function(type, pointers) {
              if (!this.isActive()) {
                return false;
              }
              var pointersTotal = pointers.length;
              var captured = false;
              for (var i = 0; i < pointersTotal; i++) {
                var total = 0;
                var pointer = pointers[i];
                this._tempZones = [];
                this._temp = this.hitTestPointer(pointer);
                this.sortGameObjects(this._temp, pointer);
                this.sortDropZones(this._tempZones);
                if (this.topOnly) {
                  if (this._temp.length) {
                    this._temp.splice(1);
                  }
                  if (this._tempZones.length) {
                    this._tempZones.splice(1);
                  }
                }
                switch (type) {
                  case CONST.MOUSE_DOWN:
                    total += this.processDragDownEvent(pointer);
                    total += this.processDownEvents(pointer);
                    total += this.processOverOutEvents(pointer);
                    break;
                  case CONST.MOUSE_UP:
                    total += this.processDragUpEvent(pointer);
                    total += this.processUpEvents(pointer);
                    total += this.processOverOutEvents(pointer);
                    break;
                  case CONST.TOUCH_START:
                    total += this.processDragDownEvent(pointer);
                    total += this.processDownEvents(pointer);
                    total += this.processOverEvents(pointer);
                    break;
                  case CONST.TOUCH_END:
                  case CONST.TOUCH_CANCEL:
                    total += this.processDragUpEvent(pointer);
                    total += this.processUpEvents(pointer);
                    total += this.processOutEvents(pointer);
                    break;
                  case CONST.MOUSE_MOVE:
                  case CONST.TOUCH_MOVE:
                    total += this.processDragMoveEvent(pointer);
                    total += this.processMoveEvents(pointer);
                    total += this.processOverOutEvents(pointer);
                    break;
                  case CONST.MOUSE_WHEEL:
                    total += this.processWheelEvent(pointer);
                    break;
                }
                if (total > 0) {
                  captured = true;
                }
              }
              this._updatedThisFrame = true;
              return captured;
            },
            clear: function(gameObject, skipQueue) {
              if (skipQueue === void 0) {
                skipQueue = false;
              }
              var input = gameObject.input;
              if (!input) {
                return;
              }
              if (!skipQueue) {
                this.queueForRemoval(gameObject);
              }
              input.gameObject = void 0;
              input.target = void 0;
              input.hitArea = void 0;
              input.hitAreaCallback = void 0;
              input.callbackContext = void 0;
              gameObject.input = null;
              var index = this._draggable.indexOf(gameObject);
              if (index > -1) {
                this._draggable.splice(index, 1);
              }
              index = this._drag[0].indexOf(gameObject);
              if (index > -1) {
                this._drag[0].splice(index, 1);
              }
              index = this._over[0].indexOf(gameObject);
              if (index > -1) {
                this._over[0].splice(index, 1);
                this.manager.resetCursor(input);
              }
              return gameObject;
            },
            disable: function(gameObject) {
              gameObject.input.enabled = false;
            },
            enable: function(gameObject, hitArea, hitAreaCallback, dropZone) {
              if (dropZone === void 0) {
                dropZone = false;
              }
              if (gameObject.input) {
                gameObject.input.enabled = true;
              } else {
                this.setHitArea(gameObject, hitArea, hitAreaCallback);
              }
              if (gameObject.input && dropZone && !gameObject.input.dropZone) {
                gameObject.input.dropZone = dropZone;
              }
              return this;
            },
            hitTestPointer: function(pointer) {
              var cameras = this.cameras.getCamerasBelowPointer(pointer);
              for (var c = 0; c < cameras.length; c++) {
                var camera = cameras[c];
                var over = this.manager.hitTest(pointer, this._list, camera);
                for (var i = 0; i < over.length; i++) {
                  var obj = over[i];
                  if (obj.input.dropZone) {
                    this._tempZones.push(obj);
                  }
                }
                if (over.length > 0) {
                  pointer.camera = camera;
                  return over;
                }
              }
              pointer.camera = cameras[0];
              return [];
            },
            processDownEvents: function(pointer) {
              var total = 0;
              var currentlyOver = this._temp;
              var _eventData = this._eventData;
              var _eventContainer = this._eventContainer;
              _eventData.cancelled = false;
              var aborted = false;
              for (var i = 0; i < currentlyOver.length; i++) {
                var gameObject = currentlyOver[i];
                if (!gameObject.input) {
                  continue;
                }
                total++;
                gameObject.emit(Events.GAMEOBJECT_POINTER_DOWN, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                this.emit(Events.GAMEOBJECT_DOWN, pointer, gameObject, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
              }
              if (!aborted && this.manager) {
                if (pointer.downElement === this.manager.game.canvas) {
                  this.emit(Events.POINTER_DOWN, pointer, currentlyOver);
                } else {
                  this.emit(Events.POINTER_DOWN_OUTSIDE, pointer);
                }
              }
              return total;
            },
            getDragState: function(pointer) {
              return this._dragState[pointer.id];
            },
            setDragState: function(pointer, state) {
              this._dragState[pointer.id] = state;
            },
            processDragThresholdEvent: function(pointer, time) {
              var passed = false;
              var timeThreshold = this.dragTimeThreshold;
              var distanceThreshold = this.dragDistanceThreshold;
              if (distanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= distanceThreshold) {
                passed = true;
              } else if (timeThreshold > 0 && time >= pointer.downTime + timeThreshold) {
                passed = true;
              }
              if (passed) {
                this.setDragState(pointer, 3);
                return this.processDragStartList(pointer);
              }
            },
            processDragStartList: function(pointer) {
              if (this.getDragState(pointer) !== 3) {
                return 0;
              }
              var list = this._drag[pointer.id];
              for (var i = 0; i < list.length; i++) {
                var gameObject = list[i];
                var input = gameObject.input;
                input.dragState = 2;
                input.dragStartX = gameObject.x;
                input.dragStartY = gameObject.y;
                input.dragStartXGlobal = pointer.worldX;
                input.dragStartYGlobal = pointer.worldY;
                input.dragX = input.dragStartXGlobal - input.dragStartX;
                input.dragY = input.dragStartYGlobal - input.dragStartY;
                gameObject.emit(Events.GAMEOBJECT_DRAG_START, pointer, input.dragX, input.dragY);
                this.emit(Events.DRAG_START, pointer, gameObject);
              }
              this.setDragState(pointer, 4);
              return list.length;
            },
            processDragDownEvent: function(pointer) {
              var currentlyOver = this._temp;
              if (this._draggable.length === 0 || currentlyOver.length === 0 || !pointer.primaryDown || this.getDragState(pointer) !== 0) {
                return 0;
              }
              this.setDragState(pointer, 1);
              var draglist = [];
              for (var i = 0; i < currentlyOver.length; i++) {
                var gameObject = currentlyOver[i];
                if (gameObject.input.draggable && gameObject.input.dragState === 0) {
                  draglist.push(gameObject);
                }
              }
              if (draglist.length === 0) {
                this.setDragState(pointer, 0);
                return 0;
              } else if (draglist.length > 1) {
                this.sortGameObjects(draglist, pointer);
                if (this.topOnly) {
                  draglist.splice(1);
                }
              }
              this._drag[pointer.id] = draglist;
              if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0) {
                this.setDragState(pointer, 3);
                return this.processDragStartList(pointer);
              } else {
                this.setDragState(pointer, 2);
                return 0;
              }
            },
            processDragMoveEvent: function(pointer) {
              if (this.getDragState(pointer) === 2) {
                this.processDragThresholdEvent(pointer, this.manager.game.loop.now);
              }
              if (this.getDragState(pointer) !== 4) {
                return 0;
              }
              var dropZones = this._tempZones;
              var list = this._drag[pointer.id];
              for (var i = 0; i < list.length; i++) {
                var gameObject = list[i];
                var input = gameObject.input;
                var target = input.target;
                if (target) {
                  var index = dropZones.indexOf(target);
                  if (index === 0) {
                    gameObject.emit(Events.GAMEOBJECT_DRAG_OVER, pointer, target);
                    this.emit(Events.DRAG_OVER, pointer, gameObject, target);
                  } else if (index > 0) {
                    gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);
                    this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);
                    input.target = dropZones[0];
                    target = input.target;
                    gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
                    this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
                  } else {
                    gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);
                    this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);
                    if (dropZones[0]) {
                      input.target = dropZones[0];
                      target = input.target;
                      gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
                      this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
                    } else {
                      input.target = null;
                    }
                  }
                } else if (!target && dropZones[0]) {
                  input.target = dropZones[0];
                  target = input.target;
                  gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
                  this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
                }
                var dragX;
                var dragY;
                if (!gameObject.parentContainer) {
                  dragX = pointer.worldX - input.dragX;
                  dragY = pointer.worldY - input.dragY;
                } else {
                  var dx = pointer.worldX - input.dragStartXGlobal;
                  var dy = pointer.worldY - input.dragStartYGlobal;
                  var rotation = gameObject.getParentRotation();
                  var dxRotated = dx * Math.cos(rotation) + dy * Math.sin(rotation);
                  var dyRotated = dy * Math.cos(rotation) - dx * Math.sin(rotation);
                  dxRotated *= 1 / gameObject.parentContainer.scaleX;
                  dyRotated *= 1 / gameObject.parentContainer.scaleY;
                  dragX = dxRotated + input.dragStartX;
                  dragY = dyRotated + input.dragStartY;
                }
                gameObject.emit(Events.GAMEOBJECT_DRAG, pointer, dragX, dragY);
                this.emit(Events.DRAG, pointer, gameObject, dragX, dragY);
              }
              return list.length;
            },
            processDragUpEvent: function(pointer) {
              var list = this._drag[pointer.id];
              for (var i = 0; i < list.length; i++) {
                var gameObject = list[i];
                var input = gameObject.input;
                if (input && input.dragState === 2) {
                  input.dragState = 0;
                  input.dragX = input.localX - gameObject.displayOriginX;
                  input.dragY = input.localY - gameObject.displayOriginY;
                  var dropped = false;
                  var target = input.target;
                  if (target) {
                    gameObject.emit(Events.GAMEOBJECT_DROP, pointer, target);
                    this.emit(Events.DROP, pointer, gameObject, target);
                    input.target = null;
                    dropped = true;
                  }
                  if (gameObject.input) {
                    gameObject.emit(Events.GAMEOBJECT_DRAG_END, pointer, input.dragX, input.dragY, dropped);
                    this.emit(Events.DRAG_END, pointer, gameObject, dropped);
                  }
                }
              }
              this.setDragState(pointer, 0);
              list.splice(0);
              return 0;
            },
            processMoveEvents: function(pointer) {
              var total = 0;
              var currentlyOver = this._temp;
              var _eventData = this._eventData;
              var _eventContainer = this._eventContainer;
              _eventData.cancelled = false;
              var aborted = false;
              for (var i = 0; i < currentlyOver.length; i++) {
                var gameObject = currentlyOver[i];
                if (!gameObject.input) {
                  continue;
                }
                total++;
                gameObject.emit(Events.GAMEOBJECT_POINTER_MOVE, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                this.emit(Events.GAMEOBJECT_MOVE, pointer, gameObject, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                if (this.topOnly) {
                  break;
                }
              }
              if (!aborted) {
                this.emit(Events.POINTER_MOVE, pointer, currentlyOver);
              }
              return total;
            },
            processWheelEvent: function(pointer) {
              var total = 0;
              var currentlyOver = this._temp;
              var _eventData = this._eventData;
              var _eventContainer = this._eventContainer;
              _eventData.cancelled = false;
              var aborted = false;
              var dx = pointer.deltaX;
              var dy = pointer.deltaY;
              var dz = pointer.deltaZ;
              for (var i = 0; i < currentlyOver.length; i++) {
                var gameObject = currentlyOver[i];
                if (!gameObject.input) {
                  continue;
                }
                total++;
                gameObject.emit(Events.GAMEOBJECT_POINTER_WHEEL, pointer, dx, dy, dz, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                this.emit(Events.GAMEOBJECT_WHEEL, pointer, gameObject, dx, dy, dz, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
              }
              if (!aborted) {
                this.emit(Events.POINTER_WHEEL, pointer, currentlyOver, dx, dy, dz);
              }
              return total;
            },
            processOverEvents: function(pointer) {
              var currentlyOver = this._temp;
              var totalInteracted = 0;
              var total = currentlyOver.length;
              var justOver = [];
              if (total > 0) {
                var manager = this.manager;
                var _eventData = this._eventData;
                var _eventContainer = this._eventContainer;
                _eventData.cancelled = false;
                var aborted = false;
                for (var i = 0; i < total; i++) {
                  var gameObject = currentlyOver[i];
                  if (!gameObject.input) {
                    continue;
                  }
                  justOver.push(gameObject);
                  manager.setCursor(gameObject.input);
                  gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                  totalInteracted++;
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                  this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                }
                if (!aborted) {
                  this.emit(Events.POINTER_OVER, pointer, justOver);
                }
              }
              this._over[pointer.id] = justOver;
              return totalInteracted;
            },
            processOutEvents: function(pointer) {
              var previouslyOver = this._over[pointer.id];
              var totalInteracted = 0;
              var total = previouslyOver.length;
              if (total > 0) {
                var manager = this.manager;
                var _eventData = this._eventData;
                var _eventContainer = this._eventContainer;
                _eventData.cancelled = false;
                var aborted = false;
                this.sortGameObjects(previouslyOver, pointer);
                for (var i = 0; i < total; i++) {
                  var gameObject = previouslyOver[i];
                  gameObject = previouslyOver[i];
                  if (!gameObject.input) {
                    continue;
                  }
                  manager.resetCursor(gameObject.input);
                  gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);
                  totalInteracted++;
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                  this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                  if (!aborted) {
                    this.emit(Events.POINTER_OUT, pointer, previouslyOver);
                  }
                }
                this._over[pointer.id] = [];
              }
              return totalInteracted;
            },
            processOverOutEvents: function(pointer) {
              var currentlyOver = this._temp;
              var i;
              var gameObject;
              var justOut = [];
              var justOver = [];
              var stillOver = [];
              var previouslyOver = this._over[pointer.id];
              var currentlyDragging = this._drag[pointer.id];
              var manager = this.manager;
              for (i = 0; i < previouslyOver.length; i++) {
                gameObject = previouslyOver[i];
                if (currentlyOver.indexOf(gameObject) === -1 && currentlyDragging.indexOf(gameObject) === -1) {
                  justOut.push(gameObject);
                } else {
                  stillOver.push(gameObject);
                }
              }
              for (i = 0; i < currentlyOver.length; i++) {
                gameObject = currentlyOver[i];
                if (previouslyOver.indexOf(gameObject) === -1) {
                  justOver.push(gameObject);
                }
              }
              var total = justOut.length;
              var totalInteracted = 0;
              var _eventData = this._eventData;
              var _eventContainer = this._eventContainer;
              _eventData.cancelled = false;
              var aborted = false;
              if (total > 0) {
                this.sortGameObjects(justOut, pointer);
                for (i = 0; i < total; i++) {
                  gameObject = justOut[i];
                  if (!gameObject.input) {
                    continue;
                  }
                  manager.resetCursor(gameObject.input);
                  gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);
                  totalInteracted++;
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                  this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                }
                if (!aborted) {
                  this.emit(Events.POINTER_OUT, pointer, justOut);
                }
              }
              total = justOver.length;
              _eventData.cancelled = false;
              aborted = false;
              if (total > 0) {
                this.sortGameObjects(justOver, pointer);
                for (i = 0; i < total; i++) {
                  gameObject = justOver[i];
                  if (!gameObject.input) {
                    continue;
                  }
                  manager.setCursor(gameObject.input);
                  gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                  totalInteracted++;
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                  this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                }
                if (!aborted) {
                  this.emit(Events.POINTER_OVER, pointer, justOver);
                }
              }
              previouslyOver = stillOver.concat(justOver);
              this._over[pointer.id] = this.sortGameObjects(previouslyOver, pointer);
              return totalInteracted;
            },
            processUpEvents: function(pointer) {
              var currentlyOver = this._temp;
              var _eventData = this._eventData;
              var _eventContainer = this._eventContainer;
              _eventData.cancelled = false;
              var aborted = false;
              for (var i = 0; i < currentlyOver.length; i++) {
                var gameObject = currentlyOver[i];
                if (!gameObject.input) {
                  continue;
                }
                gameObject.emit(Events.GAMEOBJECT_POINTER_UP, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                this.emit(Events.GAMEOBJECT_UP, pointer, gameObject, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
              }
              if (!aborted && this.manager) {
                if (pointer.upElement === this.manager.game.canvas) {
                  this.emit(Events.POINTER_UP, pointer, currentlyOver);
                } else {
                  this.emit(Events.POINTER_UP_OUTSIDE, pointer);
                }
              }
              return currentlyOver.length;
            },
            queueForInsertion: function(child) {
              if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1) {
                this._pendingInsertion.push(child);
              }
              return this;
            },
            queueForRemoval: function(child) {
              this._pendingRemoval.push(child);
              return this;
            },
            setDraggable: function(gameObjects, value) {
              if (value === void 0) {
                value = true;
              }
              if (!Array.isArray(gameObjects)) {
                gameObjects = [gameObjects];
              }
              for (var i = 0; i < gameObjects.length; i++) {
                var gameObject = gameObjects[i];
                gameObject.input.draggable = value;
                var index = this._draggable.indexOf(gameObject);
                if (value && index === -1) {
                  this._draggable.push(gameObject);
                } else if (!value && index > -1) {
                  this._draggable.splice(index, 1);
                }
              }
              return this;
            },
            makePixelPerfect: function(alphaTolerance) {
              if (alphaTolerance === void 0) {
                alphaTolerance = 1;
              }
              var textureManager = this.systems.textures;
              return CreatePixelPerfectHandler(textureManager, alphaTolerance);
            },
            setHitArea: function(gameObjects, hitArea, hitAreaCallback) {
              if (hitArea === void 0) {
                return this.setHitAreaFromTexture(gameObjects);
              }
              if (!Array.isArray(gameObjects)) {
                gameObjects = [gameObjects];
              }
              var draggable = false;
              var dropZone = false;
              var cursor = false;
              var useHandCursor = false;
              var pixelPerfect = false;
              var customHitArea = true;
              if (IsPlainObject(hitArea)) {
                var config2 = hitArea;
                hitArea = GetFastValue(config2, "hitArea", null);
                hitAreaCallback = GetFastValue(config2, "hitAreaCallback", null);
                draggable = GetFastValue(config2, "draggable", false);
                dropZone = GetFastValue(config2, "dropZone", false);
                cursor = GetFastValue(config2, "cursor", false);
                useHandCursor = GetFastValue(config2, "useHandCursor", false);
                pixelPerfect = GetFastValue(config2, "pixelPerfect", false);
                var alphaTolerance = GetFastValue(config2, "alphaTolerance", 1);
                if (pixelPerfect) {
                  hitArea = {};
                  hitAreaCallback = this.makePixelPerfect(alphaTolerance);
                }
                if (!hitArea || !hitAreaCallback) {
                  this.setHitAreaFromTexture(gameObjects);
                  customHitArea = false;
                }
              } else if (typeof hitArea === "function" && !hitAreaCallback) {
                hitAreaCallback = hitArea;
                hitArea = {};
              }
              for (var i = 0; i < gameObjects.length; i++) {
                var gameObject = gameObjects[i];
                if (pixelPerfect && gameObject.type === "Container") {
                  console.warn("Cannot pixelPerfect test a Container. Use a custom callback.");
                  continue;
                }
                var io = !gameObject.input ? CreateInteractiveObject(gameObject, hitArea, hitAreaCallback) : gameObject.input;
                io.customHitArea = customHitArea;
                io.dropZone = dropZone;
                io.cursor = useHandCursor ? "pointer" : cursor;
                gameObject.input = io;
                if (draggable) {
                  this.setDraggable(gameObject);
                }
                this.queueForInsertion(gameObject);
              }
              return this;
            },
            setHitAreaCircle: function(gameObjects, x, y, radius, callback) {
              if (callback === void 0) {
                callback = CircleContains;
              }
              var shape = new Circle(x, y, radius);
              return this.setHitArea(gameObjects, shape, callback);
            },
            setHitAreaEllipse: function(gameObjects, x, y, width, height, callback) {
              if (callback === void 0) {
                callback = EllipseContains;
              }
              var shape = new Ellipse(x, y, width, height);
              return this.setHitArea(gameObjects, shape, callback);
            },
            setHitAreaFromTexture: function(gameObjects, callback) {
              if (callback === void 0) {
                callback = RectangleContains;
              }
              if (!Array.isArray(gameObjects)) {
                gameObjects = [gameObjects];
              }
              for (var i = 0; i < gameObjects.length; i++) {
                var gameObject = gameObjects[i];
                var frame = gameObject.frame;
                var width = 0;
                var height = 0;
                if (gameObject.width) {
                  width = gameObject.width;
                  height = gameObject.height;
                } else if (frame) {
                  width = frame.realWidth;
                  height = frame.realHeight;
                }
                if (gameObject.type === "Container" && (width === 0 || height === 0)) {
                  console.warn("Container.setInteractive must specify a Shape or call setSize() first");
                  continue;
                }
                if (width !== 0 && height !== 0) {
                  gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);
                  this.queueForInsertion(gameObject);
                }
              }
              return this;
            },
            setHitAreaRectangle: function(gameObjects, x, y, width, height, callback) {
              if (callback === void 0) {
                callback = RectangleContains;
              }
              var shape = new Rectangle(x, y, width, height);
              return this.setHitArea(gameObjects, shape, callback);
            },
            setHitAreaTriangle: function(gameObjects, x1, y1, x2, y2, x3, y3, callback) {
              if (callback === void 0) {
                callback = TriangleContains;
              }
              var shape = new Triangle(x1, y1, x2, y2, x3, y3);
              return this.setHitArea(gameObjects, shape, callback);
            },
            enableDebug: function(gameObject, color) {
              if (color === void 0) {
                color = 65280;
              }
              var input = gameObject.input;
              if (!input || !input.hitArea) {
                return this;
              }
              var shape = input.hitArea;
              var shapeType = shape.type;
              var debug = input.hitAreaDebug;
              var factory = this.systems.add;
              var updateList = this.systems.updateList;
              if (debug) {
                updateList.remove(debug);
                debug.destroy();
                debug = null;
              }
              var offsetx = 0;
              var offsety = 0;
              switch (shapeType) {
                case GEOM_CONST.CIRCLE:
                  debug = factory.arc(0, 0, shape.radius);
                  offsetx = shape.x - shape.radius;
                  offsety = shape.y - shape.radius;
                  break;
                case GEOM_CONST.ELLIPSE:
                  debug = factory.ellipse(0, 0, shape.width, shape.height);
                  offsetx = shape.x - shape.width / 2;
                  offsety = shape.y - shape.height / 2;
                  break;
                case GEOM_CONST.LINE:
                  debug = factory.line(0, 0, shape.x1, shape.y1, shape.x2, shape.y2);
                  break;
                case GEOM_CONST.POLYGON:
                  debug = factory.polygon(0, 0, shape.points);
                  break;
                case GEOM_CONST.RECTANGLE:
                  debug = factory.rectangle(0, 0, shape.width, shape.height);
                  offsetx = shape.x;
                  offsety = shape.y;
                  break;
                case GEOM_CONST.TRIANGLE:
                  debug = factory.triangle(0, 0, shape.x1, shape.y1, shape.x2, shape.y2, shape.x3, shape.y3);
                  break;
              }
              if (debug) {
                debug.isFilled = false;
                debug.preUpdate = function() {
                  debug.setStrokeStyle(1 / gameObject.scale, color);
                  debug.setDisplayOrigin(gameObject.displayOriginX, gameObject.displayOriginY);
                  var x = gameObject.x;
                  var y = gameObject.y;
                  var rotation = gameObject.rotation;
                  var scaleX = gameObject.scaleX;
                  var scaleY = gameObject.scaleY;
                  if (gameObject.parentContainer) {
                    var matrix = gameObject.getWorldTransformMatrix();
                    x = matrix.tx;
                    y = matrix.ty;
                    rotation = matrix.rotation;
                    scaleX = matrix.scaleX;
                    scaleY = matrix.scaleY;
                  }
                  debug.setRotation(rotation);
                  debug.setScale(scaleX, scaleY);
                  debug.setPosition(x + offsetx, y + offsety);
                  debug.setScrollFactor(gameObject.scrollFactorX, gameObject.scrollFactorY);
                  debug.setDepth(gameObject.depth);
                };
                updateList.add(debug);
                input.hitAreaDebug = debug;
              }
              return this;
            },
            removeDebug: function(gameObject) {
              var input = gameObject.input;
              if (input && input.hitAreaDebug) {
                var debug = input.hitAreaDebug;
                this.systems.updateList.remove(debug);
                debug.destroy();
                input.hitAreaDebug = null;
              }
              return this;
            },
            setPollAlways: function() {
              return this.setPollRate(0);
            },
            setPollOnMove: function() {
              return this.setPollRate(-1);
            },
            setPollRate: function(value) {
              this.pollRate = value;
              this._pollTimer = 0;
              return this;
            },
            setGlobalTopOnly: function(value) {
              this.manager.globalTopOnly = value;
              return this;
            },
            setTopOnly: function(value) {
              this.topOnly = value;
              return this;
            },
            sortGameObjects: function(gameObjects, pointer) {
              if (gameObjects.length < 2) {
                return gameObjects;
              }
              var list = pointer.camera.renderList;
              return gameObjects.sort(function(childA, childB) {
                return list.indexOf(childB) - list.indexOf(childA);
              });
            },
            sortDropZones: function(gameObjects) {
              if (gameObjects.length < 2) {
                return gameObjects;
              }
              this.scene.sys.depthSort();
              return gameObjects.sort(this.sortDropZoneHandler.bind(this));
            },
            sortDropZoneHandler: function(childA, childB) {
              if (!childA.parentContainer && !childB.parentContainer) {
                return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);
              } else if (childA.parentContainer === childB.parentContainer) {
                return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);
              } else if (childA.parentContainer === childB) {
                return -1;
              } else if (childB.parentContainer === childA) {
                return 1;
              } else {
                var listA = childA.getIndexList();
                var listB = childB.getIndexList();
                var len = Math.min(listA.length, listB.length);
                for (var i = 0; i < len; i++) {
                  var indexA = listA[i];
                  var indexB = listB[i];
                  if (indexA === indexB) {
                    continue;
                  } else {
                    return indexB - indexA;
                  }
                }
                return listB.length - listA.length;
              }
              return 0;
            },
            stopPropagation: function() {
              this.manager._tempSkip = true;
              return this;
            },
            addPointer: function(quantity) {
              return this.manager.addPointer(quantity);
            },
            setDefaultCursor: function(cursor) {
              this.manager.setDefaultCursor(cursor);
              return this;
            },
            transitionIn: function() {
              this.enabled = this.settings.transitionAllowInput;
            },
            transitionComplete: function() {
              if (!this.settings.transitionAllowInput) {
                this.enabled = true;
              }
            },
            transitionOut: function() {
              this.enabled = this.settings.transitionAllowInput;
            },
            shutdown: function() {
              this.pluginEvents.emit(Events.SHUTDOWN);
              this._temp.length = 0;
              this._list.length = 0;
              this._draggable.length = 0;
              this._pendingRemoval.length = 0;
              this._pendingInsertion.length = 0;
              this._dragState.length = 0;
              for (var i = 0; i < 10; i++) {
                this._drag[i] = [];
                this._over[i] = [];
              }
              this.removeAllListeners();
              var manager = this.manager;
              manager.canvas.style.cursor = manager.defaultCursor;
              var eventEmitter = this.systems.events;
              eventEmitter.off(SceneEvents.TRANSITION_START, this.transitionIn, this);
              eventEmitter.off(SceneEvents.TRANSITION_OUT, this.transitionOut, this);
              eventEmitter.off(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);
              eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
              manager.events.off(Events.GAME_OUT, this.onGameOut, this);
              manager.events.off(Events.GAME_OVER, this.onGameOver, this);
              eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function() {
              this.shutdown();
              this.pluginEvents.emit(Events.DESTROY);
              this.pluginEvents.removeAllListeners();
              this.scene.sys.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.cameras = null;
              this.manager = null;
              this.events = null;
              this.mouse = null;
            },
            x: {
              get: function() {
                return this.manager.activePointer.x;
              }
            },
            y: {
              get: function() {
                return this.manager.activePointer.y;
              }
            },
            isOver: {
              get: function() {
                return this.manager.isOver;
              }
            },
            mousePointer: {
              get: function() {
                return this.manager.mousePointer;
              }
            },
            activePointer: {
              get: function() {
                return this.manager.activePointer;
              }
            },
            pointer1: {
              get: function() {
                return this.manager.pointers[1];
              }
            },
            pointer2: {
              get: function() {
                return this.manager.pointers[2];
              }
            },
            pointer3: {
              get: function() {
                return this.manager.pointers[3];
              }
            },
            pointer4: {
              get: function() {
                return this.manager.pointers[4];
              }
            },
            pointer5: {
              get: function() {
                return this.manager.pointers[5];
              }
            },
            pointer6: {
              get: function() {
                return this.manager.pointers[6];
              }
            },
            pointer7: {
              get: function() {
                return this.manager.pointers[7];
              }
            },
            pointer8: {
              get: function() {
                return this.manager.pointers[8];
              }
            },
            pointer9: {
              get: function() {
                return this.manager.pointers[9];
              }
            },
            pointer10: {
              get: function() {
                return this.manager.pointers[10];
              }
            }
          });
          PluginCache.register("InputPlugin", InputPlugin, "input");
          module2.exports = InputPlugin;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Events: __webpack_require__(152),
            KeyboardManager: __webpack_require__(404),
            KeyboardPlugin: __webpack_require__(1324),
            Key: __webpack_require__(506),
            KeyCodes: __webpack_require__(141),
            KeyCombo: __webpack_require__(507),
            AdvanceKeyCombo: __webpack_require__(509),
            ProcessKeyCombo: __webpack_require__(508),
            ResetKeyCombo: __webpack_require__(510),
            JustDown: __webpack_require__(1326),
            JustUp: __webpack_require__(1327),
            DownDuration: __webpack_require__(1328),
            UpDuration: __webpack_require__(1329)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "keydown";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "keyup";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "keycombomatch";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "down";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "keydown-";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "keyup-";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "up";
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(152);
          var GameEvents = __webpack_require__(22);
          var GetValue = __webpack_require__(6);
          var InputEvents = __webpack_require__(49);
          var InputPluginCache = __webpack_require__(151);
          var Key = __webpack_require__(506);
          var KeyCodes = __webpack_require__(141);
          var KeyCombo = __webpack_require__(507);
          var KeyMap = __webpack_require__(1325);
          var SceneEvents = __webpack_require__(21);
          var SnapFloor = __webpack_require__(76);
          var KeyboardPlugin = new Class({
            Extends: EventEmitter,
            initialize: function KeyboardPlugin2(sceneInputPlugin) {
              EventEmitter.call(this);
              this.game = sceneInputPlugin.systems.game;
              this.scene = sceneInputPlugin.scene;
              this.settings = this.scene.sys.settings;
              this.sceneInputPlugin = sceneInputPlugin;
              this.manager = sceneInputPlugin.manager.keyboard;
              this.enabled = true;
              this.keys = [];
              this.combos = [];
              this.prevCode = null;
              this.prevTime = 0;
              this.prevType = null;
              sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);
              sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
            },
            boot: function() {
              var settings = this.settings.input;
              this.enabled = GetValue(settings, "keyboard", true);
              var captures = GetValue(settings, "keyboard.capture", null);
              if (captures) {
                this.addCaptures(captures);
              }
              this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
            },
            start: function() {
              this.sceneInputPlugin.manager.events.on(InputEvents.MANAGER_PROCESS, this.update, this);
              this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);
              this.game.events.on(GameEvents.BLUR, this.resetKeys, this);
              this.scene.sys.events.on(SceneEvents.PAUSE, this.resetKeys, this);
              this.scene.sys.events.on(SceneEvents.SLEEP, this.resetKeys, this);
            },
            isActive: function() {
              return this.enabled && this.scene.sys.isActive();
            },
            addCapture: function(keycode) {
              this.manager.addCapture(keycode);
              return this;
            },
            removeCapture: function(keycode) {
              this.manager.removeCapture(keycode);
              return this;
            },
            getCaptures: function() {
              return this.manager.captures;
            },
            enableGlobalCapture: function() {
              this.manager.preventDefault = true;
              return this;
            },
            disableGlobalCapture: function() {
              this.manager.preventDefault = false;
              return this;
            },
            clearCaptures: function() {
              this.manager.clearCaptures();
              return this;
            },
            createCursorKeys: function() {
              return this.addKeys({
                up: KeyCodes.UP,
                down: KeyCodes.DOWN,
                left: KeyCodes.LEFT,
                right: KeyCodes.RIGHT,
                space: KeyCodes.SPACE,
                shift: KeyCodes.SHIFT
              });
            },
            addKeys: function(keys, enableCapture, emitOnRepeat) {
              if (enableCapture === void 0) {
                enableCapture = true;
              }
              if (emitOnRepeat === void 0) {
                emitOnRepeat = false;
              }
              var output = {};
              if (typeof keys === "string") {
                keys = keys.split(",");
                for (var i = 0; i < keys.length; i++) {
                  var currentKey = keys[i].trim();
                  if (currentKey) {
                    output[currentKey] = this.addKey(currentKey, enableCapture, emitOnRepeat);
                  }
                }
              } else {
                for (var key in keys) {
                  output[key] = this.addKey(keys[key], enableCapture, emitOnRepeat);
                }
              }
              return output;
            },
            addKey: function(key, enableCapture, emitOnRepeat) {
              if (enableCapture === void 0) {
                enableCapture = true;
              }
              if (emitOnRepeat === void 0) {
                emitOnRepeat = false;
              }
              var keys = this.keys;
              if (key instanceof Key) {
                var idx = keys.indexOf(key);
                if (idx > -1) {
                  keys[idx] = key;
                } else {
                  keys[key.keyCode] = key;
                }
                if (enableCapture) {
                  this.addCapture(key.keyCode);
                }
                key.setEmitOnRepeat(emitOnRepeat);
                return key;
              }
              if (typeof key === "string") {
                key = KeyCodes[key.toUpperCase()];
              }
              if (!keys[key]) {
                keys[key] = new Key(this, key);
                if (enableCapture) {
                  this.addCapture(key);
                }
                keys[key].setEmitOnRepeat(emitOnRepeat);
              }
              return keys[key];
            },
            removeKey: function(key, destroy) {
              if (destroy === void 0) {
                destroy = false;
              }
              var keys = this.keys;
              var ref;
              if (key instanceof Key) {
                var idx = keys.indexOf(key);
                if (idx > -1) {
                  ref = this.keys[idx];
                  this.keys[idx] = void 0;
                }
              } else if (typeof key === "string") {
                key = KeyCodes[key.toUpperCase()];
              }
              if (keys[key]) {
                ref = keys[key];
                keys[key] = void 0;
              }
              if (ref) {
                ref.plugin = null;
                if (destroy) {
                  ref.destroy();
                }
              }
              return this;
            },
            removeAllKeys: function(destroy) {
              var keys = this.keys;
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (key) {
                  keys[i] = void 0;
                  if (destroy) {
                    key.destroy();
                  }
                }
              }
              return this;
            },
            createCombo: function(keys, config2) {
              return new KeyCombo(this, keys, config2);
            },
            checkDown: function(key, duration) {
              if (duration === void 0) {
                duration = 0;
              }
              if (this.enabled && key.isDown) {
                var t = SnapFloor(this.time - key.timeDown, duration);
                if (t > key._tick) {
                  key._tick = t;
                  return true;
                }
              }
              return false;
            },
            update: function() {
              var queue = this.manager.queue;
              var len = queue.length;
              if (!this.isActive() || len === 0) {
                return;
              }
              var keys = this.keys;
              for (var i = 0; i < len; i++) {
                var event = queue[i];
                var code = event.keyCode;
                var key = keys[code];
                var repeat = false;
                if (event.cancelled === void 0) {
                  event.cancelled = 0;
                  event.stopImmediatePropagation = function() {
                    event.cancelled = 1;
                  };
                  event.stopPropagation = function() {
                    event.cancelled = -1;
                  };
                }
                if (event.cancelled === -1) {
                  continue;
                }
                if (code === this.prevCode && event.timeStamp === this.prevTime && event.type === this.prevType) {
                  continue;
                }
                this.prevCode = code;
                this.prevTime = event.timeStamp;
                this.prevType = event.type;
                if (event.type === "keydown") {
                  if (key) {
                    repeat = key.isDown;
                    key.onDown(event);
                  }
                  if (!event.cancelled && (!key || !repeat)) {
                    if (KeyMap[code]) {
                      this.emit(Events.KEY_DOWN + KeyMap[code], event);
                    }
                    if (!event.cancelled) {
                      this.emit(Events.ANY_KEY_DOWN, event);
                    }
                  }
                } else {
                  if (key) {
                    key.onUp(event);
                  }
                  if (!event.cancelled) {
                    if (KeyMap[code]) {
                      this.emit(Events.KEY_UP + KeyMap[code], event);
                    }
                    if (!event.cancelled) {
                      this.emit(Events.ANY_KEY_UP, event);
                    }
                  }
                }
                if (event.cancelled === 1) {
                  event.cancelled = 0;
                }
              }
            },
            resetKeys: function() {
              var keys = this.keys;
              for (var i = 0; i < keys.length; i++) {
                if (keys[i]) {
                  keys[i].reset();
                }
              }
              return this;
            },
            shutdown: function() {
              this.resetKeys();
              this.sceneInputPlugin.manager.events.off(InputEvents.MANAGER_PROCESS, this.update, this);
              this.game.events.off(GameEvents.BLUR, this.resetKeys);
              this.scene.sys.events.off(SceneEvents.PAUSE, this.resetKeys, this);
              this.scene.sys.events.off(SceneEvents.SLEEP, this.resetKeys, this);
              this.removeAllListeners();
              this.queue = [];
            },
            destroy: function() {
              this.shutdown();
              var keys = this.keys;
              for (var i = 0; i < keys.length; i++) {
                if (keys[i]) {
                  keys[i].destroy();
                }
              }
              this.keys = [];
              this.combos = [];
              this.queue = [];
              this.scene = null;
              this.settings = null;
              this.sceneInputPlugin = null;
              this.manager = null;
            },
            time: {
              get: function() {
                return this.sceneInputPlugin.manager.time;
              }
            }
          });
          InputPluginCache.register("KeyboardPlugin", KeyboardPlugin, "keyboard", "keyboard", "inputKeyboard");
          module2.exports = KeyboardPlugin;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var KeyCodes = __webpack_require__(141);
          var KeyMap = {};
          for (var key in KeyCodes) {
            KeyMap[KeyCodes[key]] = key;
          }
          module2.exports = KeyMap;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var JustDown = function(key) {
            if (key._justDown) {
              key._justDown = false;
              return true;
            } else {
              return false;
            }
          };
          module2.exports = JustDown;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var JustUp = function(key) {
            if (key._justUp) {
              key._justUp = false;
              return true;
            } else {
              return false;
            }
          };
          module2.exports = JustUp;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var DownDuration = function(key, duration) {
            if (duration === void 0) {
              duration = 50;
            }
            var current = key.plugin.game.loop.time - key.timeDown;
            return key.isDown && current < duration;
          };
          module2.exports = DownDuration;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var UpDuration = function(key, duration) {
            if (duration === void 0) {
              duration = 50;
            }
            var current = key.plugin.game.loop.time - key.timeUp;
            return key.isUp && current < duration;
          };
          module2.exports = UpDuration;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            MouseManager: __webpack_require__(405)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            TouchManager: __webpack_require__(407)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(20);
          var Extend = __webpack_require__(17);
          var Loader = {
            Events: __webpack_require__(91),
            FileTypes: __webpack_require__(1333),
            File: __webpack_require__(23),
            FileTypesManager: __webpack_require__(8),
            GetURL: __webpack_require__(153),
            LoaderPlugin: __webpack_require__(1359),
            MergeXHRSettings: __webpack_require__(237),
            MultiFile: __webpack_require__(47),
            XHRLoader: __webpack_require__(511),
            XHRSettings: __webpack_require__(154)
          };
          Loader = Extend(false, Loader, CONST);
          module2.exports = Loader;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            AnimationJSONFile: __webpack_require__(1334),
            AsepriteFile: __webpack_require__(1335),
            AtlasJSONFile: __webpack_require__(1336),
            AtlasXMLFile: __webpack_require__(1337),
            AudioFile: __webpack_require__(512),
            AudioSpriteFile: __webpack_require__(1338),
            BinaryFile: __webpack_require__(1339),
            BitmapFontFile: __webpack_require__(1340),
            CSSFile: __webpack_require__(1341),
            GLSLFile: __webpack_require__(1342),
            HTML5AudioFile: __webpack_require__(513),
            HTMLFile: __webpack_require__(1343),
            HTMLTextureFile: __webpack_require__(1344),
            ImageFile: __webpack_require__(70),
            JSONFile: __webpack_require__(59),
            MultiAtlasFile: __webpack_require__(1345),
            MultiScriptFile: __webpack_require__(1346),
            OBJFile: __webpack_require__(1347),
            PackFile: __webpack_require__(1348),
            PluginFile: __webpack_require__(1349),
            SceneFile: __webpack_require__(1350),
            ScenePluginFile: __webpack_require__(1351),
            ScriptFile: __webpack_require__(514),
            SpriteSheetFile: __webpack_require__(1352),
            SVGFile: __webpack_require__(1353),
            TextFile: __webpack_require__(239),
            TilemapCSVFile: __webpack_require__(1354),
            TilemapImpactFile: __webpack_require__(1355),
            TilemapJSONFile: __webpack_require__(1356),
            UnityAtlasFile: __webpack_require__(1357),
            VideoFile: __webpack_require__(1358),
            XMLFile: __webpack_require__(238)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var JSONFile = __webpack_require__(59);
          var LoaderEvents = __webpack_require__(91);
          var AnimationJSONFile = new Class({
            Extends: JSONFile,
            initialize: function AnimationJSONFile2(loader, key, url, xhrSettings, dataKey) {
              JSONFile.call(this, loader, key, url, xhrSettings, dataKey);
              this.type = "animationJSON";
            },
            onProcess: function() {
              this.loader.once(LoaderEvents.POST_PROCESS, this.onLoadComplete, this);
              JSONFile.prototype.onProcess.call(this);
            },
            onLoadComplete: function() {
              this.loader.systems.anims.fromJSON(this.data);
            }
          });
          FileTypesManager.register("animation", function(key, url, dataKey, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new AnimationJSONFile(this, key[i]));
              }
            } else {
              this.addFile(new AnimationJSONFile(this, key, url, xhrSettings, dataKey));
            }
            return this;
          });
          module2.exports = AnimationJSONFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var ImageFile = __webpack_require__(70);
          var IsPlainObject = __webpack_require__(7);
          var JSONFile = __webpack_require__(59);
          var MultiFile = __webpack_require__(47);
          var AsepriteFile = new Class({
            Extends: MultiFile,
            initialize: function AsepriteFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
              var image;
              var data;
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                image = new ImageFile(loader, {
                  key,
                  url: GetFastValue(config2, "textureURL"),
                  extension: GetFastValue(config2, "textureExtension", "png"),
                  normalMap: GetFastValue(config2, "normalMap"),
                  xhrSettings: GetFastValue(config2, "textureXhrSettings")
                });
                data = new JSONFile(loader, {
                  key,
                  url: GetFastValue(config2, "atlasURL"),
                  extension: GetFastValue(config2, "atlasExtension", "json"),
                  xhrSettings: GetFastValue(config2, "atlasXhrSettings")
                });
              } else {
                image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
              }
              if (image.linkFile) {
                MultiFile.call(this, loader, "atlasjson", key, [image, data, image.linkFile]);
              } else {
                MultiFile.call(this, loader, "atlasjson", key, [image, data]);
              }
            },
            addToCache: function() {
              if (this.isReadyToProcess()) {
                var image = this.files[0];
                var json = this.files[1];
                var normalMap = this.files[2] ? this.files[2].data : null;
                this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);
                json.addToCache();
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("aseprite", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new AsepriteFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new AsepriteFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = AsepriteFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var ImageFile = __webpack_require__(70);
          var IsPlainObject = __webpack_require__(7);
          var JSONFile = __webpack_require__(59);
          var MultiFile = __webpack_require__(47);
          var AtlasJSONFile = new Class({
            Extends: MultiFile,
            initialize: function AtlasJSONFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
              var image;
              var data;
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                image = new ImageFile(loader, {
                  key,
                  url: GetFastValue(config2, "textureURL"),
                  extension: GetFastValue(config2, "textureExtension", "png"),
                  normalMap: GetFastValue(config2, "normalMap"),
                  xhrSettings: GetFastValue(config2, "textureXhrSettings")
                });
                data = new JSONFile(loader, {
                  key,
                  url: GetFastValue(config2, "atlasURL"),
                  extension: GetFastValue(config2, "atlasExtension", "json"),
                  xhrSettings: GetFastValue(config2, "atlasXhrSettings")
                });
              } else {
                image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
              }
              if (image.linkFile) {
                MultiFile.call(this, loader, "atlasjson", key, [image, data, image.linkFile]);
              } else {
                MultiFile.call(this, loader, "atlasjson", key, [image, data]);
              }
            },
            addToCache: function() {
              if (this.isReadyToProcess()) {
                var image = this.files[0];
                var json = this.files[1];
                var normalMap = this.files[2] ? this.files[2].data : null;
                this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);
                json.pendingDestroy();
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("atlas", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new AtlasJSONFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new AtlasJSONFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = AtlasJSONFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var ImageFile = __webpack_require__(70);
          var IsPlainObject = __webpack_require__(7);
          var MultiFile = __webpack_require__(47);
          var XMLFile = __webpack_require__(238);
          var AtlasXMLFile = new Class({
            Extends: MultiFile,
            initialize: function AtlasXMLFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
              var image;
              var data;
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                image = new ImageFile(loader, {
                  key,
                  url: GetFastValue(config2, "textureURL"),
                  extension: GetFastValue(config2, "textureExtension", "png"),
                  normalMap: GetFastValue(config2, "normalMap"),
                  xhrSettings: GetFastValue(config2, "textureXhrSettings")
                });
                data = new XMLFile(loader, {
                  key,
                  url: GetFastValue(config2, "atlasURL"),
                  extension: GetFastValue(config2, "atlasExtension", "xml"),
                  xhrSettings: GetFastValue(config2, "atlasXhrSettings")
                });
              } else {
                image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                data = new XMLFile(loader, key, atlasURL, atlasXhrSettings);
              }
              if (image.linkFile) {
                MultiFile.call(this, loader, "atlasxml", key, [image, data, image.linkFile]);
              } else {
                MultiFile.call(this, loader, "atlasxml", key, [image, data]);
              }
            },
            addToCache: function() {
              if (this.isReadyToProcess()) {
                var image = this.files[0];
                var xml = this.files[1];
                var normalMap = this.files[2] ? this.files[2].data : null;
                this.loader.textureManager.addAtlasXML(image.key, image.data, xml.data, normalMap);
                xml.pendingDestroy();
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("atlasXML", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new AtlasXMLFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new AtlasXMLFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = AtlasXMLFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AudioFile = __webpack_require__(512);
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var JSONFile = __webpack_require__(59);
          var MultiFile = __webpack_require__(47);
          var AudioSpriteFile = new Class({
            Extends: MultiFile,
            initialize: function AudioSpriteFile2(loader, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings) {
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                jsonURL = GetFastValue(config2, "jsonURL");
                audioURL = GetFastValue(config2, "audioURL");
                audioConfig = GetFastValue(config2, "audioConfig");
                audioXhrSettings = GetFastValue(config2, "audioXhrSettings");
                jsonXhrSettings = GetFastValue(config2, "jsonXhrSettings");
              }
              var data;
              if (!audioURL) {
                data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);
                MultiFile.call(this, loader, "audiosprite", key, [data]);
                this.config.resourceLoad = true;
                this.config.audioConfig = audioConfig;
                this.config.audioXhrSettings = audioXhrSettings;
              } else {
                var audio = AudioFile.create(loader, key, audioURL, audioConfig, audioXhrSettings);
                if (audio) {
                  data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);
                  MultiFile.call(this, loader, "audiosprite", key, [audio, data]);
                  this.config.resourceLoad = false;
                }
              }
            },
            onFileComplete: function(file) {
              var index = this.files.indexOf(file);
              if (index !== -1) {
                this.pending--;
                if (this.config.resourceLoad && file.type === "json" && file.data.hasOwnProperty("resources")) {
                  var urls = file.data.resources;
                  var audioConfig = GetFastValue(this.config, "audioConfig");
                  var audioXhrSettings = GetFastValue(this.config, "audioXhrSettings");
                  var audio = AudioFile.create(this.loader, file.key, urls, audioConfig, audioXhrSettings);
                  if (audio) {
                    this.addToMultiFile(audio);
                    this.loader.addFile(audio);
                  }
                }
              }
            },
            addToCache: function() {
              if (this.isReadyToProcess()) {
                var fileA = this.files[0];
                var fileB = this.files[1];
                fileA.addToCache();
                fileB.addToCache();
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("audioSprite", function(key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings) {
            var game = this.systems.game;
            var gameAudioConfig = game.config.audio;
            var deviceAudio = game.device.audio;
            if (gameAudioConfig && gameAudioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
              return this;
            }
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new AudioSpriteFile(this, key[i]);
                if (multifile.files) {
                  this.addFile(multifile.files);
                }
              }
            } else {
              multifile = new AudioSpriteFile(this, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings);
              if (multifile.files) {
                this.addFile(multifile.files);
              }
            }
            return this;
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var BinaryFile = new Class({
            Extends: File,
            initialize: function BinaryFile2(loader, key, url, xhrSettings, dataType) {
              var extension = "bin";
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
                dataType = GetFastValue(config2, "dataType", dataType);
              }
              var fileConfig = {
                type: "binary",
                cache: loader.cacheManager.binary,
                extension,
                responseType: "arraybuffer",
                key,
                url,
                xhrSettings,
                config: {dataType}
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              var ctor = this.config.dataType;
              this.data = ctor ? new ctor(this.xhrLoader.response) : this.xhrLoader.response;
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("binary", function(key, url, dataType, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new BinaryFile(this, key[i]));
              }
            } else {
              this.addFile(new BinaryFile(this, key, url, xhrSettings, dataType));
            }
            return this;
          });
          module2.exports = BinaryFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var ImageFile = __webpack_require__(70);
          var IsPlainObject = __webpack_require__(7);
          var MultiFile = __webpack_require__(47);
          var ParseXMLBitmapFont = __webpack_require__(209);
          var XMLFile = __webpack_require__(238);
          var BitmapFontFile = new Class({
            Extends: MultiFile,
            initialize: function BitmapFontFile2(loader, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) {
              var image;
              var data;
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                image = new ImageFile(loader, {
                  key,
                  url: GetFastValue(config2, "textureURL"),
                  extension: GetFastValue(config2, "textureExtension", "png"),
                  normalMap: GetFastValue(config2, "normalMap"),
                  xhrSettings: GetFastValue(config2, "textureXhrSettings")
                });
                data = new XMLFile(loader, {
                  key,
                  url: GetFastValue(config2, "fontDataURL"),
                  extension: GetFastValue(config2, "fontDataExtension", "xml"),
                  xhrSettings: GetFastValue(config2, "fontDataXhrSettings")
                });
              } else {
                image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                data = new XMLFile(loader, key, fontDataURL, fontDataXhrSettings);
              }
              if (image.linkFile) {
                MultiFile.call(this, loader, "bitmapfont", key, [image, data, image.linkFile]);
              } else {
                MultiFile.call(this, loader, "bitmapfont", key, [image, data]);
              }
            },
            addToCache: function() {
              if (this.isReadyToProcess()) {
                var image = this.files[0];
                var xml = this.files[1];
                image.addToCache();
                xml.pendingDestroy();
                var texture = image.cache.get(image.key);
                var data = ParseXMLBitmapFont(xml.data, image.cache.getFrame(image.key), 0, 0, texture);
                this.loader.cacheManager.bitmapFont.add(image.key, {data, texture: image.key, frame: null});
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("bitmapFont", function(key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new BitmapFontFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new BitmapFontFile(this, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = BitmapFontFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var CSSFile = new Class({
            Extends: File,
            initialize: function CSSFile2(loader, key, url, xhrSettings) {
              var extension = "css";
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
              }
              var fileConfig = {
                type: "script",
                cache: false,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              this.data = document.createElement("style");
              this.data.defer = false;
              this.data.innerHTML = this.xhrLoader.responseText;
              document.head.appendChild(this.data);
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("css", function(key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new CSSFile(this, key[i]));
              }
            } else {
              this.addFile(new CSSFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = CSSFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var Shader = __webpack_require__(390);
          var GLSLFile = new Class({
            Extends: File,
            initialize: function GLSLFile2(loader, key, url, shaderType, xhrSettings) {
              var extension = "glsl";
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                shaderType = GetFastValue(config2, "shaderType", "fragment");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
              } else if (shaderType === void 0) {
                shaderType = "fragment";
              }
              var fileConfig = {
                type: "glsl",
                cache: loader.cacheManager.shader,
                extension,
                responseType: "text",
                key,
                url,
                config: {
                  shaderType
                },
                xhrSettings
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            },
            addToCache: function() {
              var data = this.data.split("\n");
              var block = this.extractBlock(data, 0);
              if (block) {
                while (block) {
                  var key = this.getShaderName(block.header);
                  var shaderType = this.getShaderType(block.header);
                  var uniforms = this.getShaderUniforms(block.header);
                  var shaderSrc = block.shader;
                  if (this.cache.has(key)) {
                    var shader = this.cache.get(key);
                    if (shaderType === "fragment") {
                      shader.fragmentSrc = shaderSrc;
                    } else {
                      shader.vertexSrc = shaderSrc;
                    }
                    if (!shader.uniforms) {
                      shader.uniforms = uniforms;
                    }
                  } else if (shaderType === "fragment") {
                    this.cache.add(key, new Shader(key, shaderSrc, "", uniforms));
                  } else {
                    this.cache.add(key, new Shader(key, "", shaderSrc, uniforms));
                  }
                  block = this.extractBlock(data, block.offset);
                }
              } else if (this.config.shaderType === "fragment") {
                this.cache.add(this.key, new Shader(this.key, this.data));
              } else {
                this.cache.add(this.key, new Shader(this.key, "", this.data));
              }
              this.pendingDestroy();
            },
            getShaderName: function(headerSource) {
              for (var i = 0; i < headerSource.length; i++) {
                var line = headerSource[i].trim();
                if (line.substring(0, 5) === "name:") {
                  return line.substring(5).trim();
                }
              }
              return this.key;
            },
            getShaderType: function(headerSource) {
              for (var i = 0; i < headerSource.length; i++) {
                var line = headerSource[i].trim();
                if (line.substring(0, 5) === "type:") {
                  return line.substring(5).trim();
                }
              }
              return this.config.shaderType;
            },
            getShaderUniforms: function(headerSource) {
              var uniforms = {};
              for (var i = 0; i < headerSource.length; i++) {
                var line = headerSource[i].trim();
                if (line.substring(0, 8) === "uniform.") {
                  var pos = line.indexOf(":");
                  if (pos) {
                    var key = line.substring(8, pos);
                    try {
                      uniforms[key] = JSON.parse(line.substring(pos + 1));
                    } catch (e) {
                      console.warn("Invalid uniform JSON: " + key);
                    }
                  }
                }
              }
              return uniforms;
            },
            extractBlock: function(data, offset) {
              var headerStart = -1;
              var headerEnd = -1;
              var blockEnd = -1;
              var headerOpen = false;
              var captureSource = false;
              var headerSource = [];
              var shaderSource = [];
              for (var i = offset; i < data.length; i++) {
                var line = data[i].trim();
                if (line === "---") {
                  if (headerStart === -1) {
                    headerStart = i;
                    headerOpen = true;
                  } else if (headerOpen) {
                    headerEnd = i;
                    headerOpen = false;
                    captureSource = true;
                  } else {
                    captureSource = false;
                    break;
                  }
                } else if (headerOpen) {
                  headerSource.push(line);
                } else if (captureSource) {
                  shaderSource.push(line);
                  blockEnd = i;
                }
              }
              if (!headerOpen && headerEnd !== -1) {
                return {header: headerSource, shader: shaderSource.join("\n"), offset: blockEnd};
              } else {
                return null;
              }
            }
          });
          FileTypesManager.register("glsl", function(key, url, shaderType, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new GLSLFile(this, key[i]));
              }
            } else {
              this.addFile(new GLSLFile(this, key, url, shaderType, xhrSettings));
            }
            return this;
          });
          module2.exports = GLSLFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var HTMLFile = new Class({
            Extends: File,
            initialize: function HTMLFile2(loader, key, url, xhrSettings) {
              var extension = "html";
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
              }
              var fileConfig = {
                type: "text",
                cache: loader.cacheManager.html,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("html", function(key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new HTMLFile(this, key[i]));
              }
            } else {
              this.addFile(new HTMLFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = HTMLFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var HTMLTextureFile = new Class({
            Extends: File,
            initialize: function HTMLTextureFile2(loader, key, url, width, height, xhrSettings) {
              if (width === void 0) {
                width = 512;
              }
              if (height === void 0) {
                height = 512;
              }
              var extension = "html";
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
                width = GetFastValue(config2, "width", width);
                height = GetFastValue(config2, "height", height);
              }
              var fileConfig = {
                type: "html",
                cache: loader.textureManager,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings,
                config: {
                  width,
                  height
                }
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              var w = this.config.width;
              var h = this.config.height;
              var data = [];
              data.push('<svg width="' + w + 'px" height="' + h + 'px" viewBox="0 0 ' + w + " " + h + '" xmlns="http://www.w3.org/2000/svg">');
              data.push('<foreignObject width="100%" height="100%">');
              data.push('<body xmlns="http://www.w3.org/1999/xhtml">');
              data.push(this.xhrLoader.responseText);
              data.push("</body>");
              data.push("</foreignObject>");
              data.push("</svg>");
              var svg = [data.join("\n")];
              var _this = this;
              try {
                var blob = new window.Blob(svg, {type: "image/svg+xml;charset=utf-8"});
              } catch (e) {
                _this.state = CONST.FILE_ERRORED;
                _this.onProcessComplete();
                return;
              }
              this.data = new Image();
              this.data.crossOrigin = this.crossOrigin;
              this.data.onload = function() {
                File.revokeObjectURL(_this.data);
                _this.onProcessComplete();
              };
              this.data.onerror = function() {
                File.revokeObjectURL(_this.data);
                _this.onProcessError();
              };
              File.createObjectURL(this.data, blob, "image/svg+xml");
            },
            addToCache: function() {
              var texture = this.cache.addImage(this.key, this.data);
              this.pendingDestroy(texture);
            }
          });
          FileTypesManager.register("htmlTexture", function(key, url, width, height, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new HTMLTextureFile(this, key[i]));
              }
            } else {
              this.addFile(new HTMLTextureFile(this, key, url, width, height, xhrSettings));
            }
            return this;
          });
          module2.exports = HTMLTextureFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var ImageFile = __webpack_require__(70);
          var IsPlainObject = __webpack_require__(7);
          var JSONFile = __webpack_require__(59);
          var MultiFile = __webpack_require__(47);
          var MultiAtlasFile = new Class({
            Extends: MultiFile,
            initialize: function MultiAtlasFile2(loader, key, atlasURL, path, baseURL, atlasXhrSettings, textureXhrSettings) {
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                if (GetFastValue(config2, "url", false)) {
                  atlasURL = GetFastValue(config2, "url");
                } else {
                  atlasURL = GetFastValue(config2, "atlasURL");
                }
                atlasXhrSettings = GetFastValue(config2, "xhrSettings");
                path = GetFastValue(config2, "path");
                baseURL = GetFastValue(config2, "baseURL");
                textureXhrSettings = GetFastValue(config2, "textureXhrSettings");
              }
              var data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
              MultiFile.call(this, loader, "multiatlas", key, [data]);
              this.config.path = path;
              this.config.baseURL = baseURL;
              this.config.textureXhrSettings = textureXhrSettings;
            },
            onFileComplete: function(file) {
              var index = this.files.indexOf(file);
              if (index !== -1) {
                this.pending--;
                if (file.type === "json" && file.data.hasOwnProperty("textures")) {
                  var textures = file.data.textures;
                  var config2 = this.config;
                  var loader = this.loader;
                  var currentBaseURL = loader.baseURL;
                  var currentPath = loader.path;
                  var currentPrefix = loader.prefix;
                  var baseURL = GetFastValue(config2, "baseURL", this.baseURL);
                  var path = GetFastValue(config2, "path", this.path);
                  var prefix = GetFastValue(config2, "prefix", this.prefix);
                  var textureXhrSettings = GetFastValue(config2, "textureXhrSettings");
                  loader.setBaseURL(baseURL);
                  loader.setPath(path);
                  loader.setPrefix(prefix);
                  for (var i = 0; i < textures.length; i++) {
                    var textureURL = textures[i].image;
                    var key = "MA" + this.multiKeyIndex + "_" + textureURL;
                    var image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                    this.addToMultiFile(image);
                    loader.addFile(image);
                    if (textures[i].normalMap) {
                      var normalMap = new ImageFile(loader, key, textures[i].normalMap, textureXhrSettings);
                      normalMap.type = "normalMap";
                      image.setLink(normalMap);
                      this.addToMultiFile(normalMap);
                      loader.addFile(normalMap);
                    }
                  }
                  loader.setBaseURL(currentBaseURL);
                  loader.setPath(currentPath);
                  loader.setPrefix(currentPrefix);
                }
              }
            },
            addToCache: function() {
              if (this.isReadyToProcess()) {
                var fileJSON = this.files[0];
                var data = [];
                var images = [];
                var normalMaps = [];
                for (var i = 1; i < this.files.length; i++) {
                  var file = this.files[i];
                  if (file.type === "normalMap") {
                    continue;
                  }
                  var pos = file.key.indexOf("_");
                  var key = file.key.substr(pos + 1);
                  var image = file.data;
                  for (var t = 0; t < fileJSON.data.textures.length; t++) {
                    var item = fileJSON.data.textures[t];
                    if (item.image === key) {
                      images.push(image);
                      data.push(item);
                      if (file.linkFile) {
                        normalMaps.push(file.linkFile.data);
                      }
                      break;
                    }
                  }
                }
                if (normalMaps.length === 0) {
                  normalMaps = void 0;
                }
                this.loader.textureManager.addAtlasJSONArray(this.key, images, data, normalMaps);
                this.complete = true;
                for (i = 0; i < this.files.length; i++) {
                  this.files[i].pendingDestroy();
                }
              }
            }
          });
          FileTypesManager.register("multiatlas", function(key, atlasURL, path, baseURL, atlasXhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new MultiAtlasFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new MultiAtlasFile(this, key, atlasURL, path, baseURL, atlasXhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = MultiAtlasFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var MultiFile = __webpack_require__(47);
          var ScriptFile = __webpack_require__(514);
          var MultiScriptFile = new Class({
            Extends: MultiFile,
            initialize: function MultiScriptFile2(loader, key, url, xhrSettings) {
              var extension = "js";
              var files = [];
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
              }
              if (!Array.isArray(url)) {
                url = [url];
              }
              for (var i = 0; i < url.length; i++) {
                var scriptFile = new ScriptFile(loader, {
                  key: key + "_" + i.toString(),
                  url: url[i],
                  extension,
                  xhrSettings
                });
                scriptFile.onProcess = function() {
                  this.onProcessComplete();
                };
                files.push(scriptFile);
              }
              MultiFile.call(this, loader, "scripts", key, files);
            },
            addToCache: function() {
              if (this.isReadyToProcess()) {
                for (var i = 0; i < this.files.length; i++) {
                  var file = this.files[i];
                  file.data = document.createElement("script");
                  file.data.language = "javascript";
                  file.data.type = "text/javascript";
                  file.data.defer = false;
                  file.data.text = file.xhrLoader.responseText;
                  document.head.appendChild(file.data);
                }
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("scripts", function(key, url, xhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new MultiScriptFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new MultiScriptFile(this, key, url, xhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = MultiScriptFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var MultiFile = __webpack_require__(47);
          var ParseObj = __webpack_require__(492);
          var ParseObjMaterial = __webpack_require__(493);
          var TextFile = __webpack_require__(239);
          var OBJFile = new Class({
            Extends: MultiFile,
            initialize: function OBJFile2(loader, key, objURL, matURL, flipUV, xhrSettings) {
              var obj;
              var mat;
              var cache = loader.cacheManager.obj;
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                obj = new TextFile(loader, {
                  key,
                  type: "obj",
                  cache,
                  url: GetFastValue(config2, "url"),
                  extension: GetFastValue(config2, "extension", "obj"),
                  xhrSettings: GetFastValue(config2, "xhrSettings"),
                  config: {
                    flipUV: GetFastValue(config2, "flipUV", flipUV)
                  }
                });
                matURL = GetFastValue(config2, "matURL");
                if (matURL) {
                  mat = new TextFile(loader, {
                    key,
                    type: "mat",
                    cache,
                    url: matURL,
                    extension: GetFastValue(config2, "matExtension", "mat"),
                    xhrSettings: GetFastValue(config2, "xhrSettings")
                  });
                }
              } else {
                obj = new TextFile(loader, {
                  key,
                  url: objURL,
                  type: "obj",
                  cache,
                  extension: "obj",
                  xhrSettings,
                  config: {
                    flipUV
                  }
                });
                if (matURL) {
                  mat = new TextFile(loader, {
                    key,
                    url: matURL,
                    type: "mat",
                    cache,
                    extension: "mat",
                    xhrSettings
                  });
                }
              }
              MultiFile.call(this, loader, "obj", key, [obj, mat]);
            },
            addToCache: function() {
              if (this.isReadyToProcess()) {
                var obj = this.files[0];
                var mat = this.files[1];
                var objData = ParseObj(obj.data, obj.config.flipUV);
                if (mat) {
                  objData.materials = ParseObjMaterial(mat.data);
                }
                obj.cache.add(obj.key, objData);
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("obj", function(key, objURL, matURL, flipUVs, xhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new OBJFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new OBJFile(this, key, objURL, matURL, flipUVs, xhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = OBJFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var FileTypesManager = __webpack_require__(8);
          var JSONFile = __webpack_require__(59);
          var PackFile = new Class({
            Extends: JSONFile,
            initialize: function PackFile2(loader, key, url, xhrSettings, dataKey) {
              JSONFile.call(this, loader, key, url, xhrSettings, dataKey);
              this.type = "packfile";
            },
            onProcess: function() {
              if (this.state !== CONST.FILE_POPULATED) {
                this.state = CONST.FILE_PROCESSING;
                this.data = JSON.parse(this.xhrLoader.responseText);
              }
              this.loader.addPack(this.data, this.config);
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("pack", function(key, url, packKey, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new PackFile(this, key[i]));
              }
            } else {
              this.addFile(new PackFile(this, key, url, xhrSettings, packKey));
            }
            return this;
          });
          module2.exports = PackFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var PluginFile = new Class({
            Extends: File,
            initialize: function PluginFile2(loader, key, url, start, mapping, xhrSettings) {
              var extension = "js";
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
                start = GetFastValue(config2, "start");
                mapping = GetFastValue(config2, "mapping");
              }
              var fileConfig = {
                type: "plugin",
                cache: false,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings,
                config: {
                  start,
                  mapping
                }
              };
              File.call(this, loader, fileConfig);
              if (typeof url === "function") {
                this.data = url;
                this.state = CONST.FILE_POPULATED;
              }
            },
            onProcess: function() {
              var pluginManager = this.loader.systems.plugins;
              var config2 = this.config;
              var start = GetFastValue(config2, "start", false);
              var mapping = GetFastValue(config2, "mapping", null);
              if (this.state === CONST.FILE_POPULATED) {
                pluginManager.install(this.key, this.data, start, mapping);
              } else {
                this.state = CONST.FILE_PROCESSING;
                this.data = document.createElement("script");
                this.data.language = "javascript";
                this.data.type = "text/javascript";
                this.data.defer = false;
                this.data.text = this.xhrLoader.responseText;
                document.head.appendChild(this.data);
                var plugin = pluginManager.install(this.key, window[this.key], start, mapping);
                if (start || mapping) {
                  this.loader.systems[mapping] = plugin;
                  this.loader.scene[mapping] = plugin;
                }
              }
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("plugin", function(key, url, start, mapping, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new PluginFile(this, key[i]));
              }
            } else {
              this.addFile(new PluginFile(this, key, url, start, mapping, xhrSettings));
            }
            return this;
          });
          module2.exports = PluginFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var SceneFile = new Class({
            Extends: File,
            initialize: function SceneFile2(loader, key, url, xhrSettings) {
              var extension = "js";
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
              }
              var fileConfig = {
                type: "text",
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            },
            addToCache: function() {
              var code = this.data.concat("(function(){\nreturn new " + this.key + "();\n}).call(this);");
              var eval2 = eval;
              this.loader.sceneManager.add(this.key, eval2(code));
              this.complete = true;
            }
          });
          FileTypesManager.register("sceneFile", function(key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new SceneFile(this, key[i]));
              }
            } else {
              this.addFile(new SceneFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = SceneFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var ScenePluginFile = new Class({
            Extends: File,
            initialize: function ScenePluginFile2(loader, key, url, systemKey, sceneKey, xhrSettings) {
              var extension = "js";
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
                systemKey = GetFastValue(config2, "systemKey");
                sceneKey = GetFastValue(config2, "sceneKey");
              }
              var fileConfig = {
                type: "scenePlugin",
                cache: false,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings,
                config: {
                  systemKey,
                  sceneKey
                }
              };
              File.call(this, loader, fileConfig);
              if (typeof url === "function") {
                this.data = url;
                this.state = CONST.FILE_POPULATED;
              }
            },
            onProcess: function() {
              var pluginManager = this.loader.systems.plugins;
              var config2 = this.config;
              var key = this.key;
              var systemKey = GetFastValue(config2, "systemKey", key);
              var sceneKey = GetFastValue(config2, "sceneKey", key);
              if (this.state === CONST.FILE_POPULATED) {
                pluginManager.installScenePlugin(systemKey, this.data, sceneKey, this.loader.scene, true);
              } else {
                this.state = CONST.FILE_PROCESSING;
                this.data = document.createElement("script");
                this.data.language = "javascript";
                this.data.type = "text/javascript";
                this.data.defer = false;
                this.data.text = this.xhrLoader.responseText;
                document.head.appendChild(this.data);
                pluginManager.installScenePlugin(systemKey, window[this.key], sceneKey, this.loader.scene, true);
              }
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("scenePlugin", function(key, url, systemKey, sceneKey, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new ScenePluginFile(this, key[i]));
              }
            } else {
              this.addFile(new ScenePluginFile(this, key, url, systemKey, sceneKey, xhrSettings));
            }
            return this;
          });
          module2.exports = ScenePluginFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var ImageFile = __webpack_require__(70);
          var SpriteSheetFile = new Class({
            Extends: ImageFile,
            initialize: function SpriteSheetFile2(loader, key, url, frameConfig, xhrSettings) {
              ImageFile.call(this, loader, key, url, xhrSettings, frameConfig);
              this.type = "spritesheet";
            },
            addToCache: function() {
              var texture = this.cache.addSpriteSheet(this.key, this.data, this.config);
              this.pendingDestroy(texture);
            }
          });
          FileTypesManager.register("spritesheet", function(key, url, frameConfig, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new SpriteSheetFile(this, key[i]));
              }
            } else {
              this.addFile(new SpriteSheetFile(this, key, url, frameConfig, xhrSettings));
            }
            return this;
          });
          module2.exports = SpriteSheetFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var SVGFile = new Class({
            Extends: File,
            initialize: function SVGFile2(loader, key, url, svgConfig, xhrSettings) {
              var extension = "svg";
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                svgConfig = GetFastValue(config2, "svgConfig", {});
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
              }
              var fileConfig = {
                type: "svg",
                cache: loader.textureManager,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings,
                config: {
                  width: GetFastValue(svgConfig, "width"),
                  height: GetFastValue(svgConfig, "height"),
                  scale: GetFastValue(svgConfig, "scale")
                }
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              var text = this.xhrLoader.responseText;
              var svg = [text];
              var width = this.config.width;
              var height = this.config.height;
              var scale = this.config.scale;
              resize:
                if (width && height || scale) {
                  var xml = null;
                  var parser = new DOMParser();
                  xml = parser.parseFromString(text, "text/xml");
                  var svgXML = xml.getElementsByTagName("svg")[0];
                  var hasViewBox = svgXML.hasAttribute("viewBox");
                  var svgWidth = parseFloat(svgXML.getAttribute("width"));
                  var svgHeight = parseFloat(svgXML.getAttribute("height"));
                  if (!hasViewBox && svgWidth && svgHeight) {
                    svgXML.setAttribute("viewBox", "0  0 " + svgWidth + " " + svgHeight);
                  } else if (hasViewBox && !svgWidth && !svgHeight) {
                    var viewBox = svgXML.getAttribute("viewBox").split(/\s+|,/);
                    svgWidth = viewBox[2];
                    svgHeight = viewBox[3];
                  }
                  if (scale) {
                    if (svgWidth && svgHeight) {
                      width = svgWidth * scale;
                      height = svgHeight * scale;
                    } else {
                      break resize;
                    }
                  }
                  svgXML.setAttribute("width", width.toString() + "px");
                  svgXML.setAttribute("height", height.toString() + "px");
                  svg = [new XMLSerializer().serializeToString(svgXML)];
                }
              try {
                var blob = new window.Blob(svg, {type: "image/svg+xml;charset=utf-8"});
              } catch (e) {
                this.onProcessError();
                return;
              }
              this.data = new Image();
              this.data.crossOrigin = this.crossOrigin;
              var _this = this;
              var retry = false;
              this.data.onload = function() {
                if (!retry) {
                  File.revokeObjectURL(_this.data);
                }
                _this.onProcessComplete();
              };
              this.data.onerror = function() {
                if (!retry) {
                  retry = true;
                  File.revokeObjectURL(_this.data);
                  _this.data.src = "data:image/svg+xml," + encodeURIComponent(svg.join(""));
                } else {
                  _this.onProcessError();
                }
              };
              File.createObjectURL(this.data, blob, "image/svg+xml");
            },
            addToCache: function() {
              var texture = this.cache.addImage(this.key, this.data);
              this.pendingDestroy(texture);
            }
          });
          FileTypesManager.register("svg", function(key, url, svgConfig, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new SVGFile(this, key[i]));
              }
            } else {
              this.addFile(new SVGFile(this, key, url, svgConfig, xhrSettings));
            }
            return this;
          });
          module2.exports = SVGFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var TILEMAP_FORMATS = __webpack_require__(39);
          var TilemapCSVFile = new Class({
            Extends: File,
            initialize: function TilemapCSVFile2(loader, key, url, xhrSettings) {
              var extension = "csv";
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                url = GetFastValue(config2, "url");
                xhrSettings = GetFastValue(config2, "xhrSettings");
                extension = GetFastValue(config2, "extension", extension);
              }
              var fileConfig = {
                type: "tilemapCSV",
                cache: loader.cacheManager.tilemap,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings
              };
              File.call(this, loader, fileConfig);
              this.tilemapFormat = TILEMAP_FORMATS.CSV;
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            },
            addToCache: function() {
              var tiledata = {format: this.tilemapFormat, data: this.data};
              this.cache.add(this.key, tiledata);
              this.pendingDestroy(tiledata);
            }
          });
          FileTypesManager.register("tilemapCSV", function(key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new TilemapCSVFile(this, key[i]));
              }
            } else {
              this.addFile(new TilemapCSVFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = TilemapCSVFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var JSONFile = __webpack_require__(59);
          var TILEMAP_FORMATS = __webpack_require__(39);
          var TilemapImpactFile = new Class({
            Extends: JSONFile,
            initialize: function TilemapImpactFile2(loader, key, url, xhrSettings) {
              JSONFile.call(this, loader, key, url, xhrSettings);
              this.type = "tilemapJSON";
              this.cache = loader.cacheManager.tilemap;
            },
            addToCache: function() {
              var tiledata = {format: TILEMAP_FORMATS.WELTMEISTER, data: this.data};
              this.cache.add(this.key, tiledata);
              this.pendingDestroy(tiledata);
            }
          });
          FileTypesManager.register("tilemapImpact", function(key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new TilemapImpactFile(this, key[i]));
              }
            } else {
              this.addFile(new TilemapImpactFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = TilemapImpactFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var JSONFile = __webpack_require__(59);
          var TILEMAP_FORMATS = __webpack_require__(39);
          var TilemapJSONFile = new Class({
            Extends: JSONFile,
            initialize: function TilemapJSONFile2(loader, key, url, xhrSettings) {
              JSONFile.call(this, loader, key, url, xhrSettings);
              this.type = "tilemapJSON";
              this.cache = loader.cacheManager.tilemap;
            },
            addToCache: function() {
              var tiledata = {format: TILEMAP_FORMATS.TILED_JSON, data: this.data};
              this.cache.add(this.key, tiledata);
              this.pendingDestroy(tiledata);
            }
          });
          FileTypesManager.register("tilemapTiledJSON", function(key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new TilemapJSONFile(this, key[i]));
              }
            } else {
              this.addFile(new TilemapJSONFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = TilemapJSONFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var ImageFile = __webpack_require__(70);
          var IsPlainObject = __webpack_require__(7);
          var MultiFile = __webpack_require__(47);
          var TextFile = __webpack_require__(239);
          var UnityAtlasFile = new Class({
            Extends: MultiFile,
            initialize: function UnityAtlasFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
              var image;
              var data;
              if (IsPlainObject(key)) {
                var config2 = key;
                key = GetFastValue(config2, "key");
                image = new ImageFile(loader, {
                  key,
                  url: GetFastValue(config2, "textureURL"),
                  extension: GetFastValue(config2, "textureExtension", "png"),
                  normalMap: GetFastValue(config2, "normalMap"),
                  xhrSettings: GetFastValue(config2, "textureXhrSettings")
                });
                data = new TextFile(loader, {
                  key,
                  url: GetFastValue(config2, "atlasURL"),
                  extension: GetFastValue(config2, "atlasExtension", "txt"),
                  xhrSettings: GetFastValue(config2, "atlasXhrSettings")
                });
              } else {
                image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                data = new TextFile(loader, key, atlasURL, atlasXhrSettings);
              }
              if (image.linkFile) {
                MultiFile.call(this, loader, "unityatlas", key, [image, data, image.linkFile]);
              } else {
                MultiFile.call(this, loader, "unityatlas", key, [image, data]);
              }
            },
            addToCache: function() {
              if (this.isReadyToProcess()) {
                var image = this.files[0];
                var text = this.files[1];
                var normalMap = this.files[2] ? this.files[2].data : null;
                this.loader.textureManager.addUnityAtlas(image.key, image.data, text.data, normalMap);
                text.pendingDestroy();
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("unityAtlas", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new UnityAtlasFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new UnityAtlasFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = UnityAtlasFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetURL = __webpack_require__(153);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var VideoFile = new Class({
            Extends: File,
            initialize: function VideoFile2(loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings) {
              if (loadEvent === void 0) {
                loadEvent = "loadeddata";
              }
              if (asBlob === void 0) {
                asBlob = false;
              }
              if (noAudio === void 0) {
                noAudio = false;
              }
              if (loadEvent !== "loadeddata" && loadEvent !== "canplay" && loadEvent !== "canplaythrough") {
                loadEvent = "loadeddata";
              }
              var fileConfig = {
                type: "video",
                cache: loader.cacheManager.video,
                extension: urlConfig.type,
                responseType: "blob",
                key,
                url: urlConfig.url,
                xhrSettings,
                config: {
                  loadEvent,
                  asBlob,
                  noAudio
                }
              };
              this.onLoadCallback = this.onVideoLoadHandler.bind(this);
              this.onErrorCallback = this.onVideoErrorHandler.bind(this);
              File.call(this, loader, fileConfig);
            },
            onProcess: function() {
              this.state = CONST.FILE_PROCESSING;
              if (!this.config.asBlob) {
                this.onProcessComplete();
                return;
              }
              var video = this.createVideoElement();
              this.data = video;
              var _this = this;
              this.data.onloadeddata = function() {
                _this.onProcessComplete();
              };
              this.data.onerror = function() {
                File.revokeObjectURL(_this.data);
                _this.onProcessError();
              };
              File.createObjectURL(video, this.xhrLoader.response, "");
              video.load();
            },
            createVideoElement: function() {
              var video = document.createElement("video");
              video.controls = false;
              video.crossOrigin = this.loader.crossOrigin;
              if (this.config.noAudio) {
                video.muted = true;
                video.defaultMuted = true;
                video.setAttribute("autoplay", "autoplay");
              }
              video.setAttribute("playsinline", "playsinline");
              video.setAttribute("preload", "auto");
              return video;
            },
            onVideoLoadHandler: function(event) {
              var video = event.target;
              video.removeEventListener(this.config.loadEvent, this.onLoadCallback, true);
              video.removeEventListener("error", this.onErrorCallback, true);
              this.data = video;
              this.resetXHR();
              this.loader.nextFile(this, true);
            },
            onVideoErrorHandler: function(event) {
              var video = event.target;
              if (video) {
                video.removeEventListener(this.config.loadEvent, this.onLoadCallback, true);
                video.removeEventListener("error", this.onErrorCallback, true);
              }
              this.resetXHR();
              this.loader.nextFile(this, false);
            },
            load: function() {
              var loadEvent = this.config.loadEvent;
              if (this.config.asBlob) {
                File.prototype.load.call(this);
              } else {
                this.percentComplete = 0;
                var video = this.createVideoElement();
                video.addEventListener(loadEvent, this.onLoadCallback, true);
                video.addEventListener("error", this.onErrorCallback, true);
                video.src = GetURL(this, this.loader.baseURL);
                video.load();
              }
            }
          });
          VideoFile.create = function(loader, key, urls, loadEvent, asBlob, noAudio, xhrSettings) {
            var game = loader.systems.game;
            if (IsPlainObject(key)) {
              urls = GetFastValue(key, "url", []);
              loadEvent = GetFastValue(key, "loadEvent", "loadeddata");
              asBlob = GetFastValue(key, "asBlob", false);
              noAudio = GetFastValue(key, "noAudio", false);
              xhrSettings = GetFastValue(key, "xhrSettings");
            }
            var urlConfig = VideoFile.getVideoURL(game, urls);
            if (urlConfig) {
              return new VideoFile(loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings);
            }
          };
          VideoFile.getVideoURL = function(game, urls) {
            if (!Array.isArray(urls)) {
              urls = [urls];
            }
            for (var i = 0; i < urls.length; i++) {
              var url = GetFastValue(urls[i], "url", urls[i]);
              if (url.indexOf("blob:") === 0) {
                return {
                  url,
                  type: ""
                };
              }
              var videoType;
              if (url.indexOf("data:") === 0) {
                videoType = url.split(",")[0].match(/\/(.*?);/);
              } else {
                videoType = url.match(/\.([a-zA-Z0-9]+)($|\?)/);
              }
              videoType = GetFastValue(urls[i], "type", videoType ? videoType[1] : "").toLowerCase();
              if (game.device.video[videoType]) {
                return {
                  url,
                  type: videoType
                };
              }
            }
            return null;
          };
          FileTypesManager.register("video", function(key, urls, loadEvent, asBlob, noAudio, xhrSettings) {
            var videoFile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                videoFile = VideoFile.create(this, key[i]);
                if (videoFile) {
                  this.addFile(videoFile);
                }
              }
            } else {
              videoFile = VideoFile.create(this, key, urls, loadEvent, asBlob, noAudio, xhrSettings);
              if (videoFile) {
                this.addFile(videoFile);
              }
            }
            return this;
          });
          module2.exports = VideoFile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(20);
          var CustomSet = __webpack_require__(148);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(91);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(21);
          var XHRSettings = __webpack_require__(154);
          var LoaderPlugin = new Class({
            Extends: EventEmitter,
            initialize: function LoaderPlugin2(scene) {
              EventEmitter.call(this);
              var gameConfig = scene.sys.game.config;
              var sceneConfig = scene.sys.settings.loader;
              this.scene = scene;
              this.systems = scene.sys;
              this.cacheManager = scene.sys.cache;
              this.textureManager = scene.sys.textures;
              this.sceneManager = scene.sys.game.scene;
              FileTypesManager.install(this);
              this.prefix = "";
              this.path = "";
              this.baseURL = "";
              this.setBaseURL(GetFastValue(sceneConfig, "baseURL", gameConfig.loaderBaseURL));
              this.setPath(GetFastValue(sceneConfig, "path", gameConfig.loaderPath));
              this.setPrefix(GetFastValue(sceneConfig, "prefix", gameConfig.loaderPrefix));
              this.maxParallelDownloads = GetFastValue(sceneConfig, "maxParallelDownloads", gameConfig.loaderMaxParallelDownloads);
              this.xhr = XHRSettings(GetFastValue(sceneConfig, "responseType", gameConfig.loaderResponseType), GetFastValue(sceneConfig, "async", gameConfig.loaderAsync), GetFastValue(sceneConfig, "user", gameConfig.loaderUser), GetFastValue(sceneConfig, "password", gameConfig.loaderPassword), GetFastValue(sceneConfig, "timeout", gameConfig.loaderTimeout), GetFastValue(sceneConfig, "withCredentials", gameConfig.loaderWithCredentials));
              this.crossOrigin = GetFastValue(sceneConfig, "crossOrigin", gameConfig.loaderCrossOrigin);
              this.totalToLoad = 0;
              this.progress = 0;
              this.list = new CustomSet();
              this.inflight = new CustomSet();
              this.queue = new CustomSet();
              this._deleteQueue = new CustomSet();
              this.totalFailed = 0;
              this.totalComplete = 0;
              this.state = CONST.LOADER_IDLE;
              this.multiKeyIndex = 0;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.pluginStart, this);
            },
            boot: function() {
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            pluginStart: function() {
              this.systems.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            setBaseURL: function(url) {
              if (url === void 0) {
                url = "";
              }
              if (url !== "" && url.substr(-1) !== "/") {
                url = url.concat("/");
              }
              this.baseURL = url;
              return this;
            },
            setPath: function(path) {
              if (path === void 0) {
                path = "";
              }
              if (path !== "" && path.substr(-1) !== "/") {
                path = path.concat("/");
              }
              this.path = path;
              return this;
            },
            setPrefix: function(prefix) {
              if (prefix === void 0) {
                prefix = "";
              }
              this.prefix = prefix;
              return this;
            },
            setCORS: function(crossOrigin) {
              this.crossOrigin = crossOrigin;
              return this;
            },
            addFile: function(file) {
              if (!Array.isArray(file)) {
                file = [file];
              }
              for (var i = 0; i < file.length; i++) {
                var item = file[i];
                if (!this.keyExists(item)) {
                  this.list.set(item);
                  this.emit(Events.ADD, item.key, item.type, this, item);
                  if (this.isLoading()) {
                    this.totalToLoad++;
                    this.updateProgress();
                  }
                }
              }
            },
            keyExists: function(file) {
              var keyConflict = file.hasCacheConflict();
              if (!keyConflict) {
                this.list.iterate(function(item) {
                  if (item.type === file.type && item.key === file.key) {
                    keyConflict = true;
                    return false;
                  }
                });
              }
              if (!keyConflict && this.isLoading()) {
                this.inflight.iterate(function(item) {
                  if (item.type === file.type && item.key === file.key) {
                    keyConflict = true;
                    return false;
                  }
                });
                this.queue.iterate(function(item) {
                  if (item.type === file.type && item.key === file.key) {
                    keyConflict = true;
                    return false;
                  }
                });
              }
              return keyConflict;
            },
            addPack: function(pack, packKey) {
              if (packKey && pack.hasOwnProperty(packKey)) {
                pack = {packKey: pack[packKey]};
              }
              var total = 0;
              var currentBaseURL = this.baseURL;
              var currentPath = this.path;
              var currentPrefix = this.prefix;
              for (var key in pack) {
                if (!Object.prototype.hasOwnProperty.call(pack, key)) {
                  continue;
                }
                var config2 = pack[key];
                var baseURL = GetFastValue(config2, "baseURL", currentBaseURL);
                var path = GetFastValue(config2, "path", currentPath);
                var prefix = GetFastValue(config2, "prefix", currentPrefix);
                var files = GetFastValue(config2, "files", null);
                var defaultType = GetFastValue(config2, "defaultType", "void");
                if (Array.isArray(files)) {
                  this.setBaseURL(baseURL);
                  this.setPath(path);
                  this.setPrefix(prefix);
                  for (var i = 0; i < files.length; i++) {
                    var file = files[i];
                    var type = file.hasOwnProperty("type") ? file.type : defaultType;
                    if (this[type]) {
                      this[type](file);
                      total++;
                    }
                  }
                }
              }
              this.setBaseURL(currentBaseURL);
              this.setPath(currentPath);
              this.setPrefix(currentPrefix);
              return total > 0;
            },
            isLoading: function() {
              return this.state === CONST.LOADER_LOADING || this.state === CONST.LOADER_PROCESSING;
            },
            isReady: function() {
              return this.state === CONST.LOADER_IDLE || this.state === CONST.LOADER_COMPLETE;
            },
            start: function() {
              if (!this.isReady()) {
                return;
              }
              this.progress = 0;
              this.totalFailed = 0;
              this.totalComplete = 0;
              this.totalToLoad = this.list.size;
              this.emit(Events.START, this);
              if (this.list.size === 0) {
                this.loadComplete();
              } else {
                this.state = CONST.LOADER_LOADING;
                this.inflight.clear();
                this.queue.clear();
                this.updateProgress();
                this.checkLoadQueue();
                this.systems.events.on(SceneEvents.UPDATE, this.update, this);
              }
            },
            updateProgress: function() {
              this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad;
              this.emit(Events.PROGRESS, this.progress);
            },
            update: function() {
              if (this.state === CONST.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads) {
                this.checkLoadQueue();
              }
            },
            checkLoadQueue: function() {
              this.list.each(function(file) {
                if (file.state === CONST.FILE_POPULATED || file.state === CONST.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) {
                  this.inflight.set(file);
                  this.list.delete(file);
                  if (!file.crossOrigin) {
                    file.crossOrigin = this.crossOrigin;
                  }
                  file.load();
                }
                if (this.inflight.size === this.maxParallelDownloads) {
                  return false;
                }
              }, this);
            },
            nextFile: function(file, success) {
              if (!this.inflight) {
                return;
              }
              this.inflight.delete(file);
              this.updateProgress();
              if (success) {
                this.totalComplete++;
                this.queue.set(file);
                this.emit(Events.FILE_LOAD, file);
                file.onProcess();
              } else {
                this.totalFailed++;
                this._deleteQueue.set(file);
                this.emit(Events.FILE_LOAD_ERROR, file);
                this.fileProcessComplete(file);
              }
            },
            fileProcessComplete: function(file) {
              if (!this.scene || !this.systems || !this.systems.game || this.systems.game.pendingDestroy) {
                return;
              }
              if (file.state === CONST.FILE_ERRORED) {
                if (file.multiFile) {
                  file.multiFile.onFileFailed(file);
                }
              } else if (file.state === CONST.FILE_COMPLETE) {
                if (file.multiFile) {
                  if (file.multiFile.isReadyToProcess()) {
                    file.multiFile.addToCache();
                  }
                } else {
                  file.addToCache();
                }
              }
              this.queue.delete(file);
              if (this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0) {
                this.loadComplete();
              }
            },
            loadComplete: function() {
              this.emit(Events.POST_PROCESS, this);
              this.list.clear();
              this.inflight.clear();
              this.queue.clear();
              this.progress = 1;
              this.state = CONST.LOADER_COMPLETE;
              this.systems.events.off(SceneEvents.UPDATE, this.update, this);
              this._deleteQueue.iterateLocal("destroy");
              this._deleteQueue.clear();
              this.emit(Events.COMPLETE, this, this.totalComplete, this.totalFailed);
            },
            flagForRemoval: function(file) {
              this._deleteQueue.set(file);
            },
            saveJSON: function(data, filename) {
              return this.save(JSON.stringify(data), filename);
            },
            save: function(data, filename, filetype) {
              if (filename === void 0) {
                filename = "file.json";
              }
              if (filetype === void 0) {
                filetype = "application/json";
              }
              var blob = new Blob([data], {type: filetype});
              var url = URL.createObjectURL(blob);
              var a = document.createElement("a");
              a.download = filename;
              a.textContent = "Download " + filename;
              a.href = url;
              a.click();
              return this;
            },
            reset: function() {
              this.list.clear();
              this.inflight.clear();
              this.queue.clear();
              var gameConfig = this.systems.game.config;
              var sceneConfig = this.systems.settings.loader;
              this.setBaseURL(GetFastValue(sceneConfig, "baseURL", gameConfig.loaderBaseURL));
              this.setPath(GetFastValue(sceneConfig, "path", gameConfig.loaderPath));
              this.setPrefix(GetFastValue(sceneConfig, "prefix", gameConfig.loaderPrefix));
              this.state = CONST.LOADER_IDLE;
            },
            shutdown: function() {
              this.reset();
              this.state = CONST.LOADER_SHUTDOWN;
              this.systems.events.off(SceneEvents.UPDATE, this.update, this);
              this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function() {
              this.shutdown();
              this.state = CONST.LOADER_DESTROYED;
              this.systems.events.off(SceneEvents.UPDATE, this.update, this);
              this.systems.events.off(SceneEvents.START, this.pluginStart, this);
              this.list = null;
              this.inflight = null;
              this.queue = null;
              this.scene = null;
              this.systems = null;
              this.textureManager = null;
              this.cacheManager = null;
              this.sceneManager = null;
            }
          });
          PluginCache.register("Loader", LoaderPlugin, "load");
          module2.exports = LoaderPlugin;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(60);
          var Extend = __webpack_require__(17);
          var Arcade = {
            ArcadePhysics: __webpack_require__(1361),
            Body: __webpack_require__(521),
            Collider: __webpack_require__(522),
            Components: __webpack_require__(240),
            Events: __webpack_require__(242),
            Factory: __webpack_require__(515),
            GetOverlapX: __webpack_require__(243),
            GetOverlapY: __webpack_require__(244),
            SeparateX: __webpack_require__(531),
            SeparateY: __webpack_require__(532),
            Group: __webpack_require__(518),
            Image: __webpack_require__(516),
            Sprite: __webpack_require__(155),
            StaticBody: __webpack_require__(533),
            StaticGroup: __webpack_require__(519),
            Tilemap: __webpack_require__(1385),
            World: __webpack_require__(520)
          };
          Arcade = Extend(false, Arcade, CONST);
          module2.exports = Arcade;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var DegToRad = __webpack_require__(35);
          var DistanceBetween = __webpack_require__(48);
          var DistanceSquared = __webpack_require__(347);
          var Factory = __webpack_require__(515);
          var GetFastValue = __webpack_require__(2);
          var Merge = __webpack_require__(143);
          var OverlapCirc = __webpack_require__(517);
          var OverlapRect = __webpack_require__(241);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(21);
          var Vector29 = __webpack_require__(3);
          var World = __webpack_require__(520);
          var ArcadePhysics = new Class({
            initialize: function ArcadePhysics2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.config = this.getConfig();
              this.world;
              this.add;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function() {
              this.world = new World(this.scene, this.config);
              this.add = new Factory(this.world);
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function() {
              if (!this.world) {
                this.world = new World(this.scene, this.config);
                this.add = new Factory(this.world);
              }
              var eventEmitter = this.systems.events;
              if (!GetFastValue(this.config, "customUpdate", false)) {
                eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);
              }
              eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
              eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            enableUpdate: function() {
              this.systems.events.on(SceneEvents.UPDATE, this.world.update, this.world);
            },
            disableUpdate: function() {
              this.systems.events.off(SceneEvents.UPDATE, this.world.update, this.world);
            },
            getConfig: function() {
              var gameConfig = this.systems.game.config.physics;
              var sceneConfig = this.systems.settings.physics;
              var config2 = Merge(GetFastValue(sceneConfig, "arcade", {}), GetFastValue(gameConfig, "arcade", {}));
              return config2;
            },
            overlap: function(object1, object2, overlapCallback, processCallback, callbackContext) {
              if (overlapCallback === void 0) {
                overlapCallback = null;
              }
              if (processCallback === void 0) {
                processCallback = null;
              }
              if (callbackContext === void 0) {
                callbackContext = overlapCallback;
              }
              return this.world.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);
            },
            collide: function(object1, object2, collideCallback, processCallback, callbackContext) {
              if (collideCallback === void 0) {
                collideCallback = null;
              }
              if (processCallback === void 0) {
                processCallback = null;
              }
              if (callbackContext === void 0) {
                callbackContext = collideCallback;
              }
              return this.world.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);
            },
            collideTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
              return this.world.collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext);
            },
            overlapTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
              return this.world.overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext);
            },
            pause: function() {
              return this.world.pause();
            },
            resume: function() {
              return this.world.resume();
            },
            accelerateTo: function(gameObject, x, y, speed, xSpeedMax, ySpeedMax) {
              if (speed === void 0) {
                speed = 60;
              }
              var angle = Math.atan2(y - gameObject.y, x - gameObject.x);
              gameObject.body.acceleration.setToPolar(angle, speed);
              if (xSpeedMax !== void 0 && ySpeedMax !== void 0) {
                gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax);
              }
              return angle;
            },
            accelerateToObject: function(gameObject, destination, speed, xSpeedMax, ySpeedMax) {
              return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);
            },
            closest: function(source, targets) {
              if (!targets) {
                targets = this.world.bodies.entries;
              }
              var min = Number.MAX_VALUE;
              var closest = null;
              var x = source.x;
              var y = source.y;
              var len = targets.length;
              for (var i = 0; i < len; i++) {
                var target = targets[i];
                var body = target.body || target;
                if (source === target || source === body || source === body.gameObject || source === body.center) {
                  continue;
                }
                var distance = DistanceSquared(x, y, body.center.x, body.center.y);
                if (distance < min) {
                  closest = target;
                  min = distance;
                }
              }
              return closest;
            },
            furthest: function(source, targets) {
              if (!targets) {
                targets = this.world.bodies.entries;
              }
              var max = -1;
              var farthest = null;
              var x = source.x;
              var y = source.y;
              var len = targets.length;
              for (var i = 0; i < len; i++) {
                var target = targets[i];
                var body = target.body || target;
                if (source === target || source === body || source === body.gameObject || source === body.center) {
                  continue;
                }
                var distance = DistanceSquared(x, y, body.center.x, body.center.y);
                if (distance > max) {
                  farthest = target;
                  max = distance;
                }
              }
              return farthest;
            },
            moveTo: function(gameObject, x, y, speed, maxTime) {
              if (speed === void 0) {
                speed = 60;
              }
              if (maxTime === void 0) {
                maxTime = 0;
              }
              var angle = Math.atan2(y - gameObject.y, x - gameObject.x);
              if (maxTime > 0) {
                speed = DistanceBetween(gameObject.x, gameObject.y, x, y) / (maxTime / 1e3);
              }
              gameObject.body.velocity.setToPolar(angle, speed);
              return angle;
            },
            moveToObject: function(gameObject, destination, speed, maxTime) {
              return this.moveTo(gameObject, destination.x, destination.y, speed, maxTime);
            },
            velocityFromAngle: function(angle, speed, vec2) {
              if (speed === void 0) {
                speed = 60;
              }
              if (vec2 === void 0) {
                vec2 = new Vector29();
              }
              return vec2.setToPolar(DegToRad(angle), speed);
            },
            velocityFromRotation: function(rotation, speed, vec2) {
              if (speed === void 0) {
                speed = 60;
              }
              if (vec2 === void 0) {
                vec2 = new Vector29();
              }
              return vec2.setToPolar(rotation, speed);
            },
            overlapRect: function(x, y, width, height, includeDynamic, includeStatic) {
              return OverlapRect(this.world, x, y, width, height, includeDynamic, includeStatic);
            },
            overlapCirc: function(x, y, radius, includeDynamic, includeStatic) {
              return OverlapCirc(this.world, x, y, radius, includeDynamic, includeStatic);
            },
            shutdown: function() {
              if (!this.world) {
                return;
              }
              var eventEmitter = this.systems.events;
              eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);
              eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
              eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
              this.add.destroy();
              this.world.destroy();
              this.add = null;
              this.world = null;
            },
            destroy: function() {
              this.shutdown();
              this.scene.sys.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
            }
          });
          PluginCache.register("ArcadePhysics", ArcadePhysics, "arcadePhysics");
          module2.exports = ArcadePhysics;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Acceleration = {
            setAcceleration: function(x, y) {
              this.body.acceleration.set(x, y);
              return this;
            },
            setAccelerationX: function(value) {
              this.body.acceleration.x = value;
              return this;
            },
            setAccelerationY: function(value) {
              this.body.acceleration.y = value;
              return this;
            }
          };
          module2.exports = Acceleration;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Angular = {
            setAngularVelocity: function(value) {
              this.body.angularVelocity = value;
              return this;
            },
            setAngularAcceleration: function(value) {
              this.body.angularAcceleration = value;
              return this;
            },
            setAngularDrag: function(value) {
              this.body.angularDrag = value;
              return this;
            }
          };
          module2.exports = Angular;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Bounce = {
            setBounce: function(x, y) {
              this.body.bounce.set(x, y);
              return this;
            },
            setBounceX: function(value) {
              this.body.bounce.x = value;
              return this;
            },
            setBounceY: function(value) {
              this.body.bounce.y = value;
              return this;
            },
            setCollideWorldBounds: function(value, bounceX, bounceY) {
              this.body.setCollideWorldBounds(value, bounceX, bounceY);
              return this;
            }
          };
          module2.exports = Bounce;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Debug = {
            setDebug: function(showBody, showVelocity, bodyColor) {
              this.debugShowBody = showBody;
              this.debugShowVelocity = showVelocity;
              this.debugBodyColor = bodyColor;
              return this;
            },
            setDebugBodyColor: function(value) {
              this.body.debugBodyColor = value;
              return this;
            },
            debugShowBody: {
              get: function() {
                return this.body.debugShowBody;
              },
              set: function(value) {
                this.body.debugShowBody = value;
              }
            },
            debugShowVelocity: {
              get: function() {
                return this.body.debugShowVelocity;
              },
              set: function(value) {
                this.body.debugShowVelocity = value;
              }
            },
            debugBodyColor: {
              get: function() {
                return this.body.debugBodyColor;
              },
              set: function(value) {
                this.body.debugBodyColor = value;
              }
            }
          };
          module2.exports = Debug;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Drag = {
            setDrag: function(x, y) {
              this.body.drag.set(x, y);
              return this;
            },
            setDragX: function(value) {
              this.body.drag.x = value;
              return this;
            },
            setDragY: function(value) {
              this.body.drag.y = value;
              return this;
            },
            setDamping: function(value) {
              this.body.useDamping = value;
              return this;
            }
          };
          module2.exports = Drag;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Enable = {
            enableBody: function(reset, x, y, enableGameObject, showGameObject) {
              if (reset) {
                this.body.reset(x, y);
              }
              if (enableGameObject) {
                this.body.gameObject.active = true;
              }
              if (showGameObject) {
                this.body.gameObject.visible = true;
              }
              this.body.enable = true;
              return this;
            },
            disableBody: function(disableGameObject, hideGameObject) {
              if (disableGameObject === void 0) {
                disableGameObject = false;
              }
              if (hideGameObject === void 0) {
                hideGameObject = false;
              }
              this.body.stop();
              this.body.enable = false;
              if (disableGameObject) {
                this.body.gameObject.active = false;
              }
              if (hideGameObject) {
                this.body.gameObject.visible = false;
              }
              return this;
            },
            refreshBody: function() {
              this.body.updateFromGameObject();
              return this;
            }
          };
          module2.exports = Enable;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Friction = {
            setFriction: function(x, y) {
              this.body.friction.set(x, y);
              return this;
            },
            setFrictionX: function(x) {
              this.body.friction.x = x;
              return this;
            },
            setFrictionY: function(y) {
              this.body.friction.y = y;
              return this;
            }
          };
          module2.exports = Friction;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Gravity = {
            setGravity: function(x, y) {
              this.body.gravity.set(x, y);
              return this;
            },
            setGravityX: function(x) {
              this.body.gravity.x = x;
              return this;
            },
            setGravityY: function(y) {
              this.body.gravity.y = y;
              return this;
            }
          };
          module2.exports = Gravity;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Immovable = {
            setImmovable: function(value) {
              if (value === void 0) {
                value = true;
              }
              this.body.immovable = value;
              return this;
            }
          };
          module2.exports = Immovable;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Mass = {
            setMass: function(value) {
              this.body.mass = value;
              return this;
            }
          };
          module2.exports = Mass;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Pushable = {
            setPushable: function(value) {
              if (value === void 0) {
                value = true;
              }
              this.body.pushable = value;
              return this;
            }
          };
          module2.exports = Pushable;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Size = {
            setOffset: function(x, y) {
              this.body.setOffset(x, y);
              return this;
            },
            setSize: function(width, height, center) {
              this.body.setSize(width, height, center);
              return this;
            },
            setBodySize: function(width, height, center) {
              this.body.setSize(width, height, center);
              return this;
            },
            setCircle: function(radius, offsetX, offsetY) {
              this.body.setCircle(radius, offsetX, offsetY);
              return this;
            }
          };
          module2.exports = Size;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Velocity = {
            setVelocity: function(x, y) {
              this.body.setVelocity(x, y);
              return this;
            },
            setVelocityX: function(x) {
              this.body.setVelocityX(x);
              return this;
            },
            setVelocityY: function(y) {
              this.body.setVelocityY(y);
              return this;
            },
            setMaxVelocity: function(x, y) {
              this.body.maxVelocity.set(x, y);
              return this;
            }
          };
          module2.exports = Velocity;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "collide";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "overlap";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pause";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "resume";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "tilecollide";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "tileoverlap";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "worldbounds";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "worldstep";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var body1;
          var body2;
          var body1Pushable;
          var body2Pushable;
          var body1MassImpact;
          var body2MassImpact;
          var body1FullImpact;
          var body2FullImpact;
          var body1MovingLeft;
          var body1MovingRight;
          var body1Stationary;
          var body2MovingLeft;
          var body2MovingRight;
          var body2Stationary;
          var body1OnLeft;
          var body2OnLeft;
          var overlap;
          var Set2 = function(b1, b2, ov) {
            body1 = b1;
            body2 = b2;
            var v1 = body1.velocity.x;
            var v2 = body2.velocity.x;
            body1Pushable = body1.pushable;
            body1MovingLeft = body1._dx < 0;
            body1MovingRight = body1._dx > 0;
            body1Stationary = body1._dx === 0;
            body1OnLeft = Math.abs(body1.right - body2.x) <= Math.abs(body2.right - body1.x);
            body1FullImpact = v2 - v1 * body1.bounce.x;
            body2Pushable = body2.pushable;
            body2MovingLeft = body2._dx < 0;
            body2MovingRight = body2._dx > 0;
            body2Stationary = body2._dx === 0;
            body2OnLeft = !body1OnLeft;
            body2FullImpact = v1 - v2 * body2.bounce.x;
            overlap = Math.abs(ov);
            return BlockCheck();
          };
          var BlockCheck = function() {
            if (body1MovingRight && body1OnLeft && body2.blocked.right) {
              body1.processX(-overlap, body1FullImpact, false, true);
              return 1;
            }
            if (body1MovingLeft && body2OnLeft && body2.blocked.left) {
              body1.processX(overlap, body1FullImpact, true);
              return 1;
            }
            if (body2MovingRight && body2OnLeft && body1.blocked.right) {
              body2.processX(-overlap, body2FullImpact, false, true);
              return 2;
            }
            if (body2MovingLeft && body1OnLeft && body1.blocked.left) {
              body2.processX(overlap, body2FullImpact, true);
              return 2;
            }
            return 0;
          };
          var Check = function() {
            var v1 = body1.velocity.x;
            var v2 = body2.velocity.x;
            var nv1 = Math.sqrt(v2 * v2 * body2.mass / body1.mass) * (v2 > 0 ? 1 : -1);
            var nv2 = Math.sqrt(v1 * v1 * body1.mass / body2.mass) * (v1 > 0 ? 1 : -1);
            var avg = (nv1 + nv2) * 0.5;
            nv1 -= avg;
            nv2 -= avg;
            body1MassImpact = avg + nv1 * body1.bounce.x;
            body2MassImpact = avg + nv2 * body2.bounce.x;
            if (body1MovingLeft && body2OnLeft) {
              return Run(0);
            }
            if (body2MovingLeft && body1OnLeft) {
              return Run(1);
            }
            if (body1MovingRight && body1OnLeft) {
              return Run(2);
            }
            if (body2MovingRight && body2OnLeft) {
              return Run(3);
            }
            return false;
          };
          var Run = function(side) {
            if (body1Pushable && body2Pushable) {
              overlap *= 0.5;
              if (side === 0 || side === 3) {
                body1.processX(overlap, body1MassImpact);
                body2.processX(-overlap, body2MassImpact);
              } else {
                body1.processX(-overlap, body1MassImpact);
                body2.processX(overlap, body2MassImpact);
              }
            } else if (body1Pushable && !body2Pushable) {
              if (side === 0 || side === 3) {
                body1.processX(overlap, body1FullImpact, true);
              } else {
                body1.processX(-overlap, body1FullImpact, false, true);
              }
            } else if (!body1Pushable && body2Pushable) {
              if (side === 0 || side === 3) {
                body2.processX(-overlap, body2FullImpact, false, true);
              } else {
                body2.processX(overlap, body2FullImpact, true);
              }
            } else {
              var halfOverlap = overlap * 0.5;
              if (side === 0) {
                if (body2Stationary) {
                  body1.processX(overlap, 0, true);
                  body2.processX(0, null, false, true);
                } else if (body2MovingRight) {
                  body1.processX(halfOverlap, 0, true);
                  body2.processX(-halfOverlap, 0, false, true);
                } else {
                  body1.processX(halfOverlap, body2.velocity.x, true);
                  body2.processX(-halfOverlap, null, false, true);
                }
              } else if (side === 1) {
                if (body1Stationary) {
                  body1.processX(0, null, false, true);
                  body2.processX(overlap, 0, true);
                } else if (body1MovingRight) {
                  body1.processX(-halfOverlap, 0, false, true);
                  body2.processX(halfOverlap, 0, true);
                } else {
                  body1.processX(-halfOverlap, null, false, true);
                  body2.processX(halfOverlap, body1.velocity.x, true);
                }
              } else if (side === 2) {
                if (body2Stationary) {
                  body1.processX(-overlap, 0, false, true);
                  body2.processX(0, null, true);
                } else if (body2MovingLeft) {
                  body1.processX(-halfOverlap, 0, false, true);
                  body2.processX(halfOverlap, 0, true);
                } else {
                  body1.processX(-halfOverlap, body2.velocity.x, false, true);
                  body2.processX(halfOverlap, null, true);
                }
              } else if (side === 3) {
                if (body1Stationary) {
                  body1.processX(0, null, true);
                  body2.processX(-overlap, 0, false, true);
                } else if (body1MovingLeft) {
                  body1.processX(halfOverlap, 0, true);
                  body2.processX(-halfOverlap, 0, false, true);
                } else {
                  body1.processX(halfOverlap, body2.velocity.y, true);
                  body2.processX(-halfOverlap, null, false, true);
                }
              }
            }
            return true;
          };
          var RunImmovableBody1 = function(blockedState) {
            if (blockedState === 1) {
              body2.velocity.x = 0;
            } else if (body1OnLeft) {
              body2.processX(overlap, body2FullImpact, true);
            } else {
              body2.processX(-overlap, body2FullImpact, false, true);
            }
            if (body1.moves) {
              body2.y += (body1.y - body1.prev.y) * body1.friction.y;
              body2._dy = body2.y - body2.prev.y;
            }
          };
          var RunImmovableBody2 = function(blockedState) {
            if (blockedState === 2) {
              body1.velocity.x = 0;
            }
            if (body2OnLeft) {
              body1.processX(overlap, body1FullImpact, true);
            } else {
              body1.processX(-overlap, body1FullImpact, false, true);
            }
            if (body2.moves) {
              body1.y += (body2.y - body2.prev.y) * body2.friction.y;
              body1._dy = body1.y - body1.prev.y;
            }
          };
          module2.exports = {
            BlockCheck,
            Check,
            Set: Set2,
            Run,
            RunImmovableBody1,
            RunImmovableBody2
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var body1;
          var body2;
          var body1Pushable;
          var body2Pushable;
          var body1MassImpact;
          var body2MassImpact;
          var body1FullImpact;
          var body2FullImpact;
          var body1MovingUp;
          var body1MovingDown;
          var body1Stationary;
          var body2MovingUp;
          var body2MovingDown;
          var body2Stationary;
          var body1OnTop;
          var body2OnTop;
          var overlap;
          var Set2 = function(b1, b2, ov) {
            body1 = b1;
            body2 = b2;
            var v1 = body1.velocity.y;
            var v2 = body2.velocity.y;
            body1Pushable = body1.pushable;
            body1MovingUp = body1._dy < 0;
            body1MovingDown = body1._dy > 0;
            body1Stationary = body1._dy === 0;
            body1OnTop = Math.abs(body1.bottom - body2.y) <= Math.abs(body2.bottom - body1.y);
            body1FullImpact = v2 - v1 * body1.bounce.y;
            body2Pushable = body2.pushable;
            body2MovingUp = body2._dy < 0;
            body2MovingDown = body2._dy > 0;
            body2Stationary = body2._dy === 0;
            body2OnTop = !body1OnTop;
            body2FullImpact = v1 - v2 * body2.bounce.y;
            overlap = Math.abs(ov);
            return BlockCheck();
          };
          var BlockCheck = function() {
            if (body1MovingDown && body1OnTop && body2.blocked.down) {
              body1.processY(-overlap, body1FullImpact, false, true);
              return 1;
            }
            if (body1MovingUp && body2OnTop && body2.blocked.up) {
              body1.processY(overlap, body1FullImpact, true);
              return 1;
            }
            if (body2MovingDown && body2OnTop && body1.blocked.down) {
              body2.processY(-overlap, body2FullImpact, false, true);
              return 2;
            }
            if (body2MovingUp && body1OnTop && body1.blocked.up) {
              body2.processY(overlap, body2FullImpact, true);
              return 2;
            }
            return 0;
          };
          var Check = function() {
            var v1 = body1.velocity.y;
            var v2 = body2.velocity.y;
            var nv1 = Math.sqrt(v2 * v2 * body2.mass / body1.mass) * (v2 > 0 ? 1 : -1);
            var nv2 = Math.sqrt(v1 * v1 * body1.mass / body2.mass) * (v1 > 0 ? 1 : -1);
            var avg = (nv1 + nv2) * 0.5;
            nv1 -= avg;
            nv2 -= avg;
            body1MassImpact = avg + nv1 * body1.bounce.y;
            body2MassImpact = avg + nv2 * body2.bounce.y;
            if (body1MovingUp && body2OnTop) {
              return Run(0);
            }
            if (body2MovingUp && body1OnTop) {
              return Run(1);
            }
            if (body1MovingDown && body1OnTop) {
              return Run(2);
            }
            if (body2MovingDown && body2OnTop) {
              return Run(3);
            }
            return false;
          };
          var Run = function(side) {
            if (body1Pushable && body2Pushable) {
              overlap *= 0.5;
              if (side === 0 || side === 3) {
                body1.processY(overlap, body1MassImpact);
                body2.processY(-overlap, body2MassImpact);
              } else {
                body1.processY(-overlap, body1MassImpact);
                body2.processY(overlap, body2MassImpact);
              }
            } else if (body1Pushable && !body2Pushable) {
              if (side === 0 || side === 3) {
                body1.processY(overlap, body1FullImpact, true);
              } else {
                body1.processY(-overlap, body1FullImpact, false, true);
              }
            } else if (!body1Pushable && body2Pushable) {
              if (side === 0 || side === 3) {
                body2.processY(-overlap, body2FullImpact, false, true);
              } else {
                body2.processY(overlap, body2FullImpact, true);
              }
            } else {
              var halfOverlap = overlap * 0.5;
              if (side === 0) {
                if (body2Stationary) {
                  body1.processY(overlap, 0, true);
                  body2.processY(0, null, false, true);
                } else if (body2MovingDown) {
                  body1.processY(halfOverlap, 0, true);
                  body2.processY(-halfOverlap, 0, false, true);
                } else {
                  body1.processY(halfOverlap, body2.velocity.y, true);
                  body2.processY(-halfOverlap, null, false, true);
                }
              } else if (side === 1) {
                if (body1Stationary) {
                  body1.processY(0, null, false, true);
                  body2.processY(overlap, 0, true);
                } else if (body1MovingDown) {
                  body1.processY(-halfOverlap, 0, false, true);
                  body2.processY(halfOverlap, 0, true);
                } else {
                  body1.processY(-halfOverlap, null, false, true);
                  body2.processY(halfOverlap, body1.velocity.y, true);
                }
              } else if (side === 2) {
                if (body2Stationary) {
                  body1.processY(-overlap, 0, false, true);
                  body2.processY(0, null, true);
                } else if (body2MovingUp) {
                  body1.processY(-halfOverlap, 0, false, true);
                  body2.processY(halfOverlap, 0, true);
                } else {
                  body1.processY(-halfOverlap, body2.velocity.y, false, true);
                  body2.processY(halfOverlap, null, true);
                }
              } else if (side === 3) {
                if (body1Stationary) {
                  body1.processY(0, null, true);
                  body2.processY(-overlap, 0, false, true);
                } else if (body1MovingUp) {
                  body1.processY(halfOverlap, 0, true);
                  body2.processY(-halfOverlap, 0, false, true);
                } else {
                  body1.processY(halfOverlap, body2.velocity.y, true);
                  body2.processY(-halfOverlap, null, false, true);
                }
              }
            }
            return true;
          };
          var RunImmovableBody1 = function(blockedState) {
            if (blockedState === 1) {
              body2.velocity.y = 0;
            } else if (body1OnTop) {
              body2.processY(overlap, body2FullImpact, true);
            } else {
              body2.processY(-overlap, body2FullImpact, false, true);
            }
            if (body1.moves) {
              body2.x += (body1.x - body1.prev.x) * body1.friction.x;
              body2._dx = body2.x - body2.prev.x;
            }
          };
          var RunImmovableBody2 = function(blockedState) {
            if (blockedState === 2) {
              body1.velocity.y = 0;
            } else if (body2OnTop) {
              body1.processY(overlap, body1FullImpact, true);
            } else {
              body1.processY(-overlap, body1FullImpact, false, true);
            }
            if (body2.moves) {
              body1.x += (body2.x - body2.prev.x) * body2.friction.x;
              body1._dx = body1.x - body1.prev.x;
            }
          };
          module2.exports = {
            BlockCheck,
            Check,
            Set: Set2,
            Run,
            RunImmovableBody1,
            RunImmovableBody2
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Tilemap = {
            ProcessTileCallbacks: __webpack_require__(524),
            ProcessTileSeparationX: __webpack_require__(528),
            ProcessTileSeparationY: __webpack_require__(530),
            SeparateTile: __webpack_require__(526),
            TileCheckX: __webpack_require__(527),
            TileCheckY: __webpack_require__(529),
            TileIntersectsBody: __webpack_require__(245)
          };
          module2.exports = Tilemap;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Joachim Grill <joachim@codeandweb.com>
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2018 CodeAndWeb GmbH
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Bodies = __webpack_require__(126);
          var Body = __webpack_require__(71);
          var Common = __webpack_require__(50);
          var GetFastValue = __webpack_require__(2);
          var Vertices = __webpack_require__(94);
          var PhysicsEditorParser = {
            parseBody: function(x, y, config2, options) {
              if (options === void 0) {
                options = {};
              }
              var fixtureConfigs = GetFastValue(config2, "fixtures", []);
              var fixtures = [];
              for (var fc = 0; fc < fixtureConfigs.length; fc++) {
                var fixtureParts = this.parseFixture(fixtureConfigs[fc]);
                for (var i = 0; i < fixtureParts.length; i++) {
                  fixtures.push(fixtureParts[i]);
                }
              }
              var matterConfig = Common.clone(config2, true);
              Common.extend(matterConfig, options, true);
              delete matterConfig.fixtures;
              delete matterConfig.type;
              var body = Body.create(matterConfig);
              Body.setParts(body, fixtures);
              Body.setPosition(body, {x, y});
              return body;
            },
            parseFixture: function(fixtureConfig) {
              var matterConfig = Common.extend({}, false, fixtureConfig);
              delete matterConfig.circle;
              delete matterConfig.vertices;
              var fixtures;
              if (fixtureConfig.circle) {
                var x = GetFastValue(fixtureConfig.circle, "x");
                var y = GetFastValue(fixtureConfig.circle, "y");
                var r = GetFastValue(fixtureConfig.circle, "radius");
                fixtures = [Bodies.circle(x, y, r, matterConfig)];
              } else if (fixtureConfig.vertices) {
                fixtures = this.parseVertices(fixtureConfig.vertices, matterConfig);
              }
              return fixtures;
            },
            parseVertices: function(vertexSets, options) {
              if (options === void 0) {
                options = {};
              }
              var parts = [];
              for (var v = 0; v < vertexSets.length; v++) {
                Vertices.clockwiseSort(vertexSets[v]);
                parts.push(Body.create(Common.extend({
                  position: Vertices.centre(vertexSets[v]),
                  vertices: vertexSets[v]
                }, options)));
              }
              return Bodies.flagCoincidentParts(parts);
            }
          };
          module2.exports = PhysicsEditorParser;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Bodies = __webpack_require__(126);
          var Body = __webpack_require__(71);
          var PhysicsJSONParser = {
            parseBody: function(x, y, config2, options) {
              if (options === void 0) {
                options = {};
              }
              var body;
              var vertexSets = config2.vertices;
              if (vertexSets.length === 1) {
                options.vertices = vertexSets[0];
                body = Body.create(options);
                Bodies.flagCoincidentParts(body.parts);
              } else {
                var parts = [];
                for (var i = 0; i < vertexSets.length; i++) {
                  var part = Body.create({
                    vertices: vertexSets[i]
                  });
                  parts.push(part);
                }
                Bodies.flagCoincidentParts(parts);
                options.parts = parts;
                body = Body.create(options);
              }
              body.label = config2.label;
              Body.setPosition(body, {x, y});
              return body;
            }
          };
          module2.exports = PhysicsJSONParser;
        },
        function(module2, exports2, __webpack_require__) {
          var Composites = {};
          module2.exports = Composites;
          var Composite = __webpack_require__(163);
          var Constraint = __webpack_require__(246);
          var Common = __webpack_require__(50);
          var Body = __webpack_require__(71);
          var Bodies = __webpack_require__(126);
          (function() {
            Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
              var stack = Composite.create({label: "Stack"}), x = xx, y = yy, lastBody, i = 0;
              for (var row = 0; row < rows; row++) {
                var maxHeight = 0;
                for (var column = 0; column < columns; column++) {
                  var body = callback(x, y, column, row, lastBody, i);
                  if (body) {
                    var bodyHeight = body.bounds.max.y - body.bounds.min.y, bodyWidth = body.bounds.max.x - body.bounds.min.x;
                    if (bodyHeight > maxHeight)
                      maxHeight = bodyHeight;
                    Body.translate(body, {x: bodyWidth * 0.5, y: bodyHeight * 0.5});
                    x = body.bounds.max.x + columnGap;
                    Composite.addBody(stack, body);
                    lastBody = body;
                    i += 1;
                  } else {
                    x += columnGap;
                  }
                }
                y += maxHeight + rowGap;
                x = xx;
              }
              return stack;
            };
            Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
              var bodies = composite.bodies;
              for (var i = 1; i < bodies.length; i++) {
                var bodyA = bodies[i - 1], bodyB = bodies[i], bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y, bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y, bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;
                var defaults = {
                  bodyA,
                  pointA: {x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA},
                  bodyB,
                  pointB: {x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB}
                };
                var constraint = Common.extend(defaults, options);
                Composite.addConstraint(composite, Constraint.create(constraint));
              }
              composite.label += " Chain";
              return composite;
            };
            Composites.mesh = function(composite, columns, rows, crossBrace, options) {
              var bodies = composite.bodies, row, col, bodyA, bodyB, bodyC;
              for (row = 0; row < rows; row++) {
                for (col = 1; col < columns; col++) {
                  bodyA = bodies[col - 1 + row * columns];
                  bodyB = bodies[col + row * columns];
                  Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA, bodyB}, options)));
                }
                if (row > 0) {
                  for (col = 0; col < columns; col++) {
                    bodyA = bodies[col + (row - 1) * columns];
                    bodyB = bodies[col + row * columns];
                    Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA, bodyB}, options)));
                    if (crossBrace && col > 0) {
                      bodyC = bodies[col - 1 + (row - 1) * columns];
                      Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA: bodyC, bodyB}, options)));
                    }
                    if (crossBrace && col < columns - 1) {
                      bodyC = bodies[col + 1 + (row - 1) * columns];
                      Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA: bodyC, bodyB}, options)));
                    }
                  }
                }
              }
              composite.label += " Mesh";
              return composite;
            };
            Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
              return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {
                var actualRows = Math.min(rows, Math.ceil(columns / 2)), lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;
                if (row > actualRows)
                  return;
                row = actualRows - row;
                var start = row, end = columns - 1 - row;
                if (column < start || column > end)
                  return;
                if (i === 1) {
                  Body.translate(lastBody, {x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0});
                }
                var xOffset = lastBody ? column * lastBodyWidth : 0;
                return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);
              });
            };
            Composites.newtonsCradle = function(xx, yy, number, size, length) {
              var newtonsCradle = Composite.create({label: "Newtons Cradle"});
              for (var i = 0; i < number; i++) {
                var separation = 1.9, circle = Bodies.circle(xx + i * (size * separation), yy + length, size, {inertia: Infinity, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1}), constraint = Constraint.create({pointA: {x: xx + i * (size * separation), y: yy}, bodyB: circle});
                Composite.addBody(newtonsCradle, circle);
                Composite.addConstraint(newtonsCradle, constraint);
              }
              return newtonsCradle;
            };
            Composites.car = function(xx, yy, width, height, wheelSize) {
              var group = Body.nextGroup(true), wheelBase = 20, wheelAOffset = -width * 0.5 + wheelBase, wheelBOffset = width * 0.5 - wheelBase, wheelYOffset = 0;
              var car = Composite.create({label: "Car"}), body = Bodies.rectangle(xx, yy, width, height, {
                collisionFilter: {
                  group
                },
                chamfer: {
                  radius: height * 0.5
                },
                density: 2e-4
              });
              var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, {
                collisionFilter: {
                  group
                },
                friction: 0.8
              });
              var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, {
                collisionFilter: {
                  group
                },
                friction: 0.8
              });
              var axelA = Constraint.create({
                bodyB: body,
                pointB: {x: wheelAOffset, y: wheelYOffset},
                bodyA: wheelA,
                stiffness: 1,
                length: 0
              });
              var axelB = Constraint.create({
                bodyB: body,
                pointB: {x: wheelBOffset, y: wheelYOffset},
                bodyA: wheelB,
                stiffness: 1,
                length: 0
              });
              Composite.addBody(car, body);
              Composite.addBody(car, wheelA);
              Composite.addBody(car, wheelB);
              Composite.addConstraint(car, axelA);
              Composite.addConstraint(car, axelB);
              return car;
            };
            Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
              particleOptions = Common.extend({inertia: Infinity}, particleOptions);
              constraintOptions = Common.extend({stiffness: 0.2, render: {type: "line", anchors: false}}, constraintOptions);
              var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {
                return Bodies.circle(x, y, particleRadius, particleOptions);
              });
              Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);
              softBody.label = "Soft Body";
              return softBody;
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Svg = {};
          module2.exports = Svg;
          var Bounds = __webpack_require__(117);
          var Common = __webpack_require__(50);
          (function() {
            Svg.pathToVertices = function(path, sampleLength) {
              if (typeof window !== "undefined" && !("SVGPathSeg" in window)) {
                Common.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
              }
              var i, il, total, point, segment, segments, segmentsQueue, lastSegment, lastPoint, segmentIndex, points = [], lx, ly, length = 0, x = 0, y = 0;
              sampleLength = sampleLength || 15;
              var addPoint = function(px, py, pathSegType) {
                var isRelative = pathSegType % 2 === 1 && pathSegType > 1;
                if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {
                  if (lastPoint && isRelative) {
                    lx = lastPoint.x;
                    ly = lastPoint.y;
                  } else {
                    lx = 0;
                    ly = 0;
                  }
                  var point2 = {
                    x: lx + px,
                    y: ly + py
                  };
                  if (isRelative || !lastPoint) {
                    lastPoint = point2;
                  }
                  points.push(point2);
                  x = lx + px;
                  y = ly + py;
                }
              };
              var addSegmentPoint = function(segment2) {
                var segType = segment2.pathSegTypeAsLetter.toUpperCase();
                if (segType === "Z")
                  return;
                switch (segType) {
                  case "M":
                  case "L":
                  case "T":
                  case "C":
                  case "S":
                  case "Q":
                    x = segment2.x;
                    y = segment2.y;
                    break;
                  case "H":
                    x = segment2.x;
                    break;
                  case "V":
                    y = segment2.y;
                    break;
                }
                addPoint(x, y, segment2.pathSegType);
              };
              Svg._svgPathToAbsolute(path);
              total = path.getTotalLength();
              segments = [];
              for (i = 0; i < path.pathSegList.numberOfItems; i += 1)
                segments.push(path.pathSegList.getItem(i));
              segmentsQueue = segments.concat();
              while (length < total) {
                segmentIndex = path.getPathSegAtLength(length);
                segment = segments[segmentIndex];
                if (segment != lastSegment) {
                  while (segmentsQueue.length && segmentsQueue[0] != segment)
                    addSegmentPoint(segmentsQueue.shift());
                  lastSegment = segment;
                }
                switch (segment.pathSegTypeAsLetter.toUpperCase()) {
                  case "C":
                  case "T":
                  case "S":
                  case "Q":
                  case "A":
                    point = path.getPointAtLength(length);
                    addPoint(point.x, point.y, 0);
                    break;
                }
                length += sampleLength;
              }
              for (i = 0, il = segmentsQueue.length; i < il; ++i)
                addSegmentPoint(segmentsQueue[i]);
              return points;
            };
            Svg._svgPathToAbsolute = function(path) {
              var x0, y0, x1, y1, x2, y2, segs = path.pathSegList, x = 0, y = 0, len = segs.numberOfItems;
              for (var i = 0; i < len; ++i) {
                var seg = segs.getItem(i), segType = seg.pathSegTypeAsLetter;
                if (/[MLHVCSQTA]/.test(segType)) {
                  if ("x" in seg)
                    x = seg.x;
                  if ("y" in seg)
                    y = seg.y;
                } else {
                  if ("x1" in seg)
                    x1 = x + seg.x1;
                  if ("x2" in seg)
                    x2 = x + seg.x2;
                  if ("y1" in seg)
                    y1 = y + seg.y1;
                  if ("y2" in seg)
                    y2 = y + seg.y2;
                  if ("x" in seg)
                    x += seg.x;
                  if ("y" in seg)
                    y += seg.y;
                  switch (segType) {
                    case "m":
                      segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);
                      break;
                    case "l":
                      segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);
                      break;
                    case "h":
                      segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);
                      break;
                    case "v":
                      segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);
                      break;
                    case "c":
                      segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);
                      break;
                    case "s":
                      segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);
                      break;
                    case "q":
                      segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);
                      break;
                    case "t":
                      segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);
                      break;
                    case "a":
                      segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);
                      break;
                    case "z":
                    case "Z":
                      x = x0;
                      y = y0;
                      break;
                  }
                }
                if (segType == "M" || segType == "m") {
                  x0 = x;
                  y0 = y;
                }
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Bodies = __webpack_require__(126);
          var Body = __webpack_require__(71);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(534);
          var EventEmitter = __webpack_require__(9);
          var GetFastValue = __webpack_require__(2);
          var HasValue = __webpack_require__(125);
          var Vertices = __webpack_require__(94);
          var MatterTileBody = new Class({
            Extends: EventEmitter,
            Mixins: [
              Components.Bounce,
              Components.Collision,
              Components.Friction,
              Components.Gravity,
              Components.Mass,
              Components.Sensor,
              Components.Sleep,
              Components.Static
            ],
            initialize: function MatterTileBody2(world, tile, options) {
              EventEmitter.call(this);
              this.tile = tile;
              this.world = world;
              if (tile.physics.matterBody) {
                tile.physics.matterBody.destroy();
              }
              tile.physics.matterBody = this;
              var body = GetFastValue(options, "body", null);
              var addToWorld = GetFastValue(options, "addToWorld", true);
              if (!body) {
                var collisionGroup = tile.getCollisionGroup();
                var collisionObjects = GetFastValue(collisionGroup, "objects", []);
                if (collisionObjects.length > 0) {
                  this.setFromTileCollision(options);
                } else {
                  this.setFromTileRectangle(options);
                }
              } else {
                this.setBody(body, addToWorld);
              }
            },
            setFromTileRectangle: function(options) {
              if (options === void 0) {
                options = {};
              }
              if (!HasValue(options, "isStatic")) {
                options.isStatic = true;
              }
              if (!HasValue(options, "addToWorld")) {
                options.addToWorld = true;
              }
              var bounds = this.tile.getBounds();
              var cx = bounds.x + bounds.width / 2;
              var cy = bounds.y + bounds.height / 2;
              var body = Bodies.rectangle(cx, cy, bounds.width, bounds.height, options);
              this.setBody(body, options.addToWorld);
              return this;
            },
            setFromTileCollision: function(options) {
              if (options === void 0) {
                options = {};
              }
              if (!HasValue(options, "isStatic")) {
                options.isStatic = true;
              }
              if (!HasValue(options, "addToWorld")) {
                options.addToWorld = true;
              }
              var sx = this.tile.tilemapLayer.scaleX;
              var sy = this.tile.tilemapLayer.scaleY;
              var tileX = this.tile.getLeft();
              var tileY = this.tile.getTop();
              var collisionGroup = this.tile.getCollisionGroup();
              var collisionObjects = GetFastValue(collisionGroup, "objects", []);
              var parts = [];
              for (var i = 0; i < collisionObjects.length; i++) {
                var object = collisionObjects[i];
                var ox = tileX + object.x * sx;
                var oy = tileY + object.y * sy;
                var ow = object.width * sx;
                var oh = object.height * sy;
                var body = null;
                if (object.rectangle) {
                  body = Bodies.rectangle(ox + ow / 2, oy + oh / 2, ow, oh, options);
                } else if (object.ellipse) {
                  body = Bodies.circle(ox + ow / 2, oy + oh / 2, ow / 2, options);
                } else if (object.polygon || object.polyline) {
                  var originalPoints = object.polygon ? object.polygon : object.polyline;
                  var points = originalPoints.map(function(p) {
                    return {x: p.x * sx, y: p.y * sy};
                  });
                  var vertices = Vertices.create(points);
                  var center = Vertices.centre(vertices);
                  ox += center.x;
                  oy += center.y;
                  body = Bodies.fromVertices(ox, oy, vertices, options);
                }
                if (body) {
                  parts.push(body);
                }
              }
              if (parts.length === 1) {
                this.setBody(parts[0], options.addToWorld);
              } else if (parts.length > 1) {
                options.parts = parts;
                this.setBody(Body.create(options), options.addToWorld);
              }
              return this;
            },
            setBody: function(body, addToWorld) {
              if (addToWorld === void 0) {
                addToWorld = true;
              }
              if (this.body) {
                this.removeBody();
              }
              this.body = body;
              this.body.gameObject = this;
              if (addToWorld) {
                this.world.add(this.body);
              }
              return this;
            },
            removeBody: function() {
              if (this.body) {
                this.world.remove(this.body);
                this.body.gameObject = void 0;
                this.body = void 0;
              }
              return this;
            },
            destroy: function() {
              this.removeBody();
              this.tile.physics.matterBody = void 0;
              this.removeAllListeners();
            }
          });
          module2.exports = MatterTileBody;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Matter = __webpack_require__(1493);
          Matter.Body = __webpack_require__(71);
          Matter.Composite = __webpack_require__(163);
          Matter.World = __webpack_require__(1393);
          Matter.Detector = __webpack_require__(587);
          Matter.Grid = __webpack_require__(1394);
          Matter.Pairs = __webpack_require__(1395);
          Matter.Pair = __webpack_require__(535);
          Matter.Query = __webpack_require__(1494);
          Matter.Resolver = __webpack_require__(1396);
          Matter.SAT = __webpack_require__(588);
          Matter.Constraint = __webpack_require__(246);
          Matter.Common = __webpack_require__(50);
          Matter.Engine = __webpack_require__(1495);
          Matter.Events = __webpack_require__(268);
          Matter.Sleeping = __webpack_require__(267);
          Matter.Plugin = __webpack_require__(1392);
          Matter.Bodies = __webpack_require__(126);
          Matter.Composites = __webpack_require__(1388);
          Matter.Axes = __webpack_require__(585);
          Matter.Bounds = __webpack_require__(117);
          Matter.Svg = __webpack_require__(1389);
          Matter.Vector = __webpack_require__(116);
          Matter.Vertices = __webpack_require__(94);
          Matter.World.add = Matter.Composite.add;
          Matter.World.remove = Matter.Composite.remove;
          Matter.World.addComposite = Matter.Composite.addComposite;
          Matter.World.addBody = Matter.Composite.addBody;
          Matter.World.addConstraint = Matter.Composite.addConstraint;
          Matter.World.clear = Matter.Composite.clear;
          module2.exports = Matter;
        },
        function(module2, exports2, __webpack_require__) {
          var Plugin = {};
          module2.exports = Plugin;
          var Common = __webpack_require__(50);
          (function() {
            Plugin._registry = {};
            Plugin.register = function(plugin) {
              if (!Plugin.isPlugin(plugin)) {
                Common.warn("Plugin.register:", Plugin.toString(plugin), "does not implement all required fields.");
              }
              if (plugin.name in Plugin._registry) {
                var registered = Plugin._registry[plugin.name], pluginVersion = Plugin.versionParse(plugin.version).number, registeredVersion = Plugin.versionParse(registered.version).number;
                if (pluginVersion > registeredVersion) {
                  Common.warn("Plugin.register:", Plugin.toString(registered), "was upgraded to", Plugin.toString(plugin));
                  Plugin._registry[plugin.name] = plugin;
                } else if (pluginVersion < registeredVersion) {
                  Common.warn("Plugin.register:", Plugin.toString(registered), "can not be downgraded to", Plugin.toString(plugin));
                } else if (plugin !== registered) {
                  Common.warn("Plugin.register:", Plugin.toString(plugin), "is already registered to different plugin object");
                }
              } else {
                Plugin._registry[plugin.name] = plugin;
              }
              return plugin;
            };
            Plugin.resolve = function(dependency) {
              return Plugin._registry[Plugin.dependencyParse(dependency).name];
            };
            Plugin.toString = function(plugin) {
              return typeof plugin === "string" ? plugin : (plugin.name || "anonymous") + "@" + (plugin.version || plugin.range || "0.0.0");
            };
            Plugin.isPlugin = function(obj) {
              return obj && obj.name && obj.version && obj.install;
            };
            Plugin.isUsed = function(module3, name) {
              return module3.used.indexOf(name) > -1;
            };
            Plugin.isFor = function(plugin, module3) {
              var parsed = plugin.for && Plugin.dependencyParse(plugin.for);
              return !plugin.for || module3.name === parsed.name && Plugin.versionSatisfies(module3.version, parsed.range);
            };
            Plugin.use = function(module3, plugins) {
              module3.uses = (module3.uses || []).concat(plugins || []);
              if (module3.uses.length === 0) {
                Common.warn("Plugin.use:", Plugin.toString(module3), "does not specify any dependencies to install.");
                return;
              }
              var dependencies = Plugin.dependencies(module3), sortedDependencies = Common.topologicalSort(dependencies), status = [];
              for (var i = 0; i < sortedDependencies.length; i += 1) {
                if (sortedDependencies[i] === module3.name) {
                  continue;
                }
                var plugin = Plugin.resolve(sortedDependencies[i]);
                if (!plugin) {
                  status.push("\u274C " + sortedDependencies[i]);
                  continue;
                }
                if (Plugin.isUsed(module3, plugin.name)) {
                  continue;
                }
                if (!Plugin.isFor(plugin, module3)) {
                  Common.warn("Plugin.use:", Plugin.toString(plugin), "is for", plugin.for, "but installed on", Plugin.toString(module3) + ".");
                  plugin._warned = true;
                }
                if (plugin.install) {
                  plugin.install(module3);
                } else {
                  Common.warn("Plugin.use:", Plugin.toString(plugin), "does not specify an install function.");
                  plugin._warned = true;
                }
                if (plugin._warned) {
                  status.push("\u{1F536} " + Plugin.toString(plugin));
                  delete plugin._warned;
                } else {
                  status.push("\u2705 " + Plugin.toString(plugin));
                }
                module3.used.push(plugin.name);
              }
              if (status.length > 0 && !plugin.silent) {
                Common.info(status.join("  "));
              }
            };
            Plugin.dependencies = function(module3, tracked) {
              var parsedBase = Plugin.dependencyParse(module3), name = parsedBase.name;
              tracked = tracked || {};
              if (name in tracked) {
                return;
              }
              module3 = Plugin.resolve(module3) || module3;
              tracked[name] = Common.map(module3.uses || [], function(dependency) {
                if (Plugin.isPlugin(dependency)) {
                  Plugin.register(dependency);
                }
                var parsed = Plugin.dependencyParse(dependency), resolved = Plugin.resolve(dependency);
                if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {
                  Common.warn("Plugin.dependencies:", Plugin.toString(resolved), "does not satisfy", Plugin.toString(parsed), "used by", Plugin.toString(parsedBase) + ".");
                  resolved._warned = true;
                  module3._warned = true;
                } else if (!resolved) {
                  Common.warn("Plugin.dependencies:", Plugin.toString(dependency), "used by", Plugin.toString(parsedBase), "could not be resolved.");
                  module3._warned = true;
                }
                return parsed.name;
              });
              for (var i = 0; i < tracked[name].length; i += 1) {
                Plugin.dependencies(tracked[name][i], tracked);
              }
              return tracked;
            };
            Plugin.dependencyParse = function(dependency) {
              if (Common.isString(dependency)) {
                var pattern = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/;
                if (!pattern.test(dependency)) {
                  Common.warn("Plugin.dependencyParse:", dependency, "is not a valid dependency string.");
                }
                return {
                  name: dependency.split("@")[0],
                  range: dependency.split("@")[1] || "*"
                };
              }
              return {
                name: dependency.name,
                range: dependency.range || dependency.version
              };
            };
            Plugin.versionParse = function(range) {
              var pattern = /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/;
              if (!pattern.test(range)) {
                Common.warn("Plugin.versionParse:", range, "is not a valid version or range.");
              }
              var identifiers = range.split("-");
              range = identifiers[0];
              var isRange = isNaN(Number(range[0])), version = isRange ? range.substr(1) : range, parts = Common.map(version.split("."), function(part) {
                return Number(part);
              });
              return {
                isRange,
                version,
                range,
                operator: isRange ? range[0] : "",
                parts,
                prerelease: identifiers[1],
                number: parts[0] * 1e8 + parts[1] * 1e4 + parts[2]
              };
            };
            Plugin.versionSatisfies = function(version, range) {
              range = range || "*";
              var rangeParsed = Plugin.versionParse(range), rangeParts = rangeParsed.parts, versionParsed = Plugin.versionParse(version), versionParts = versionParsed.parts;
              if (rangeParsed.isRange) {
                if (rangeParsed.operator === "*" || version === "*") {
                  return true;
                }
                if (rangeParsed.operator === "~") {
                  return versionParts[0] === rangeParts[0] && versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
                }
                if (rangeParsed.operator === "^") {
                  if (rangeParts[0] > 0) {
                    return versionParts[0] === rangeParts[0] && versionParsed.number >= rangeParsed.number;
                  }
                  if (rangeParts[1] > 0) {
                    return versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
                  }
                  return versionParts[2] === rangeParts[2];
                }
              }
              return version === range || version === "*";
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var World = {};
          module2.exports = World;
          var Composite = __webpack_require__(163);
          var Constraint = __webpack_require__(246);
          var Common = __webpack_require__(50);
          (function() {
            World.create = function(options) {
              var composite = Composite.create();
              var defaults = {
                label: "World",
                gravity: {
                  x: 0,
                  y: 1,
                  scale: 1e-3
                },
                bounds: {
                  min: {x: -Infinity, y: -Infinity},
                  max: {x: Infinity, y: Infinity}
                }
              };
              return Common.extend(composite, defaults, options);
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Grid = {};
          module2.exports = Grid;
          var Pair = __webpack_require__(535);
          var Detector = __webpack_require__(587);
          var Common = __webpack_require__(50);
          (function() {
            Grid.create = function(options) {
              var defaults = {
                controller: Grid,
                detector: Detector.collisions,
                buckets: {},
                pairs: {},
                pairsList: [],
                bucketWidth: 48,
                bucketHeight: 48
              };
              return Common.extend(defaults, options);
            };
            Grid.update = function(grid, bodies, engine, forceUpdate) {
              var i, col, row, world = engine.world, buckets = grid.buckets, bucket, bucketId, gridChanged = false;
              var metrics = engine.metrics;
              metrics.broadphaseTests = 0;
              for (i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (body.isSleeping && !forceUpdate)
                  continue;
                if (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y)
                  continue;
                var newRegion = Grid._getRegion(grid, body);
                if (!body.region || newRegion.id !== body.region.id || forceUpdate) {
                  metrics.broadphaseTests += 1;
                  if (!body.region || forceUpdate)
                    body.region = newRegion;
                  var union = Grid._regionUnion(newRegion, body.region);
                  for (col = union.startCol; col <= union.endCol; col++) {
                    for (row = union.startRow; row <= union.endRow; row++) {
                      bucketId = Grid._getBucketId(col, row);
                      bucket = buckets[bucketId];
                      var isInsideNewRegion = col >= newRegion.startCol && col <= newRegion.endCol && row >= newRegion.startRow && row <= newRegion.endRow;
                      var isInsideOldRegion = col >= body.region.startCol && col <= body.region.endCol && row >= body.region.startRow && row <= body.region.endRow;
                      if (!isInsideNewRegion && isInsideOldRegion) {
                        if (isInsideOldRegion) {
                          if (bucket)
                            Grid._bucketRemoveBody(grid, bucket, body);
                        }
                      }
                      if (body.region === newRegion || isInsideNewRegion && !isInsideOldRegion || forceUpdate) {
                        if (!bucket)
                          bucket = Grid._createBucket(buckets, bucketId);
                        Grid._bucketAddBody(grid, bucket, body);
                      }
                    }
                  }
                  body.region = newRegion;
                  gridChanged = true;
                }
              }
              if (gridChanged)
                grid.pairsList = Grid._createActivePairsList(grid);
            };
            Grid.clear = function(grid) {
              grid.buckets = {};
              grid.pairs = {};
              grid.pairsList = [];
            };
            Grid._regionUnion = function(regionA, regionB) {
              var startCol = Math.min(regionA.startCol, regionB.startCol), endCol = Math.max(regionA.endCol, regionB.endCol), startRow = Math.min(regionA.startRow, regionB.startRow), endRow = Math.max(regionA.endRow, regionB.endRow);
              return Grid._createRegion(startCol, endCol, startRow, endRow);
            };
            Grid._getRegion = function(grid, body) {
              var bounds = body.bounds, startCol = Math.floor(bounds.min.x / grid.bucketWidth), endCol = Math.floor(bounds.max.x / grid.bucketWidth), startRow = Math.floor(bounds.min.y / grid.bucketHeight), endRow = Math.floor(bounds.max.y / grid.bucketHeight);
              return Grid._createRegion(startCol, endCol, startRow, endRow);
            };
            Grid._createRegion = function(startCol, endCol, startRow, endRow) {
              return {
                id: startCol + "," + endCol + "," + startRow + "," + endRow,
                startCol,
                endCol,
                startRow,
                endRow
              };
            };
            Grid._getBucketId = function(column, row) {
              return "C" + column + "R" + row;
            };
            Grid._createBucket = function(buckets, bucketId) {
              var bucket = buckets[bucketId] = [];
              return bucket;
            };
            Grid._bucketAddBody = function(grid, bucket, body) {
              for (var i = 0; i < bucket.length; i++) {
                var bodyB = bucket[i];
                if (body.id === bodyB.id || body.isStatic && bodyB.isStatic)
                  continue;
                var pairId = Pair.id(body, bodyB), pair = grid.pairs[pairId];
                if (pair) {
                  pair[2] += 1;
                } else {
                  grid.pairs[pairId] = [body, bodyB, 1];
                }
              }
              bucket.push(body);
            };
            Grid._bucketRemoveBody = function(grid, bucket, body) {
              bucket.splice(bucket.indexOf(body), 1);
              for (var i = 0; i < bucket.length; i++) {
                var bodyB = bucket[i], pairId = Pair.id(body, bodyB), pair = grid.pairs[pairId];
                if (pair)
                  pair[2] -= 1;
              }
            };
            Grid._createActivePairsList = function(grid) {
              var pairKeys, pair, pairs = [];
              pairKeys = Common.keys(grid.pairs);
              for (var k = 0; k < pairKeys.length; k++) {
                pair = grid.pairs[pairKeys[k]];
                if (pair[2] > 0) {
                  pairs.push(pair);
                } else {
                  delete grid.pairs[pairKeys[k]];
                }
              }
              return pairs;
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Pairs = {};
          module2.exports = Pairs;
          var Pair = __webpack_require__(535);
          var Common = __webpack_require__(50);
          (function() {
            Pairs._pairMaxIdleLife = 1e3;
            Pairs.create = function(options) {
              return Common.extend({
                table: {},
                list: [],
                collisionStart: [],
                collisionActive: [],
                collisionEnd: []
              }, options);
            };
            Pairs.update = function(pairs, collisions, timestamp) {
              var pairsList = pairs.list, pairsTable = pairs.table, collisionStart = pairs.collisionStart, collisionEnd = pairs.collisionEnd, collisionActive = pairs.collisionActive, collision, pairId, pair, i;
              collisionStart.length = 0;
              collisionEnd.length = 0;
              collisionActive.length = 0;
              for (i = 0; i < pairsList.length; i++) {
                pairsList[i].confirmedActive = false;
              }
              for (i = 0; i < collisions.length; i++) {
                collision = collisions[i];
                if (collision.collided) {
                  pairId = Pair.id(collision.bodyA, collision.bodyB);
                  pair = pairsTable[pairId];
                  if (pair) {
                    if (pair.isActive) {
                      collisionActive.push(pair);
                    } else {
                      collisionStart.push(pair);
                    }
                    Pair.update(pair, collision, timestamp);
                    pair.confirmedActive = true;
                  } else {
                    pair = Pair.create(collision, timestamp);
                    pairsTable[pairId] = pair;
                    collisionStart.push(pair);
                    pairsList.push(pair);
                  }
                }
              }
              for (i = 0; i < pairsList.length; i++) {
                pair = pairsList[i];
                if (pair.isActive && !pair.confirmedActive) {
                  Pair.setActive(pair, false, timestamp);
                  collisionEnd.push(pair);
                }
              }
            };
            Pairs.removeOld = function(pairs, timestamp) {
              var pairsList = pairs.list, pairsTable = pairs.table, indexesToRemove = [], pair, collision, pairIndex, i;
              for (i = 0; i < pairsList.length; i++) {
                pair = pairsList[i];
                collision = pair.collision;
                if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {
                  pair.timeUpdated = timestamp;
                  continue;
                }
                if (timestamp - pair.timeUpdated > Pairs._pairMaxIdleLife) {
                  indexesToRemove.push(i);
                }
              }
              for (i = 0; i < indexesToRemove.length; i++) {
                pairIndex = indexesToRemove[i] - i;
                pair = pairsList[pairIndex];
                delete pairsTable[pair.id];
                pairsList.splice(pairIndex, 1);
              }
            };
            Pairs.clear = function(pairs) {
              pairs.table = {};
              pairs.list.length = 0;
              pairs.collisionStart.length = 0;
              pairs.collisionActive.length = 0;
              pairs.collisionEnd.length = 0;
              return pairs;
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Resolver = {};
          module2.exports = Resolver;
          var Vertices = __webpack_require__(94);
          var Vector = __webpack_require__(116);
          var Common = __webpack_require__(50);
          var Bounds = __webpack_require__(117);
          (function() {
            Resolver._restingThresh = 4;
            Resolver._restingThreshTangent = 6;
            Resolver._positionDampen = 0.9;
            Resolver._positionWarming = 0.8;
            Resolver._frictionNormalMultiplier = 5;
            Resolver.preSolvePosition = function(pairs) {
              var i, pair, activeCount;
              for (i = 0; i < pairs.length; i++) {
                pair = pairs[i];
                if (!pair.isActive)
                  continue;
                activeCount = pair.activeContacts.length;
                pair.collision.parentA.totalContacts += activeCount;
                pair.collision.parentB.totalContacts += activeCount;
              }
            };
            Resolver.solvePosition = function(pairs, bodies, timeScale) {
              var i, normalX, normalY, pair, collision, bodyA, bodyB, normal, separation, penetration, positionImpulseA, positionImpulseB, contactShare, bodyBtoAX, bodyBtoAY, positionImpulse, impulseCoefficient = timeScale * Resolver._positionDampen;
              for (i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                body.previousPositionImpulse.x = body.positionImpulse.x;
                body.previousPositionImpulse.y = body.positionImpulse.y;
              }
              for (i = 0; i < pairs.length; i++) {
                pair = pairs[i];
                if (!pair.isActive || pair.isSensor)
                  continue;
                collision = pair.collision;
                bodyA = collision.parentA;
                bodyB = collision.parentB;
                normal = collision.normal;
                positionImpulseA = bodyA.previousPositionImpulse;
                positionImpulseB = bodyB.previousPositionImpulse;
                penetration = collision.penetration;
                bodyBtoAX = positionImpulseB.x - positionImpulseA.x + penetration.x;
                bodyBtoAY = positionImpulseB.y - positionImpulseA.y + penetration.y;
                normalX = normal.x;
                normalY = normal.y;
                separation = normalX * bodyBtoAX + normalY * bodyBtoAY;
                pair.separation = separation;
                positionImpulse = (separation - pair.slop) * impulseCoefficient;
                if (bodyA.isStatic || bodyB.isStatic)
                  positionImpulse *= 2;
                if (!(bodyA.isStatic || bodyA.isSleeping)) {
                  contactShare = positionImpulse / bodyA.totalContacts;
                  bodyA.positionImpulse.x += normalX * contactShare;
                  bodyA.positionImpulse.y += normalY * contactShare;
                }
                if (!(bodyB.isStatic || bodyB.isSleeping)) {
                  contactShare = positionImpulse / bodyB.totalContacts;
                  bodyB.positionImpulse.x -= normalX * contactShare;
                  bodyB.positionImpulse.y -= normalY * contactShare;
                }
              }
            };
            Resolver.postSolvePosition = function(bodies) {
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                body.totalContacts = 0;
                if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {
                  for (var j = 0; j < body.parts.length; j++) {
                    var part = body.parts[j];
                    Vertices.translate(part.vertices, body.positionImpulse);
                    Bounds.update(part.bounds, part.vertices, body.velocity);
                    part.position.x += body.positionImpulse.x;
                    part.position.y += body.positionImpulse.y;
                  }
                  body.positionPrev.x += body.positionImpulse.x;
                  body.positionPrev.y += body.positionImpulse.y;
                  if (Vector.dot(body.positionImpulse, body.velocity) < 0) {
                    body.positionImpulse.x = 0;
                    body.positionImpulse.y = 0;
                  } else {
                    body.positionImpulse.x *= Resolver._positionWarming;
                    body.positionImpulse.y *= Resolver._positionWarming;
                  }
                }
              }
            };
            Resolver.preSolveVelocity = function(pairs) {
              var i, j, pair, contacts, collision, bodyA, bodyB, normal, tangent, contact, contactVertex, normalImpulse, tangentImpulse, offset, impulse = Vector._temp[0], tempA = Vector._temp[1];
              for (i = 0; i < pairs.length; i++) {
                pair = pairs[i];
                if (!pair.isActive || pair.isSensor)
                  continue;
                contacts = pair.activeContacts;
                collision = pair.collision;
                bodyA = collision.parentA;
                bodyB = collision.parentB;
                normal = collision.normal;
                tangent = collision.tangent;
                for (j = 0; j < contacts.length; j++) {
                  contact = contacts[j];
                  contactVertex = contact.vertex;
                  normalImpulse = contact.normalImpulse;
                  tangentImpulse = contact.tangentImpulse;
                  if (normalImpulse !== 0 || tangentImpulse !== 0) {
                    impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;
                    impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse;
                    if (!(bodyA.isStatic || bodyA.isSleeping)) {
                      offset = Vector.sub(contactVertex, bodyA.position, tempA);
                      bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                      bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                      bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;
                    }
                    if (!(bodyB.isStatic || bodyB.isSleeping)) {
                      offset = Vector.sub(contactVertex, bodyB.position, tempA);
                      bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                      bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                      bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;
                    }
                  }
                }
              }
            };
            Resolver.solveVelocity = function(pairs, timeScale) {
              var timeScaleSquared = timeScale * timeScale, impulse = Vector._temp[0], tempA = Vector._temp[1], tempB = Vector._temp[2], tempC = Vector._temp[3], tempD = Vector._temp[4], tempE = Vector._temp[5];
              for (var i = 0; i < pairs.length; i++) {
                var pair = pairs[i];
                if (!pair.isActive || pair.isSensor)
                  continue;
                var collision = pair.collision, bodyA = collision.parentA, bodyB = collision.parentB, normal = collision.normal, tangent = collision.tangent, contacts = pair.activeContacts, contactShare = 1 / contacts.length;
                bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;
                bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;
                bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;
                bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;
                bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;
                bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;
                for (var j = 0; j < contacts.length; j++) {
                  var contact = contacts[j], contactVertex = contact.vertex, offsetA = Vector.sub(contactVertex, bodyA.position, tempA), offsetB = Vector.sub(contactVertex, bodyB.position, tempB), velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC), velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD), relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE), normalVelocity = Vector.dot(normal, relativeVelocity);
                  var tangentVelocity = Vector.dot(tangent, relativeVelocity), tangentSpeed = Math.abs(tangentVelocity), tangentVelocityDirection = Common.sign(tangentVelocity);
                  var normalImpulse = (1 + pair.restitution) * normalVelocity, normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;
                  var tangentImpulse = tangentVelocity, maxFriction = Infinity;
                  if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {
                    maxFriction = tangentSpeed;
                    tangentImpulse = Common.clamp(pair.friction * tangentVelocityDirection * timeScaleSquared, -maxFriction, maxFriction);
                  }
                  var oAcN = Vector.cross(offsetA, normal), oBcN = Vector.cross(offsetB, normal), share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);
                  normalImpulse *= share;
                  tangentImpulse *= share;
                  if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {
                    contact.normalImpulse = 0;
                  } else {
                    var contactNormalImpulse = contact.normalImpulse;
                    contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);
                    normalImpulse = contact.normalImpulse - contactNormalImpulse;
                  }
                  if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {
                    contact.tangentImpulse = 0;
                  } else {
                    var contactTangentImpulse = contact.tangentImpulse;
                    contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);
                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;
                  }
                  impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;
                  impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse;
                  if (!(bodyA.isStatic || bodyA.isSleeping)) {
                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                    bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;
                  }
                  if (!(bodyB.isStatic || bodyB.isSleeping)) {
                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                    bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;
                  }
                }
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            BasePlugin: __webpack_require__(536),
            DefaultPlugins: __webpack_require__(194),
            PluginCache: __webpack_require__(24),
            PluginManager: __webpack_require__(408),
            ScenePlugin: __webpack_require__(1398)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
          * @author       Richard Davey <rich@photonstorm.com>
          * @copyright    2020 Photon Storm Ltd.
          * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}
          */
          var BasePlugin = __webpack_require__(536);
          var Class = __webpack_require__(0);
          var SceneEvents = __webpack_require__(21);
          var ScenePlugin = new Class({
            Extends: BasePlugin,
            initialize: function ScenePlugin2(scene, pluginManager) {
              BasePlugin.call(this, pluginManager);
              this.scene = scene;
              this.systems = scene.sys;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
            },
            boot: function() {
            },
            destroy: function() {
              this.pluginManager = null;
              this.game = null;
              this.scene = null;
              this.systems = null;
            }
          });
          module2.exports = ScenePlugin;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Canvas: __webpack_require__(1400),
            Events: __webpack_require__(88),
            Snapshot: __webpack_require__(1401),
            WebGL: __webpack_require__(1402)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            CanvasRenderer: __webpack_require__(362),
            GetBlendModes: __webpack_require__(364),
            SetTransform: __webpack_require__(30)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Canvas: __webpack_require__(363),
            WebGL: __webpack_require__(377)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var WEBGL_CONST = __webpack_require__(104);
          var Extend = __webpack_require__(17);
          var WebGL = {
            PipelineManager: __webpack_require__(366),
            Pipelines: __webpack_require__(1403),
            RenderTarget: __webpack_require__(139),
            Utils: __webpack_require__(12),
            WebGLPipeline: __webpack_require__(57),
            WebGLRenderer: __webpack_require__(365),
            WebGLShader: __webpack_require__(369)
          };
          WebGL = Extend(false, WebGL, WEBGL_CONST);
          module2.exports = WebGL;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(65);
          var Extend = __webpack_require__(17);
          var Pipelines = {
            BitmapMaskPipeline: __webpack_require__(367),
            Events: __webpack_require__(368),
            GraphicsPipeline: __webpack_require__(370),
            LightPipeline: __webpack_require__(371),
            MultiPipeline: __webpack_require__(105),
            PointLightPipeline: __webpack_require__(372),
            PostFXPipeline: __webpack_require__(1404),
            RopePipeline: __webpack_require__(373),
            SinglePipeline: __webpack_require__(374),
            UtilityPipeline: __webpack_require__(375)
          };
          Pipelines = Extend(false, Pipelines, CONST);
          module2.exports = Pipelines;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var ColorMatrix = __webpack_require__(195);
          var GetFastValue = __webpack_require__(2);
          var ShaderSourceFS = __webpack_require__(1405);
          var ShaderSourceVS = __webpack_require__(376);
          var WebGLPipeline = __webpack_require__(57);
          var PostFXPipeline = new Class({
            Extends: WebGLPipeline,
            initialize: function PostFXPipeline2(config2) {
              config2.renderTarget = GetFastValue(config2, "renderTarget", 1);
              config2.fragShader = GetFastValue(config2, "fragShader", ShaderSourceFS);
              config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS);
              config2.attributes = GetFastValue(config2, "attributes", [
                {
                  name: "inPosition",
                  size: 2
                },
                {
                  name: "inTexCoord",
                  size: 2
                }
              ]);
              config2.batchSize = 1;
              config2.vertices = [
                -1,
                -1,
                0,
                0,
                -1,
                1,
                0,
                1,
                1,
                1,
                1,
                1,
                -1,
                -1,
                0,
                0,
                1,
                1,
                1,
                1,
                1,
                -1,
                1,
                0
              ];
              WebGLPipeline.call(this, config2);
              this.isPostFX = true;
              this.gameObject;
              this.colorMatrix = new ColorMatrix();
              this.fullFrame1;
              this.fullFrame2;
              this.halfFrame1;
              this.halfFrame2;
              if (this.renderer.isBooted) {
                this.manager = this.renderer.pipelines;
                this.boot();
              }
            },
            boot: function() {
              WebGLPipeline.prototype.boot.call(this);
              var utility = this.manager.UTILITY_PIPELINE;
              this.fullFrame1 = utility.fullFrame1;
              this.fullFrame2 = utility.fullFrame2;
              this.halfFrame1 = utility.halfFrame1;
              this.halfFrame2 = utility.halfFrame2;
              this.set1i("uMainSampler", 0);
            },
            onDraw: function(renderTarget) {
              this.bindAndDraw(renderTarget);
            },
            copyFrame: function(source, target, brightness, clear, clearAlpha) {
              this.manager.copyFrame(source, target, brightness, clear, clearAlpha);
            },
            copyToGame: function(source) {
              this.manager.copyToGame(source);
            },
            drawFrame: function(source, target, clearAlpha) {
              this.manager.drawFrame(source, target, clearAlpha, this.colorMatrix);
            },
            blendFrames: function(source1, source2, target, strength, clearAlpha) {
              this.manager.blendFrames(source1, source2, target, strength, clearAlpha);
            },
            blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
              this.manager.blendFramesAdditive(source1, source2, target, strength, clearAlpha);
            },
            clearFrame: function(target, clearAlpha) {
              this.manager.clearFrame(target, clearAlpha);
            },
            blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode) {
              this.manager.blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);
            },
            copyFrameRect: function(source, target, x, y, width, height, clear, clearAlpha) {
              this.manager.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);
            },
            bindAndDraw: function(source, target, clear, clearAlpha, currentShader) {
              if (clear === void 0) {
                clear = true;
              }
              if (clearAlpha === void 0) {
                clearAlpha = true;
              }
              var gl = this.gl;
              var renderer = this.renderer;
              this.bind(currentShader);
              this.set1i("uMainSampler", 0);
              if (target) {
                gl.viewport(0, 0, target.width, target.height);
                gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
                if (clear) {
                  if (clearAlpha) {
                    gl.clearColor(0, 0, 0, 0);
                  } else {
                    gl.clearColor(0, 0, 0, 1);
                  }
                  gl.clear(gl.COLOR_BUFFER_BIT);
                }
              } else {
                renderer.popFramebuffer(false, false, false);
                if (!renderer.currentFramebuffer) {
                  gl.viewport(0, 0, renderer.width, renderer.height);
                }
              }
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, source.texture);
              gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              if (!target) {
                renderer.resetTextures();
              } else {
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              }
            }
          });
          module2.exports = PostFXPipeline;
        },
        function(module2, exports2) {
          module2.exports = [
            "#define SHADER_NAME PHASER_POSTFX_FS",
            "",
            "precision mediump float;",
            "",
            "uniform sampler2D uMainSampler;",
            "",
            "varying vec2 outTexCoord;",
            "",
            "void main ()",
            "{",
            "    gl_FragColor = texture2D(uMainSampler, outTexCoord);",
            "}",
            ""
          ].join("\n");
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Extend = __webpack_require__(17);
          var CONST = __webpack_require__(198);
          var Scale = {
            Center: __webpack_require__(397),
            Events: __webpack_require__(101),
            Orientation: __webpack_require__(398),
            ScaleManager: __webpack_require__(409),
            ScaleModes: __webpack_require__(399),
            Zoom: __webpack_require__(400)
          };
          Scale = Extend(false, Scale, CONST.CENTER);
          Scale = Extend(false, Scale, CONST.ORIENTATION);
          Scale = Extend(false, Scale, CONST.SCALE_MODE);
          Scale = Extend(false, Scale, CONST.ZOOM);
          module2.exports = Scale;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(142);
          var Extend = __webpack_require__(17);
          var Scene = {
            Events: __webpack_require__(21),
            GetPhysicsPlugins: __webpack_require__(413),
            GetScenePlugins: __webpack_require__(414),
            SceneManager: __webpack_require__(411),
            ScenePlugin: __webpack_require__(1408),
            Settings: __webpack_require__(415),
            Systems: __webpack_require__(201)
          };
          Scene = Extend(false, Scene, CONST);
          module2.exports = Scene;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(21);
          var GetFastValue = __webpack_require__(2);
          var PluginCache = __webpack_require__(24);
          var ScenePlugin = new Class({
            initialize: function ScenePlugin2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.settings = scene.sys.settings;
              this.key = scene.sys.settings.key;
              this.manager = scene.sys.game.scene;
              this.transitionProgress = 0;
              this._elapsed = 0;
              this._target = null;
              this._duration = 0;
              this._onUpdate;
              this._onUpdateScope;
              this._willSleep = false;
              this._willRemove = false;
              scene.sys.events.once(Events.BOOT, this.boot, this);
              scene.sys.events.on(Events.START, this.pluginStart, this);
            },
            boot: function() {
              this.systems.events.once(Events.DESTROY, this.destroy, this);
            },
            pluginStart: function() {
              this._target = null;
              this.systems.events.once(Events.SHUTDOWN, this.shutdown, this);
            },
            start: function(key, data) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.queueOp("stop", this.key);
              this.manager.queueOp("start", key, data);
              return this;
            },
            restart: function(data) {
              var key = this.key;
              this.manager.queueOp("stop", key);
              this.manager.queueOp("start", key, data);
              return this;
            },
            transition: function(config2) {
              if (config2 === void 0) {
                config2 = {};
              }
              var key = GetFastValue(config2, "target", false);
              var target = this.manager.getScene(key);
              if (!key || !this.checkValidTransition(target)) {
                return false;
              }
              var duration = GetFastValue(config2, "duration", 1e3);
              this._elapsed = 0;
              this._target = target;
              this._duration = duration;
              this._willSleep = GetFastValue(config2, "sleep", false);
              this._willRemove = GetFastValue(config2, "remove", false);
              var callback = GetFastValue(config2, "onUpdate", null);
              if (callback) {
                this._onUpdate = callback;
                this._onUpdateScope = GetFastValue(config2, "onUpdateScope", this.scene);
              }
              var allowInput = GetFastValue(config2, "allowInput", false);
              this.settings.transitionAllowInput = allowInput;
              var targetSettings = target.sys.settings;
              targetSettings.isTransition = true;
              targetSettings.transitionFrom = this.scene;
              targetSettings.transitionDuration = duration;
              targetSettings.transitionAllowInput = allowInput;
              if (GetFastValue(config2, "moveAbove", false)) {
                this.manager.moveAbove(this.key, key);
              } else if (GetFastValue(config2, "moveBelow", false)) {
                this.manager.moveBelow(this.key, key);
              }
              if (target.sys.isSleeping()) {
                target.sys.wake(GetFastValue(config2, "data"));
              } else {
                this.manager.start(key, GetFastValue(config2, "data"));
              }
              this.systems.events.emit(Events.TRANSITION_OUT, target, duration);
              this.systems.events.on(Events.UPDATE, this.step, this);
              return true;
            },
            checkValidTransition: function(target) {
              if (!target || target.sys.isActive() || target.sys.isTransitioning() || target === this.scene || this.systems.isTransitioning()) {
                return false;
              }
              return true;
            },
            step: function(time, delta) {
              this._elapsed += delta;
              this.transitionProgress = Clamp(this._elapsed / this._duration, 0, 1);
              if (this._onUpdate) {
                this._onUpdate.call(this._onUpdateScope, this.transitionProgress);
              }
              if (this._elapsed >= this._duration) {
                this.transitionComplete();
              }
            },
            transitionComplete: function() {
              var targetSys = this._target.sys;
              var targetSettings = this._target.sys.settings;
              this.systems.events.off(Events.UPDATE, this.step, this);
              targetSys.events.emit(Events.TRANSITION_COMPLETE, this.scene);
              targetSettings.isTransition = false;
              targetSettings.transitionFrom = null;
              this._duration = 0;
              this._target = null;
              this._onUpdate = null;
              this._onUpdateScope = null;
              if (this._willRemove) {
                this.manager.remove(this.key);
              } else if (this._willSleep) {
                this.systems.sleep();
              } else {
                this.manager.stop(this.key);
              }
            },
            add: function(key, sceneConfig, autoStart, data) {
              return this.manager.add(key, sceneConfig, autoStart, data);
            },
            launch: function(key, data) {
              if (key && key !== this.key) {
                this.manager.queueOp("start", key, data);
              }
              return this;
            },
            run: function(key, data) {
              if (key && key !== this.key) {
                this.manager.queueOp("run", key, data);
              }
              return this;
            },
            pause: function(key, data) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.queueOp("pause", key, data);
              return this;
            },
            resume: function(key, data) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.queueOp("resume", key, data);
              return this;
            },
            sleep: function(key, data) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.queueOp("sleep", key, data);
              return this;
            },
            wake: function(key, data) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.queueOp("wake", key, data);
              return this;
            },
            switch: function(key) {
              if (key !== this.key) {
                this.manager.queueOp("switch", this.key, key);
              }
              return this;
            },
            stop: function(key, data) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.queueOp("stop", key, data);
              return this;
            },
            setActive: function(value, key, data) {
              if (key === void 0) {
                key = this.key;
              }
              var scene = this.manager.getScene(key);
              if (scene) {
                scene.sys.setActive(value, data);
              }
              return this;
            },
            setVisible: function(value, key) {
              if (key === void 0) {
                key = this.key;
              }
              var scene = this.manager.getScene(key);
              if (scene) {
                scene.sys.setVisible(value);
              }
              return this;
            },
            isSleeping: function(key) {
              if (key === void 0) {
                key = this.key;
              }
              return this.manager.isSleeping(key);
            },
            isActive: function(key) {
              if (key === void 0) {
                key = this.key;
              }
              return this.manager.isActive(key);
            },
            isPaused: function(key) {
              if (key === void 0) {
                key = this.key;
              }
              return this.manager.isPaused(key);
            },
            isVisible: function(key) {
              if (key === void 0) {
                key = this.key;
              }
              return this.manager.isVisible(key);
            },
            swapPosition: function(keyA, keyB) {
              if (keyB === void 0) {
                keyB = this.key;
              }
              if (keyA !== keyB) {
                this.manager.swapPosition(keyA, keyB);
              }
              return this;
            },
            moveAbove: function(keyA, keyB) {
              if (keyB === void 0) {
                keyB = this.key;
              }
              if (keyA !== keyB) {
                this.manager.moveAbove(keyA, keyB);
              }
              return this;
            },
            moveBelow: function(keyA, keyB) {
              if (keyB === void 0) {
                keyB = this.key;
              }
              if (keyA !== keyB) {
                this.manager.moveBelow(keyA, keyB);
              }
              return this;
            },
            remove: function(key) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.remove(key);
              return this;
            },
            moveUp: function(key) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.moveUp(key);
              return this;
            },
            moveDown: function(key) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.moveDown(key);
              return this;
            },
            bringToTop: function(key) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.bringToTop(key);
              return this;
            },
            sendToBack: function(key) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.sendToBack(key);
              return this;
            },
            get: function(key) {
              return this.manager.getScene(key);
            },
            getIndex: function(key) {
              if (key === void 0) {
                key = this.key;
              }
              return this.manager.getIndex(key);
            },
            shutdown: function() {
              var eventEmitter = this.systems.events;
              eventEmitter.off(Events.SHUTDOWN, this.shutdown, this);
              eventEmitter.off(Events.POST_UPDATE, this.step, this);
              eventEmitter.off(Events.TRANSITION_OUT);
            },
            destroy: function() {
              this.shutdown();
              this.scene.sys.events.off(Events.START, this.start, this);
              this.scene = null;
              this.systems = null;
              this.settings = null;
              this.manager = null;
            }
          });
          PluginCache.register("ScenePlugin", ScenePlugin, "scenePlugin");
          module2.exports = ScenePlugin;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Events: __webpack_require__(432),
            List: __webpack_require__(107),
            Map: __webpack_require__(99),
            ProcessQueue: __webpack_require__(208),
            RTree: __webpack_require__(525),
            Set: __webpack_require__(148),
            Size: __webpack_require__(410)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Extend = __webpack_require__(17);
          var FilterMode = __webpack_require__(1411);
          var Textures = {
            CanvasTexture: __webpack_require__(417),
            Events: __webpack_require__(103),
            FilterMode,
            Frame: __webpack_require__(106),
            Parsers: __webpack_require__(419),
            Texture: __webpack_require__(203),
            TextureManager: __webpack_require__(416),
            TextureSource: __webpack_require__(418)
          };
          Textures = Extend(false, Textures, FilterMode);
          module2.exports = Textures;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = {
            LINEAR: 0,
            NEAREST: 1
          };
          module2.exports = CONST;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Extend = __webpack_require__(17);
          var CONST = __webpack_require__(1413);
          var Tilemaps = {
            Components: __webpack_require__(247),
            Parsers: __webpack_require__(1446),
            Formats: __webpack_require__(39),
            ImageCollection: __webpack_require__(572),
            ParseToTilemap: __webpack_require__(258),
            Tile: __webpack_require__(83),
            Tilemap: __webpack_require__(576),
            TilemapCreator: __webpack_require__(1452),
            TilemapFactory: __webpack_require__(1453),
            Tileset: __webpack_require__(121),
            TilemapLayer: __webpack_require__(577),
            Orientation: __webpack_require__(29),
            LayerData: __webpack_require__(119),
            MapData: __webpack_require__(120),
            ObjectLayer: __webpack_require__(568)
          };
          Tilemaps = Extend(false, Tilemaps, CONST.ORIENTATION);
          module2.exports = Tilemaps;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = {
            ORIENTATION: __webpack_require__(29)
          };
          module2.exports = CONST;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTilesWithin = __webpack_require__(26);
          var CalculateFacesWithin = __webpack_require__(61);
          var Copy = function(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer) {
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (srcTileX < 0) {
              srcTileX = 0;
            }
            if (srcTileY < 0) {
              srcTileY = 0;
            }
            var srcTiles = GetTilesWithin(srcTileX, srcTileY, width, height, null, layer);
            var offsetX = destTileX - srcTileX;
            var offsetY = destTileY - srcTileY;
            for (var i = 0; i < srcTiles.length; i++) {
              var tileX = srcTiles[i].x + offsetX;
              var tileY = srcTiles[i].y + offsetY;
              if (tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height) {
                if (layer.data[tileY][tileX]) {
                  layer.data[tileY][tileX].copy(srcTiles[i]);
                }
              }
            }
            if (recalculateFaces) {
              CalculateFacesWithin(destTileX - 1, destTileY - 1, width + 2, height + 2, layer);
            }
          };
          module2.exports = Copy;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTilesWithin = __webpack_require__(26);
          var ReplaceByIndex = __webpack_require__(538);
          var CreateFromTiles = function(indexes, replacements, spriteConfig, scene, camera, layer) {
            if (!spriteConfig) {
              spriteConfig = {};
            }
            if (!Array.isArray(indexes)) {
              indexes = [indexes];
            }
            var tilemapLayer = layer.tilemapLayer;
            if (!scene) {
              scene = tilemapLayer.scene;
            }
            if (!camera) {
              camera = scene.cameras.main;
            }
            var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);
            var sprites = [];
            var i;
            for (i = 0; i < tiles.length; i++) {
              var tile = tiles[i];
              if (indexes.indexOf(tile.index) !== -1) {
                var point = tilemapLayer.tileToWorldXY(tile.x, tile.y, void 0, camera, layer);
                spriteConfig.x = point.x;
                spriteConfig.y = point.y;
                sprites.push(scene.make.sprite(spriteConfig));
              }
            }
            if (typeof replacements === "number") {
              for (i = 0; i < indexes.length; i++) {
                ReplaceByIndex(indexes[i], replacements, 0, 0, layer.width, layer.height, layer);
              }
            } else if (Array.isArray(replacements)) {
              for (i = 0; i < indexes.length; i++) {
                ReplaceByIndex(indexes[i], replacements[i], 0, 0, layer.width, layer.height, layer);
              }
            }
            return sprites;
          };
          module2.exports = CreateFromTiles;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTilesWithin = __webpack_require__(26);
          var CalculateFacesWithin = __webpack_require__(61);
          var SetTileCollision = __webpack_require__(72);
          var Fill = function(index, tileX, tileY, width, height, recalculateFaces, layer) {
            var doesIndexCollide = layer.collideIndexes.indexOf(index) !== -1;
            var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
            for (var i = 0; i < tiles.length; i++) {
              tiles[i].index = index;
              SetTileCollision(tiles[i], doesIndexCollide);
            }
            if (recalculateFaces) {
              CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);
            }
          };
          module2.exports = Fill;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTilesWithin = __webpack_require__(26);
          var FilterTiles = function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
            var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
            return tiles.filter(callback, context);
          };
          module2.exports = FilterTiles;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var FindByIndex = function(findIndex, skip, reverse, layer) {
            if (skip === void 0) {
              skip = 0;
            }
            if (reverse === void 0) {
              reverse = false;
            }
            var count = 0;
            var tx;
            var ty;
            var tile;
            if (reverse) {
              for (ty = layer.height - 1; ty >= 0; ty--) {
                for (tx = layer.width - 1; tx >= 0; tx--) {
                  tile = layer.data[ty][tx];
                  if (tile && tile.index === findIndex) {
                    if (count === skip) {
                      return tile;
                    } else {
                      count += 1;
                    }
                  }
                }
              }
            } else {
              for (ty = 0; ty < layer.height; ty++) {
                for (tx = 0; tx < layer.width; tx++) {
                  tile = layer.data[ty][tx];
                  if (tile && tile.index === findIndex) {
                    if (count === skip) {
                      return tile;
                    } else {
                      count += 1;
                    }
                  }
                }
              }
            }
            return null;
          };
          module2.exports = FindByIndex;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTilesWithin = __webpack_require__(26);
          var FindTile = function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
            var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
            return tiles.find(callback, context) || null;
          };
          module2.exports = FindTile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTilesWithin = __webpack_require__(26);
          var ForEachTile = function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
            var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
            tiles.forEach(callback, context);
          };
          module2.exports = ForEachTile;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(29);
          var CullTiles = __webpack_require__(540);
          var HexagonalCullTiles = __webpack_require__(541);
          var IsometricCullTiles = __webpack_require__(543);
          var NOOP = __webpack_require__(1);
          var StaggeredCullTiles = __webpack_require__(544);
          var GetCullTilesFunction = function(orientation) {
            if (orientation === CONST.ORTHOGONAL) {
              return CullTiles;
            } else if (orientation === CONST.HEXAGONAL) {
              return HexagonalCullTiles;
            } else if (orientation === CONST.STAGGERED) {
              return StaggeredCullTiles;
            } else if (orientation === CONST.ISOMETRIC) {
              return IsometricCullTiles;
            } else {
              return NOOP;
            }
          };
          module2.exports = GetCullTilesFunction;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTileAt = __webpack_require__(156);
          var Vector29 = __webpack_require__(3);
          var point = new Vector29();
          var GetTileAtWorldXY = function(worldX, worldY, nonNull, camera, layer) {
            layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);
            return GetTileAt(point.x, point.y, nonNull, layer);
          };
          module2.exports = GetTileAtWorldXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Geom = __webpack_require__(477);
          var GetTilesWithin = __webpack_require__(26);
          var Intersects = __webpack_require__(478);
          var NOOP = __webpack_require__(1);
          var Vector29 = __webpack_require__(3);
          var TriangleToRectangle = function(triangle, rect) {
            return Intersects.RectangleToTriangle(rect, triangle);
          };
          var point = new Vector29();
          var pointStart = new Vector29();
          var pointEnd = new Vector29();
          var GetTilesWithinShape = function(shape, filteringOptions, camera, layer) {
            if (shape === void 0) {
              return [];
            }
            var intersectTest = NOOP;
            if (shape instanceof Geom.Circle) {
              intersectTest = Intersects.CircleToRectangle;
            } else if (shape instanceof Geom.Rectangle) {
              intersectTest = Intersects.RectangleToRectangle;
            } else if (shape instanceof Geom.Triangle) {
              intersectTest = TriangleToRectangle;
            } else if (shape instanceof Geom.Line) {
              intersectTest = Intersects.LineToRectangle;
            }
            layer.tilemapLayer.worldToTileXY(shape.left, shape.top, true, pointStart, camera);
            var xStart = pointStart.x;
            var yStart = pointStart.y;
            layer.tilemapLayer.worldToTileXY(shape.right, shape.bottom, true, pointEnd, camera);
            var xEnd = Math.ceil(pointEnd.x);
            var yEnd = Math.ceil(pointEnd.y);
            var width = Math.max(xEnd - xStart, 1);
            var height = Math.max(yEnd - yStart, 1);
            var tiles = GetTilesWithin(xStart, yStart, width, height, filteringOptions, layer);
            var tileWidth = layer.tileWidth;
            var tileHeight = layer.tileHeight;
            if (layer.tilemapLayer) {
              tileWidth *= layer.tilemapLayer.scaleX;
              tileHeight *= layer.tilemapLayer.scaleY;
            }
            var results = [];
            var tileRect = new Geom.Rectangle(0, 0, tileWidth, tileHeight);
            for (var i = 0; i < tiles.length; i++) {
              var tile = tiles[i];
              layer.tilemapLayer.tileToWorldXY(tile.x, tile.y, point, camera);
              tileRect.x = point.x;
              tileRect.y = point.y;
              if (intersectTest(shape, tileRect)) {
                results.push(tile);
              }
            }
            return results;
          };
          module2.exports = GetTilesWithinShape;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(29);
          var NOOP = __webpack_require__(1);
          var TileToWorldX = __webpack_require__(249);
          var GetTileToWorldXFunction = function(orientation) {
            if (orientation === CONST.ORTHOGONAL) {
              return TileToWorldX;
            } else {
              return NOOP;
            }
          };
          module2.exports = GetTileToWorldXFunction;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(29);
          var HexagonalTileToWorldXY = __webpack_require__(546);
          var IsometricTileToWorldXY = __webpack_require__(547);
          var NOOP = __webpack_require__(1);
          var StaggeredTileToWorldXY = __webpack_require__(548);
          var TileToWorldXY = __webpack_require__(549);
          var GetTileToWorldXYFunction = function(orientation) {
            if (orientation === CONST.ORTHOGONAL) {
              return TileToWorldXY;
            } else if (orientation === CONST.ISOMETRIC) {
              return IsometricTileToWorldXY;
            } else if (orientation === CONST.HEXAGONAL) {
              return HexagonalTileToWorldXY;
            } else if (orientation === CONST.STAGGERED) {
              return StaggeredTileToWorldXY;
            } else {
              return NOOP;
            }
          };
          module2.exports = GetTileToWorldXYFunction;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(29);
          var HexagonalTileToWorldY = __webpack_require__(550);
          var NOOP = __webpack_require__(1);
          var StaggeredTileToWorldY = __webpack_require__(551);
          var TileToWorldY = __webpack_require__(250);
          var GetTileToWorldYFunction = function(orientation) {
            if (orientation === CONST.ORTHOGONAL) {
              return TileToWorldY;
            } else if (orientation === CONST.HEXAGONAL) {
              return HexagonalTileToWorldY;
            } else if (orientation === CONST.STAGGERED) {
              return StaggeredTileToWorldY;
            } else {
              return NOOP;
            }
          };
          module2.exports = GetTileToWorldYFunction;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(29);
          var NOOP = __webpack_require__(1);
          var WorldToTileX = __webpack_require__(251);
          var GetWorldToTileXFunction = function(orientation) {
            if (orientation === CONST.ORTHOGONAL) {
              return WorldToTileX;
            } else {
              return NOOP;
            }
          };
          module2.exports = GetWorldToTileXFunction;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(29);
          var HexagonalWorldToTileXY = __webpack_require__(552);
          var IsometricWorldToTileXY = __webpack_require__(553);
          var NOOP = __webpack_require__(1);
          var StaggeredWorldToTileXY = __webpack_require__(554);
          var WorldToTileXY = __webpack_require__(555);
          var GetWorldToTileXYFunction = function(orientation) {
            if (orientation === CONST.ORTHOGONAL) {
              return WorldToTileXY;
            } else if (orientation === CONST.ISOMETRIC) {
              return IsometricWorldToTileXY;
            } else if (orientation === CONST.HEXAGONAL) {
              return HexagonalWorldToTileXY;
            } else if (orientation === CONST.STAGGERED) {
              return StaggeredWorldToTileXY;
            } else {
              return NOOP;
            }
          };
          module2.exports = GetWorldToTileXYFunction;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(29);
          var HexagonalWorldToTileY = __webpack_require__(556);
          var NOOP = __webpack_require__(1);
          var StaggeredWorldToTileY = __webpack_require__(557);
          var WorldToTileY = __webpack_require__(252);
          var GetWorldToTileYFunction = function(orientation) {
            if (orientation === CONST.ORTHOGONAL) {
              return WorldToTileY;
            } else if (orientation === CONST.HEXAGONAL) {
              return HexagonalWorldToTileY;
            } else if (orientation === CONST.STAGGERED) {
              return StaggeredWorldToTileY;
            } else {
              return NOOP;
            }
          };
          module2.exports = GetWorldToTileYFunction;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var HasTileAt = __webpack_require__(558);
          var Vector29 = __webpack_require__(3);
          var point = new Vector29();
          var HasTileAtWorldXY = function(worldX, worldY, camera, layer) {
            layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);
            var tileX = point.x;
            var tileY = point.y;
            return HasTileAt(tileX, tileY, layer);
          };
          module2.exports = HasTileAtWorldXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var PutTileAt = __webpack_require__(253);
          var Vector29 = __webpack_require__(3);
          var point = new Vector29();
          var PutTileAtWorldXY = function(tile, worldX, worldY, recalculateFaces, camera, layer) {
            layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);
            return PutTileAt(tile, point.x, point.y, recalculateFaces, layer);
          };
          module2.exports = PutTileAtWorldXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CalculateFacesWithin = __webpack_require__(61);
          var PutTileAt = __webpack_require__(253);
          var PutTilesAt = function(tilesArray, tileX, tileY, recalculateFaces, layer) {
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (!Array.isArray(tilesArray)) {
              return null;
            }
            if (!Array.isArray(tilesArray[0])) {
              tilesArray = [tilesArray];
            }
            var height = tilesArray.length;
            var width = tilesArray[0].length;
            for (var ty = 0; ty < height; ty++) {
              for (var tx = 0; tx < width; tx++) {
                var tile = tilesArray[ty][tx];
                PutTileAt(tile, tileX + tx, tileY + ty, false, layer);
              }
            }
            if (recalculateFaces) {
              CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);
            }
          };
          module2.exports = PutTilesAt;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTilesWithin = __webpack_require__(26);
          var GetRandom = __webpack_require__(207);
          var Randomize = function(tileX, tileY, width, height, indexes, layer) {
            var i;
            var tiles = GetTilesWithin(tileX, tileY, width, height, {}, layer);
            if (!indexes) {
              indexes = [];
              for (i = 0; i < tiles.length; i++) {
                if (indexes.indexOf(tiles[i].index) === -1) {
                  indexes.push(tiles[i].index);
                }
              }
            }
            for (i = 0; i < tiles.length; i++) {
              tiles[i].index = GetRandom(indexes);
            }
          };
          module2.exports = Randomize;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RemoveTileAt = __webpack_require__(559);
          var Vector29 = __webpack_require__(3);
          var point = new Vector29();
          var RemoveTileAtWorldXY = function(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer) {
            layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);
            return RemoveTileAt(point.x, point.y, replaceWithNull, recalculateFaces, layer);
          };
          module2.exports = RemoveTileAtWorldXY;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTilesWithin = __webpack_require__(26);
          var Color = __webpack_require__(391);
          var defaultTileColor = new Color(105, 210, 231, 150);
          var defaultCollidingTileColor = new Color(243, 134, 48, 200);
          var defaultFaceColor = new Color(40, 39, 37, 150);
          var RenderDebug = function(graphics, styleConfig, layer) {
            if (styleConfig === void 0) {
              styleConfig = {};
            }
            var tileColor = styleConfig.tileColor !== void 0 ? styleConfig.tileColor : defaultTileColor;
            var collidingTileColor = styleConfig.collidingTileColor !== void 0 ? styleConfig.collidingTileColor : defaultCollidingTileColor;
            var faceColor = styleConfig.faceColor !== void 0 ? styleConfig.faceColor : defaultFaceColor;
            var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);
            graphics.translateCanvas(layer.tilemapLayer.x, layer.tilemapLayer.y);
            graphics.scaleCanvas(layer.tilemapLayer.scaleX, layer.tilemapLayer.scaleY);
            for (var i = 0; i < tiles.length; i++) {
              var tile = tiles[i];
              var tw = tile.width;
              var th = tile.height;
              var x = tile.pixelX;
              var y = tile.pixelY;
              var color = tile.collides ? collidingTileColor : tileColor;
              if (color !== null) {
                graphics.fillStyle(color.color, color.alpha / 255);
                graphics.fillRect(x, y, tw, th);
              }
              x += 1;
              y += 1;
              tw -= 2;
              th -= 2;
              if (faceColor !== null) {
                graphics.lineStyle(1, faceColor.color, faceColor.alpha / 255);
                if (tile.faceTop) {
                  graphics.lineBetween(x, y, x + tw, y);
                }
                if (tile.faceRight) {
                  graphics.lineBetween(x + tw, y, x + tw, y + th);
                }
                if (tile.faceBottom) {
                  graphics.lineBetween(x, y + th, x + tw, y + th);
                }
                if (tile.faceLeft) {
                  graphics.lineBetween(x, y, x, y + th);
                }
              }
            }
          };
          module2.exports = RenderDebug;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetTileCollision = __webpack_require__(72);
          var CalculateFacesWithin = __webpack_require__(61);
          var SetLayerCollisionIndex = __webpack_require__(158);
          var SetCollision = function(indexes, collides, recalculateFaces, layer, updateLayer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (updateLayer === void 0) {
              updateLayer = true;
            }
            if (!Array.isArray(indexes)) {
              indexes = [indexes];
            }
            for (var i = 0; i < indexes.length; i++) {
              SetLayerCollisionIndex(indexes[i], collides, layer);
            }
            if (updateLayer) {
              for (var ty = 0; ty < layer.height; ty++) {
                for (var tx = 0; tx < layer.width; tx++) {
                  var tile = layer.data[ty][tx];
                  if (tile && indexes.indexOf(tile.index) !== -1) {
                    SetTileCollision(tile, collides);
                  }
                }
              }
            }
            if (recalculateFaces) {
              CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
            }
          };
          module2.exports = SetCollision;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetTileCollision = __webpack_require__(72);
          var CalculateFacesWithin = __webpack_require__(61);
          var SetLayerCollisionIndex = __webpack_require__(158);
          var SetCollisionBetween = function(start, stop, collides, recalculateFaces, layer, updateLayer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (updateLayer === void 0) {
              updateLayer = true;
            }
            if (start > stop) {
              return;
            }
            for (var index = start; index <= stop; index++) {
              SetLayerCollisionIndex(index, collides, layer);
            }
            if (updateLayer) {
              for (var ty = 0; ty < layer.height; ty++) {
                for (var tx = 0; tx < layer.width; tx++) {
                  var tile = layer.data[ty][tx];
                  if (tile) {
                    if (tile.index >= start && tile.index <= stop) {
                      SetTileCollision(tile, collides);
                    }
                  }
                }
              }
            }
            if (recalculateFaces) {
              CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
            }
          };
          module2.exports = SetCollisionBetween;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetTileCollision = __webpack_require__(72);
          var CalculateFacesWithin = __webpack_require__(61);
          var SetLayerCollisionIndex = __webpack_require__(158);
          var SetCollisionByExclusion = function(indexes, collides, recalculateFaces, layer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (!Array.isArray(indexes)) {
              indexes = [indexes];
            }
            for (var ty = 0; ty < layer.height; ty++) {
              for (var tx = 0; tx < layer.width; tx++) {
                var tile = layer.data[ty][tx];
                if (tile && indexes.indexOf(tile.index) === -1) {
                  SetTileCollision(tile, collides);
                  SetLayerCollisionIndex(tile.index, collides, layer);
                }
              }
            }
            if (recalculateFaces) {
              CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
            }
          };
          module2.exports = SetCollisionByExclusion;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetTileCollision = __webpack_require__(72);
          var CalculateFacesWithin = __webpack_require__(61);
          var HasValue = __webpack_require__(125);
          var SetCollisionByProperty = function(properties, collides, recalculateFaces, layer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            for (var ty = 0; ty < layer.height; ty++) {
              for (var tx = 0; tx < layer.width; tx++) {
                var tile = layer.data[ty][tx];
                if (!tile) {
                  continue;
                }
                for (var property in properties) {
                  if (!HasValue(tile.properties, property)) {
                    continue;
                  }
                  var values = properties[property];
                  if (!Array.isArray(values)) {
                    values = [values];
                  }
                  for (var i = 0; i < values.length; i++) {
                    if (tile.properties[property] === values[i]) {
                      SetTileCollision(tile, collides);
                    }
                  }
                }
              }
            }
            if (recalculateFaces) {
              CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
            }
          };
          module2.exports = SetCollisionByProperty;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetTileCollision = __webpack_require__(72);
          var CalculateFacesWithin = __webpack_require__(61);
          var SetCollisionFromCollisionGroup = function(collides, recalculateFaces, layer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            for (var ty = 0; ty < layer.height; ty++) {
              for (var tx = 0; tx < layer.width; tx++) {
                var tile = layer.data[ty][tx];
                if (!tile) {
                  continue;
                }
                var collisionGroup = tile.getCollisionGroup();
                if (collisionGroup && collisionGroup.objects && collisionGroup.objects.length > 0) {
                  SetTileCollision(tile, collides);
                }
              }
            }
            if (recalculateFaces) {
              CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
            }
          };
          module2.exports = SetCollisionFromCollisionGroup;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var SetTileIndexCallback = function(indexes, callback, callbackContext, layer) {
            if (typeof indexes === "number") {
              layer.callbacks[indexes] = callback !== null ? {callback, callbackContext} : void 0;
            } else {
              for (var i = 0, len = indexes.length; i < len; i++) {
                layer.callbacks[indexes[i]] = callback !== null ? {callback, callbackContext} : void 0;
              }
            }
          };
          module2.exports = SetTileIndexCallback;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTilesWithin = __webpack_require__(26);
          var SetTileLocationCallback = function(tileX, tileY, width, height, callback, callbackContext, layer) {
            var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
            for (var i = 0; i < tiles.length; i++) {
              tiles[i].setCollisionCallback(callback, callbackContext);
            }
          };
          module2.exports = SetTileLocationCallback;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTilesWithin = __webpack_require__(26);
          var ShuffleArray = __webpack_require__(129);
          var Shuffle = function(tileX, tileY, width, height, layer) {
            var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
            var indexes = tiles.map(function(tile) {
              return tile.index;
            });
            ShuffleArray(indexes);
            for (var i = 0; i < tiles.length; i++) {
              tiles[i].index = indexes[i];
            }
          };
          module2.exports = Shuffle;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTilesWithin = __webpack_require__(26);
          var SwapByIndex = function(indexA, indexB, tileX, tileY, width, height, layer) {
            var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
            for (var i = 0; i < tiles.length; i++) {
              if (tiles[i]) {
                if (tiles[i].index === indexA) {
                  tiles[i].index = indexB;
                } else if (tiles[i].index === indexB) {
                  tiles[i].index = indexA;
                }
              }
            }
          };
          module2.exports = SwapByIndex;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetTilesWithin = __webpack_require__(26);
          var WeightedRandomize = function(tileX, tileY, width, height, weightedIndexes, layer) {
            if (!weightedIndexes) {
              return;
            }
            var i;
            var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
            var weightTotal = 0;
            for (i = 0; i < weightedIndexes.length; i++) {
              weightTotal += weightedIndexes[i].weight;
            }
            if (weightTotal <= 0) {
              return;
            }
            for (i = 0; i < tiles.length; i++) {
              var rand = Math.random() * weightTotal;
              var sum = 0;
              var randomIndex = -1;
              for (var j = 0; j < weightedIndexes.length; j++) {
                sum += weightedIndexes[j].weight;
                if (rand <= sum) {
                  var chosen = weightedIndexes[j].index;
                  randomIndex = Array.isArray(chosen) ? chosen[Math.floor(Math.random() * chosen.length)] : chosen;
                  break;
                }
              }
              tiles[i].index = randomIndex;
            }
          };
          module2.exports = WeightedRandomize;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            FromOrientationString: __webpack_require__(254),
            Parse: __webpack_require__(560),
            Parse2DArray: __webpack_require__(255),
            ParseCSV: __webpack_require__(561),
            Impact: __webpack_require__(1447),
            Tiled: __webpack_require__(1448)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            ParseTileLayers: __webpack_require__(574),
            ParseTilesets: __webpack_require__(575),
            ParseWeltmeister: __webpack_require__(573)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            AssignTileProperties: __webpack_require__(563),
            Base64Decode: __webpack_require__(570),
            BuildTilesetIndex: __webpack_require__(564),
            CreateGroupLayer: __webpack_require__(159),
            ParseGID: __webpack_require__(257),
            ParseImageLayers: __webpack_require__(565),
            ParseJSONTiled: __webpack_require__(562),
            ParseObject: __webpack_require__(256),
            ParseObjectLayers: __webpack_require__(566),
            ParseTileLayers: __webpack_require__(569),
            ParseTilesets: __webpack_require__(571)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1450);
          }
          if (true) {
            renderCanvas = __webpack_require__(1451);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Utils = __webpack_require__(12);
          var TilemapLayerWebGLRenderer = function(renderer, src, camera) {
            var renderTiles = src.cull(camera);
            var tileCount = renderTiles.length;
            var alpha = camera.alpha * src.alpha;
            if (tileCount === 0 || alpha <= 0) {
              return;
            }
            var gidMap = src.gidMap;
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            var getTint = Utils.getTintAppendFloatAlpha;
            var scrollFactorX = src.scrollFactorX;
            var scrollFactorY = src.scrollFactorY;
            var x = src.x;
            var y = src.y;
            var sx = src.scaleX;
            var sy = src.scaleY;
            renderer.pipelines.preBatch(src);
            for (var i = 0; i < tileCount; i++) {
              var tile = renderTiles[i];
              var tileset = gidMap[tile.index];
              if (!tileset) {
                continue;
              }
              var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);
              if (tileTexCoords === null) {
                continue;
              }
              var texture = tileset.glTexture;
              var textureUnit = pipeline.setTexture2D(texture, src);
              var frameWidth = tileset.tileWidth;
              var frameHeight = tileset.tileHeight;
              var frameX = tileTexCoords.x;
              var frameY = tileTexCoords.y;
              var tw = tileset.tileWidth * 0.5;
              var th = tileset.tileHeight * 0.5;
              var tint = getTint(tile.tint, alpha * tile.alpha);
              pipeline.batchTexture(src, texture, texture.width, texture.height, x + (tw + tile.pixelX) * sx, y + (th + tile.pixelY) * sy, tile.width, tile.height, sx, sy, tile.rotation, tile.flipX, tile.flipY, scrollFactorX, scrollFactorY, tw, th, frameX, frameY, frameWidth, frameHeight, tint, tint, tint, tint, false, 0, 0, camera, null, true, textureUnit);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = TilemapLayerWebGLRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var TransformMatrix = __webpack_require__(25);
          var tempMatrix1 = new TransformMatrix();
          var tempMatrix2 = new TransformMatrix();
          var tempMatrix3 = new TransformMatrix();
          var TilemapLayerCanvasRenderer = function(renderer, src, camera, parentMatrix) {
            var renderTiles = src.cull(camera);
            var tileCount = renderTiles.length;
            var alpha = camera.alpha * src.alpha;
            if (tileCount === 0 || alpha <= 0) {
              return;
            }
            var camMatrix = tempMatrix1;
            var layerMatrix = tempMatrix2;
            var calcMatrix = tempMatrix3;
            layerMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);
            camMatrix.copyFrom(camera.matrix);
            var ctx = renderer.currentContext;
            var gidMap = src.gidMap;
            ctx.save();
            if (parentMatrix) {
              camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
              layerMatrix.e = src.x;
              layerMatrix.f = src.y;
              camMatrix.multiply(layerMatrix, calcMatrix);
              calcMatrix.copyToContext(ctx);
            } else {
              layerMatrix.e -= camera.scrollX * src.scrollFactorX;
              layerMatrix.f -= camera.scrollY * src.scrollFactorY;
              layerMatrix.copyToContext(ctx);
            }
            if (!renderer.antialias || src.scaleX > 1 || src.scaleY > 1) {
              ctx.imageSmoothingEnabled = false;
            }
            for (var i = 0; i < tileCount; i++) {
              var tile = renderTiles[i];
              var tileset = gidMap[tile.index];
              if (!tileset) {
                continue;
              }
              var image = tileset.image.getSourceImage();
              var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);
              if (tileTexCoords === null) {
                continue;
              }
              var tileWidth = tileset.tileWidth;
              var tileHeight = tileset.tileHeight;
              var halfWidth = tileWidth * 0.5;
              var halfHeight = tileHeight * 0.5;
              ctx.save();
              ctx.translate(tile.pixelX + halfWidth, tile.pixelY + halfHeight);
              if (tile.rotation !== 0) {
                ctx.rotate(tile.rotation);
              }
              if (tile.flipX || tile.flipY) {
                ctx.scale(tile.flipX ? -1 : 1, tile.flipY ? -1 : 1);
              }
              ctx.globalAlpha = alpha * tile.alpha;
              ctx.drawImage(image, tileTexCoords.x, tileTexCoords.y, tileWidth, tileHeight, -halfWidth, -halfHeight, tileWidth, tileHeight);
              ctx.restore();
            }
            ctx.restore();
          };
          module2.exports = TilemapLayerCanvasRenderer;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectCreator = __webpack_require__(16);
          var ParseToTilemap = __webpack_require__(258);
          GameObjectCreator.register("tilemap", function(config2) {
            var c = config2 !== void 0 ? config2 : {};
            return ParseToTilemap(this.scene, c.key, c.tileWidth, c.tileHeight, c.width, c.height, c.data, c.insertNull);
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GameObjectFactory = __webpack_require__(5);
          var ParseToTilemap = __webpack_require__(258);
          GameObjectFactory.register("tilemap", function(key, tileWidth, tileHeight, width, height, data, insertNull) {
            if (key === null) {
              key = void 0;
            }
            if (tileWidth === null) {
              tileWidth = void 0;
            }
            if (tileHeight === null) {
              tileHeight = void 0;
            }
            if (width === null) {
              width = void 0;
            }
            if (height === null) {
              height = void 0;
            }
            return ParseToTilemap(this.scene, key, tileWidth, tileHeight, width, height, data, insertNull);
          });
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Clock: __webpack_require__(1455),
            TimerEvent: __webpack_require__(578)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(21);
          var TimerEvent = __webpack_require__(578);
          var Remove = __webpack_require__(89);
          var Clock = new Class({
            initialize: function Clock2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.now = 0;
              this.timeScale = 1;
              this.paused = false;
              this._active = [];
              this._pendingInsertion = [];
              this._pendingRemoval = [];
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function() {
              this.now = this.systems.game.loop.time;
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function() {
              var eventEmitter = this.systems.events;
              eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
              eventEmitter.on(SceneEvents.UPDATE, this.update, this);
              eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            addEvent: function(config2) {
              var event;
              if (config2 instanceof TimerEvent) {
                event = config2;
                this.removeEvent(event);
                event.elapsed = event.startAt;
                event.hasDispatched = false;
                event.repeatCount = event.repeat === -1 || event.loop ? 999999999999 : event.repeat;
              } else {
                event = new TimerEvent(config2);
              }
              this._pendingInsertion.push(event);
              return event;
            },
            delayedCall: function(delay, callback, args, callbackScope) {
              return this.addEvent({delay, callback, args, callbackScope});
            },
            clearPendingEvents: function() {
              this._pendingInsertion = [];
              return this;
            },
            removeEvent: function(events) {
              if (!Array.isArray(events)) {
                events = [events];
              }
              for (var i = 0; i < events.length; i++) {
                var event = events[i];
                Remove(this._pendingRemoval, event);
                Remove(this._pendingInsertion, event);
                Remove(this._active, event);
              }
              return this;
            },
            removeAllEvents: function() {
              this._pendingRemoval = this._pendingRemoval.concat(this._active);
              return this;
            },
            preUpdate: function() {
              var toRemove = this._pendingRemoval.length;
              var toInsert = this._pendingInsertion.length;
              if (toRemove === 0 && toInsert === 0) {
                return;
              }
              var i;
              var event;
              for (i = 0; i < toRemove; i++) {
                event = this._pendingRemoval[i];
                var index = this._active.indexOf(event);
                if (index > -1) {
                  this._active.splice(index, 1);
                }
                event.destroy();
              }
              for (i = 0; i < toInsert; i++) {
                event = this._pendingInsertion[i];
                this._active.push(event);
              }
              this._pendingRemoval.length = 0;
              this._pendingInsertion.length = 0;
            },
            update: function(time, delta) {
              this.now = time;
              if (this.paused) {
                return;
              }
              delta *= this.timeScale;
              for (var i = 0; i < this._active.length; i++) {
                var event = this._active[i];
                if (event.paused) {
                  continue;
                }
                event.elapsed += delta * event.timeScale;
                if (event.elapsed >= event.delay) {
                  var remainder = event.elapsed - event.delay;
                  event.elapsed = event.delay;
                  if (!event.hasDispatched && event.callback) {
                    event.hasDispatched = true;
                    event.callback.apply(event.callbackScope, event.args);
                  }
                  if (event.repeatCount > 0) {
                    event.repeatCount--;
                    event.elapsed = remainder;
                    event.hasDispatched = false;
                  } else {
                    this._pendingRemoval.push(event);
                  }
                }
              }
            },
            shutdown: function() {
              var i;
              for (i = 0; i < this._pendingInsertion.length; i++) {
                this._pendingInsertion[i].destroy();
              }
              for (i = 0; i < this._active.length; i++) {
                this._active[i].destroy();
              }
              for (i = 0; i < this._pendingRemoval.length; i++) {
                this._pendingRemoval[i].destroy();
              }
              this._active.length = 0;
              this._pendingRemoval.length = 0;
              this._pendingInsertion.length = 0;
              var eventEmitter = this.systems.events;
              eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
              eventEmitter.off(SceneEvents.UPDATE, this.update, this);
              eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function() {
              this.shutdown();
              this.scene.sys.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
            }
          });
          PluginCache.register("Clock", Clock, "time");
          module2.exports = Clock;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var CONST = __webpack_require__(97);
          var Extend = __webpack_require__(17);
          var Tweens = {
            Builders: __webpack_require__(1457),
            Events: __webpack_require__(263),
            TweenManager: __webpack_require__(1473),
            Tween: __webpack_require__(262),
            TweenData: __webpack_require__(264),
            Timeline: __webpack_require__(584)
          };
          Tweens = Extend(false, Tweens, CONST);
          module2.exports = Tweens;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            GetBoolean: __webpack_require__(96),
            GetEaseFunction: __webpack_require__(80),
            GetNewValue: __webpack_require__(160),
            GetProps: __webpack_require__(579),
            GetTargets: __webpack_require__(259),
            GetTweens: __webpack_require__(580),
            GetValueOp: __webpack_require__(260),
            NumberTweenBuilder: __webpack_require__(581),
            StaggerBuilder: __webpack_require__(582),
            TimelineBuilder: __webpack_require__(583),
            TweenBuilder: __webpack_require__(161)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = [
            "callbackScope",
            "completeDelay",
            "delay",
            "duration",
            "ease",
            "easeParams",
            "flipX",
            "flipY",
            "hold",
            "loop",
            "loopDelay",
            "offset",
            "onActive",
            "onActiveParams",
            "onActiveScope",
            "onComplete",
            "onCompleteParams",
            "onCompleteScope",
            "onLoop",
            "onLoopParams",
            "onLoopScope",
            "onRepeat",
            "onRepeatParams",
            "onRepeatScope",
            "onStart",
            "onStartParams",
            "onStartScope",
            "onStop",
            "onStopParams",
            "onStopScope",
            "onUpdate",
            "onUpdateParams",
            "onUpdateScope",
            "onYoyo",
            "onYoyoParams",
            "onYoyoScope",
            "paused",
            "props",
            "repeat",
            "repeatDelay",
            "targets",
            "useFrames",
            "yoyo"
          ];
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "complete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "loop";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pause";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "resume";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "start";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "update";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "active";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "complete";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "loop";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "repeat";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "start";
        },
        function(module2, exports2) {
          /**
           * @author       samme
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "stop";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "update";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "yoyo";
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ArrayRemove = __webpack_require__(89);
          var Class = __webpack_require__(0);
          var NumberTweenBuilder = __webpack_require__(581);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(21);
          var StaggerBuilder = __webpack_require__(582);
          var TimelineBuilder = __webpack_require__(583);
          var TWEEN_CONST = __webpack_require__(97);
          var TweenBuilder = __webpack_require__(161);
          var TweenManager = new Class({
            initialize: function TweenManager2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.timeScale = 1;
              this._add = [];
              this._pending = [];
              this._active = [];
              this._destroy = [];
              this._toProcess = 0;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function() {
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function() {
              var eventEmitter = this.systems.events;
              eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
              eventEmitter.on(SceneEvents.UPDATE, this.update, this);
              eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              this.timeScale = 1;
            },
            createTimeline: function(config2) {
              return TimelineBuilder(this, config2);
            },
            timeline: function(config2) {
              var timeline = TimelineBuilder(this, config2);
              if (!timeline.paused) {
                this._add.push(timeline);
                this._toProcess++;
              }
              return timeline;
            },
            create: function(config2) {
              return TweenBuilder(this, config2);
            },
            add: function(config2) {
              var tween = TweenBuilder(this, config2);
              this._add.push(tween);
              this._toProcess++;
              return tween;
            },
            existing: function(tween) {
              this._add.push(tween);
              this._toProcess++;
              return this;
            },
            addCounter: function(config2) {
              var tween = NumberTweenBuilder(this, config2);
              this._add.push(tween);
              this._toProcess++;
              return tween;
            },
            stagger: function(value, options) {
              return StaggerBuilder(value, options);
            },
            preUpdate: function() {
              if (this._toProcess === 0) {
                return;
              }
              var list = this._destroy;
              var active = this._active;
              var pending = this._pending;
              var i;
              var tween;
              for (i = 0; i < list.length; i++) {
                tween = list[i];
                var idx = active.indexOf(tween);
                if (idx === -1) {
                  idx = pending.indexOf(tween);
                  if (idx > -1) {
                    tween.state = TWEEN_CONST.REMOVED;
                    pending.splice(idx, 1);
                  }
                } else {
                  tween.state = TWEEN_CONST.REMOVED;
                  active.splice(idx, 1);
                }
              }
              list.length = 0;
              list = this._add;
              for (i = 0; i < list.length; i++) {
                tween = list[i];
                if (tween.state === TWEEN_CONST.PENDING_ADD) {
                  if (tween.init()) {
                    tween.play();
                    this._active.push(tween);
                  } else {
                    this._pending.push(tween);
                  }
                }
              }
              list.length = 0;
              this._toProcess = 0;
            },
            update: function(timestamp, delta) {
              var list = this._active;
              var tween;
              delta *= this.timeScale;
              for (var i = 0; i < list.length; i++) {
                tween = list[i];
                if (tween.update(timestamp, delta)) {
                  this._destroy.push(tween);
                  this._toProcess++;
                }
              }
            },
            remove: function(tween) {
              ArrayRemove(this._add, tween);
              ArrayRemove(this._pending, tween);
              ArrayRemove(this._active, tween);
              ArrayRemove(this._destroy, tween);
              tween.state = TWEEN_CONST.REMOVED;
              return this;
            },
            makeActive: function(tween) {
              if (this._add.indexOf(tween) !== -1 || this._active.indexOf(tween) !== -1) {
                return this;
              }
              var idx = this._pending.indexOf(tween);
              if (idx !== -1) {
                this._pending.splice(idx, 1);
              }
              this._add.push(tween);
              tween.state = TWEEN_CONST.PENDING_ADD;
              this._toProcess++;
              return this;
            },
            each: function(callback, scope) {
              var args = [null];
              for (var i = 1; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (var texture in this.list) {
                args[0] = this.list[texture];
                callback.apply(scope, args);
              }
            },
            getAllTweens: function() {
              var list = this._active;
              var output = [];
              for (var i = 0; i < list.length; i++) {
                output.push(list[i]);
              }
              return output;
            },
            getGlobalTimeScale: function() {
              return this.timeScale;
            },
            getTweensOf: function(target, includePending) {
              if (includePending === void 0) {
                includePending = false;
              }
              var list = this._active;
              var tween;
              var output = [];
              var i;
              var t;
              if (!Array.isArray(target)) {
                target = [target];
              }
              for (i = 0; i < list.length; i++) {
                tween = list[i];
                for (t = 0; t < target.length; t++) {
                  if (tween.hasTarget(target[t])) {
                    output.push(tween);
                  }
                }
              }
              if (includePending) {
                list = this._pending;
                for (i = 0; i < list.length; i++) {
                  tween = list[i];
                  for (t = 0; t < target.length; t++) {
                    if (tween.hasTarget(target[t])) {
                      output.push(tween);
                    }
                  }
                }
              }
              return output;
            },
            isTweening: function(target) {
              var list = this._active;
              var tween;
              for (var i = 0; i < list.length; i++) {
                tween = list[i];
                if (tween.hasTarget(target) && tween.isPlaying()) {
                  return true;
                }
              }
              return false;
            },
            killAll: function() {
              var tweens = this.getAllTweens();
              for (var i = 0; i < tweens.length; i++) {
                tweens[i].stop();
              }
              return this;
            },
            killTweensOf: function(target) {
              var tweens = this.getTweensOf(target);
              for (var i = 0; i < tweens.length; i++) {
                tweens[i].stop();
              }
              return this;
            },
            pauseAll: function() {
              var list = this._active;
              for (var i = 0; i < list.length; i++) {
                list[i].pause();
              }
              return this;
            },
            resumeAll: function() {
              var list = this._active;
              for (var i = 0; i < list.length; i++) {
                list[i].resume();
              }
              return this;
            },
            setGlobalTimeScale: function(value) {
              this.timeScale = value;
              return this;
            },
            shutdown: function() {
              this.killAll();
              this._add = [];
              this._pending = [];
              this._active = [];
              this._destroy = [];
              this._toProcess = 0;
              var eventEmitter = this.systems.events;
              eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
              eventEmitter.off(SceneEvents.UPDATE, this.update, this);
              eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function() {
              this.shutdown();
              this.scene.sys.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
            }
          });
          PluginCache.register("TweenManager", TweenManager, "tweens");
          module2.exports = TweenManager;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Array: __webpack_require__(205),
            Base64: __webpack_require__(1475),
            Objects: __webpack_require__(1477),
            String: __webpack_require__(1481),
            NOOP: __webpack_require__(1)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            ArrayBufferToBase64: __webpack_require__(1476),
            Base64ToArrayBuffer: __webpack_require__(427)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          var ArrayBufferToBase64 = function(arrayBuffer, mediaType) {
            var bytes = new Uint8Array(arrayBuffer);
            var len = bytes.length;
            var base64 = mediaType ? "data:" + mediaType + ";base64," : "";
            for (var i = 0; i < len; i += 3) {
              base64 += chars[bytes[i] >> 2];
              base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
              base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
              base64 += chars[bytes[i + 2] & 63];
            }
            if (len % 3 === 2) {
              base64 = base64.substring(0, base64.length - 1) + "=";
            } else if (len % 3 === 1) {
              base64 = base64.substring(0, base64.length - 2) + "==";
            }
            return base64;
          };
          module2.exports = ArrayBufferToBase64;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Clone: __webpack_require__(77),
            DeepCopy: __webpack_require__(172),
            Extend: __webpack_require__(17),
            GetAdvancedValue: __webpack_require__(13),
            GetFastValue: __webpack_require__(2),
            GetMinMaxValue: __webpack_require__(1478),
            GetValue: __webpack_require__(6),
            HasAll: __webpack_require__(1479),
            HasAny: __webpack_require__(449),
            HasValue: __webpack_require__(125),
            IsPlainObject: __webpack_require__(7),
            Merge: __webpack_require__(143),
            MergeRight: __webpack_require__(1480),
            Pick: __webpack_require__(567),
            SetValue: __webpack_require__(472)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var GetValue = __webpack_require__(6);
          var Clamp = __webpack_require__(18);
          var GetMinMaxValue = function(source, key, min, max, defaultValue) {
            if (defaultValue === void 0) {
              defaultValue = min;
            }
            var value = GetValue(source, key, defaultValue);
            return Clamp(value, min, max);
          };
          module2.exports = GetMinMaxValue;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var HasAll = function(source, keys) {
            for (var i = 0; i < keys.length; i++) {
              if (!source.hasOwnProperty(keys[i])) {
                return false;
              }
            }
            return true;
          };
          module2.exports = HasAll;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Clone = __webpack_require__(77);
          var MergeRight = function(obj1, obj2) {
            var clone = Clone(obj1);
            for (var key in obj2) {
              if (clone.hasOwnProperty(key)) {
                clone[key] = obj2[key];
              }
            }
            return clone;
          };
          module2.exports = MergeRight;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Format: __webpack_require__(1482),
            Pad: __webpack_require__(183),
            RemoveAt: __webpack_require__(1483),
            Reverse: __webpack_require__(1484),
            UppercaseFirst: __webpack_require__(202),
            UUID: __webpack_require__(219)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Format = function(string, values) {
            return string.replace(/%([0-9]+)/g, function(s, n) {
              return values[Number(n) - 1];
            });
          };
          module2.exports = Format;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var RemoveAt = function(string, index) {
            if (index === 0) {
              return string.slice(1);
            } else {
              return string.slice(0, index - 1) + string.slice(index);
            }
          };
          module2.exports = RemoveAt;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Reverse = function(string) {
            return string.split("").reverse().join("");
          };
          module2.exports = Reverse;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            SoundManagerCreator: __webpack_require__(420),
            Events: __webpack_require__(69),
            BaseSound: __webpack_require__(145),
            BaseSoundManager: __webpack_require__(144),
            WebAudioSound: __webpack_require__(428),
            WebAudioSoundManager: __webpack_require__(426),
            HTML5AudioSound: __webpack_require__(423),
            HTML5AudioSoundManager: __webpack_require__(421),
            NoAudioSound: __webpack_require__(425),
            NoAudioSoundManager: __webpack_require__(424)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Vector29 = __webpack_require__(3);
          var BodyBounds = new Class({
            initialize: function BodyBounds2() {
              this.boundsCenter = new Vector29();
              this.centerDiff = new Vector29();
            },
            parseBody: function(body) {
              body = body.hasOwnProperty("body") ? body.body : body;
              if (!body.hasOwnProperty("bounds") || !body.hasOwnProperty("centerOfMass")) {
                return false;
              }
              var boundsCenter = this.boundsCenter;
              var centerDiff = this.centerDiff;
              var boundsWidth = body.bounds.max.x - body.bounds.min.x;
              var boundsHeight = body.bounds.max.y - body.bounds.min.y;
              var bodyCenterX = boundsWidth * body.centerOfMass.x;
              var bodyCenterY = boundsHeight * body.centerOfMass.y;
              boundsCenter.set(boundsWidth / 2, boundsHeight / 2);
              centerDiff.set(bodyCenterX - boundsCenter.x, bodyCenterY - boundsCenter.y);
              return true;
            },
            getTopLeft: function(body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector29(x + center.x + diff.x, y + center.y + diff.y);
              }
              return false;
            },
            getTopCenter: function(body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector29(x + diff.x, y + center.y + diff.y);
              }
              return false;
            },
            getTopRight: function(body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector29(x - (center.x - diff.x), y + center.y + diff.y);
              }
              return false;
            },
            getLeftCenter: function(body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector29(x + center.x + diff.x, y + diff.y);
              }
              return false;
            },
            getCenter: function(body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var diff = this.centerDiff;
                return new Vector29(x + diff.x, y + diff.y);
              }
              return false;
            },
            getRightCenter: function(body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector29(x - (center.x - diff.x), y + diff.y);
              }
              return false;
            },
            getBottomLeft: function(body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector29(x + center.x + diff.x, y - (center.y - diff.y));
              }
              return false;
            },
            getBottomCenter: function(body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector29(x + diff.x, y - (center.y - diff.y));
              }
              return false;
            },
            getBottomRight: function(body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector29(x - (center.x - diff.x), y - (center.y - diff.y));
              }
              return false;
            }
          });
          module2.exports = BodyBounds;
        },
        function(module2, exports2) {
          /**
           * @author       Stefan Hedman <schteppe@gmail.com> (http://steffe.se)
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            decomp: polygonDecomp,
            quickDecomp: polygonQuickDecomp,
            isSimple: polygonIsSimple,
            removeCollinearPoints: polygonRemoveCollinearPoints,
            removeDuplicatePoints: polygonRemoveDuplicatePoints,
            makeCCW: polygonMakeCCW
          };
          function lineInt(l1, l2, precision) {
            precision = precision || 0;
            var i = [0, 0];
            var a1, b1, c1, a2, b2, c2, det;
            a1 = l1[1][1] - l1[0][1];
            b1 = l1[0][0] - l1[1][0];
            c1 = a1 * l1[0][0] + b1 * l1[0][1];
            a2 = l2[1][1] - l2[0][1];
            b2 = l2[0][0] - l2[1][0];
            c2 = a2 * l2[0][0] + b2 * l2[0][1];
            det = a1 * b2 - a2 * b1;
            if (!scalar_eq(det, 0, precision)) {
              i[0] = (b2 * c1 - b1 * c2) / det;
              i[1] = (a1 * c2 - a2 * c1) / det;
            }
            return i;
          }
          function lineSegmentsIntersect(p1, p2, q1, q2) {
            var dx = p2[0] - p1[0];
            var dy = p2[1] - p1[1];
            var da = q2[0] - q1[0];
            var db = q2[1] - q1[1];
            if (da * dy - db * dx === 0) {
              return false;
            }
            var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
            var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);
            return s >= 0 && s <= 1 && t >= 0 && t <= 1;
          }
          function triangleArea(a, b, c) {
            return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
          }
          function isLeft(a, b, c) {
            return triangleArea(a, b, c) > 0;
          }
          function isLeftOn(a, b, c) {
            return triangleArea(a, b, c) >= 0;
          }
          function isRight(a, b, c) {
            return triangleArea(a, b, c) < 0;
          }
          function isRightOn(a, b, c) {
            return triangleArea(a, b, c) <= 0;
          }
          var tmpPoint1 = [], tmpPoint2 = [];
          function collinear(a, b, c, thresholdAngle) {
            if (!thresholdAngle) {
              return triangleArea(a, b, c) === 0;
            } else {
              var ab = tmpPoint1, bc = tmpPoint2;
              ab[0] = b[0] - a[0];
              ab[1] = b[1] - a[1];
              bc[0] = c[0] - b[0];
              bc[1] = c[1] - b[1];
              var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));
              return angle < thresholdAngle;
            }
          }
          function sqdist(a, b) {
            var dx = b[0] - a[0];
            var dy = b[1] - a[1];
            return dx * dx + dy * dy;
          }
          function polygonAt(polygon, i) {
            var s = polygon.length;
            return polygon[i < 0 ? i % s + s : i % s];
          }
          function polygonClear(polygon) {
            polygon.length = 0;
          }
          function polygonAppend(polygon, poly, from, to) {
            for (var i = from; i < to; i++) {
              polygon.push(poly[i]);
            }
          }
          function polygonMakeCCW(polygon) {
            var br = 0, v = polygon;
            for (var i = 1; i < polygon.length; ++i) {
              if (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0]) {
                br = i;
              }
            }
            if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
              polygonReverse(polygon);
              return true;
            } else {
              return false;
            }
          }
          function polygonReverse(polygon) {
            var tmp = [];
            var N = polygon.length;
            for (var i = 0; i !== N; i++) {
              tmp.push(polygon.pop());
            }
            for (var i = 0; i !== N; i++) {
              polygon[i] = tmp[i];
            }
          }
          function polygonIsReflex(polygon, i) {
            return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
          }
          var tmpLine1 = [], tmpLine2 = [];
          function polygonCanSee(polygon, a, b) {
            var p, dist, l1 = tmpLine1, l2 = tmpLine2;
            if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {
              return false;
            }
            dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));
            for (var i = 0; i !== polygon.length; ++i) {
              if ((i + 1) % polygon.length === a || i === a) {
                continue;
              }
              if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) {
                l1[0] = polygonAt(polygon, a);
                l1[1] = polygonAt(polygon, b);
                l2[0] = polygonAt(polygon, i);
                l2[1] = polygonAt(polygon, i + 1);
                p = lineInt(l1, l2);
                if (sqdist(polygonAt(polygon, a), p) < dist) {
                  return false;
                }
              }
            }
            return true;
          }
          function polygonCanSee2(polygon, a, b) {
            for (var i = 0; i !== polygon.length; ++i) {
              if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {
                continue;
              }
              if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {
                return false;
              }
            }
            return true;
          }
          function polygonCopy(polygon, i, j, targetPoly) {
            var p = targetPoly || [];
            polygonClear(p);
            if (i < j) {
              for (var k = i; k <= j; k++) {
                p.push(polygon[k]);
              }
            } else {
              for (var k = 0; k <= j; k++) {
                p.push(polygon[k]);
              }
              for (var k = i; k < polygon.length; k++) {
                p.push(polygon[k]);
              }
            }
            return p;
          }
          function polygonGetCutEdges(polygon) {
            var min = [], tmp1 = [], tmp2 = [], tmpPoly = [];
            var nDiags = Number.MAX_VALUE;
            for (var i = 0; i < polygon.length; ++i) {
              if (polygonIsReflex(polygon, i)) {
                for (var j = 0; j < polygon.length; ++j) {
                  if (polygonCanSee(polygon, i, j)) {
                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));
                    for (var k = 0; k < tmp2.length; k++) {
                      tmp1.push(tmp2[k]);
                    }
                    if (tmp1.length < nDiags) {
                      min = tmp1;
                      nDiags = tmp1.length;
                      min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);
                    }
                  }
                }
              }
            }
            return min;
          }
          function polygonDecomp(polygon) {
            var edges = polygonGetCutEdges(polygon);
            if (edges.length > 0) {
              return polygonSlice(polygon, edges);
            } else {
              return [polygon];
            }
          }
          function polygonSlice(polygon, cutEdges) {
            if (cutEdges.length === 0) {
              return [polygon];
            }
            if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {
              var polys = [polygon];
              for (var i = 0; i < cutEdges.length; i++) {
                var cutEdge = cutEdges[i];
                for (var j = 0; j < polys.length; j++) {
                  var poly = polys[j];
                  var result = polygonSlice(poly, cutEdge);
                  if (result) {
                    polys.splice(j, 1);
                    polys.push(result[0], result[1]);
                    break;
                  }
                }
              }
              return polys;
            } else {
              var cutEdge = cutEdges;
              var i = polygon.indexOf(cutEdge[0]);
              var j = polygon.indexOf(cutEdge[1]);
              if (i !== -1 && j !== -1) {
                return [
                  polygonCopy(polygon, i, j),
                  polygonCopy(polygon, j, i)
                ];
              } else {
                return false;
              }
            }
          }
          function polygonIsSimple(polygon) {
            var path = polygon, i;
            for (i = 0; i < path.length - 1; i++) {
              for (var j = 0; j < i - 1; j++) {
                if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
                  return false;
                }
              }
            }
            for (i = 1; i < path.length - 2; i++) {
              if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {
                return false;
              }
            }
            return true;
          }
          function getIntersectionPoint(p1, p2, q1, q2, delta) {
            delta = delta || 0;
            var a1 = p2[1] - p1[1];
            var b1 = p1[0] - p2[0];
            var c1 = a1 * p1[0] + b1 * p1[1];
            var a2 = q2[1] - q1[1];
            var b2 = q1[0] - q2[0];
            var c2 = a2 * q1[0] + b2 * q1[1];
            var det = a1 * b2 - a2 * b1;
            if (!scalar_eq(det, 0, delta)) {
              return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];
            } else {
              return [0, 0];
            }
          }
          function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {
            maxlevel = maxlevel || 100;
            level = level || 0;
            delta = delta || 25;
            result = typeof result !== "undefined" ? result : [];
            reflexVertices = reflexVertices || [];
            steinerPoints = steinerPoints || [];
            var upperInt = [0, 0], lowerInt = [0, 0], p = [0, 0];
            var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0;
            var upperIndex = 0, lowerIndex = 0, closestIndex = 0;
            var lowerPoly = [], upperPoly = [];
            var poly = polygon, v = polygon;
            if (v.length < 3) {
              return result;
            }
            level++;
            if (level > maxlevel) {
              console.warn("quickDecomp: max level (" + maxlevel + ") reached.");
              return result;
            }
            for (var i = 0; i < polygon.length; ++i) {
              if (polygonIsReflex(poly, i)) {
                reflexVertices.push(poly[i]);
                upperDist = lowerDist = Number.MAX_VALUE;
                for (var j = 0; j < polygon.length; ++j) {
                  if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {
                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1));
                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) {
                      d = sqdist(poly[i], p);
                      if (d < lowerDist) {
                        lowerDist = d;
                        lowerInt = p;
                        lowerIndex = j;
                      }
                    }
                  }
                  if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));
                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {
                      d = sqdist(poly[i], p);
                      if (d < upperDist) {
                        upperDist = d;
                        upperInt = p;
                        upperIndex = j;
                      }
                    }
                  }
                }
                if (lowerIndex === (upperIndex + 1) % polygon.length) {
                  p[0] = (lowerInt[0] + upperInt[0]) / 2;
                  p[1] = (lowerInt[1] + upperInt[1]) / 2;
                  steinerPoints.push(p);
                  if (i < upperIndex) {
                    polygonAppend(lowerPoly, poly, i, upperIndex + 1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    if (lowerIndex !== 0) {
                      polygonAppend(upperPoly, poly, lowerIndex, poly.length);
                    }
                    polygonAppend(upperPoly, poly, 0, i + 1);
                  } else {
                    if (i !== 0) {
                      polygonAppend(lowerPoly, poly, i, poly.length);
                    }
                    polygonAppend(lowerPoly, poly, 0, upperIndex + 1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    polygonAppend(upperPoly, poly, lowerIndex, i + 1);
                  }
                } else {
                  if (lowerIndex > upperIndex) {
                    upperIndex += polygon.length;
                  }
                  closestDist = Number.MAX_VALUE;
                  if (upperIndex < lowerIndex) {
                    return result;
                  }
                  for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                      d = sqdist(polygonAt(poly, i), polygonAt(poly, j));
                      if (d < closestDist && polygonCanSee2(poly, i, j)) {
                        closestDist = d;
                        closestIndex = j % polygon.length;
                      }
                    }
                  }
                  if (i < closestIndex) {
                    polygonAppend(lowerPoly, poly, i, closestIndex + 1);
                    if (closestIndex !== 0) {
                      polygonAppend(upperPoly, poly, closestIndex, v.length);
                    }
                    polygonAppend(upperPoly, poly, 0, i + 1);
                  } else {
                    if (i !== 0) {
                      polygonAppend(lowerPoly, poly, i, v.length);
                    }
                    polygonAppend(lowerPoly, poly, 0, closestIndex + 1);
                    polygonAppend(upperPoly, poly, closestIndex, i + 1);
                  }
                }
                if (lowerPoly.length < upperPoly.length) {
                  polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                  polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                } else {
                  polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                  polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                }
                return result;
              }
            }
            result.push(polygon);
            return result;
          }
          function polygonRemoveCollinearPoints(polygon, precision) {
            var num = 0;
            for (var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {
              if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {
                polygon.splice(i % polygon.length, 1);
                num++;
              }
            }
            return num;
          }
          function polygonRemoveDuplicatePoints(polygon, precision) {
            for (var i = polygon.length - 1; i >= 1; --i) {
              var pi = polygon[i];
              for (var j = i - 1; j >= 0; --j) {
                if (points_eq(pi, polygon[j], precision)) {
                  polygon.splice(i, 1);
                  continue;
                }
              }
            }
          }
          function scalar_eq(a, b, precision) {
            precision = precision || 0;
            return Math.abs(a - b) <= precision;
          }
          function points_eq(a, b, precision) {
            return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);
          }
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Bodies = __webpack_require__(126);
          var Class = __webpack_require__(0);
          var Composites = __webpack_require__(1388);
          var Constraint = __webpack_require__(246);
          var Svg = __webpack_require__(1389);
          var MatterGameObject = __webpack_require__(1489);
          var MatterImage = __webpack_require__(1490);
          var MatterSprite = __webpack_require__(1491);
          var MatterTileBody = __webpack_require__(1390);
          var PhysicsEditorParser = __webpack_require__(1386);
          var PhysicsJSONParser = __webpack_require__(1387);
          var PointerConstraint = __webpack_require__(1492);
          var Vertices = __webpack_require__(94);
          var Factory = new Class({
            initialize: function Factory2(world) {
              this.world = world;
              this.scene = world.scene;
              this.sys = world.scene.sys;
            },
            rectangle: function(x, y, width, height, options) {
              var body = Bodies.rectangle(x, y, width, height, options);
              this.world.add(body);
              return body;
            },
            trapezoid: function(x, y, width, height, slope, options) {
              var body = Bodies.trapezoid(x, y, width, height, slope, options);
              this.world.add(body);
              return body;
            },
            circle: function(x, y, radius, options, maxSides) {
              var body = Bodies.circle(x, y, radius, options, maxSides);
              this.world.add(body);
              return body;
            },
            polygon: function(x, y, sides, radius, options) {
              var body = Bodies.polygon(x, y, sides, radius, options);
              this.world.add(body);
              return body;
            },
            fromVertices: function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
              if (typeof vertexSets === "string") {
                vertexSets = Vertices.fromPath(vertexSets);
              }
              var body = Bodies.fromVertices(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea);
              this.world.add(body);
              return body;
            },
            fromPhysicsEditor: function(x, y, config2, options, addToWorld) {
              if (addToWorld === void 0) {
                addToWorld = true;
              }
              var body = PhysicsEditorParser.parseBody(x, y, config2, options);
              if (addToWorld && !this.world.has(body)) {
                this.world.add(body);
              }
              return body;
            },
            fromSVG: function(x, y, xml, scale, options, addToWorld) {
              if (scale === void 0) {
                scale = 1;
              }
              if (options === void 0) {
                options = {};
              }
              if (addToWorld === void 0) {
                addToWorld = true;
              }
              var path = xml.getElementsByTagName("path");
              var vertexSets = [];
              for (var i = 0; i < path.length; i++) {
                var points = Svg.pathToVertices(path[i], 30);
                if (scale !== 1) {
                  Vertices.scale(points, scale, scale);
                }
                vertexSets.push(points);
              }
              var body = Bodies.fromVertices(x, y, vertexSets, options);
              if (addToWorld) {
                this.world.add(body);
              }
              return body;
            },
            fromJSON: function(x, y, config2, options, addToWorld) {
              if (options === void 0) {
                options = {};
              }
              if (addToWorld === void 0) {
                addToWorld = true;
              }
              var body = PhysicsJSONParser.parseBody(x, y, config2, options);
              if (body && addToWorld) {
                this.world.add(body);
              }
              return body;
            },
            imageStack: function(key, frame, x, y, columns, rows, columnGap, rowGap, options) {
              if (columnGap === void 0) {
                columnGap = 0;
              }
              if (rowGap === void 0) {
                rowGap = 0;
              }
              if (options === void 0) {
                options = {};
              }
              var world = this.world;
              var displayList = this.sys.displayList;
              options.addToWorld = false;
              var stack = Composites.stack(x, y, columns, rows, columnGap, rowGap, function(x2, y2) {
                var image = new MatterImage(world, x2, y2, key, frame, options);
                displayList.add(image);
                return image.body;
              });
              world.add(stack);
              return stack;
            },
            stack: function(x, y, columns, rows, columnGap, rowGap, callback) {
              var stack = Composites.stack(x, y, columns, rows, columnGap, rowGap, callback);
              this.world.add(stack);
              return stack;
            },
            pyramid: function(x, y, columns, rows, columnGap, rowGap, callback) {
              var stack = Composites.pyramid(x, y, columns, rows, columnGap, rowGap, callback);
              this.world.add(stack);
              return stack;
            },
            chain: function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
              return Composites.chain(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options);
            },
            mesh: function(composite, columns, rows, crossBrace, options) {
              return Composites.mesh(composite, columns, rows, crossBrace, options);
            },
            newtonsCradle: function(x, y, number, size, length) {
              var composite = Composites.newtonsCradle(x, y, number, size, length);
              this.world.add(composite);
              return composite;
            },
            car: function(x, y, width, height, wheelSize) {
              var composite = Composites.car(x, y, width, height, wheelSize);
              this.world.add(composite);
              return composite;
            },
            softBody: function(x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
              var composite = Composites.softBody(x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions);
              this.world.add(composite);
              return composite;
            },
            joint: function(bodyA, bodyB, length, stiffness, options) {
              return this.constraint(bodyA, bodyB, length, stiffness, options);
            },
            spring: function(bodyA, bodyB, length, stiffness, options) {
              return this.constraint(bodyA, bodyB, length, stiffness, options);
            },
            constraint: function(bodyA, bodyB, length, stiffness, options) {
              if (stiffness === void 0) {
                stiffness = 1;
              }
              if (options === void 0) {
                options = {};
              }
              options.bodyA = bodyA.type === "body" ? bodyA : bodyA.body;
              options.bodyB = bodyB.type === "body" ? bodyB : bodyB.body;
              if (!isNaN(length)) {
                options.length = length;
              }
              options.stiffness = stiffness;
              var constraint = Constraint.create(options);
              this.world.add(constraint);
              return constraint;
            },
            worldConstraint: function(body, length, stiffness, options) {
              if (stiffness === void 0) {
                stiffness = 1;
              }
              if (options === void 0) {
                options = {};
              }
              options.bodyB = body.type === "body" ? body : body.body;
              if (!isNaN(length)) {
                options.length = length;
              }
              options.stiffness = stiffness;
              var constraint = Constraint.create(options);
              this.world.add(constraint);
              return constraint;
            },
            mouseSpring: function(options) {
              return this.pointerConstraint(options);
            },
            pointerConstraint: function(options) {
              if (options === void 0) {
                options = {};
              }
              if (!options.hasOwnProperty("render")) {
                options.render = {visible: false};
              }
              var pointerConstraint = new PointerConstraint(this.scene, this.world, options);
              this.world.add(pointerConstraint.constraint);
              return pointerConstraint;
            },
            image: function(x, y, key, frame, options) {
              var image = new MatterImage(this.world, x, y, key, frame, options);
              this.sys.displayList.add(image);
              return image;
            },
            tileBody: function(tile, options) {
              return new MatterTileBody(this.world, tile, options);
            },
            sprite: function(x, y, key, frame, options) {
              var sprite = new MatterSprite(this.world, x, y, key, frame, options);
              this.sys.displayList.add(sprite);
              this.sys.updateList.add(sprite);
              return sprite;
            },
            gameObject: function(gameObject, options, addToWorld) {
              return MatterGameObject(this.world, gameObject, options, addToWorld);
            },
            destroy: function() {
              this.world = null;
              this.scene = null;
              this.sys = null;
            }
          });
          module2.exports = Factory;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Components = __webpack_require__(534);
          var GetFastValue = __webpack_require__(2);
          var Vector29 = __webpack_require__(3);
          function hasGetterOrSetter(def) {
            return !!def.get && typeof def.get === "function" || !!def.set && typeof def.set === "function";
          }
          var MatterGameObject = function(world, gameObject, options, addToWorld) {
            if (options === void 0) {
              options = {};
            }
            if (addToWorld === void 0) {
              addToWorld = true;
            }
            var x = gameObject.x;
            var y = gameObject.y;
            gameObject.body = {
              temp: true,
              position: {
                x,
                y
              }
            };
            var mixins = [
              Components.Bounce,
              Components.Collision,
              Components.Force,
              Components.Friction,
              Components.Gravity,
              Components.Mass,
              Components.Sensor,
              Components.SetBody,
              Components.Sleep,
              Components.Static,
              Components.Transform,
              Components.Velocity
            ];
            mixins.forEach(function(mixin) {
              for (var key in mixin) {
                if (hasGetterOrSetter(mixin[key])) {
                  Object.defineProperty(gameObject, key, {
                    get: mixin[key].get,
                    set: mixin[key].set
                  });
                } else {
                  Object.defineProperty(gameObject, key, {value: mixin[key]});
                }
              }
            });
            gameObject.world = world;
            gameObject._tempVec2 = new Vector29(x, y);
            if (options.hasOwnProperty("type") && options.type === "body") {
              gameObject.setExistingBody(options, addToWorld);
            } else {
              var shape = GetFastValue(options, "shape", null);
              if (!shape) {
                shape = "rectangle";
              }
              options.addToWorld = addToWorld;
              gameObject.setBody(shape, options);
            }
            return gameObject;
          };
          module2.exports = MatterGameObject;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(534);
          var GameObject = __webpack_require__(15);
          var GetFastValue = __webpack_require__(2);
          var Image2 = __webpack_require__(124);
          var Pipeline = __webpack_require__(171);
          var Vector29 = __webpack_require__(3);
          var MatterImage = new Class({
            Extends: Image2,
            Mixins: [
              Components.Bounce,
              Components.Collision,
              Components.Force,
              Components.Friction,
              Components.Gravity,
              Components.Mass,
              Components.Sensor,
              Components.SetBody,
              Components.Sleep,
              Components.Static,
              Components.Transform,
              Components.Velocity,
              Pipeline
            ],
            initialize: function MatterImage2(world, x, y, texture, frame, options) {
              GameObject.call(this, world.scene, "Image");
              this._crop = this.resetCropObject();
              this.setTexture(texture, frame);
              this.setSizeToFrame();
              this.setOrigin();
              this.world = world;
              this._tempVec2 = new Vector29(x, y);
              var shape = GetFastValue(options, "shape", null);
              if (shape) {
                this.setBody(shape, options);
              } else {
                this.setRectangle(this.width, this.height, options);
              }
              this.setPosition(x, y);
              this.initPipeline();
            }
          });
          module2.exports = MatterImage;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var AnimationState = __webpack_require__(162);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(534);
          var GameObject = __webpack_require__(15);
          var GetFastValue = __webpack_require__(2);
          var Pipeline = __webpack_require__(171);
          var Sprite = __webpack_require__(73);
          var Vector29 = __webpack_require__(3);
          var MatterSprite = new Class({
            Extends: Sprite,
            Mixins: [
              Components.Bounce,
              Components.Collision,
              Components.Force,
              Components.Friction,
              Components.Gravity,
              Components.Mass,
              Components.Sensor,
              Components.SetBody,
              Components.Sleep,
              Components.Static,
              Components.Transform,
              Components.Velocity,
              Pipeline
            ],
            initialize: function MatterSprite2(world, x, y, texture, frame, options) {
              GameObject.call(this, world.scene, "Sprite");
              this._crop = this.resetCropObject();
              this.anims = new AnimationState(this);
              this.setTexture(texture, frame);
              this.setSizeToFrame();
              this.setOrigin();
              this.world = world;
              this._tempVec2 = new Vector29(x, y);
              var shape = GetFastValue(options, "shape", null);
              if (shape) {
                this.setBody(shape, options);
              } else {
                this.setRectangle(this.width, this.height, options);
              }
              this.setPosition(x, y);
              this.initPipeline();
            }
          });
          module2.exports = MatterSprite;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Bounds = __webpack_require__(117);
          var Class = __webpack_require__(0);
          var Composite = __webpack_require__(163);
          var Constraint = __webpack_require__(246);
          var Detector = __webpack_require__(587);
          var Events = __webpack_require__(586);
          var InputEvents = __webpack_require__(49);
          var Merge = __webpack_require__(143);
          var Sleeping = __webpack_require__(267);
          var Vector29 = __webpack_require__(3);
          var Vertices = __webpack_require__(94);
          var PointerConstraint = new Class({
            initialize: function PointerConstraint2(scene, world, options) {
              if (options === void 0) {
                options = {};
              }
              var defaults = {
                label: "Pointer Constraint",
                pointA: {x: 0, y: 0},
                pointB: {x: 0, y: 0},
                length: 0.01,
                stiffness: 0.1,
                angularStiffness: 1,
                collisionFilter: {
                  category: 1,
                  mask: 4294967295,
                  group: 0
                }
              };
              this.scene = scene;
              this.world = world;
              this.camera = null;
              this.pointer = null;
              this.active = true;
              this.position = new Vector29();
              this.body = null;
              this.part = null;
              this.constraint = Constraint.create(Merge(options, defaults));
              this.world.on(Events.BEFORE_UPDATE, this.update, this);
              scene.sys.input.on(InputEvents.POINTER_DOWN, this.onDown, this);
              scene.sys.input.on(InputEvents.POINTER_UP, this.onUp, this);
            },
            onDown: function(pointer) {
              if (!this.pointer) {
                this.pointer = pointer;
                this.camera = pointer.camera;
              }
            },
            onUp: function(pointer) {
              if (pointer === this.pointer) {
                this.pointer = null;
              }
            },
            getBody: function(pointer) {
              var pos = this.position;
              var constraint = this.constraint;
              this.camera.getWorldPoint(pointer.x, pointer.y, pos);
              var bodies = Composite.allBodies(this.world.localWorld);
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (!body.ignorePointer && Bounds.contains(body.bounds, pos) && Detector.canCollide(body.collisionFilter, constraint.collisionFilter)) {
                  if (this.hitTestBody(body, pos)) {
                    this.world.emit(Events.DRAG_START, body, this.part, this);
                    return true;
                  }
                }
              }
              return false;
            },
            hitTestBody: function(body, position) {
              var constraint = this.constraint;
              var partsLength = body.parts.length;
              var start = partsLength > 1 ? 1 : 0;
              for (var i = start; i < partsLength; i++) {
                var part = body.parts[i];
                if (Vertices.contains(part.vertices, position)) {
                  constraint.pointA = position;
                  constraint.pointB = {x: position.x - body.position.x, y: position.y - body.position.y};
                  constraint.bodyB = body;
                  constraint.angleB = body.angle;
                  Sleeping.set(body, false);
                  this.part = part;
                  this.body = body;
                  return true;
                }
              }
              return false;
            },
            update: function() {
              var pointer = this.pointer;
              var body = this.body;
              if (!this.active || !pointer) {
                if (body) {
                  this.stopDrag();
                }
                return;
              }
              if (!pointer.isDown && body) {
                this.stopDrag();
                return;
              } else if (pointer.isDown) {
                if (!body && !this.getBody(pointer)) {
                  return;
                }
                body = this.body;
                var pos = this.position;
                var constraint = this.constraint;
                this.camera.getWorldPoint(pointer.x, pointer.y, pos);
                constraint.pointA.x = pos.x;
                constraint.pointA.y = pos.y;
                Sleeping.set(body, false);
                this.world.emit(Events.DRAG, body, this);
              }
            },
            stopDrag: function() {
              var body = this.body;
              var constraint = this.constraint;
              constraint.bodyB = null;
              constraint.pointB = null;
              this.pointer = null;
              this.body = null;
              this.part = null;
              if (body) {
                this.world.emit(Events.DRAG_END, body, this);
              }
            },
            destroy: function() {
              this.world.removeConstraint(this.constraint);
              this.pointer = null;
              this.constraint = null;
              this.body = null;
              this.part = null;
              this.world.off(Events.BEFORE_UPDATE, this.update);
              this.scene.sys.input.off(InputEvents.POINTER_DOWN, this.onDown, this);
              this.scene.sys.input.off(InputEvents.POINTER_UP, this.onUp, this);
            }
          });
          module2.exports = PointerConstraint;
        },
        function(module2, exports2, __webpack_require__) {
          var Matter = {};
          module2.exports = Matter;
          var Plugin = __webpack_require__(1392);
          var Common = __webpack_require__(50);
          (function() {
            Matter.name = "matter-js";
            Matter.version = "0.14.2";
            Matter.uses = [];
            Matter.used = [];
            Matter.use = function() {
              Plugin.use(Matter, Array.prototype.slice.call(arguments));
            };
            Matter.before = function(path, func) {
              path = path.replace(/^Matter./, "");
              return Common.chainPathBefore(Matter, path, func);
            };
            Matter.after = function(path, func) {
              path = path.replace(/^Matter./, "");
              return Common.chainPathAfter(Matter, path, func);
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Query = {};
          module2.exports = Query;
          var Vector = __webpack_require__(116);
          var SAT = __webpack_require__(588);
          var Bounds = __webpack_require__(117);
          var Bodies = __webpack_require__(126);
          var Vertices = __webpack_require__(94);
          (function() {
            Query.collides = function(body, bodies) {
              var collisions = [];
              for (var i = 0; i < bodies.length; i++) {
                var bodyA = bodies[i];
                if (body === bodyA) {
                  continue;
                }
                if (Bounds.overlaps(bodyA.bounds, body.bounds)) {
                  for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {
                    var part = bodyA.parts[j];
                    if (Bounds.overlaps(part.bounds, body.bounds)) {
                      var collision = SAT.collides(part, body);
                      if (collision.collided) {
                        collisions.push(collision);
                        break;
                      }
                    }
                  }
                }
              }
              return collisions;
            };
            Query.ray = function(bodies, startPoint, endPoint, rayWidth) {
              rayWidth = rayWidth || 1e-100;
              var rayAngle = Vector.angle(startPoint, endPoint), rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)), rayX = (endPoint.x + startPoint.x) * 0.5, rayY = (endPoint.y + startPoint.y) * 0.5, ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, {angle: rayAngle}), collisions = Query.collides(ray, bodies);
              for (var i = 0; i < collisions.length; i += 1) {
                var collision = collisions[i];
                collision.body = collision.bodyB = collision.bodyA;
              }
              return collisions;
            };
            Query.region = function(bodies, bounds, outside) {
              var result = [];
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i], overlaps = Bounds.overlaps(body.bounds, bounds);
                if (overlaps && !outside || !overlaps && outside)
                  result.push(body);
              }
              return result;
            };
            Query.point = function(bodies, point) {
              var result = [];
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (Bounds.contains(body.bounds, point)) {
                  for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {
                    var part = body.parts[j];
                    if (Bounds.contains(part.bounds, point) && Vertices.contains(part.vertices, point)) {
                      result.push(body);
                      break;
                    }
                  }
                }
              }
              return result;
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Engine = {};
          module2.exports = Engine;
          var World = __webpack_require__(1393);
          var Sleeping = __webpack_require__(267);
          var Resolver = __webpack_require__(1396);
          var Pairs = __webpack_require__(1395);
          var Metrics = __webpack_require__(1528);
          var Grid = __webpack_require__(1394);
          var Events = __webpack_require__(268);
          var Composite = __webpack_require__(163);
          var Constraint = __webpack_require__(246);
          var Common = __webpack_require__(50);
          var Body = __webpack_require__(71);
          (function() {
            Engine.create = function(element, options) {
              options = Common.isElement(element) ? options : element;
              element = Common.isElement(element) ? element : null;
              options = options || {};
              if (element || options.render) {
                Common.warn("Engine.create: engine.render is deprecated (see docs)");
              }
              var defaults = {
                positionIterations: 6,
                velocityIterations: 4,
                constraintIterations: 2,
                enableSleeping: false,
                events: [],
                plugin: {},
                timing: {
                  timestamp: 0,
                  timeScale: 1
                },
                broadphase: {
                  controller: Grid
                }
              };
              var engine = Common.extend(defaults, options);
              engine.world = options.world || World.create(engine.world);
              engine.pairs = Pairs.create();
              engine.broadphase = engine.broadphase.controller.create(engine.broadphase);
              engine.metrics = engine.metrics || {extended: false};
              engine.metrics = Metrics.create(engine.metrics);
              return engine;
            };
            Engine.update = function(engine, delta, correction) {
              delta = delta || 1e3 / 60;
              correction = correction || 1;
              var world = engine.world, timing = engine.timing, broadphase = engine.broadphase, broadphasePairs = [], i;
              timing.timestamp += delta * timing.timeScale;
              var event = {
                timestamp: timing.timestamp
              };
              Events.trigger(engine, "beforeUpdate", event);
              var allBodies = Composite.allBodies(world), allConstraints = Composite.allConstraints(world);
              Metrics.reset(engine.metrics);
              if (engine.enableSleeping)
                Sleeping.update(allBodies, timing.timeScale);
              Engine._bodiesApplyGravity(allBodies, world.gravity);
              Engine._bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);
              Constraint.preSolveAll(allBodies);
              for (i = 0; i < engine.constraintIterations; i++) {
                Constraint.solveAll(allConstraints, timing.timeScale);
              }
              Constraint.postSolveAll(allBodies);
              if (broadphase.controller) {
                if (world.isModified)
                  broadphase.controller.clear(broadphase);
                broadphase.controller.update(broadphase, allBodies, engine, world.isModified);
                broadphasePairs = broadphase.pairsList;
              } else {
                broadphasePairs = allBodies;
              }
              if (world.isModified) {
                Composite.setModified(world, false, false, true);
              }
              var collisions = broadphase.detector(broadphasePairs, engine);
              var pairs = engine.pairs, timestamp = timing.timestamp;
              Pairs.update(pairs, collisions, timestamp);
              Pairs.removeOld(pairs, timestamp);
              if (engine.enableSleeping)
                Sleeping.afterCollisions(pairs.list, timing.timeScale);
              if (pairs.collisionStart.length > 0)
                Events.trigger(engine, "collisionStart", {pairs: pairs.collisionStart});
              Resolver.preSolvePosition(pairs.list);
              for (i = 0; i < engine.positionIterations; i++) {
                Resolver.solvePosition(pairs.list, allBodies, timing.timeScale);
              }
              Resolver.postSolvePosition(allBodies);
              Constraint.preSolveAll(allBodies);
              for (i = 0; i < engine.constraintIterations; i++) {
                Constraint.solveAll(allConstraints, timing.timeScale);
              }
              Constraint.postSolveAll(allBodies);
              Resolver.preSolveVelocity(pairs.list);
              for (i = 0; i < engine.velocityIterations; i++) {
                Resolver.solveVelocity(pairs.list, timing.timeScale);
              }
              if (pairs.collisionActive.length > 0)
                Events.trigger(engine, "collisionActive", {pairs: pairs.collisionActive});
              if (pairs.collisionEnd.length > 0)
                Events.trigger(engine, "collisionEnd", {pairs: pairs.collisionEnd});
              Metrics.update(engine.metrics, engine);
              Engine._bodiesClearForces(allBodies);
              Events.trigger(engine, "afterUpdate", event);
              return engine;
            };
            Engine.merge = function(engineA, engineB) {
              Common.extend(engineA, engineB);
              if (engineB.world) {
                engineA.world = engineB.world;
                Engine.clear(engineA);
                var bodies = Composite.allBodies(engineA.world);
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  Sleeping.set(body, false);
                  body.id = Common.nextId();
                }
              }
            };
            Engine.clear = function(engine) {
              var world = engine.world;
              Pairs.clear(engine.pairs);
              var broadphase = engine.broadphase;
              if (broadphase.controller) {
                var bodies = Composite.allBodies(world);
                broadphase.controller.clear(broadphase);
                broadphase.controller.update(broadphase, bodies, engine, true);
              }
            };
            Engine._bodiesClearForces = function(bodies) {
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                body.force.x = 0;
                body.force.y = 0;
                body.torque = 0;
              }
            };
            Engine._bodiesApplyGravity = function(bodies, gravity) {
              var gravityScale = typeof gravity.scale !== "undefined" ? gravity.scale : 1e-3;
              if (gravity.x === 0 && gravity.y === 0 || gravityScale === 0) {
                return;
              }
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (body.ignoreGravity || body.isStatic || body.isSleeping)
                  continue;
                body.force.x += body.mass * gravity.x * gravityScale * body.gravityScale.x;
                body.force.y += body.mass * gravity.y * gravityScale * body.gravityScale.y;
              }
            };
            Engine._bodiesUpdate = function(bodies, deltaTime, timeScale, correction, worldBounds) {
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (body.isStatic || body.isSleeping)
                  continue;
                Body.update(body, deltaTime, timeScale, correction);
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Bodies = __webpack_require__(126);
          var Body = __webpack_require__(71);
          var Class = __webpack_require__(0);
          var Common = __webpack_require__(50);
          var Composite = __webpack_require__(163);
          var Engine = __webpack_require__(1495);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(586);
          var GetFastValue = __webpack_require__(2);
          var GetValue = __webpack_require__(6);
          var MatterBody = __webpack_require__(71);
          var MatterEvents = __webpack_require__(268);
          var MatterTileBody = __webpack_require__(1390);
          var MatterWorld = __webpack_require__(1393);
          var Vector = __webpack_require__(116);
          var World = new Class({
            Extends: EventEmitter,
            initialize: function World2(scene, config2) {
              EventEmitter.call(this);
              this.scene = scene;
              this.engine = Engine.create(config2);
              this.localWorld = this.engine.world;
              var gravity = GetValue(config2, "gravity", null);
              if (gravity) {
                this.setGravity(gravity.x, gravity.y, gravity.scale);
              } else if (gravity === false) {
                this.setGravity(0, 0, 0);
              }
              this.walls = {left: null, right: null, top: null, bottom: null};
              this.enabled = GetValue(config2, "enabled", true);
              this.correction = GetValue(config2, "correction", 1);
              this.getDelta = GetValue(config2, "getDelta", this.update60Hz);
              var runnerConfig = GetFastValue(config2, "runner", {});
              var hasFPS = GetFastValue(runnerConfig, "fps", false);
              var fps = GetFastValue(runnerConfig, "fps", 60);
              var delta = GetFastValue(runnerConfig, "delta", 1e3 / fps);
              var deltaMin = GetFastValue(runnerConfig, "deltaMin", 1e3 / fps);
              var deltaMax = GetFastValue(runnerConfig, "deltaMax", 1e3 / (fps * 0.5));
              if (!hasFPS) {
                fps = 1e3 / delta;
              }
              this.runner = {
                fps,
                correction: GetFastValue(runnerConfig, "correction", 1),
                deltaSampleSize: GetFastValue(runnerConfig, "deltaSampleSize", 60),
                counterTimestamp: 0,
                frameCounter: 0,
                deltaHistory: [],
                timePrev: null,
                timeScalePrev: 1,
                frameRequestId: null,
                isFixed: GetFastValue(runnerConfig, "isFixed", false),
                delta,
                deltaMin,
                deltaMax
              };
              this.autoUpdate = GetValue(config2, "autoUpdate", true);
              var debugConfig = GetValue(config2, "debug", false);
              this.drawDebug = typeof debugConfig === "object" ? true : debugConfig;
              this.debugGraphic;
              this.debugConfig = {
                showAxes: GetFastValue(debugConfig, "showAxes", false),
                showAngleIndicator: GetFastValue(debugConfig, "showAngleIndicator", false),
                angleColor: GetFastValue(debugConfig, "angleColor", 15208787),
                showBroadphase: GetFastValue(debugConfig, "showBroadphase", false),
                broadphaseColor: GetFastValue(debugConfig, "broadphaseColor", 16757760),
                showBounds: GetFastValue(debugConfig, "showBounds", false),
                boundsColor: GetFastValue(debugConfig, "boundsColor", 16777215),
                showVelocity: GetFastValue(debugConfig, "showVelocity", false),
                velocityColor: GetFastValue(debugConfig, "velocityColor", 44783),
                showCollisions: GetFastValue(debugConfig, "showCollisions", false),
                collisionColor: GetFastValue(debugConfig, "collisionColor", 16094476),
                showSeparations: GetFastValue(debugConfig, "showSeparations", false),
                separationColor: GetFastValue(debugConfig, "separationColor", 16753920),
                showBody: GetFastValue(debugConfig, "showBody", true),
                showStaticBody: GetFastValue(debugConfig, "showStaticBody", true),
                showInternalEdges: GetFastValue(debugConfig, "showInternalEdges", false),
                renderFill: GetFastValue(debugConfig, "renderFill", false),
                renderLine: GetFastValue(debugConfig, "renderLine", true),
                fillColor: GetFastValue(debugConfig, "fillColor", 1075465),
                fillOpacity: GetFastValue(debugConfig, "fillOpacity", 1),
                lineColor: GetFastValue(debugConfig, "lineColor", 2678297),
                lineOpacity: GetFastValue(debugConfig, "lineOpacity", 1),
                lineThickness: GetFastValue(debugConfig, "lineThickness", 1),
                staticFillColor: GetFastValue(debugConfig, "staticFillColor", 857979),
                staticLineColor: GetFastValue(debugConfig, "staticLineColor", 1255396),
                showSleeping: GetFastValue(debugConfig, "showSleeping", false),
                staticBodySleepOpacity: GetFastValue(debugConfig, "staticBodySleepOpacity", 0.7),
                sleepFillColor: GetFastValue(debugConfig, "sleepFillColor", 4605510),
                sleepLineColor: GetFastValue(debugConfig, "sleepLineColor", 10066585),
                showSensors: GetFastValue(debugConfig, "showSensors", true),
                sensorFillColor: GetFastValue(debugConfig, "sensorFillColor", 857979),
                sensorLineColor: GetFastValue(debugConfig, "sensorLineColor", 1255396),
                showPositions: GetFastValue(debugConfig, "showPositions", true),
                positionSize: GetFastValue(debugConfig, "positionSize", 4),
                positionColor: GetFastValue(debugConfig, "positionColor", 14697178),
                showJoint: GetFastValue(debugConfig, "showJoint", true),
                jointColor: GetFastValue(debugConfig, "jointColor", 14737474),
                jointLineOpacity: GetFastValue(debugConfig, "jointLineOpacity", 1),
                jointLineThickness: GetFastValue(debugConfig, "jointLineThickness", 2),
                pinSize: GetFastValue(debugConfig, "pinSize", 4),
                pinColor: GetFastValue(debugConfig, "pinColor", 4382944),
                springColor: GetFastValue(debugConfig, "springColor", 14697184),
                anchorColor: GetFastValue(debugConfig, "anchorColor", 15724527),
                anchorSize: GetFastValue(debugConfig, "anchorSize", 4),
                showConvexHulls: GetFastValue(debugConfig, "showConvexHulls", false),
                hullColor: GetFastValue(debugConfig, "hullColor", 14091216)
              };
              if (this.drawDebug) {
                this.createDebugGraphic();
              }
              this.setEventsProxy();
              if (GetFastValue(config2, "setBounds", false)) {
                var boundsConfig = config2["setBounds"];
                if (typeof boundsConfig === "boolean") {
                  this.setBounds();
                } else {
                  var x = GetFastValue(boundsConfig, "x", 0);
                  var y = GetFastValue(boundsConfig, "y", 0);
                  var width = GetFastValue(boundsConfig, "width", scene.sys.scale.width);
                  var height = GetFastValue(boundsConfig, "height", scene.sys.scale.height);
                  var thickness = GetFastValue(boundsConfig, "thickness", 64);
                  var left = GetFastValue(boundsConfig, "left", true);
                  var right = GetFastValue(boundsConfig, "right", true);
                  var top = GetFastValue(boundsConfig, "top", true);
                  var bottom = GetFastValue(boundsConfig, "bottom", true);
                  this.setBounds(x, y, width, height, thickness, left, right, top, bottom);
                }
              }
            },
            setCompositeRenderStyle: function(composite) {
              var bodies = composite.bodies;
              var constraints = composite.constraints;
              var composites = composite.composites;
              var i;
              var obj;
              var render;
              for (i = 0; i < bodies.length; i++) {
                obj = bodies[i];
                render = obj.render;
                this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);
              }
              for (i = 0; i < constraints.length; i++) {
                obj = constraints[i];
                render = obj.render;
                this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);
              }
              for (i = 0; i < composites.length; i++) {
                obj = composites[i];
                this.setCompositeRenderStyle(obj);
              }
              return this;
            },
            setBodyRenderStyle: function(body, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity) {
              var render = body.render;
              var config2 = this.debugConfig;
              if (!render) {
                return this;
              }
              if (lineColor === void 0 || lineColor === null) {
                lineColor = body.isStatic ? config2.staticLineColor : config2.lineColor;
              }
              if (lineOpacity === void 0 || lineOpacity === null) {
                lineOpacity = config2.lineOpacity;
              }
              if (lineThickness === void 0 || lineThickness === null) {
                lineThickness = config2.lineThickness;
              }
              if (fillColor === void 0 || fillColor === null) {
                fillColor = body.isStatic ? config2.staticFillColor : config2.fillColor;
              }
              if (fillOpacity === void 0 || fillOpacity === null) {
                fillOpacity = config2.fillOpacity;
              }
              if (lineColor !== false) {
                render.lineColor = lineColor;
              }
              if (lineOpacity !== false) {
                render.lineOpacity = lineOpacity;
              }
              if (lineThickness !== false) {
                render.lineThickness = lineThickness;
              }
              if (fillColor !== false) {
                render.fillColor = fillColor;
              }
              if (fillOpacity !== false) {
                render.fillOpacity = fillOpacity;
              }
              return this;
            },
            setConstraintRenderStyle: function(constraint, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize) {
              var render = constraint.render;
              var config2 = this.debugConfig;
              if (!render) {
                return this;
              }
              if (lineColor === void 0 || lineColor === null) {
                var type = render.type;
                if (type === "line") {
                  lineColor = config2.jointColor;
                } else if (type === "pin") {
                  lineColor = config2.pinColor;
                } else if (type === "spring") {
                  lineColor = config2.springColor;
                }
              }
              if (lineOpacity === void 0 || lineOpacity === null) {
                lineOpacity = config2.jointLineOpacity;
              }
              if (lineThickness === void 0 || lineThickness === null) {
                lineThickness = config2.jointLineThickness;
              }
              if (pinSize === void 0 || pinSize === null) {
                pinSize = config2.pinSize;
              }
              if (anchorColor === void 0 || anchorColor === null) {
                anchorColor = config2.anchorColor;
              }
              if (anchorSize === void 0 || anchorSize === null) {
                anchorSize = config2.anchorSize;
              }
              if (lineColor !== false) {
                render.lineColor = lineColor;
              }
              if (lineOpacity !== false) {
                render.lineOpacity = lineOpacity;
              }
              if (lineThickness !== false) {
                render.lineThickness = lineThickness;
              }
              if (pinSize !== false) {
                render.pinSize = pinSize;
              }
              if (anchorColor !== false) {
                render.anchorColor = anchorColor;
              }
              if (anchorSize !== false) {
                render.anchorSize = anchorSize;
              }
              return this;
            },
            setEventsProxy: function() {
              var _this = this;
              var engine = this.engine;
              var world = this.localWorld;
              if (this.drawDebug) {
                MatterEvents.on(world, "compositeModified", function(composite) {
                  _this.setCompositeRenderStyle(composite);
                });
                MatterEvents.on(world, "beforeAdd", function(event) {
                  var objects = [].concat(event.object);
                  for (var i = 0; i < objects.length; i++) {
                    var obj = objects[i];
                    var render = obj.render;
                    if (obj.type === "body") {
                      _this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);
                    } else if (obj.type === "composite") {
                      _this.setCompositeRenderStyle(obj);
                    } else if (obj.type === "constraint") {
                      _this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);
                    }
                  }
                });
              }
              MatterEvents.on(world, "beforeAdd", function(event) {
                _this.emit(Events.BEFORE_ADD, event);
              });
              MatterEvents.on(world, "afterAdd", function(event) {
                _this.emit(Events.AFTER_ADD, event);
              });
              MatterEvents.on(world, "beforeRemove", function(event) {
                _this.emit(Events.BEFORE_REMOVE, event);
              });
              MatterEvents.on(world, "afterRemove", function(event) {
                _this.emit(Events.AFTER_REMOVE, event);
              });
              MatterEvents.on(engine, "beforeUpdate", function(event) {
                _this.emit(Events.BEFORE_UPDATE, event);
              });
              MatterEvents.on(engine, "afterUpdate", function(event) {
                _this.emit(Events.AFTER_UPDATE, event);
              });
              MatterEvents.on(engine, "collisionStart", function(event) {
                var pairs = event.pairs;
                var bodyA;
                var bodyB;
                if (pairs.length > 0) {
                  bodyA = pairs[0].bodyA;
                  bodyB = pairs[0].bodyB;
                }
                _this.emit(Events.COLLISION_START, event, bodyA, bodyB);
              });
              MatterEvents.on(engine, "collisionActive", function(event) {
                var pairs = event.pairs;
                var bodyA;
                var bodyB;
                if (pairs.length > 0) {
                  bodyA = pairs[0].bodyA;
                  bodyB = pairs[0].bodyB;
                }
                _this.emit(Events.COLLISION_ACTIVE, event, bodyA, bodyB);
              });
              MatterEvents.on(engine, "collisionEnd", function(event) {
                var pairs = event.pairs;
                var bodyA;
                var bodyB;
                if (pairs.length > 0) {
                  bodyA = pairs[0].bodyA;
                  bodyB = pairs[0].bodyB;
                }
                _this.emit(Events.COLLISION_END, event, bodyA, bodyB);
              });
            },
            setBounds: function(x, y, width, height, thickness, left, right, top, bottom) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = this.scene.sys.scale.width;
              }
              if (height === void 0) {
                height = this.scene.sys.scale.height;
              }
              if (thickness === void 0) {
                thickness = 64;
              }
              if (left === void 0) {
                left = true;
              }
              if (right === void 0) {
                right = true;
              }
              if (top === void 0) {
                top = true;
              }
              if (bottom === void 0) {
                bottom = true;
              }
              this.updateWall(left, "left", x - thickness, y - thickness, thickness, height + thickness * 2);
              this.updateWall(right, "right", x + width, y - thickness, thickness, height + thickness * 2);
              this.updateWall(top, "top", x, y - thickness, width, thickness);
              this.updateWall(bottom, "bottom", x, y + height, width, thickness);
              return this;
            },
            updateWall: function(add, position, x, y, width, height) {
              var wall = this.walls[position];
              if (add) {
                if (wall) {
                  MatterWorld.remove(this.localWorld, wall);
                }
                x += width / 2;
                y += height / 2;
                this.walls[position] = this.create(x, y, width, height, {isStatic: true, friction: 0, frictionStatic: 0});
              } else {
                if (wall) {
                  MatterWorld.remove(this.localWorld, wall);
                }
                this.walls[position] = null;
              }
            },
            createDebugGraphic: function() {
              var graphic = this.scene.sys.add.graphics({x: 0, y: 0});
              graphic.setDepth(Number.MAX_VALUE);
              this.debugGraphic = graphic;
              this.drawDebug = true;
              return graphic;
            },
            disableGravity: function() {
              this.localWorld.gravity.x = 0;
              this.localWorld.gravity.y = 0;
              this.localWorld.gravity.scale = 0;
              return this;
            },
            setGravity: function(x, y, scale) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 1;
              }
              this.localWorld.gravity.x = x;
              this.localWorld.gravity.y = y;
              if (scale !== void 0) {
                this.localWorld.gravity.scale = scale;
              }
              return this;
            },
            create: function(x, y, width, height, options) {
              var body = Bodies.rectangle(x, y, width, height, options);
              MatterWorld.add(this.localWorld, body);
              return body;
            },
            add: function(object) {
              MatterWorld.add(this.localWorld, object);
              return this;
            },
            remove: function(object, deep) {
              if (!Array.isArray(object)) {
                object = [object];
              }
              for (var i = 0; i < object.length; i++) {
                var entity = object[i];
                var body = entity.body ? entity.body : entity;
                Composite.remove(this.localWorld, body, deep);
              }
              return this;
            },
            removeConstraint: function(constraint, deep) {
              Composite.remove(this.localWorld, constraint, deep);
              return this;
            },
            convertTilemapLayer: function(tilemapLayer, options) {
              var layerData = tilemapLayer.layer;
              var tiles = tilemapLayer.getTilesWithin(0, 0, layerData.width, layerData.height, {isColliding: true});
              this.convertTiles(tiles, options);
              return this;
            },
            convertTiles: function(tiles, options) {
              if (tiles.length === 0) {
                return this;
              }
              for (var i = 0; i < tiles.length; i++) {
                new MatterTileBody(this, tiles[i], options);
              }
              return this;
            },
            nextGroup: function(isNonColliding) {
              return MatterBody.nextGroup(isNonColliding);
            },
            nextCategory: function() {
              return MatterBody.nextCategory();
            },
            pause: function() {
              this.enabled = false;
              this.emit(Events.PAUSE);
              return this;
            },
            resume: function() {
              this.enabled = true;
              this.emit(Events.RESUME);
              return this;
            },
            update: function(time, delta) {
              if (!this.enabled || !this.autoUpdate) {
                return;
              }
              var engine = this.engine;
              var runner = this.runner;
              var timing = engine.timing;
              var correction = this.correction;
              if (runner.isFixed) {
                delta = this.getDelta(time, delta);
              } else {
                delta = time - runner.timePrev || runner.delta;
                runner.timePrev = time;
                runner.deltaHistory.push(delta);
                runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);
                delta = Math.min.apply(null, runner.deltaHistory);
                delta = delta < runner.deltaMin ? runner.deltaMin : delta;
                delta = delta > runner.deltaMax ? runner.deltaMax : delta;
                correction = delta / runner.delta;
                runner.delta = delta;
              }
              if (runner.timeScalePrev !== 0) {
                correction *= timing.timeScale / runner.timeScalePrev;
              }
              if (timing.timeScale === 0) {
                correction = 0;
              }
              runner.timeScalePrev = timing.timeScale;
              runner.correction = correction;
              runner.frameCounter += 1;
              if (time - runner.counterTimestamp >= 1e3) {
                runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1e3);
                runner.counterTimestamp = time;
                runner.frameCounter = 0;
              }
              Engine.update(engine, delta, correction);
            },
            step: function(delta, correction) {
              Engine.update(this.engine, delta, correction);
            },
            update60Hz: function() {
              return 1e3 / 60;
            },
            update30Hz: function() {
              return 1e3 / 30;
            },
            has: function(body) {
              var src = body.hasOwnProperty("body") ? body.body : body;
              return Composite.get(this.localWorld, src.id, src.type) !== null;
            },
            getAllBodies: function() {
              return Composite.allBodies(this.localWorld);
            },
            getAllConstraints: function() {
              return Composite.allConstraints(this.localWorld);
            },
            getAllComposites: function() {
              return Composite.allComposites(this.localWorld);
            },
            postUpdate: function() {
              if (!this.drawDebug) {
                return;
              }
              var config2 = this.debugConfig;
              var engine = this.engine;
              var graphics = this.debugGraphic;
              var bodies = Composite.allBodies(this.localWorld);
              this.debugGraphic.clear();
              if (config2.showBroadphase && engine.broadphase.controller) {
                this.renderGrid(engine.broadphase, graphics, config2.broadphaseColor, 0.5);
              }
              if (config2.showBounds) {
                this.renderBodyBounds(bodies, graphics, config2.boundsColor, 0.5);
              }
              if (config2.showBody || config2.showStaticBody) {
                this.renderBodies(bodies);
              }
              if (config2.showJoint) {
                this.renderJoints();
              }
              if (config2.showAxes || config2.showAngleIndicator) {
                this.renderBodyAxes(bodies, graphics, config2.showAxes, config2.angleColor, 0.5);
              }
              if (config2.showVelocity) {
                this.renderBodyVelocity(bodies, graphics, config2.velocityColor, 1, 2);
              }
              if (config2.showSeparations) {
                this.renderSeparations(engine.pairs.list, graphics, config2.separationColor);
              }
              if (config2.showCollisions) {
                this.renderCollisions(engine.pairs.list, graphics, config2.collisionColor);
              }
            },
            renderGrid: function(grid, graphics, lineColor, lineOpacity) {
              graphics.lineStyle(1, lineColor, lineOpacity);
              var bucketKeys = Common.keys(grid.buckets);
              for (var i = 0; i < bucketKeys.length; i++) {
                var bucketId = bucketKeys[i];
                if (grid.buckets[bucketId].length < 2) {
                  continue;
                }
                var region = bucketId.split(/C|R/);
                graphics.strokeRect(parseInt(region[1], 10) * grid.bucketWidth, parseInt(region[2], 10) * grid.bucketHeight, grid.bucketWidth, grid.bucketHeight);
              }
              return this;
            },
            renderSeparations: function(pairs, graphics, lineColor) {
              graphics.lineStyle(1, lineColor, 1);
              for (var i = 0; i < pairs.length; i++) {
                var pair = pairs[i];
                if (!pair.isActive) {
                  continue;
                }
                var collision = pair.collision;
                var bodyA = collision.bodyA;
                var bodyB = collision.bodyB;
                var posA = bodyA.position;
                var posB = bodyB.position;
                var penetration = collision.penetration;
                var k = !bodyA.isStatic && !bodyB.isStatic ? 4 : 1;
                if (bodyB.isStatic) {
                  k = 0;
                }
                graphics.lineBetween(posB.x, posB.y, posB.x - penetration.x * k, posB.y - penetration.y * k);
                k = !bodyA.isStatic && !bodyB.isStatic ? 4 : 1;
                if (bodyA.isStatic) {
                  k = 0;
                }
                graphics.lineBetween(posA.x, posA.y, posA.x - penetration.x * k, posA.y - penetration.y * k);
              }
              return this;
            },
            renderCollisions: function(pairs, graphics, lineColor) {
              graphics.lineStyle(1, lineColor, 0.5);
              graphics.fillStyle(lineColor, 1);
              var i;
              var pair;
              for (i = 0; i < pairs.length; i++) {
                pair = pairs[i];
                if (!pair.isActive) {
                  continue;
                }
                for (var j = 0; j < pair.activeContacts.length; j++) {
                  var contact = pair.activeContacts[j];
                  var vertex = contact.vertex;
                  graphics.fillRect(vertex.x - 2, vertex.y - 2, 5, 5);
                }
              }
              for (i = 0; i < pairs.length; i++) {
                pair = pairs[i];
                if (!pair.isActive) {
                  continue;
                }
                var collision = pair.collision;
                var contacts = pair.activeContacts;
                if (contacts.length > 0) {
                  var normalPosX = contacts[0].vertex.x;
                  var normalPosY = contacts[0].vertex.y;
                  if (contacts.length === 2) {
                    normalPosX = (contacts[0].vertex.x + contacts[1].vertex.x) / 2;
                    normalPosY = (contacts[0].vertex.y + contacts[1].vertex.y) / 2;
                  }
                  if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic) {
                    graphics.lineBetween(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8, normalPosX, normalPosY);
                  } else {
                    graphics.lineBetween(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8, normalPosX, normalPosY);
                  }
                }
              }
              return this;
            },
            renderBodyBounds: function(bodies, graphics, lineColor, lineOpacity) {
              graphics.lineStyle(1, lineColor, lineOpacity);
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (!body.render.visible) {
                  continue;
                }
                var bounds = body.bounds;
                if (bounds) {
                  graphics.strokeRect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);
                } else {
                  var parts = body.parts;
                  for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    var part = parts[j];
                    graphics.strokeRect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);
                  }
                }
              }
              return this;
            },
            renderBodyAxes: function(bodies, graphics, showAxes, lineColor, lineOpacity) {
              graphics.lineStyle(1, lineColor, lineOpacity);
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                var parts = body.parts;
                if (!body.render.visible) {
                  continue;
                }
                var part;
                var j;
                var k;
                if (showAxes) {
                  for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    part = parts[j];
                    for (k = 0; k < part.axes.length; k++) {
                      var axis = part.axes[k];
                      graphics.lineBetween(part.position.x, part.position.y, part.position.x + axis.x * 20, part.position.y + axis.y * 20);
                    }
                  }
                } else {
                  for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    part = parts[j];
                    for (k = 0; k < part.axes.length; k++) {
                      graphics.lineBetween(part.position.x, part.position.y, (part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2);
                    }
                  }
                }
              }
              return this;
            },
            renderBodyVelocity: function(bodies, graphics, lineColor, lineOpacity, lineThickness) {
              graphics.lineStyle(lineThickness, lineColor, lineOpacity);
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (!body.render.visible) {
                  continue;
                }
                graphics.lineBetween(body.position.x, body.position.y, body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);
              }
              return this;
            },
            renderBodies: function(bodies) {
              var graphics = this.debugGraphic;
              var config2 = this.debugConfig;
              var showBody = config2.showBody;
              var showStaticBody = config2.showStaticBody;
              var showSleeping = config2.showSleeping;
              var showInternalEdges = config2.showInternalEdges;
              var showConvexHulls = config2.showConvexHulls;
              var renderFill = config2.renderFill;
              var renderLine = config2.renderLine;
              var staticBodySleepOpacity = config2.staticBodySleepOpacity;
              var sleepFillColor = config2.sleepFillColor;
              var sleepLineColor = config2.sleepLineColor;
              var hullColor = config2.hullColor;
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (!body.render.visible) {
                  continue;
                }
                if (!showStaticBody && body.isStatic || !showBody && !body.isStatic) {
                  continue;
                }
                var lineColor = body.render.lineColor;
                var lineOpacity = body.render.lineOpacity;
                var lineThickness = body.render.lineThickness;
                var fillColor = body.render.fillColor;
                var fillOpacity = body.render.fillOpacity;
                if (showSleeping && body.isSleeping) {
                  if (body.isStatic) {
                    lineOpacity *= staticBodySleepOpacity;
                    fillOpacity *= staticBodySleepOpacity;
                  } else {
                    lineColor = sleepLineColor;
                    fillColor = sleepFillColor;
                  }
                }
                if (!renderFill) {
                  fillColor = null;
                }
                if (!renderLine) {
                  lineColor = null;
                }
                this.renderBody(body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity);
                var partsLength = body.parts.length;
                if (showConvexHulls && partsLength > 1) {
                  this.renderConvexHull(body, graphics, hullColor, lineThickness);
                }
              }
            },
            renderBody: function(body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity) {
              if (lineColor === void 0) {
                lineColor = null;
              }
              if (lineOpacity === void 0) {
                lineOpacity = null;
              }
              if (lineThickness === void 0) {
                lineThickness = 1;
              }
              if (fillColor === void 0) {
                fillColor = null;
              }
              if (fillOpacity === void 0) {
                fillOpacity = null;
              }
              var config2 = this.debugConfig;
              var sensorFillColor = config2.sensorFillColor;
              var sensorLineColor = config2.sensorLineColor;
              var parts = body.parts;
              var partsLength = parts.length;
              for (var k = partsLength > 1 ? 1 : 0; k < partsLength; k++) {
                var part = parts[k];
                var render = part.render;
                var opacity = render.opacity;
                if (!render.visible || opacity === 0 || part.isSensor && !config2.showSensors) {
                  continue;
                }
                var circleRadius = part.circleRadius;
                graphics.beginPath();
                if (part.isSensor) {
                  if (fillColor !== null) {
                    graphics.fillStyle(sensorFillColor, fillOpacity * opacity);
                  }
                  if (lineColor !== null) {
                    graphics.lineStyle(lineThickness, sensorLineColor, lineOpacity * opacity);
                  }
                } else {
                  if (fillColor !== null) {
                    graphics.fillStyle(fillColor, fillOpacity * opacity);
                  }
                  if (lineColor !== null) {
                    graphics.lineStyle(lineThickness, lineColor, lineOpacity * opacity);
                  }
                }
                if (circleRadius) {
                  graphics.arc(part.position.x, part.position.y, circleRadius, 0, 2 * Math.PI);
                } else {
                  var vertices = part.vertices;
                  var vertLength = vertices.length;
                  graphics.moveTo(vertices[0].x, vertices[0].y);
                  for (var j = 1; j < vertLength; j++) {
                    var vert = vertices[j];
                    if (!vertices[j - 1].isInternal || showInternalEdges) {
                      graphics.lineTo(vert.x, vert.y);
                    } else {
                      graphics.moveTo(vert.x, vert.y);
                    }
                    if (j < vertLength && vert.isInternal && !showInternalEdges) {
                      var nextIndex = (j + 1) % vertLength;
                      graphics.moveTo(vertices[nextIndex].x, vertices[nextIndex].y);
                    }
                  }
                  graphics.closePath();
                }
                if (fillColor !== null) {
                  graphics.fillPath();
                }
                if (lineColor !== null) {
                  graphics.strokePath();
                }
              }
              if (config2.showPositions && !body.isStatic) {
                var px = body.position.x;
                var py = body.position.y;
                var hs = Math.ceil(config2.positionSize / 2);
                graphics.fillStyle(config2.positionColor, 1);
                graphics.fillRect(px - hs, py - hs, config2.positionSize, config2.positionSize);
              }
              return this;
            },
            renderConvexHull: function(body, graphics, hullColor, lineThickness) {
              if (lineThickness === void 0) {
                lineThickness = 1;
              }
              var parts = body.parts;
              var partsLength = parts.length;
              if (partsLength > 1) {
                var verts = body.vertices;
                graphics.lineStyle(lineThickness, hullColor);
                graphics.beginPath();
                graphics.moveTo(verts[0].x, verts[0].y);
                for (var v = 1; v < verts.length; v++) {
                  graphics.lineTo(verts[v].x, verts[v].y);
                }
                graphics.lineTo(verts[0].x, verts[0].y);
                graphics.strokePath();
              }
              return this;
            },
            renderJoints: function() {
              var graphics = this.debugGraphic;
              var constraints = Composite.allConstraints(this.localWorld);
              for (var i = 0; i < constraints.length; i++) {
                var config2 = constraints[i].render;
                var lineColor = config2.lineColor;
                var lineOpacity = config2.lineOpacity;
                var lineThickness = config2.lineThickness;
                var pinSize = config2.pinSize;
                var anchorColor = config2.anchorColor;
                var anchorSize = config2.anchorSize;
                this.renderConstraint(constraints[i], graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize);
              }
            },
            renderConstraint: function(constraint, graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize) {
              var render = constraint.render;
              if (!render.visible || !constraint.pointA || !constraint.pointB) {
                return this;
              }
              graphics.lineStyle(lineThickness, lineColor, lineOpacity);
              var bodyA = constraint.bodyA;
              var bodyB = constraint.bodyB;
              var start;
              var end;
              if (bodyA) {
                start = Vector.add(bodyA.position, constraint.pointA);
              } else {
                start = constraint.pointA;
              }
              if (render.type === "pin") {
                graphics.strokeCircle(start.x, start.y, pinSize);
              } else {
                if (bodyB) {
                  end = Vector.add(bodyB.position, constraint.pointB);
                } else {
                  end = constraint.pointB;
                }
                graphics.beginPath();
                graphics.moveTo(start.x, start.y);
                if (render.type === "spring") {
                  var delta = Vector.sub(end, start);
                  var normal = Vector.perp(Vector.normalise(delta));
                  var coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20));
                  var offset;
                  for (var j = 1; j < coils; j += 1) {
                    offset = j % 2 === 0 ? 1 : -1;
                    graphics.lineTo(start.x + delta.x * (j / coils) + normal.x * offset * 4, start.y + delta.y * (j / coils) + normal.y * offset * 4);
                  }
                }
                graphics.lineTo(end.x, end.y);
              }
              graphics.strokePath();
              if (render.anchors && anchorSize > 0) {
                graphics.fillStyle(anchorColor);
                graphics.fillCircle(start.x, start.y, anchorSize);
                graphics.fillCircle(end.x, end.y, anchorSize);
              }
              return this;
            },
            resetCollisionIDs: function() {
              Body._nextCollidingGroupId = 1;
              Body._nextNonCollidingGroupId = -1;
              Body._nextCategory = 1;
              return this;
            },
            shutdown: function() {
              MatterEvents.off(this.engine);
              this.removeAllListeners();
              MatterWorld.clear(this.localWorld, false);
              Engine.clear(this.engine);
              if (this.drawDebug) {
                this.debugGraphic.destroy();
              }
            },
            destroy: function() {
              this.shutdown();
            }
          });
          module2.exports = World;
        },
        function(module2, exports2, __webpack_require__) {
          (function(global2) {
            /**
            * @author       Richard Davey <rich@photonstorm.com>
            * @copyright    2020 Photon Storm Ltd.
            * @license      {@link https://opensource.org/licenses/MIT|MIT License}
            */
            __webpack_require__(590);
            var CONST = __webpack_require__(32);
            var Extend = __webpack_require__(17);
            var Phaser8 = {
              Actions: __webpack_require__(269),
              Animations: __webpack_require__(699),
              BlendModes: __webpack_require__(34),
              Cache: __webpack_require__(711),
              Cameras: __webpack_require__(714),
              Core: __webpack_require__(803),
              Class: __webpack_require__(0),
              Create: __webpack_require__(884),
              Curves: __webpack_require__(890),
              Data: __webpack_require__(892),
              Display: __webpack_require__(894),
              DOM: __webpack_require__(913),
              Events: __webpack_require__(914),
              Game: __webpack_require__(916),
              GameObjects: __webpack_require__(1007),
              Geom: __webpack_require__(477),
              Input: __webpack_require__(1302),
              Loader: __webpack_require__(1332),
              Math: __webpack_require__(190),
              Physics: __webpack_require__(1498),
              Plugins: __webpack_require__(1397),
              Renderer: __webpack_require__(1399),
              Scale: __webpack_require__(1406),
              ScaleModes: __webpack_require__(164),
              Scene: __webpack_require__(412),
              Scenes: __webpack_require__(1407),
              Structs: __webpack_require__(1409),
              Textures: __webpack_require__(1410),
              Tilemaps: __webpack_require__(1412),
              Time: __webpack_require__(1454),
              Tweens: __webpack_require__(1456),
              Utils: __webpack_require__(1474)
            };
            if (true) {
              Phaser8.Sound = __webpack_require__(1485);
            }
            if (false) {
            }
            if (false) {
            }
            Phaser8 = Extend(false, Phaser8, CONST);
            module2.exports = Phaser8;
            global2.Phaser = Phaser8;
          }).call(this, __webpack_require__(589));
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            Arcade: __webpack_require__(1360),
            Matter: __webpack_require__(1499)
          };
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = {
            BodyBounds: __webpack_require__(1486),
            Components: __webpack_require__(534),
            Events: __webpack_require__(586),
            Factory: __webpack_require__(1488),
            MatterGameObject: __webpack_require__(1489),
            Image: __webpack_require__(1490),
            Matter: __webpack_require__(1391),
            MatterPhysics: __webpack_require__(1529),
            PolyDecomp: __webpack_require__(1487),
            Sprite: __webpack_require__(1491),
            TileBody: __webpack_require__(1390),
            PhysicsEditorParser: __webpack_require__(1386),
            PhysicsJSONParser: __webpack_require__(1387),
            PointerConstraint: __webpack_require__(1492),
            World: __webpack_require__(1496)
          };
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Bounce = {
            setBounce: function(value) {
              this.body.restitution = value;
              return this;
            }
          };
          module2.exports = Bounce;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Collision = {
            setCollisionCategory: function(value) {
              this.body.collisionFilter.category = value;
              return this;
            },
            setCollisionGroup: function(value) {
              this.body.collisionFilter.group = value;
              return this;
            },
            setCollidesWith: function(categories) {
              var flags = 0;
              if (!Array.isArray(categories)) {
                flags = categories;
              } else {
                for (var i = 0; i < categories.length; i++) {
                  flags |= categories[i];
                }
              }
              this.body.collisionFilter.mask = flags;
              return this;
            },
            setOnCollide: function(callback) {
              this.body.onCollideCallback = callback;
              return this;
            },
            setOnCollideEnd: function(callback) {
              this.body.onCollideEndCallback = callback;
              return this;
            },
            setOnCollideActive: function(callback) {
              this.body.onCollideActiveCallback = callback;
              return this;
            },
            setOnCollideWith: function(body, callback) {
              if (!Array.isArray(body)) {
                body = [body];
              }
              for (var i = 0; i < body.length; i++) {
                var src = body[i].hasOwnProperty("body") ? body[i].body : body[i];
                this.body.setOnCollideWith(src, callback);
              }
              return this;
            }
          };
          module2.exports = Collision;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Body = __webpack_require__(71);
          var Force = {
            applyForce: function(force) {
              this._tempVec2.set(this.body.position.x, this.body.position.y);
              Body.applyForce(this.body, this._tempVec2, force);
              return this;
            },
            applyForceFrom: function(position, force) {
              Body.applyForce(this.body, position, force);
              return this;
            },
            thrust: function(speed) {
              var angle = this.body.angle;
              this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
              Body.applyForce(this.body, {x: this.body.position.x, y: this.body.position.y}, this._tempVec2);
              return this;
            },
            thrustLeft: function(speed) {
              var angle = this.body.angle - Math.PI / 2;
              this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
              Body.applyForce(this.body, {x: this.body.position.x, y: this.body.position.y}, this._tempVec2);
              return this;
            },
            thrustRight: function(speed) {
              var angle = this.body.angle + Math.PI / 2;
              this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
              Body.applyForce(this.body, {x: this.body.position.x, y: this.body.position.y}, this._tempVec2);
              return this;
            },
            thrustBack: function(speed) {
              var angle = this.body.angle - Math.PI;
              this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
              Body.applyForce(this.body, {x: this.body.position.x, y: this.body.position.y}, this._tempVec2);
              return this;
            }
          };
          module2.exports = Force;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Friction = {
            setFriction: function(value, air, fstatic) {
              this.body.friction = value;
              if (air !== void 0) {
                this.body.frictionAir = air;
              }
              if (fstatic !== void 0) {
                this.body.frictionStatic = fstatic;
              }
              return this;
            },
            setFrictionAir: function(value) {
              this.body.frictionAir = value;
              return this;
            },
            setFrictionStatic: function(value) {
              this.body.frictionStatic = value;
              return this;
            }
          };
          module2.exports = Friction;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Gravity = {
            setIgnoreGravity: function(value) {
              this.body.ignoreGravity = value;
              return this;
            }
          };
          module2.exports = Gravity;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Body = __webpack_require__(71);
          var Vector29 = __webpack_require__(3);
          var Mass = {
            setMass: function(value) {
              Body.setMass(this.body, value);
              return this;
            },
            setDensity: function(value) {
              Body.setDensity(this.body, value);
              return this;
            },
            centerOfMass: {
              get: function() {
                return new Vector29(this.body.centerOfMass.x, this.body.centerOfMass.y);
              }
            }
          };
          module2.exports = Mass;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Sensor = {
            setSensor: function(value) {
              this.body.isSensor = value;
              return this;
            },
            isSensor: function() {
              return this.body.isSensor;
            }
          };
          module2.exports = Sensor;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Bodies = __webpack_require__(126);
          var Body = __webpack_require__(71);
          var FuzzyEquals = __webpack_require__(123);
          var GetFastValue = __webpack_require__(2);
          var PhysicsEditorParser = __webpack_require__(1386);
          var PhysicsJSONParser = __webpack_require__(1387);
          var Vertices = __webpack_require__(94);
          var SetBody = {
            setRectangle: function(width, height, options) {
              return this.setBody({type: "rectangle", width, height}, options);
            },
            setCircle: function(radius, options) {
              return this.setBody({type: "circle", radius}, options);
            },
            setPolygon: function(radius, sides, options) {
              return this.setBody({type: "polygon", sides, radius}, options);
            },
            setTrapezoid: function(width, height, slope, options) {
              return this.setBody({type: "trapezoid", width, height, slope}, options);
            },
            setExistingBody: function(body, addToWorld) {
              if (addToWorld === void 0) {
                addToWorld = true;
              }
              if (this.body) {
                this.world.remove(this.body, true);
              }
              this.body = body;
              for (var i = 0; i < body.parts.length; i++) {
                body.parts[i].gameObject = this;
              }
              var _this = this;
              body.destroy = function destroy() {
                _this.world.remove(_this.body, true);
                _this.body.gameObject = null;
              };
              if (addToWorld) {
                if (this.world.has(body)) {
                  this.world.remove(body, true);
                }
                this.world.add(body);
              }
              if (this._originComponent) {
                var rx = body.render.sprite.xOffset;
                var ry = body.render.sprite.yOffset;
                var comx = body.centerOfMass.x;
                var comy = body.centerOfMass.y;
                if (FuzzyEquals(comx, 0.5) && FuzzyEquals(comy, 0.5)) {
                  this.setOrigin(rx + 0.5, ry + 0.5);
                } else {
                  var cx = body.centerOffset.x;
                  var cy = body.centerOffset.y;
                  this.setOrigin(rx + cx / this.displayWidth, ry + cy / this.displayHeight);
                }
              }
              return this;
            },
            setBody: function(config2, options) {
              if (!config2) {
                return this;
              }
              var body;
              if (typeof config2 === "string") {
                config2 = {type: config2};
              }
              var shapeType = GetFastValue(config2, "type", "rectangle");
              var bodyX = GetFastValue(config2, "x", this._tempVec2.x);
              var bodyY = GetFastValue(config2, "y", this._tempVec2.y);
              var bodyWidth = GetFastValue(config2, "width", this.width);
              var bodyHeight = GetFastValue(config2, "height", this.height);
              switch (shapeType) {
                case "rectangle":
                  body = Bodies.rectangle(bodyX, bodyY, bodyWidth, bodyHeight, options);
                  break;
                case "circle":
                  var radius = GetFastValue(config2, "radius", Math.max(bodyWidth, bodyHeight) / 2);
                  var maxSides = GetFastValue(config2, "maxSides", 25);
                  body = Bodies.circle(bodyX, bodyY, radius, options, maxSides);
                  break;
                case "trapezoid":
                  var slope = GetFastValue(config2, "slope", 0.5);
                  body = Bodies.trapezoid(bodyX, bodyY, bodyWidth, bodyHeight, slope, options);
                  break;
                case "polygon":
                  var sides = GetFastValue(config2, "sides", 5);
                  var pRadius = GetFastValue(config2, "radius", Math.max(bodyWidth, bodyHeight) / 2);
                  body = Bodies.polygon(bodyX, bodyY, sides, pRadius, options);
                  break;
                case "fromVertices":
                case "fromVerts":
                  var verts = GetFastValue(config2, "verts", null);
                  if (verts) {
                    if (typeof verts === "string") {
                      verts = Vertices.fromPath(verts);
                    }
                    if (this.body && !this.body.hasOwnProperty("temp")) {
                      Body.setVertices(this.body, verts);
                      body = this.body;
                    } else {
                      var flagInternal = GetFastValue(config2, "flagInternal", false);
                      var removeCollinear = GetFastValue(config2, "removeCollinear", 0.01);
                      var minimumArea = GetFastValue(config2, "minimumArea", 10);
                      body = Bodies.fromVertices(bodyX, bodyY, verts, options, flagInternal, removeCollinear, minimumArea);
                    }
                  }
                  break;
                case "fromPhysicsEditor":
                  body = PhysicsEditorParser.parseBody(bodyX, bodyY, config2, options);
                  break;
                case "fromPhysicsTracer":
                  body = PhysicsJSONParser.parseBody(bodyX, bodyY, config2, options);
                  break;
              }
              if (body) {
                this.setExistingBody(body, config2.addToWorld);
              }
              return this;
            }
          };
          module2.exports = SetBody;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Events = __webpack_require__(586);
          var Sleeping = __webpack_require__(267);
          var MatterEvents = __webpack_require__(268);
          var Sleep = {
            setToSleep: function() {
              Sleeping.set(this.body, true);
            },
            setAwake: function() {
              Sleeping.set(this.body, false);
            },
            setSleepThreshold: function(value) {
              if (value === void 0) {
                value = 60;
              }
              this.body.sleepThreshold = value;
              return this;
            },
            setSleepEvents: function(start, end) {
              this.setSleepStartEvent(start);
              this.setSleepEndEvent(end);
              return this;
            },
            setSleepStartEvent: function(value) {
              if (value) {
                var world = this.world;
                MatterEvents.on(this.body, "sleepStart", function(event) {
                  world.emit(Events.SLEEP_START, event, this);
                });
              } else {
                MatterEvents.off(this.body, "sleepStart");
              }
              return this;
            },
            setSleepEndEvent: function(value) {
              if (value) {
                var world = this.world;
                MatterEvents.on(this.body, "sleepEnd", function(event) {
                  world.emit(Events.SLEEP_END, event, this);
                });
              } else {
                MatterEvents.off(this.body, "sleepEnd");
              }
              return this;
            }
          };
          module2.exports = Sleep;
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "afteradd";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "afterremove";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "afterupdate";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "beforeadd";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "beforeremove";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "beforeupdate";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "collisionactive";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "collisionend";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "collisionstart";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "dragend";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "drag";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "dragstart";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "pause";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "resume";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "sleepend";
        },
        function(module2, exports2) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          module2.exports = "sleepstart";
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Body = __webpack_require__(71);
          var Static = {
            setStatic: function(value) {
              Body.setStatic(this.body, value);
              return this;
            },
            isStatic: function() {
              return this.body.isStatic;
            }
          };
          module2.exports = Static;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Body = __webpack_require__(71);
          var MATH_CONST = __webpack_require__(14);
          var WrapAngle = __webpack_require__(265);
          var WrapAngleDegrees = __webpack_require__(266);
          var _FLAG = 4;
          var Transform = {
            x: {
              get: function() {
                return this.body.position.x;
              },
              set: function(value) {
                this._tempVec2.set(value, this.y);
                Body.setPosition(this.body, this._tempVec2);
              }
            },
            y: {
              get: function() {
                return this.body.position.y;
              },
              set: function(value) {
                this._tempVec2.set(this.x, value);
                Body.setPosition(this.body, this._tempVec2);
              }
            },
            scaleX: {
              get: function() {
                return this._scaleX;
              },
              set: function(value) {
                var factorX = 1 / this._scaleX;
                var factorY = 1 / this._scaleY;
                this._scaleX = value;
                if (this._scaleX === 0) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
                Body.scale(this.body, factorX, factorY);
                Body.scale(this.body, value, this._scaleY);
              }
            },
            scaleY: {
              get: function() {
                return this._scaleY;
              },
              set: function(value) {
                var factorX = 1 / this._scaleX;
                var factorY = 1 / this._scaleY;
                this._scaleY = value;
                if (this._scaleY === 0) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
                Body.scale(this.body, factorX, factorY);
                Body.scale(this.body, this._scaleX, value);
              }
            },
            angle: {
              get: function() {
                return WrapAngleDegrees(this.body.angle * MATH_CONST.RAD_TO_DEG);
              },
              set: function(value) {
                this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
              }
            },
            rotation: {
              get: function() {
                return this.body.angle;
              },
              set: function(value) {
                this._rotation = WrapAngle(value);
                Body.setAngle(this.body, this._rotation);
              }
            },
            setPosition: function(x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = x;
              }
              this._tempVec2.set(x, y);
              Body.setPosition(this.body, this._tempVec2);
              return this;
            },
            setRotation: function(radians) {
              if (radians === void 0) {
                radians = 0;
              }
              this._rotation = WrapAngle(radians);
              Body.setAngle(this.body, radians);
              return this;
            },
            setFixedRotation: function() {
              Body.setInertia(this.body, Infinity);
              return this;
            },
            setAngle: function(degrees) {
              if (degrees === void 0) {
                degrees = 0;
              }
              this.angle = degrees;
              Body.setAngle(this.body, this.rotation);
              return this;
            },
            setScale: function(x, y, point) {
              if (x === void 0) {
                x = 1;
              }
              if (y === void 0) {
                y = x;
              }
              var factorX = 1 / this._scaleX;
              var factorY = 1 / this._scaleY;
              this._scaleX = x;
              this._scaleY = y;
              Body.scale(this.body, factorX, factorY, point);
              Body.scale(this.body, x, y, point);
              return this;
            }
          };
          module2.exports = Transform;
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var Body = __webpack_require__(71);
          var Velocity = {
            setAngularVelocity: function(value) {
              Body.setAngularVelocity(this.body, value);
              return this;
            },
            setVelocityX: function(x) {
              this._tempVec2.set(x, this.body.velocity.y);
              Body.setVelocity(this.body, this._tempVec2);
              return this;
            },
            setVelocityY: function(y) {
              this._tempVec2.set(this.body.velocity.x, y);
              Body.setVelocity(this.body, this._tempVec2);
              return this;
            },
            setVelocity: function(x, y) {
              this._tempVec2.set(x, y);
              Body.setVelocity(this.body, this._tempVec2);
              return this;
            }
          };
          module2.exports = Velocity;
        },
        function(module2, exports2, __webpack_require__) {
          var Metrics = {};
          module2.exports = Metrics;
          var Composite = __webpack_require__(163);
          var Common = __webpack_require__(50);
          (function() {
            Metrics.create = function(options) {
              var defaults = {
                extended: false,
                narrowDetections: 0,
                narrowphaseTests: 0,
                narrowReuse: 0,
                narrowReuseCount: 0,
                midphaseTests: 0,
                broadphaseTests: 0,
                narrowEff: 1e-4,
                midEff: 1e-4,
                broadEff: 1e-4,
                collisions: 0,
                buckets: 0,
                bodies: 0,
                pairs: 0
              };
              return Common.extend(defaults, false, options);
            };
            Metrics.reset = function(metrics) {
              if (metrics.extended) {
                metrics.narrowDetections = 0;
                metrics.narrowphaseTests = 0;
                metrics.narrowReuse = 0;
                metrics.narrowReuseCount = 0;
                metrics.midphaseTests = 0;
                metrics.broadphaseTests = 0;
                metrics.narrowEff = 0;
                metrics.midEff = 0;
                metrics.broadEff = 0;
                metrics.collisions = 0;
                metrics.buckets = 0;
                metrics.pairs = 0;
                metrics.bodies = 0;
              }
            };
            Metrics.update = function(metrics, engine) {
              if (metrics.extended) {
                var world = engine.world, bodies = Composite.allBodies(world);
                metrics.collisions = metrics.narrowDetections;
                metrics.pairs = engine.pairs.list.length;
                metrics.bodies = bodies.length;
                metrics.midEff = (metrics.narrowDetections / (metrics.midphaseTests || 1)).toFixed(2);
                metrics.narrowEff = (metrics.narrowDetections / (metrics.narrowphaseTests || 1)).toFixed(2);
                metrics.broadEff = (1 - metrics.broadphaseTests / (bodies.length || 1)).toFixed(2);
                metrics.narrowReuse = (metrics.narrowReuseCount / (metrics.narrowphaseTests || 1)).toFixed(2);
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          /**
           * @author       Richard Davey <rich@photonstorm.com>
           * @copyright    2020 Photon Storm Ltd.
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var ALIGN_CONST = __webpack_require__(122);
          var Axes = __webpack_require__(585);
          var Bodies = __webpack_require__(126);
          var Body = __webpack_require__(71);
          var BodyBounds = __webpack_require__(1486);
          var Bounds = __webpack_require__(117);
          var Class = __webpack_require__(0);
          var Composite = __webpack_require__(163);
          var Composites = __webpack_require__(1388);
          var Constraint = __webpack_require__(246);
          var Detector = __webpack_require__(587);
          var DistanceBetween = __webpack_require__(48);
          var Factory = __webpack_require__(1488);
          var GetFastValue = __webpack_require__(2);
          var GetValue = __webpack_require__(6);
          var Grid = __webpack_require__(1394);
          var MatterAttractors = __webpack_require__(1530);
          var MatterCollisionEvents = __webpack_require__(1531);
          var MatterLib = __webpack_require__(1493);
          var MatterWrap = __webpack_require__(1532);
          var Merge = __webpack_require__(143);
          var Pair = __webpack_require__(535);
          var Pairs = __webpack_require__(1395);
          var Plugin = __webpack_require__(1392);
          var PluginCache = __webpack_require__(24);
          var Query = __webpack_require__(1494);
          var Resolver = __webpack_require__(1396);
          var SAT = __webpack_require__(588);
          var SceneEvents = __webpack_require__(21);
          var Svg = __webpack_require__(1389);
          var Vector = __webpack_require__(116);
          var Vertices = __webpack_require__(94);
          var World = __webpack_require__(1496);
          var MatterPhysics = new Class({
            initialize: function MatterPhysics2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.config = this.getConfig();
              this.world;
              this.add;
              this.bodyBounds;
              this.body = Body;
              this.composite = Composite;
              this.detector = Detector;
              this.grid = Grid;
              this.pair = Pair;
              this.pairs = Pairs;
              this.query = Query;
              this.resolver = Resolver;
              this.sat = SAT;
              this.constraint = Constraint;
              this.bodies = Bodies;
              this.composites = Composites;
              this.axes = Axes;
              this.bounds = Bounds;
              this.svg = Svg;
              this.vector = Vector;
              this.vertices = Vertices;
              this.verts = Vertices;
              this._tempVec2 = Vector.create();
              if (GetValue(this.config, "plugins.collisionevents", true)) {
                this.enableCollisionEventsPlugin();
              }
              if (GetValue(this.config, "plugins.attractors", false)) {
                this.enableAttractorPlugin();
              }
              if (GetValue(this.config, "plugins.wrap", false)) {
                this.enableWrapPlugin();
              }
              Resolver._restingThresh = GetValue(this.config, "restingThresh", 4);
              Resolver._restingThreshTangent = GetValue(this.config, "restingThreshTangent", 6);
              Resolver._positionDampen = GetValue(this.config, "positionDampen", 0.9);
              Resolver._positionWarming = GetValue(this.config, "positionWarming", 0.8);
              Resolver._frictionNormalMultiplier = GetValue(this.config, "frictionNormalMultiplier", 5);
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function() {
              this.world = new World(this.scene, this.config);
              this.add = new Factory(this.world);
              this.bodyBounds = new BodyBounds();
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function() {
              if (!this.world) {
                this.world = new World(this.scene, this.config);
                this.add = new Factory(this.world);
              }
              var eventEmitter = this.systems.events;
              eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);
              eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
              eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            getConfig: function() {
              var gameConfig = this.systems.game.config.physics;
              var sceneConfig = this.systems.settings.physics;
              var config2 = Merge(GetFastValue(sceneConfig, "matter", {}), GetFastValue(gameConfig, "matter", {}));
              return config2;
            },
            enableAttractorPlugin: function() {
              Plugin.register(MatterAttractors);
              Plugin.use(MatterLib, MatterAttractors);
              return this;
            },
            enableWrapPlugin: function() {
              Plugin.register(MatterWrap);
              Plugin.use(MatterLib, MatterWrap);
              return this;
            },
            enableCollisionEventsPlugin: function() {
              Plugin.register(MatterCollisionEvents);
              Plugin.use(MatterLib, MatterCollisionEvents);
              return this;
            },
            pause: function() {
              return this.world.pause();
            },
            resume: function() {
              return this.world.resume();
            },
            set60Hz: function() {
              this.world.getDelta = this.world.update60Hz;
              this.world.autoUpdate = true;
              return this;
            },
            set30Hz: function() {
              this.world.getDelta = this.world.update30Hz;
              this.world.autoUpdate = true;
              return this;
            },
            step: function(delta, correction) {
              this.world.step(delta, correction);
            },
            containsPoint: function(body, x, y) {
              body = this.getMatterBodies(body);
              var position = Vector.create(x, y);
              var result = Query.point(body, position);
              return result.length > 0 ? true : false;
            },
            intersectPoint: function(x, y, bodies) {
              bodies = this.getMatterBodies(bodies);
              var position = Vector.create(x, y);
              var output = [];
              var result = Query.point(bodies, position);
              result.forEach(function(body) {
                if (output.indexOf(body) === -1) {
                  output.push(body);
                }
              });
              return output;
            },
            intersectRect: function(x, y, width, height, outside, bodies) {
              if (outside === void 0) {
                outside = false;
              }
              bodies = this.getMatterBodies(bodies);
              var bounds = {
                min: {x, y},
                max: {x: x + width, y: y + height}
              };
              var output = [];
              var result = Query.region(bodies, bounds, outside);
              result.forEach(function(body) {
                if (output.indexOf(body) === -1) {
                  output.push(body);
                }
              });
              return output;
            },
            intersectRay: function(x1, y1, x2, y2, rayWidth, bodies) {
              if (rayWidth === void 0) {
                rayWidth = 1;
              }
              bodies = this.getMatterBodies(bodies);
              var result = [];
              var collisions = Query.ray(bodies, Vector.create(x1, y1), Vector.create(x2, y2), rayWidth);
              for (var i = 0; i < collisions.length; i++) {
                result.push(collisions[i].body);
              }
              return result;
            },
            intersectBody: function(body, bodies) {
              bodies = this.getMatterBodies(bodies);
              var result = [];
              var collisions = Query.collides(body, bodies);
              for (var i = 0; i < collisions.length; i++) {
                var pair = collisions[i];
                if (pair.bodyA === body) {
                  result.push(pair.bodyB);
                } else {
                  result.push(pair.bodyA);
                }
              }
              return result;
            },
            overlap: function(target, bodies, overlapCallback, processCallback, callbackContext) {
              if (overlapCallback === void 0) {
                overlapCallback = null;
              }
              if (processCallback === void 0) {
                processCallback = null;
              }
              if (callbackContext === void 0) {
                callbackContext = overlapCallback;
              }
              if (!Array.isArray(target)) {
                target = [target];
              }
              target = this.getMatterBodies(target);
              bodies = this.getMatterBodies(bodies);
              var match = false;
              for (var i = 0; i < target.length; i++) {
                var entry = target[i];
                var collisions = Query.collides(entry, bodies);
                for (var c = 0; c < collisions.length; c++) {
                  var info = collisions[c];
                  var bodyB = info.bodyA.id === entry.id ? info.bodyB : info.bodyA;
                  if (!processCallback || processCallback.call(callbackContext, entry, bodyB, info)) {
                    match = true;
                    if (overlapCallback) {
                      overlapCallback.call(callbackContext, entry, bodyB, info);
                    } else if (!processCallback) {
                      return true;
                    }
                  }
                }
              }
              return match;
            },
            setCollisionCategory: function(bodies, value) {
              bodies = this.getMatterBodies(bodies);
              bodies.forEach(function(body) {
                body.collisionFilter.category = value;
              });
              return this;
            },
            setCollisionGroup: function(bodies, value) {
              bodies = this.getMatterBodies(bodies);
              bodies.forEach(function(body) {
                body.collisionFilter.group = value;
              });
              return this;
            },
            setCollidesWith: function(bodies, categories) {
              bodies = this.getMatterBodies(bodies);
              var flags = 0;
              if (!Array.isArray(categories)) {
                flags = categories;
              } else {
                for (var i = 0; i < categories.length; i++) {
                  flags |= categories[i];
                }
              }
              bodies.forEach(function(body) {
                body.collisionFilter.mask = flags;
              });
              return this;
            },
            getMatterBodies: function(bodies) {
              if (!bodies) {
                return this.world.getAllBodies();
              }
              if (!Array.isArray(bodies)) {
                bodies = [bodies];
              }
              var output = [];
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i].hasOwnProperty("body") ? bodies[i].body : bodies[i];
                output.push(body);
              }
              return output;
            },
            setVelocity: function(bodies, x, y) {
              bodies = this.getMatterBodies(bodies);
              var vec2 = this._tempVec2;
              vec2.x = x;
              vec2.y = y;
              bodies.forEach(function(body) {
                Body.setVelocity(body, vec2);
              });
              return this;
            },
            setVelocityX: function(bodies, x) {
              bodies = this.getMatterBodies(bodies);
              var vec2 = this._tempVec2;
              vec2.x = x;
              bodies.forEach(function(body) {
                vec2.y = body.velocity.y;
                Body.setVelocity(body, vec2);
              });
              return this;
            },
            setVelocityY: function(bodies, y) {
              bodies = this.getMatterBodies(bodies);
              var vec2 = this._tempVec2;
              vec2.y = y;
              bodies.forEach(function(body) {
                vec2.x = body.velocity.x;
                Body.setVelocity(body, vec2);
              });
              return this;
            },
            setAngularVelocity: function(bodies, value) {
              bodies = this.getMatterBodies(bodies);
              bodies.forEach(function(body) {
                Body.setAngularVelocity(body, value);
              });
              return this;
            },
            applyForce: function(bodies, force) {
              bodies = this.getMatterBodies(bodies);
              var vec2 = this._tempVec2;
              bodies.forEach(function(body) {
                vec2.x = body.position.x;
                vec2.y = body.position.y;
                Body.applyForce(body, vec2, force);
              });
              return this;
            },
            applyForceFromPosition: function(bodies, position, speed, angle) {
              bodies = this.getMatterBodies(bodies);
              var vec2 = this._tempVec2;
              bodies.forEach(function(body) {
                if (angle === void 0) {
                  angle = body.angle;
                }
                vec2.x = speed * Math.cos(angle);
                vec2.y = speed * Math.sin(angle);
                Body.applyForce(body, position, vec2);
              });
              return this;
            },
            applyForceFromAngle: function(bodies, speed, angle) {
              bodies = this.getMatterBodies(bodies);
              var vec2 = this._tempVec2;
              bodies.forEach(function(body) {
                if (angle === void 0) {
                  angle = body.angle;
                }
                vec2.x = speed * Math.cos(angle);
                vec2.y = speed * Math.sin(angle);
                Body.applyForce(body, {x: body.position.x, y: body.position.y}, vec2);
              });
              return this;
            },
            getConstraintLength: function(constraint) {
              var aX = constraint.pointA.x;
              var aY = constraint.pointA.y;
              var bX = constraint.pointB.x;
              var bY = constraint.pointB.y;
              if (constraint.bodyA) {
                aX += constraint.bodyA.position.x;
                aY += constraint.bodyA.position.y;
              }
              if (constraint.bodyB) {
                bX += constraint.bodyB.position.x;
                bY += constraint.bodyB.position.y;
              }
              return DistanceBetween(aX, aY, bX, bY);
            },
            alignBody: function(body, x, y, align) {
              body = body.hasOwnProperty("body") ? body.body : body;
              var pos;
              switch (align) {
                case ALIGN_CONST.TOP_LEFT:
                case ALIGN_CONST.LEFT_TOP:
                  pos = this.bodyBounds.getTopLeft(body, x, y);
                  break;
                case ALIGN_CONST.TOP_CENTER:
                  pos = this.bodyBounds.getTopCenter(body, x, y);
                  break;
                case ALIGN_CONST.TOP_RIGHT:
                case ALIGN_CONST.RIGHT_TOP:
                  pos = this.bodyBounds.getTopRight(body, x, y);
                  break;
                case ALIGN_CONST.LEFT_CENTER:
                  pos = this.bodyBounds.getLeftCenter(body, x, y);
                  break;
                case ALIGN_CONST.CENTER:
                  pos = this.bodyBounds.getCenter(body, x, y);
                  break;
                case ALIGN_CONST.RIGHT_CENTER:
                  pos = this.bodyBounds.getRightCenter(body, x, y);
                  break;
                case ALIGN_CONST.LEFT_BOTTOM:
                case ALIGN_CONST.BOTTOM_LEFT:
                  pos = this.bodyBounds.getBottomLeft(body, x, y);
                  break;
                case ALIGN_CONST.BOTTOM_CENTER:
                  pos = this.bodyBounds.getBottomCenter(body, x, y);
                  break;
                case ALIGN_CONST.BOTTOM_RIGHT:
                case ALIGN_CONST.RIGHT_BOTTOM:
                  pos = this.bodyBounds.getBottomRight(body, x, y);
                  break;
              }
              if (pos) {
                Body.setPosition(body, pos);
              }
              return this;
            },
            shutdown: function() {
              var eventEmitter = this.systems.events;
              if (this.world) {
                eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);
                eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
              }
              eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
              if (this.add) {
                this.add.destroy();
              }
              if (this.world) {
                this.world.destroy();
              }
              this.add = null;
              this.world = null;
            },
            destroy: function() {
              this.shutdown();
              this.scene.sys.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
            }
          });
          PluginCache.register("MatterPhysics", MatterPhysics, "matterPhysics");
          module2.exports = MatterPhysics;
        },
        function(module2, exports2, __webpack_require__) {
          var Matter = __webpack_require__(1391);
          var MatterAttractors = {
            name: "matter-attractors",
            version: "0.1.7",
            for: "matter-js@^0.14.2",
            silent: true,
            install: function(base) {
              base.after("Body.create", function() {
                MatterAttractors.Body.init(this);
              });
              base.before("Engine.update", function(engine) {
                MatterAttractors.Engine.update(engine);
              });
            },
            Body: {
              init: function(body) {
                body.plugin.attractors = body.plugin.attractors || [];
              }
            },
            Engine: {
              update: function(engine) {
                var bodies = Matter.Composite.allBodies(engine.world);
                for (var i = 0; i < bodies.length; i++) {
                  var bodyA = bodies[i];
                  var attractors = bodyA.plugin.attractors;
                  if (attractors && attractors.length > 0) {
                    for (var j = 0; j < bodies.length; j++) {
                      var bodyB = bodies[j];
                      if (i !== j) {
                        for (var k = 0; k < attractors.length; k++) {
                          var attractor = attractors[k];
                          var forceVector = attractor;
                          if (Matter.Common.isFunction(attractor)) {
                            forceVector = attractor(bodyA, bodyB);
                          }
                          if (forceVector) {
                            Matter.Body.applyForce(bodyB, bodyB.position, forceVector);
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            Attractors: {
              gravityConstant: 1e-3,
              gravity: function(bodyA, bodyB) {
                var bToA = Matter.Vector.sub(bodyB.position, bodyA.position);
                var distanceSq = Matter.Vector.magnitudeSquared(bToA) || 1e-4;
                var normal = Matter.Vector.normalise(bToA);
                var magnitude = -MatterAttractors.Attractors.gravityConstant * (bodyA.mass * bodyB.mass / distanceSq);
                var force = Matter.Vector.mult(normal, magnitude);
                Matter.Body.applyForce(bodyA, bodyA.position, Matter.Vector.neg(force));
                Matter.Body.applyForce(bodyB, bodyB.position, force);
              }
            }
          };
          module2.exports = MatterAttractors;
        },
        function(module2, exports2) {
          /**
           * @author       @dxu https://github.com/dxu/matter-collision-events
           * @author       Richard Davey <rich@photonstorm.com>
           * @license      {@link https://opensource.org/licenses/MIT|MIT License}
           */
          var MatterCollisionEvents = {
            name: "matter-collision-events",
            version: "0.1.6",
            for: "matter-js@^0.14.2",
            silent: true,
            install: function(matter) {
              matter.after("Engine.create", function() {
                matter.Events.on(this, "collisionStart", function(event) {
                  event.pairs.map(function(pair) {
                    var bodyA = pair.bodyA;
                    var bodyB = pair.bodyB;
                    if (bodyA.gameObject) {
                      bodyA.gameObject.emit("collide", bodyA, bodyB, pair);
                    }
                    if (bodyB.gameObject) {
                      bodyB.gameObject.emit("collide", bodyB, bodyA, pair);
                    }
                    matter.Events.trigger(bodyA, "onCollide", {pair});
                    matter.Events.trigger(bodyB, "onCollide", {pair});
                    if (bodyA.onCollideCallback) {
                      bodyA.onCollideCallback(pair);
                    }
                    if (bodyB.onCollideCallback) {
                      bodyB.onCollideCallback(pair);
                    }
                    if (bodyA.onCollideWith[bodyB.id]) {
                      bodyA.onCollideWith[bodyB.id](bodyB, pair);
                    }
                    if (bodyB.onCollideWith[bodyA.id]) {
                      bodyB.onCollideWith[bodyA.id](bodyA, pair);
                    }
                  });
                });
                matter.Events.on(this, "collisionActive", function(event) {
                  event.pairs.map(function(pair) {
                    var bodyA = pair.bodyA;
                    var bodyB = pair.bodyB;
                    if (bodyA.gameObject) {
                      bodyA.gameObject.emit("collideActive", bodyA, bodyB, pair);
                    }
                    if (bodyB.gameObject) {
                      bodyB.gameObject.emit("collideActive", bodyB, bodyA, pair);
                    }
                    matter.Events.trigger(bodyA, "onCollideActive", {pair});
                    matter.Events.trigger(bodyB, "onCollideActive", {pair});
                    if (bodyA.onCollideActiveCallback) {
                      bodyA.onCollideActiveCallback(pair);
                    }
                    if (bodyB.onCollideActiveCallback) {
                      bodyB.onCollideActiveCallback(pair);
                    }
                  });
                });
                matter.Events.on(this, "collisionEnd", function(event) {
                  event.pairs.map(function(pair) {
                    var bodyA = pair.bodyA;
                    var bodyB = pair.bodyB;
                    if (bodyA.gameObject) {
                      bodyA.gameObject.emit("collideEnd", bodyA, bodyB, pair);
                    }
                    if (bodyB.gameObject) {
                      bodyB.gameObject.emit("collideEnd", bodyB, bodyA, pair);
                    }
                    matter.Events.trigger(bodyA, "onCollideEnd", {pair});
                    matter.Events.trigger(bodyB, "onCollideEnd", {pair});
                    if (bodyA.onCollideEndCallback) {
                      bodyA.onCollideEndCallback(pair);
                    }
                    if (bodyB.onCollideEndCallback) {
                      bodyB.onCollideEndCallback(pair);
                    }
                  });
                });
              });
            }
          };
          module2.exports = MatterCollisionEvents;
        },
        function(module2, exports2, __webpack_require__) {
          var Matter = __webpack_require__(1391);
          var MatterWrap = {
            name: "matter-wrap",
            version: "0.1.4",
            for: "matter-js@^0.14.2",
            silent: true,
            install: function(base) {
              base.after("Engine.update", function() {
                MatterWrap.Engine.update(this);
              });
            },
            Engine: {
              update: function(engine) {
                var world = engine.world, bodies = Matter.Composite.allBodies(world), composites = Matter.Composite.allComposites(world);
                for (var i = 0; i < bodies.length; i += 1) {
                  var body = bodies[i];
                  if (body.plugin.wrap) {
                    MatterWrap.Body.wrap(body, body.plugin.wrap);
                  }
                }
                for (i = 0; i < composites.length; i += 1) {
                  var composite = composites[i];
                  if (composite.plugin.wrap) {
                    MatterWrap.Composite.wrap(composite, composite.plugin.wrap);
                  }
                }
              }
            },
            Bounds: {
              wrap: function(objectBounds, bounds) {
                var x = null, y = null;
                if (typeof bounds.min.x !== "undefined" && typeof bounds.max.x !== "undefined") {
                  if (objectBounds.min.x > bounds.max.x) {
                    x = bounds.min.x - objectBounds.max.x;
                  } else if (objectBounds.max.x < bounds.min.x) {
                    x = bounds.max.x - objectBounds.min.x;
                  }
                }
                if (typeof bounds.min.y !== "undefined" && typeof bounds.max.y !== "undefined") {
                  if (objectBounds.min.y > bounds.max.y) {
                    y = bounds.min.y - objectBounds.max.y;
                  } else if (objectBounds.max.y < bounds.min.y) {
                    y = bounds.max.y - objectBounds.min.y;
                  }
                }
                if (x !== null || y !== null) {
                  return {
                    x: x || 0,
                    y: y || 0
                  };
                }
              }
            },
            Body: {
              wrap: function(body, bounds) {
                var translation = MatterWrap.Bounds.wrap(body.bounds, bounds);
                if (translation) {
                  Matter.Body.translate(body, translation);
                }
                return translation;
              }
            },
            Composite: {
              bounds: function(composite) {
                var bodies = Matter.Composite.allBodies(composite), vertices = [];
                for (var i = 0; i < bodies.length; i += 1) {
                  var body = bodies[i];
                  vertices.push(body.bounds.min, body.bounds.max);
                }
                return Matter.Bounds.create(vertices);
              },
              wrap: function(composite, bounds) {
                var translation = MatterWrap.Bounds.wrap(MatterWrap.Composite.bounds(composite), bounds);
                if (translation) {
                  Matter.Composite.translate(composite, translation);
                }
                return translation;
              }
            }
          };
          module2.exports = MatterWrap;
        }
      ]);
    });
  });

  // node_modules/tslib/tslib.js
  var require_tslib = __commonJS((exports, module) => {
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar3;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", {value: true});
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      __extends2 = function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest2 = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = {label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: []}, f, y, t, g;
        return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return {value: op[1], done: false};
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return {value: op[0] ? op[1] : void 0, done: true};
        }
      };
      __createBinding2 = function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __exportStar3 = function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !exports2.hasOwnProperty(p))
            exports2[p] = m[p];
      };
      __values2 = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return {value: o && o[i++], done: !o};
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = {error};
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read2(arguments[i]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? {value: __await2(o[n](v)), done: n === "return"} : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({value: v2, done: d});
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", {value: raw});
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (Object.hasOwnProperty.call(mod, k))
              result[k] = mod[k];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : {default: mod};
      };
      __classPrivateFieldGet2 = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar3);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  });

  // src/main.ts
  var require_main = __commonJS((exports, module) => {
    module.exports = GridEngine;
  });

  // src/Utils/VectorUtils.ts
  var Phaser2 = __toModule(require_phaser());
  var Vector2 = Phaser2.Math.Vector2;
  var VectorUtils = class {
    static vec2str(vec) {
      return `${vec.x}#${vec.y}`;
    }
    static equal(vec1, vec2) {
      return VectorUtils.vec2str(vec1) == VectorUtils.vec2str(vec2);
    }
    static manhattanDistance(pos1, pos2) {
      const xDist = Math.abs(pos1.x - pos2.x);
      const yDist = Math.abs(pos1.y - pos2.y);
      return xDist + yDist;
    }
    static scalarMult(vec, scalar) {
      return vec.clone().multiply(new Vector2(scalar, scalar));
    }
  };

  // src/Movement/TargetMovement/TargetMovement.ts
  var Phaser5 = __toModule(require_phaser());

  // src/Direction/Direction.ts
  var Phaser3 = __toModule(require_phaser());
  var Vector22 = Phaser3.Math.Vector2;
  var Direction;
  (function(Direction2) {
    Direction2["NONE"] = "none";
    Direction2["LEFT"] = "left";
    Direction2["UP_LEFT"] = "up-left";
    Direction2["UP"] = "up";
    Direction2["UP_RIGHT"] = "up-right";
    Direction2["RIGHT"] = "right";
    Direction2["DOWN_RIGHT"] = "down-right";
    Direction2["DOWN"] = "down";
    Direction2["DOWN_LEFT"] = "down-left";
  })(Direction || (Direction = {}));
  function turnCounterClockwise(direction) {
    const mapping = {
      [Direction.LEFT]: Direction.DOWN_LEFT,
      [Direction.UP_LEFT]: Direction.LEFT,
      [Direction.UP]: Direction.UP_LEFT,
      [Direction.UP_RIGHT]: Direction.UP,
      [Direction.RIGHT]: Direction.UP_RIGHT,
      [Direction.DOWN_RIGHT]: Direction.RIGHT,
      [Direction.DOWN]: Direction.DOWN_RIGHT,
      [Direction.DOWN_LEFT]: Direction.DOWN,
      [Direction.NONE]: Direction.NONE
    };
    return mapping[direction];
  }
  function directionVector(direction) {
    const directionVectors = {
      [Direction.UP]: Vector22.UP.clone(),
      [Direction.DOWN]: Vector22.DOWN.clone(),
      [Direction.LEFT]: Vector22.LEFT.clone(),
      [Direction.RIGHT]: Vector22.RIGHT.clone(),
      [Direction.NONE]: Vector22.ZERO.clone(),
      [Direction.UP_LEFT]: new Vector22(-1, -1),
      [Direction.UP_RIGHT]: new Vector22(1, -1),
      [Direction.DOWN_RIGHT]: new Vector22(1, 1),
      [Direction.DOWN_LEFT]: new Vector22(-1, 1)
    };
    return directionVectors[direction];
  }
  function oppositeDirection(direction) {
    const oppositeDirections = {
      [Direction.UP]: Direction.DOWN,
      [Direction.DOWN]: Direction.UP,
      [Direction.LEFT]: Direction.RIGHT,
      [Direction.RIGHT]: Direction.LEFT,
      [Direction.NONE]: Direction.NONE,
      [Direction.UP_LEFT]: Direction.DOWN_RIGHT,
      [Direction.UP_RIGHT]: Direction.DOWN_LEFT,
      [Direction.DOWN_RIGHT]: Direction.UP_LEFT,
      [Direction.DOWN_LEFT]: Direction.UP_RIGHT
    };
    return oppositeDirections[direction];
  }
  var NumberOfDirections;
  (function(NumberOfDirections3) {
    NumberOfDirections3[NumberOfDirections3["FOUR"] = 4] = "FOUR";
    NumberOfDirections3[NumberOfDirections3["EIGHT"] = 8] = "EIGHT";
  })(NumberOfDirections || (NumberOfDirections = {}));

  // src/Algorithms/ShortestPath/Bfs/Bfs.ts
  var Phaser4 = __toModule(require_phaser());
  var Vector23 = Phaser4.Math.Vector2;
  var Bfs = class {
    static getShortestPath(startPos, targetPos, isBlocked) {
      const shortestPath = Bfs.shortestPathBfs(startPos, targetPos, isBlocked);
      return {
        path: Bfs.returnPath(shortestPath.previous, startPos, targetPos),
        closestToTarget: shortestPath.closestToTarget
      };
    }
    static shortestPathBfs(startNode, stopNode, isBlocked) {
      const previous = new Map();
      const visited = new Set();
      const queue = [];
      let closestToTarget = startNode;
      let smallestDistToTarget = VectorUtils.manhattanDistance(startNode, stopNode);
      queue.push({node: startNode, dist: 0});
      visited.add(VectorUtils.vec2str(startNode));
      while (queue.length > 0) {
        const {node, dist} = queue.shift();
        const distToTarget = VectorUtils.manhattanDistance(node, stopNode);
        if (distToTarget < smallestDistToTarget) {
          smallestDistToTarget = distToTarget;
          closestToTarget = node;
        }
        if (VectorUtils.equal(node, stopNode)) {
          return {shortestDistance: dist, previous, closestToTarget};
        }
        for (const neighbour of Bfs.getNeighbours(node, isBlocked)) {
          if (!visited.has(VectorUtils.vec2str(neighbour))) {
            previous.set(VectorUtils.vec2str(neighbour), node);
            queue.push({node: neighbour, dist: dist + 1});
            visited.add(VectorUtils.vec2str(neighbour));
          }
        }
      }
      return {shortestDistance: -1, previous, closestToTarget};
    }
    static getNeighbours(pos, isBlocked) {
      return [
        new Vector23(pos.x, pos.y + 1),
        new Vector23(pos.x + 1, pos.y),
        new Vector23(pos.x - 1, pos.y),
        new Vector23(pos.x, pos.y - 1)
      ].filter((pos2) => !isBlocked(pos2));
    }
    static returnPath(previous, startNode, stopNode) {
      const ret = [];
      let currentNode = stopNode;
      ret.push(currentNode);
      while (!VectorUtils.equal(currentNode, startNode)) {
        currentNode = previous.get(VectorUtils.vec2str(currentNode));
        if (!currentNode)
          return [];
        ret.push(currentNode);
      }
      return ret.reverse();
    }
  };

  // src/Movement/TargetMovement/TargetMovement.ts
  var Vector24 = Phaser5.Math.Vector2;
  var TargetMovement = class {
    constructor(tilemap, targetPos, distance = 0, closestPointIfBlocked = false) {
      this.tilemap = tilemap;
      this.targetPos = targetPos;
      this.distance = distance;
      this.closestPointIfBlocked = closestPointIfBlocked;
      this.isBlocking = (targetPos) => {
        return (pos) => {
          if (VectorUtils.equal(pos, targetPos))
            return false;
          return this.tilemap.isBlocking(pos);
        };
      };
    }
    setCharacter(character) {
      this.character = character;
    }
    update() {
      const {dir, dist} = this.getDirOnShortestPath();
      if (this.noPathExists(dist)) {
        this.character.move(Direction.NONE);
      } else if (dist <= this.distance) {
        this.character.turnTowards(dir);
      } else {
        this.character.move(dir);
      }
    }
    noPathExists(distance) {
      return distance == -1;
    }
    getShortestPath() {
      const {path: shortestPath, closestToTarget} = Bfs.getShortestPath(this.character.getTilePos(), this.targetPos, this.isBlocking(this.targetPos));
      const noPathFound = shortestPath.length == 0;
      if (noPathFound && this.closestPointIfBlocked) {
        const shortestPathToClosestPoint = Bfs.getShortestPath(this.character.getTilePos(), closestToTarget, this.isBlocking(this.targetPos)).path;
        const distOffset = VectorUtils.manhattanDistance(closestToTarget, this.targetPos);
        return {path: shortestPathToClosestPoint, distOffset};
      }
      return {path: shortestPath, distOffset: 0};
    }
    getDirOnShortestPath() {
      const {path: shortestPath, distOffset} = this.getShortestPath();
      if (shortestPath.length == 0)
        return {dir: Direction.NONE, dist: -1};
      if (shortestPath.length == 1)
        return {dir: Direction.NONE, dist: 0};
      const nextField = shortestPath[1];
      const result = {
        dir: void 0,
        dist: shortestPath.length - 1 + distOffset
      };
      if (nextField.x > this.character.getTilePos().x) {
        result.dir = Direction.RIGHT;
      } else if (nextField.x < this.character.getTilePos().x) {
        result.dir = Direction.LEFT;
      } else if (nextField.y < this.character.getTilePos().y) {
        result.dir = Direction.UP;
      } else if (nextField.y > this.character.getTilePos().y) {
        result.dir = Direction.DOWN;
      }
      return result;
    }
  };

  // src/Movement/FollowMovement/FollowMovement.ts
  var FollowMovement = class {
    constructor(gridTilemap, charToFollow, distance = 0, closestPointIfBlocked = false) {
      this.gridTilemap = gridTilemap;
      this.charToFollow = charToFollow;
      this.distance = distance;
      this.closestPointIfBlocked = closestPointIfBlocked;
    }
    setCharacter(character) {
      this.character = character;
    }
    update() {
      const targetMovement = new TargetMovement(this.gridTilemap, this.charToFollow.getTilePos(), this.distance + 1, this.closestPointIfBlocked);
      targetMovement.setCharacter(this.character);
      targetMovement.update();
    }
  };

  // src/GridCharacter/CharacterAnimation/CharacterAnimation.ts
  var _CharacterAnimation = class {
    constructor(sprite, walkingAnimationMapping, characterIndex) {
      this.sprite = sprite;
      this.walkingAnimationMapping = walkingAnimationMapping;
      this.characterIndex = characterIndex;
      this.lastFootLeft = false;
      this.directionToFrameRow = {
        [Direction.DOWN]: 0,
        [Direction.LEFT]: 1,
        [Direction.RIGHT]: 2,
        [Direction.UP]: 3
      };
      this._isEnabled = true;
    }
    setIsEnabled(isEnabled) {
      this._isEnabled = isEnabled;
    }
    isEnabled() {
      return this._isEnabled;
    }
    updateCharacterFrame(movementDirection, hasWalkedHalfATile) {
      if (this._isEnabled) {
        if (hasWalkedHalfATile) {
          this.setStandingFrameDuringWalk(movementDirection);
        } else {
          this.setWalkingFrame(movementDirection);
        }
      }
    }
    setStandingFrame(direction) {
      if (this._isEnabled) {
        this._setStandingFrame(direction);
      }
    }
    setWalkingAnimationMapping(walkingAnimationMapping) {
      this.walkingAnimationMapping = walkingAnimationMapping;
    }
    setStandingFrameDuringWalk(direction) {
      if (!this.isCurrentFrameStanding(direction)) {
        this.lastFootLeft = !this.lastFootLeft;
      }
      this._setStandingFrame(direction);
    }
    setWalkingFrame(direction) {
      const frameRow = this.framesOfDirection(direction);
      this.sprite.setFrame(this.lastFootLeft ? frameRow.rightFoot : frameRow.leftFoot);
    }
    _setStandingFrame(direction) {
      this.sprite.setFrame(this.framesOfDirection(direction).standing);
    }
    isCurrentFrameStanding(direction) {
      return Number(this.sprite.frame.name) == this.framesOfDirection(direction).standing;
    }
    framesOfDirection(direction) {
      if (this.walkingAnimationMapping) {
        return this.getFramesForAnimationMapping(direction);
      }
      return this.getFramesForCharIndex(direction);
    }
    getFramesForAnimationMapping(direction) {
      return this.walkingAnimationMapping[direction];
    }
    getFramesForCharIndex(direction) {
      const charsInRow = this.sprite.texture.source[0].width / this.sprite.width / _CharacterAnimation.FRAMES_CHAR_ROW;
      const playerCharRow = Math.floor(this.characterIndex / charsInRow);
      const playerCharCol = this.characterIndex % charsInRow;
      const framesInRow = charsInRow * _CharacterAnimation.FRAMES_CHAR_ROW;
      const framesInSameRowBefore = _CharacterAnimation.FRAMES_CHAR_ROW * playerCharCol;
      const rows = this.directionToFrameRow[direction] + playerCharRow * _CharacterAnimation.FRAMES_CHAR_COL;
      const startFrame = framesInSameRowBefore + rows * framesInRow;
      return {
        rightFoot: startFrame,
        standing: startFrame + 1,
        leftFoot: startFrame + 2
      };
    }
  };
  var CharacterAnimation = _CharacterAnimation;
  CharacterAnimation.FRAMES_CHAR_ROW = 3;
  CharacterAnimation.FRAMES_CHAR_COL = 4;

  // src/GridCharacter/GridCharacter.ts
  var Phaser7 = __toModule(require_phaser());

  // src/GridTilemap/GridTilemap.ts
  var Phaser6 = __toModule(require_phaser());
  var Vector25 = Phaser6.Math.Vector2;
  var _GridTilemap = class {
    constructor(tilemap, firstLayerAboveChar) {
      this.tilemap = tilemap;
      this.firstLayerAboveChar = firstLayerAboveChar;
      this.characters = new Map();
      this.collisionTilePropertyName = "gm_collide";
      this.setLayerDepths();
    }
    addCharacter(character) {
      this.characters.set(character.getId(), character);
    }
    removeCharacter(charId) {
      this.characters.delete(charId);
    }
    getCharacters() {
      return [...this.characters.values()];
    }
    isBlocking(pos, direction) {
      return this.hasNoTile(pos) || this.hasBlockingTile(pos, direction) || this.hasBlockingChar(pos);
    }
    hasBlockingTile(pos, direction) {
      if (this.hasNoTile(pos))
        return true;
      const collidesPropName = _GridTilemap.ONE_WAY_COLLIDE_PROP_PREFIX + direction;
      return this.tilemap.layers.some((layer) => {
        const tile = this.tilemap.getTileAt(pos.x, pos.y, false, layer.name);
        return tile?.properties && (tile.properties[_GridTilemap.LEGACY_COLLIDE_PROP_NAME] || tile.properties[this.collisionTilePropertyName] || tile.properties[collidesPropName]);
      });
    }
    hasNoTile(pos) {
      return !this.tilemap.layers.some((layer) => this.tilemap.hasTileAt(pos.x, pos.y, layer.name));
    }
    hasBlockingChar(pos) {
      return [...this.characters.values()].some((char) => char.isBlockingTile(pos));
    }
    setCollisionTilePropertyName(name) {
      this.collisionTilePropertyName = name;
    }
    getTileWidth() {
      const tilemapScale = this.tilemap.layers[0].tilemapLayer.scale;
      return this.tilemap.tileWidth * tilemapScale;
    }
    getTileHeight() {
      const tilemapScale = this.tilemap.layers[0].tilemapLayer.scale;
      return this.tilemap.tileHeight * tilemapScale;
    }
    getLayerProp(layer, name) {
      const layerProps = layer.properties;
      const prop = layerProps.find((el) => el.name == name);
      return prop?.value;
    }
    hasLayerProp(layer, name) {
      return this.getLayerProp(layer, name) != void 0;
    }
    isLayerAlwaysOnTop(layerData, layerIndex) {
      return layerIndex >= this.firstLayerAboveChar || this.hasLayerProp(layerData, _GridTilemap.ALWAYS_TOP_PROP_NAME);
    }
    setLayerDepths() {
      const layersToDelete = [];
      this.tilemap.layers.forEach((layerData, layerIndex) => {
        if (this.isLayerAlwaysOnTop(layerData, layerIndex)) {
          layerData.tilemapLayer.setDepth(_GridTilemap.FIRST_PLAYER_LAYER + _GridTilemap.MAX_PLAYER_LAYERS + layerIndex);
        } else if (this.hasLayerProp(layerData, _GridTilemap.HEIGHT_SHIFT_PROP_NAME)) {
          this.createLayerForEachRow(layerData, layerIndex);
          layersToDelete.push(layerData.tilemapLayer);
        } else {
          layerData.tilemapLayer.setDepth(layerIndex);
        }
      });
      layersToDelete.forEach((layer) => layer.destroy());
    }
    createLayerForEachRow(layer, layerIndex) {
      const heightShift = this.getLayerProp(layer, _GridTilemap.HEIGHT_SHIFT_PROP_NAME);
      for (let row = 0; row < layer.height; row++) {
        const newLayer = this.tilemap.createBlankLayer(`${layerIndex}#${row}`, layer.tilemapLayer.tileset);
        for (let col = 0; col < layer.width; col++) {
          newLayer.putTileAt(layer.data[row][col], col, row);
        }
        newLayer.scale = layer.tilemapLayer.scale;
        const makeHigherThanPlayerWhenOnSameLevel = 0.5;
        newLayer.setDepth(_GridTilemap.FIRST_PLAYER_LAYER + row + heightShift - 1 + makeHigherThanPlayerWhenOnSameLevel);
      }
    }
  };
  var GridTilemap = _GridTilemap;
  GridTilemap.MAX_PLAYER_LAYERS = 1e3;
  GridTilemap.FIRST_PLAYER_LAYER = 1e3;
  GridTilemap.ALWAYS_TOP_PROP_NAME = "gm_alwaysTop";
  GridTilemap.HEIGHT_SHIFT_PROP_NAME = "gm_heightShift";
  GridTilemap.ONE_WAY_COLLIDE_PROP_PREFIX = "gm_collide_";
  GridTilemap.LEGACY_COLLIDE_PROP_NAME = "collides";

  // node_modules/tslib/modules/index.js
  var import_tslib = __toModule(require_tslib());
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar: __exportStar2,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet
  } = import_tslib.default;

  // node_modules/rxjs/_esm5/internal/util/isFunction.js
  function isFunction(x) {
    return typeof x === "function";
  }

  // node_modules/rxjs/_esm5/internal/config.js
  var _enable_super_gross_mode_that_will_cause_bad_things = false;
  var config = {
    Promise: void 0,
    set useDeprecatedSynchronousErrorHandling(value) {
      if (value) {
        var error = /* @__PURE__ */ new Error();
        /* @__PURE__ */ console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
      } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
        /* @__PURE__ */ console.log("RxJS: Back to a better error behavior. Thank you. <3");
      }
      _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
      return _enable_super_gross_mode_that_will_cause_bad_things;
    }
  };

  // node_modules/rxjs/_esm5/internal/util/hostReportError.js
  function hostReportError(err) {
    setTimeout(function() {
      throw err;
    }, 0);
  }

  // node_modules/rxjs/_esm5/internal/Observer.js
  var empty = {
    closed: true,
    next: function(value) {
    },
    error: function(err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError(err);
      }
    },
    complete: function() {
    }
  };

  // node_modules/rxjs/_esm5/internal/util/isArray.js
  var isArray = /* @__PURE__ */ function() {
    return Array.isArray || function(x) {
      return x && typeof x.length === "number";
    };
  }();

  // node_modules/rxjs/_esm5/internal/util/isObject.js
  function isObject(x) {
    return x !== null && typeof x === "object";
  }

  // node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js
  var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
    function UnsubscriptionErrorImpl2(errors) {
      Error.call(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
      return this;
    }
    UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
    return UnsubscriptionErrorImpl2;
  }();
  var UnsubscriptionError = UnsubscriptionErrorImpl;

  // node_modules/rxjs/_esm5/internal/Subscription.js
  var Subscription = /* @__PURE__ */ function() {
    function Subscription2(unsubscribe) {
      this.closed = false;
      this._parentOrParents = null;
      this._subscriptions = null;
      if (unsubscribe) {
        this._ctorUnsubscribe = true;
        this._unsubscribe = unsubscribe;
      }
    }
    Subscription2.prototype.unsubscribe = function() {
      var errors;
      if (this.closed) {
        return;
      }
      var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
      this.closed = true;
      this._parentOrParents = null;
      this._subscriptions = null;
      if (_parentOrParents instanceof Subscription2) {
        _parentOrParents.remove(this);
      } else if (_parentOrParents !== null) {
        for (var index = 0; index < _parentOrParents.length; ++index) {
          var parent_1 = _parentOrParents[index];
          parent_1.remove(this);
        }
      }
      if (isFunction(_unsubscribe)) {
        if (_ctorUnsubscribe) {
          this._unsubscribe = void 0;
        }
        try {
          _unsubscribe.call(this);
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
        }
      }
      if (isArray(_subscriptions)) {
        var index = -1;
        var len = _subscriptions.length;
        while (++index < len) {
          var sub = _subscriptions[index];
          if (isObject(sub)) {
            try {
              sub.unsubscribe();
            } catch (e) {
              errors = errors || [];
              if (e instanceof UnsubscriptionError) {
                errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
              } else {
                errors.push(e);
              }
            }
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var subscription = teardown;
      if (!teardown) {
        return Subscription2.EMPTY;
      }
      switch (typeof teardown) {
        case "function":
          subscription = new Subscription2(teardown);
        case "object":
          if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
            return subscription;
          } else if (this.closed) {
            subscription.unsubscribe();
            return subscription;
          } else if (!(subscription instanceof Subscription2)) {
            var tmp = subscription;
            subscription = new Subscription2();
            subscription._subscriptions = [tmp];
          }
          break;
        default: {
          throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
        }
      }
      var _parentOrParents = subscription._parentOrParents;
      if (_parentOrParents === null) {
        subscription._parentOrParents = this;
      } else if (_parentOrParents instanceof Subscription2) {
        if (_parentOrParents === this) {
          return subscription;
        }
        subscription._parentOrParents = [_parentOrParents, this];
      } else if (_parentOrParents.indexOf(this) === -1) {
        _parentOrParents.push(this);
      } else {
        return subscription;
      }
      var subscriptions = this._subscriptions;
      if (subscriptions === null) {
        this._subscriptions = [subscription];
      } else {
        subscriptions.push(subscription);
      }
      return subscription;
    };
    Subscription2.prototype.remove = function(subscription) {
      var subscriptions = this._subscriptions;
      if (subscriptions) {
        var subscriptionIndex = subscriptions.indexOf(subscription);
        if (subscriptionIndex !== -1) {
          subscriptions.splice(subscriptionIndex, 1);
        }
      }
    };
    Subscription2.EMPTY = function(empty2) {
      empty2.closed = true;
      return empty2;
    }(new Subscription2());
    return Subscription2;
  }();
  function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function(errs, err) {
      return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
    }, []);
  }

  // node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
  var rxSubscriber = /* @__PURE__ */ function() {
    return typeof Symbol === "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
  }();

  // node_modules/rxjs/_esm5/internal/Subscriber.js
  var Subscriber = /* @__PURE__ */ function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destinationOrNext, error, complete) {
      var _this = _super.call(this) || this;
      _this.syncErrorValue = null;
      _this.syncErrorThrown = false;
      _this.syncErrorThrowable = false;
      _this.isStopped = false;
      switch (arguments.length) {
        case 0:
          _this.destination = empty;
          break;
        case 1:
          if (!destinationOrNext) {
            _this.destination = empty;
            break;
          }
          if (typeof destinationOrNext === "object") {
            if (destinationOrNext instanceof Subscriber2) {
              _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
              _this.destination = destinationOrNext;
              destinationOrNext.add(_this);
            } else {
              _this.syncErrorThrowable = true;
              _this.destination = new SafeSubscriber(_this, destinationOrNext);
            }
            break;
          }
        default:
          _this.syncErrorThrowable = true;
          _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
          break;
      }
      return _this;
    }
    Subscriber2.prototype[rxSubscriber] = function() {
      return this;
    };
    Subscriber2.create = function(next, error, complete) {
      var subscriber = new Subscriber2(next, error, complete);
      subscriber.syncErrorThrowable = false;
      return subscriber;
    };
    Subscriber2.prototype.next = function(value) {
      if (!this.isStopped) {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (!this.isStopped) {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (this.closed) {
        return;
      }
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      this.destination.error(err);
      this.unsubscribe();
    };
    Subscriber2.prototype._complete = function() {
      this.destination.complete();
      this.unsubscribe();
    };
    Subscriber2.prototype._unsubscribeAndRecycle = function() {
      var _parentOrParents = this._parentOrParents;
      this._parentOrParents = null;
      this.unsubscribe();
      this.closed = false;
      this.isStopped = false;
      this._parentOrParents = _parentOrParents;
      return this;
    };
    return Subscriber2;
  }(Subscription);
  var SafeSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      _this._parentSubscriber = _parentSubscriber;
      var next;
      var context = _this;
      if (isFunction(observerOrNext)) {
        next = observerOrNext;
      } else if (observerOrNext) {
        next = observerOrNext.next;
        error = observerOrNext.error;
        complete = observerOrNext.complete;
        if (observerOrNext !== empty) {
          context = Object.create(observerOrNext);
          if (isFunction(context.unsubscribe)) {
            _this.add(context.unsubscribe.bind(context));
          }
          context.unsubscribe = _this.unsubscribe.bind(_this);
        }
      }
      _this._context = context;
      _this._next = next;
      _this._error = error;
      _this._complete = complete;
      return _this;
    }
    SafeSubscriber2.prototype.next = function(value) {
      if (!this.isStopped && this._next) {
        var _parentSubscriber = this._parentSubscriber;
        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._next, value);
        } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        var _parentSubscriber = this._parentSubscriber;
        var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
        if (this._error) {
          if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(this._error, err);
            this.unsubscribe();
          } else {
            this.__tryOrSetError(_parentSubscriber, this._error, err);
            this.unsubscribe();
          }
        } else if (!_parentSubscriber.syncErrorThrowable) {
          this.unsubscribe();
          if (useDeprecatedSynchronousErrorHandling) {
            throw err;
          }
          hostReportError(err);
        } else {
          if (useDeprecatedSynchronousErrorHandling) {
            _parentSubscriber.syncErrorValue = err;
            _parentSubscriber.syncErrorThrown = true;
          } else {
            hostReportError(err);
          }
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber2.prototype.complete = function() {
      var _this = this;
      if (!this.isStopped) {
        var _parentSubscriber = this._parentSubscriber;
        if (this._complete) {
          var wrappedComplete = function() {
            return _this._complete.call(_this._context);
          };
          if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(wrappedComplete);
            this.unsubscribe();
          } else {
            this.__tryOrSetError(_parentSubscriber, wrappedComplete);
            this.unsubscribe();
          }
        } else {
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value) {
      try {
        fn.call(this._context, value);
      } catch (err) {
        this.unsubscribe();
        if (config.useDeprecatedSynchronousErrorHandling) {
          throw err;
        } else {
          hostReportError(err);
        }
      }
    };
    SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn, value) {
      if (!config.useDeprecatedSynchronousErrorHandling) {
        throw new Error("bad call");
      }
      try {
        fn.call(this._context, value);
      } catch (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
          parent.syncErrorValue = err;
          parent.syncErrorThrown = true;
          return true;
        } else {
          hostReportError(err);
          return true;
        }
      }
      return false;
    };
    SafeSubscriber2.prototype._unsubscribe = function() {
      var _parentSubscriber = this._parentSubscriber;
      this._context = null;
      this._parentSubscriber = null;
      _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber2;
  }(Subscriber);

  // node_modules/rxjs/_esm5/internal/util/canReportError.js
  function canReportError(observer) {
    while (observer) {
      var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
      if (closed_1 || isStopped) {
        return false;
      } else if (destination && destination instanceof Subscriber) {
        observer = destination;
      } else {
        observer = null;
      }
    }
    return true;
  }

  // node_modules/rxjs/_esm5/internal/util/toSubscriber.js
  function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
      if (nextOrObserver instanceof Subscriber) {
        return nextOrObserver;
      }
      if (nextOrObserver[rxSubscriber]) {
        return nextOrObserver[rxSubscriber]();
      }
    }
    if (!nextOrObserver && !error && !complete) {
      return new Subscriber(empty);
    }
    return new Subscriber(nextOrObserver, error, complete);
  }

  // node_modules/rxjs/_esm5/internal/symbol/observable.js
  var observable = /* @__PURE__ */ function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();

  // node_modules/rxjs/_esm5/internal/util/identity.js
  function identity(x) {
    return x;
  }

  // node_modules/rxjs/_esm5/internal/util/pipe.js
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }

  // node_modules/rxjs/_esm5/internal/Observable.js
  var Observable = /* @__PURE__ */ function() {
    function Observable3(subscribe) {
      this._isScalar = false;
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable3.prototype.lift = function(operator) {
      var observable2 = new Observable3();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable3.prototype.subscribe = function(observerOrNext, error, complete) {
      var operator = this.operator;
      var sink = toSubscriber(observerOrNext, error, complete);
      if (operator) {
        sink.add(operator.call(sink, this.source));
      } else {
        sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
      }
      if (config.useDeprecatedSynchronousErrorHandling) {
        if (sink.syncErrorThrowable) {
          sink.syncErrorThrowable = false;
          if (sink.syncErrorThrown) {
            throw sink.syncErrorValue;
          }
        }
      }
      return sink;
    };
    Observable3.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
          sink.syncErrorThrown = true;
          sink.syncErrorValue = err;
        }
        if (canReportError(sink)) {
          sink.error(err);
        } else {
          console.warn(err);
        }
      }
    };
    Observable3.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscription;
        subscription = _this.subscribe(function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            if (subscription) {
              subscription.unsubscribe();
            }
          }
        }, reject, resolve);
      });
    };
    Observable3.prototype._subscribe = function(subscriber) {
      var source = this.source;
      return source && source.subscribe(subscriber);
    };
    Observable3.prototype[observable] = function() {
      return this;
    };
    Observable3.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      if (operations.length === 0) {
        return this;
      }
      return pipeFromArray(operations)(this);
    };
    Observable3.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable3.create = function(subscribe) {
      return new Observable3(subscribe);
    };
    return Observable3;
  }();
  function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
      promiseCtor = config.Promise || Promise;
    }
    if (!promiseCtor) {
      throw new Error("no Promise impl found");
    }
    return promiseCtor;
  }

  // node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
  var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
    function ObjectUnsubscribedErrorImpl2() {
      Error.call(this);
      this.message = "object unsubscribed";
      this.name = "ObjectUnsubscribedError";
      return this;
    }
    ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl2;
  }();
  var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

  // node_modules/rxjs/_esm5/internal/SubjectSubscription.js
  var SubjectSubscription = /* @__PURE__ */ function(_super) {
    __extends(SubjectSubscription2, _super);
    function SubjectSubscription2(subject, subscriber) {
      var _this = _super.call(this) || this;
      _this.subject = subject;
      _this.subscriber = subscriber;
      _this.closed = false;
      return _this;
    }
    SubjectSubscription2.prototype.unsubscribe = function() {
      if (this.closed) {
        return;
      }
      this.closed = true;
      var subject = this.subject;
      var observers = subject.observers;
      this.subject = null;
      if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
        return;
      }
      var subscriberIndex = observers.indexOf(this.subscriber);
      if (subscriberIndex !== -1) {
        observers.splice(subscriberIndex, 1);
      }
    };
    return SubjectSubscription2;
  }(Subscription);

  // node_modules/rxjs/_esm5/internal/Subject.js
  var SubjectSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SubjectSubscriber2, _super);
    function SubjectSubscriber2(destination) {
      var _this = _super.call(this, destination) || this;
      _this.destination = destination;
      return _this;
    }
    return SubjectSubscriber2;
  }(Subscriber);
  var Subject = /* @__PURE__ */ function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.observers = [];
      _this.closed = false;
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype[rxSubscriber] = function() {
      return new SubjectSubscriber(this);
    };
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype.next = function(value) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      if (!this.isStopped) {
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
          copy[i].next(value);
        }
      }
    };
    Subject2.prototype.error = function(err) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      this.hasError = true;
      this.thrownError = err;
      this.isStopped = true;
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();
      for (var i = 0; i < len; i++) {
        copy[i].error(err);
      }
      this.observers.length = 0;
    };
    Subject2.prototype.complete = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      this.isStopped = true;
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();
      for (var i = 0; i < len; i++) {
        copy[i].complete();
      }
      this.observers.length = 0;
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = true;
      this.closed = true;
      this.observers = null;
    };
    Subject2.prototype._trySubscribe = function(subscriber) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else {
        return _super.prototype._trySubscribe.call(this, subscriber);
      }
    };
    Subject2.prototype._subscribe = function(subscriber) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription.EMPTY;
      } else if (this.isStopped) {
        subscriber.complete();
        return Subscription.EMPTY;
      } else {
        this.observers.push(subscriber);
        return new SubjectSubscription(this, subscriber);
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable);
  var AnonymousSubject = /* @__PURE__ */ function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var destination = this.destination;
      if (destination && destination.next) {
        destination.next(value);
      }
    };
    AnonymousSubject2.prototype.error = function(err) {
      var destination = this.destination;
      if (destination && destination.error) {
        this.destination.error(err);
      }
    };
    AnonymousSubject2.prototype.complete = function() {
      var destination = this.destination;
      if (destination && destination.complete) {
        this.destination.complete();
      }
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var source = this.source;
      if (source) {
        return this.source.subscribe(subscriber);
      } else {
        return Subscription.EMPTY;
      }
    };
    return AnonymousSubject2;
  }(Subject);

  // node_modules/rxjs/_esm5/internal/util/subscribeToArray.js
  var subscribeToArray = function(array) {
    return function(subscriber) {
      for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    };
  };

  // node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js
  var subscribeToPromise = function(promise) {
    return function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, hostReportError);
      return subscriber;
    };
  };

  // node_modules/rxjs/_esm5/internal/symbol/iterator.js
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  var iterator = /* @__PURE__ */ getSymbolIterator();

  // node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
  var subscribeToIterable = function(iterable) {
    return function(subscriber) {
      var iterator2 = iterable[iterator]();
      do {
        var item = void 0;
        try {
          item = iterator2.next();
        } catch (err) {
          subscriber.error(err);
          return subscriber;
        }
        if (item.done) {
          subscriber.complete();
          break;
        }
        subscriber.next(item.value);
        if (subscriber.closed) {
          break;
        }
      } while (true);
      if (typeof iterator2.return === "function") {
        subscriber.add(function() {
          if (iterator2.return) {
            iterator2.return();
          }
        });
      }
      return subscriber;
    };
  };

  // node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
  var subscribeToObservable = function(obj) {
    return function(subscriber) {
      var obs = obj[observable]();
      if (typeof obs.subscribe !== "function") {
        throw new TypeError("Provided object does not correctly implement Symbol.observable");
      } else {
        return obs.subscribe(subscriber);
      }
    };
  };

  // node_modules/rxjs/_esm5/internal/util/isArrayLike.js
  var isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
  };

  // node_modules/rxjs/_esm5/internal/util/isPromise.js
  function isPromise(value) {
    return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
  }

  // node_modules/rxjs/_esm5/internal/util/subscribeTo.js
  var subscribeTo = function(result) {
    if (!!result && typeof result[observable] === "function") {
      return subscribeToObservable(result);
    } else if (isArrayLike(result)) {
      return subscribeToArray(result);
    } else if (isPromise(result)) {
      return subscribeToPromise(result);
    } else if (!!result && typeof result[iterator] === "function") {
      return subscribeToIterable(result);
    } else {
      var value = isObject(result) ? "an invalid object" : "'" + result + "'";
      var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
      throw new TypeError(msg);
    }
  };

  // node_modules/rxjs/_esm5/internal/innerSubscribe.js
  var SimpleInnerSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SimpleInnerSubscriber2, _super);
    function SimpleInnerSubscriber2(parent) {
      var _this = _super.call(this) || this;
      _this.parent = parent;
      return _this;
    }
    SimpleInnerSubscriber2.prototype._next = function(value) {
      this.parent.notifyNext(value);
    };
    SimpleInnerSubscriber2.prototype._error = function(error) {
      this.parent.notifyError(error);
      this.unsubscribe();
    };
    SimpleInnerSubscriber2.prototype._complete = function() {
      this.parent.notifyComplete();
      this.unsubscribe();
    };
    return SimpleInnerSubscriber2;
  }(Subscriber);
  var SimpleOuterSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SimpleOuterSubscriber2, _super);
    function SimpleOuterSubscriber2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
      this.destination.next(innerValue);
    };
    SimpleOuterSubscriber2.prototype.notifyError = function(err) {
      this.destination.error(err);
    };
    SimpleOuterSubscriber2.prototype.notifyComplete = function() {
      this.destination.complete();
    };
    return SimpleOuterSubscriber2;
  }(Subscriber);
  function innerSubscribe(result, innerSubscriber) {
    if (innerSubscriber.closed) {
      return void 0;
    }
    if (result instanceof Observable) {
      return result.subscribe(innerSubscriber);
    }
    return subscribeTo(result)(innerSubscriber);
  }

  // node_modules/rxjs/_esm5/internal/operators/filter.js
  function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
      return source.lift(new FilterOperator(predicate, thisArg));
    };
  }
  var FilterOperator = /* @__PURE__ */ function() {
    function FilterOperator2(predicate, thisArg) {
      this.predicate = predicate;
      this.thisArg = thisArg;
    }
    FilterOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator2;
  }();
  var FilterSubscriber = /* @__PURE__ */ function(_super) {
    __extends(FilterSubscriber2, _super);
    function FilterSubscriber2(destination, predicate, thisArg) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.thisArg = thisArg;
      _this.count = 0;
      return _this;
    }
    FilterSubscriber2.prototype._next = function(value) {
      var result;
      try {
        result = this.predicate.call(this.thisArg, value, this.count++);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      if (result) {
        this.destination.next(value);
      }
    };
    return FilterSubscriber2;
  }(Subscriber);

  // src/GridCharacter/GridCharacter.ts
  var Vector26 = Phaser7.Math.Vector2;
  var GridCharacter = class {
    constructor(id, config2) {
      this.id = id;
      this.movementDirection = Direction.NONE;
      this.tileSizePixelsWalked = Vector26.ZERO.clone();
      this._nextTilePos = new Vector26(0, 0);
      this._tilePos = new Vector26(0, 0);
      this.movementStarted$ = new Subject();
      this.movementStopped$ = new Subject();
      this.directionChanged$ = new Subject();
      this.positionChanged$ = new Subject();
      this.positionChangeFinished$ = new Subject();
      this.lastMovementImpulse = Direction.NONE;
      this.facingDirection = Direction.DOWN;
      let characterIndex = 0;
      let walkingAnimationMapping;
      if (typeof config2.walkingAnimationMapping == "number") {
        characterIndex = config2.walkingAnimationMapping;
      } else {
        walkingAnimationMapping = config2.walkingAnimationMapping;
      }
      this.sprite = config2.sprite;
      this.sprite.setOrigin(0, 0);
      this.container = config2.container;
      this.tilemap = config2.tilemap;
      this.speed = config2.speed;
      this.customOffset = new Vector26(config2.offsetX || 0, config2.offsetY || 0);
      this.isIsometric = config2.isometric;
      this.tileSize = config2.tileSize.clone();
      this.animation = new CharacterAnimation(this.sprite, walkingAnimationMapping, characterIndex);
      this.animation.setIsEnabled(config2.walkingAnimationEnabled);
      this.animation.setStandingFrame(Direction.DOWN);
      this.speedPixelsPerSecond = this.createSpeedPixelsPerSecond();
      this.updateZindex();
    }
    getId() {
      return this.id;
    }
    getSpeed() {
      return this.speed;
    }
    setSpeed(speed) {
      this.speed = speed;
    }
    setMovement(movement) {
      this.movement = movement;
      this.movement.setCharacter(this);
    }
    getMovement() {
      return this.movement;
    }
    setWalkingAnimationMapping(walkingAnimationMapping) {
      this.animation.setWalkingAnimationMapping(walkingAnimationMapping);
    }
    setTilePosition(tilePosition) {
      if (this.isMoving())
        return;
      this.nextTilePos = tilePosition;
      this.tilePos = tilePosition;
      this.updateZindex();
      this.setPosition(tilePosition.clone().multiply(this.getTileDistance(Direction.UP_LEFT)).add(this.getOffset()).add(this.customOffset));
    }
    getTilePos() {
      return this.tilePos;
    }
    move(direction) {
      this.lastMovementImpulse = direction;
      if (direction == Direction.NONE)
        return;
      if (this.isMoving())
        return;
      if (this.isBlockingDirection(direction)) {
        this.facingDirection = direction;
        this.animation.setStandingFrame(direction);
        this.directionChanged$.next(direction);
      } else {
        this.startMoving(direction);
      }
    }
    update(delta) {
      this.movement?.update(delta);
      if (this.isMoving()) {
        this.updateCharacterPosition(delta);
      }
      this.lastMovementImpulse = Direction.NONE;
    }
    getMovementDirection() {
      return this.movementDirection;
    }
    isBlockingTile(tilePos) {
      return this.nextTilePos.equals(tilePos) || this.tilePos.equals(tilePos);
    }
    isBlockingDirection(direction) {
      if (direction == Direction.NONE)
        return false;
      return this.tilemap.hasBlockingTile(this.tilePosInDirection(direction), oppositeDirection(this.toMapDirection(direction))) || this.tilemap.hasBlockingChar(this.tilePosInDirection(direction));
    }
    isMoving() {
      return this.movementDirection != Direction.NONE;
    }
    turnTowards(direction) {
      if (this.isMoving())
        return;
      if (direction == Direction.NONE)
        return;
      this.facingDirection = direction;
      this.animation.setStandingFrame(direction);
    }
    getFacingDirection() {
      return this.facingDirection;
    }
    movementStarted() {
      return this.movementStarted$;
    }
    movementStopped() {
      return this.movementStopped$;
    }
    directionChanged() {
      return this.directionChanged$;
    }
    positionChanged() {
      return this.positionChanged$;
    }
    positionChangeFinished() {
      return this.positionChangeFinished$;
    }
    createSpeedPixelsPerSecond() {
      const speedPixelsPerSecond = {
        [Direction.LEFT]: new Vector26(this.tileSize.x, 0),
        [Direction.RIGHT]: new Vector26(this.tileSize.x, 0),
        [Direction.UP]: new Vector26(0, this.tileSize.y),
        [Direction.DOWN]: new Vector26(0, this.tileSize.y),
        [Direction.UP_LEFT]: this.getTileDistance(Direction.UP_LEFT),
        [Direction.UP_RIGHT]: this.getTileDistance(Direction.UP_RIGHT),
        [Direction.DOWN_LEFT]: this.getTileDistance(Direction.DOWN_LEFT),
        [Direction.DOWN_RIGHT]: this.getTileDistance(Direction.DOWN_RIGHT),
        [Direction.NONE]: Vector26.ZERO.clone()
      };
      Object.entries(speedPixelsPerSecond).forEach(([key, val]) => {
        speedPixelsPerSecond[key] = VectorUtils.scalarMult(val, this.speed);
      });
      return speedPixelsPerSecond;
    }
    getTileDistance(direction) {
      if (direction === Direction.NONE)
        return Vector26.ZERO.clone();
      if (!this.isIsometric)
        return this.tileSize.clone();
      switch (direction) {
        case Direction.DOWN:
        case Direction.UP:
        case Direction.LEFT:
        case Direction.RIGHT:
          return this.tileSize.clone();
        default:
          return VectorUtils.scalarMult(this.tileSize, 0.5);
      }
    }
    getOffset() {
      const offsetX = this.tileSize.x / 2 - Math.floor(this.sprite.width * this.sprite.scale / 2);
      const offsetY = -(this.sprite.height * this.sprite.scale) + this.tileSize.y;
      return new Vector26(offsetX, offsetY);
    }
    get nextTilePos() {
      return this._nextTilePos.clone();
    }
    set nextTilePos(newTilePos) {
      this._nextTilePos.x = newTilePos.x;
      this._nextTilePos.y = newTilePos.y;
    }
    get tilePos() {
      return this._tilePos.clone();
    }
    set tilePos(newTilePos) {
      this._tilePos.x = newTilePos.x;
      this._tilePos.y = newTilePos.y;
    }
    updateZindex() {
      const gameObject = this.container || this.sprite;
      gameObject.setDepth(GridTilemap.FIRST_PLAYER_LAYER + this.nextTilePos.y);
    }
    setPosition(position) {
      const gameObject = this.container || this.sprite;
      gameObject.x = position.x;
      gameObject.y = position.y;
    }
    getPosition() {
      const gameObject = this.container || this.sprite;
      return new Vector26(gameObject.x, gameObject.y);
    }
    startMoving(direction) {
      this.movementStarted$.next(direction);
      this.movementDirection = direction;
      this.facingDirection = direction;
      this.updateTilePos();
    }
    updateTilePos() {
      this.tilePos = this.nextTilePos;
      const newTilePos = this.nextTilePos.add(directionVector(this.toMapDirection(this.movementDirection)));
      this.positionChanged$.next({
        exitTile: this.nextTilePos,
        enterTile: newTilePos
      });
      this.nextTilePos = newTilePos;
    }
    toMapDirection(direction) {
      if (!this.isIsometric) {
        return direction;
      } else {
        return turnCounterClockwise(direction);
      }
    }
    tilePosInDirection(direction) {
      return this.nextTilePos.add(directionVector(this.toMapDirection(direction)));
    }
    updateCharacterPosition(delta) {
      const pixelsToWalkThisUpdate = this.getSpeedPerDelta(delta);
      if (!this.willCrossTileBorderThisUpdate(pixelsToWalkThisUpdate)) {
        this.moveCharacterSprite(pixelsToWalkThisUpdate);
      } else if (this.shouldContinueMoving()) {
        this.moveCharacterSprite(pixelsToWalkThisUpdate);
        this.positionChangeFinished$.next({
          exitTile: this.tilePos,
          enterTile: this.nextTilePos
        });
        this.updateTilePos();
      } else {
        this.moveCharacterSpriteRestOfTile();
        this.stopMoving();
      }
    }
    shouldContinueMoving() {
      return this.movementDirection == this.lastMovementImpulse && !this.isBlockingDirection(this.lastMovementImpulse);
    }
    getSpeedPerDelta(delta) {
      const deltaInSeconds = delta / 1e3;
      return this.speedPixelsPerSecond[this.movementDirection].clone().multiply(new Vector26(deltaInSeconds, deltaInSeconds)).multiply(directionVector(this.movementDirection));
    }
    willCrossTileBorderThisUpdate(pixelsToWalkThisUpdate) {
      return this.tileSizePixelsWalked.x + Math.abs(pixelsToWalkThisUpdate.x) >= this.getTileDistance(this.movementDirection).x || this.tileSizePixelsWalked.y + Math.abs(pixelsToWalkThisUpdate.y) >= this.getTileDistance(this.movementDirection).y;
    }
    moveCharacterSpriteRestOfTile() {
      this.moveCharacterSprite(this.getTileDistance(this.movementDirection).clone().subtract(this.tileSizePixelsWalked).multiply(directionVector(this.movementDirection)));
    }
    moveCharacterSprite(speed) {
      const newPlayerPos = this.getPosition().add(speed);
      this.setPosition(newPlayerPos);
      this.tileSizePixelsWalked.x += Math.abs(speed.x);
      this.tileSizePixelsWalked.y += Math.abs(speed.y);
      this.animation.updateCharacterFrame(this.movementDirection, this.hasWalkedHalfATile());
      this.tileSizePixelsWalked.x %= this.getTileDistance(this.movementDirection).x;
      this.tileSizePixelsWalked.y %= this.getTileDistance(this.movementDirection).y;
      if (this.hasWalkedHalfATile()) {
        this.updateZindex();
      }
    }
    stopMoving() {
      this.movementStopped$.next(this.movementDirection);
      this.positionChangeFinished$.next({
        exitTile: this.tilePos,
        enterTile: this.nextTilePos
      });
      this.movementDirection = Direction.NONE;
      this.tilePos = this.nextTilePos;
    }
    hasWalkedHalfATile() {
      return this.tileSizePixelsWalked.x > this.getTileDistance(this.movementDirection).x / 2 || this.tileSizePixelsWalked.y > this.getTileDistance(this.movementDirection).y / 2;
    }
  };

  // src/GridEngine.ts
  var import_phaser = __toModule(require_phaser());

  // src/Movement/RandomMovement/RandomMovement.ts
  var Vector27 = Phaser.Math.Vector2;
  var RandomMovement = class {
    constructor(delay = 0, radius = -1) {
      this.delay = delay;
      this.radius = radius;
    }
    setCharacter(character) {
      this.character = character;
      this.delayLeft = this.delay;
      this.initialRow = character.getTilePos().y;
      this.initialCol = character.getTilePos().x;
      this.stepSize = this.getRandomInt(this.radius) + 1;
      this.stepsWalked = 0;
      this.currentMovementDirection = Direction.NONE;
    }
    update(delta) {
      if (this.shouldContinueWalkingCurrentDirection()) {
        this.stepsWalked++;
        this.character.move(this.currentMovementDirection);
      } else {
        this.delayLeft -= delta;
        if (this.delayLeft <= 0) {
          this.delayLeft = this.delay;
          const dir = this.getFreeRandomDirection();
          this.character.move(dir);
          this.currentMovementDirection = dir;
          this.stepsWalked = 1;
          this.stepSize = this.getRandomInt(this.radius) + 1;
        }
      }
    }
    shouldContinueWalkingCurrentDirection() {
      return this.stepsWalked < this.stepSize && this.currentMovementDirection !== Direction.NONE && !this.character.isBlockingDirection(this.currentMovementDirection) && this.isWithinRadius(this.currentMovementDirection);
    }
    getFreeDirections() {
      const directions = [
        Direction.UP,
        Direction.RIGHT,
        Direction.DOWN,
        Direction.LEFT
      ];
      const unblocked = directions.filter((dir) => !this.character.isBlockingDirection(dir));
      return unblocked.filter((dir) => this.isWithinRadius(dir));
    }
    isWithinRadius(dir) {
      if (this.radius == -1)
        return true;
      const dist = VectorUtils.manhattanDistance(this.character.getTilePos().add(directionVector(dir)), new Vector27(this.initialCol, this.initialRow));
      return dist <= this.radius;
    }
    getFreeRandomDirection() {
      const freeDirections = this.getFreeDirections();
      if (freeDirections.length == 0)
        return Direction.NONE;
      return freeDirections[this.getRandomInt(freeDirections.length)];
    }
    getRandomInt(max) {
      return Math.floor(Math.random() * Math.floor(max));
    }
  };

  // node_modules/rxjs/_esm5/internal/operators/takeUntil.js
  function takeUntil(notifier) {
    return function(source) {
      return source.lift(new TakeUntilOperator(notifier));
    };
  }
  var TakeUntilOperator = /* @__PURE__ */ function() {
    function TakeUntilOperator2(notifier) {
      this.notifier = notifier;
    }
    TakeUntilOperator2.prototype.call = function(subscriber, source) {
      var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
      var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
      if (notifierSubscription && !takeUntilSubscriber.seenValue) {
        takeUntilSubscriber.add(notifierSubscription);
        return source.subscribe(takeUntilSubscriber);
      }
      return takeUntilSubscriber;
    };
    return TakeUntilOperator2;
  }();
  var TakeUntilSubscriber = /* @__PURE__ */ function(_super) {
    __extends(TakeUntilSubscriber2, _super);
    function TakeUntilSubscriber2(destination) {
      var _this = _super.call(this, destination) || this;
      _this.seenValue = false;
      return _this;
    }
    TakeUntilSubscriber2.prototype.notifyNext = function() {
      this.seenValue = true;
      this.complete();
    };
    TakeUntilSubscriber2.prototype.notifyComplete = function() {
    };
    return TakeUntilSubscriber2;
  }(SimpleOuterSubscriber);

  // src/GridEngine.ts
  var Vector28 = Phaser.Math.Vector2;
  var GridEngine = class extends Phaser.Plugins.ScenePlugin {
    constructor(scene, pluginManager) {
      super(scene, pluginManager);
      this.scene = scene;
      this.isCreated = false;
      this.movementStopped$ = new Subject();
      this.movementStarted$ = new Subject();
      this.directionChanged$ = new Subject();
      this.positionChanged$ = new Subject();
      this.positionChangeFinished$ = new Subject();
      this.charRemoved$ = new Subject();
    }
    boot() {
      this.systems.events.on("update", this.update, this);
    }
    create(tilemap, config2) {
      this.isCreated = true;
      this.gridCharacters = new Map();
      this.tilemap = tilemap;
      this.gridTilemap = this.createTilemap(tilemap, config2);
      if (config2.collisionTilePropertyName) {
        this.gridTilemap.setCollisionTilePropertyName(config2.collisionTilePropertyName);
      }
      this.addCharacters(config2);
    }
    getPosition(charId) {
      this.initGuard();
      this.unknownCharGuard(charId);
      return this.gridCharacters.get(charId).getTilePos();
    }
    moveLeft(charId) {
      this.moveChar(charId, Direction.LEFT);
    }
    moveRight(charId) {
      this.moveChar(charId, Direction.RIGHT);
    }
    moveUp(charId) {
      this.moveChar(charId, Direction.UP);
    }
    moveDown(charId) {
      this.moveChar(charId, Direction.DOWN);
    }
    move(charId, direction) {
      this.moveChar(charId, direction);
    }
    moveRandomly(charId, delay = 0, radius = -1) {
      this.initGuard();
      this.unknownCharGuard(charId);
      const randomMovement = new RandomMovement(delay, radius);
      this.gridCharacters.get(charId).setMovement(randomMovement);
    }
    moveTo(charId, targetPos, closestPointIfBlocked = false) {
      this.initGuard();
      this.unknownCharGuard(charId);
      const targetMovement = new TargetMovement(this.gridTilemap, targetPos, 0, closestPointIfBlocked);
      this.gridCharacters.get(charId).setMovement(targetMovement);
    }
    stopMovingRandomly(charId) {
      console.warn("GridEngine: `stopMovingRandomly` is deprecated. Use `stopMovement()` instead.");
      this._stopMovement(charId);
    }
    stopMovement(charId) {
      this._stopMovement(charId);
    }
    setSpeed(charId, speed) {
      this.initGuard();
      this.unknownCharGuard(charId);
      this.gridCharacters.get(charId).setSpeed(speed);
    }
    setWalkingAnimationMapping(charId, walkingAnimationMapping) {
      this.initGuard();
      this.unknownCharGuard(charId);
      this.gridCharacters.get(charId).setWalkingAnimationMapping(walkingAnimationMapping);
    }
    update(_time, delta) {
      if (this.isCreated) {
        if (this.gridCharacters) {
          for (const [_key, val] of this.gridCharacters) {
            val.update(delta);
          }
        }
      }
    }
    addCharacter(charData) {
      this.initGuard();
      if (charData.characterIndex != void 0) {
        console.warn("GridEngine: CharacterConfig property `characterIndex` is deprecated. Use `walkingAnimtionMapping` instead.");
      }
      const charConfig = {
        sprite: charData.sprite,
        speed: charData.speed || 4,
        tilemap: this.gridTilemap,
        tileSize: new Vector28(this.gridTilemap.getTileWidth(), this.gridTilemap.getTileHeight()),
        isometric: this.tilemap.orientation == `${Phaser.Tilemaps.Orientation.ISOMETRIC}`,
        walkingAnimationMapping: charData.walkingAnimationMapping,
        walkingAnimationEnabled: charData.walkingAnimationEnabled,
        container: charData.container,
        offsetX: charData.offsetX,
        offsetY: charData.offsetY
      };
      if (charConfig.walkingAnimationMapping == void 0) {
        charConfig.walkingAnimationMapping = charData.characterIndex;
      }
      if (charConfig.walkingAnimationEnabled == void 0) {
        charConfig.walkingAnimationEnabled = true;
      }
      const gridChar = new GridCharacter(charData.id, charConfig);
      if (charData.facingDirection) {
        gridChar.turnTowards(charData.facingDirection);
      }
      this.gridCharacters.set(charData.id, gridChar);
      gridChar.setTilePosition(charData.startPosition || new Vector28(0, 0));
      this.gridTilemap.addCharacter(gridChar);
      gridChar.movementStopped().pipe(this.takeUntilCharRemoved(gridChar.getId())).subscribe((direction) => {
        this.movementStopped$.next([gridChar.getId(), direction]);
      });
      gridChar.movementStarted().pipe(this.takeUntilCharRemoved(gridChar.getId())).subscribe((direction) => {
        this.movementStarted$.next([gridChar.getId(), direction]);
      });
      gridChar.directionChanged().pipe(this.takeUntilCharRemoved(gridChar.getId())).subscribe((direction) => {
        this.directionChanged$.next([gridChar.getId(), direction]);
      });
      gridChar.positionChanged().pipe(this.takeUntilCharRemoved(gridChar.getId())).subscribe(({exitTile, enterTile}) => {
        this.positionChanged$.next({
          charId: gridChar.getId(),
          exitTile,
          enterTile
        });
      });
      gridChar.positionChangeFinished().pipe(this.takeUntilCharRemoved(gridChar.getId())).subscribe(({exitTile, enterTile}) => {
        this.positionChangeFinished$.next({
          charId: gridChar.getId(),
          exitTile,
          enterTile
        });
      });
    }
    hasCharacter(charId) {
      this.initGuard();
      return this.gridCharacters.has(charId);
    }
    removeCharacter(charId) {
      this.initGuard();
      this.unknownCharGuard(charId);
      this.gridTilemap.removeCharacter(charId);
      this.gridCharacters.delete(charId);
      this.charRemoved$.next(charId);
    }
    removeAllCharacters() {
      this.initGuard();
      for (const charId of this.gridCharacters.keys()) {
        this.removeCharacter(charId);
      }
    }
    getAllCharacters() {
      this.initGuard();
      return [...this.gridCharacters.keys()];
    }
    follow(charId, charIdToFollow, distance = 0, closestPointIfBlocked = false) {
      this.initGuard();
      this.unknownCharGuard(charId);
      this.unknownCharGuard(charIdToFollow);
      const followMovement = new FollowMovement(this.gridTilemap, this.gridCharacters.get(charIdToFollow), distance, closestPointIfBlocked);
      this.gridCharacters.get(charId).setMovement(followMovement);
    }
    stopFollowing(charId) {
      console.warn("GridEngine: `stopFollowing` is deprecated. Use `stopMovement()` instead.");
      this._stopMovement(charId);
    }
    isMoving(charId) {
      this.initGuard();
      this.unknownCharGuard(charId);
      return this.gridCharacters.get(charId).isMoving();
    }
    getFacingDirection(charId) {
      this.initGuard();
      this.unknownCharGuard(charId);
      return this.gridCharacters.get(charId).getFacingDirection();
    }
    turnTowards(charId, direction) {
      this.initGuard();
      this.unknownCharGuard(charId);
      return this.gridCharacters.get(charId).turnTowards(direction);
    }
    movementStarted() {
      return this.movementStarted$;
    }
    movementStopped() {
      return this.movementStopped$;
    }
    directionChanged() {
      return this.directionChanged$;
    }
    positionChanged() {
      return this.positionChanged$;
    }
    positionChangeFinished() {
      return this.positionChangeFinished$;
    }
    takeUntilCharRemoved(charId) {
      return takeUntil(this.charRemoved$.pipe(filter((cId) => cId == charId)));
    }
    initGuard() {
      if (!this.isCreated) {
        throw new Error("Plugin not initialized. You need to call create() first.");
      }
    }
    unknownCharGuard(charId) {
      if (!this.gridCharacters.has(charId)) {
        throw new Error(`Character unknown: ${charId}`);
      }
    }
    createTilemap(tilemap, config2) {
      if (config2.firstLayerAboveChar != void 0) {
        console.warn("GridEngine: Config property `firstLayerAboveChar` is deprecated. Use a property `alwaysTop` on the tilemap layers instead.");
        return new GridTilemap(tilemap, config2.firstLayerAboveChar);
      } else {
        return new GridTilemap(tilemap);
      }
    }
    addCharacters(config2) {
      config2.characters.forEach((charData) => this.addCharacter(charData));
    }
    moveChar(charId, direction) {
      this.initGuard();
      this.unknownCharGuard(charId);
      this.gridCharacters.get(charId).move(direction);
    }
    _stopMovement(charId) {
      this.initGuard();
      this.unknownCharGuard(charId);
      this.gridCharacters.get(charId).setMovement(void 0);
    }
  };
  return require_main();
})();
