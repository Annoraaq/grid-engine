var GridEngine = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // src/Algorithms/ShortestPath/PathBlockedStrategy.ts
  var PathBlockedStrategy;
  var init_PathBlockedStrategy = __esm({
    "src/Algorithms/ShortestPath/PathBlockedStrategy.ts"() {
      (function(PathBlockedStrategy2) {
        PathBlockedStrategy2["WAIT"] = "WAIT";
        PathBlockedStrategy2["RETRY"] = "RETRY";
        PathBlockedStrategy2["STOP"] = "STOP";
      })(PathBlockedStrategy || (PathBlockedStrategy = {}));
    }
  });

  // src/Utils/Vector2/Vector2.ts
  var _Vector2, Vector2;
  var init_Vector2 = __esm({
    "src/Utils/Vector2/Vector2.ts"() {
      _Vector2 = class {
        constructor(x, y) {
          if (typeof x === "number") {
            this.x = x;
            this.y = y || 0;
          } else {
            this.x = x.x;
            this.y = x.y;
          }
        }
        clone() {
          return new _Vector2(this.x, this.y);
        }
        add(vector) {
          return new _Vector2(this.x + vector.x, this.y + vector.y);
        }
        multiply(vector) {
          return new _Vector2(this.x * vector.x, this.y * vector.y);
        }
        subtract(vector) {
          return new _Vector2(this.x - vector.x, this.y - vector.y);
        }
        equals(vector) {
          return this.x === vector.x && this.y === vector.y;
        }
      };
      Vector2 = _Vector2;
      Vector2.ZERO = new _Vector2(0, 0);
      Vector2.UP = new _Vector2(0, -1);
      Vector2.DOWN = new _Vector2(0, 1);
      Vector2.LEFT = new _Vector2(-1, 0);
      Vector2.RIGHT = new _Vector2(1, 0);
    }
  });

  // src/Direction/Direction.ts
  function getDirections(numberOfDirections) {
    const directions = [
      Direction.UP,
      Direction.RIGHT,
      Direction.DOWN,
      Direction.LEFT
    ];
    const diagonals = [
      Direction.DOWN_LEFT,
      Direction.DOWN_RIGHT,
      Direction.UP_RIGHT,
      Direction.UP_LEFT
    ];
    if (numberOfDirections === NumberOfDirections.EIGHT) {
      return [...directions, ...diagonals];
    }
    return directions;
  }
  function isDiagonal(direction) {
    const diagonals = [
      Direction.DOWN_LEFT,
      Direction.DOWN_RIGHT,
      Direction.UP_RIGHT,
      Direction.UP_LEFT
    ];
    return diagonals.includes(direction);
  }
  function turnCounterClockwise(direction) {
    const mapping = {
      [Direction.LEFT]: Direction.DOWN_LEFT,
      [Direction.UP_LEFT]: Direction.LEFT,
      [Direction.UP]: Direction.UP_LEFT,
      [Direction.UP_RIGHT]: Direction.UP,
      [Direction.RIGHT]: Direction.UP_RIGHT,
      [Direction.DOWN_RIGHT]: Direction.RIGHT,
      [Direction.DOWN]: Direction.DOWN_RIGHT,
      [Direction.DOWN_LEFT]: Direction.DOWN,
      [Direction.NONE]: Direction.NONE
    };
    return mapping[direction];
  }
  function directionVector(direction) {
    const directionVectors = {
      [Direction.UP]: Vector2.UP.clone(),
      [Direction.DOWN]: Vector2.DOWN.clone(),
      [Direction.LEFT]: Vector2.LEFT.clone(),
      [Direction.RIGHT]: Vector2.RIGHT.clone(),
      [Direction.NONE]: Vector2.ZERO.clone(),
      [Direction.UP_LEFT]: new Vector2(-1, -1),
      [Direction.UP_RIGHT]: new Vector2(1, -1),
      [Direction.DOWN_RIGHT]: new Vector2(1, 1),
      [Direction.DOWN_LEFT]: new Vector2(-1, 1)
    };
    return directionVectors[direction];
  }
  function oppositeDirection(direction) {
    const oppositeDirections = {
      [Direction.UP]: Direction.DOWN,
      [Direction.DOWN]: Direction.UP,
      [Direction.LEFT]: Direction.RIGHT,
      [Direction.RIGHT]: Direction.LEFT,
      [Direction.NONE]: Direction.NONE,
      [Direction.UP_LEFT]: Direction.DOWN_RIGHT,
      [Direction.UP_RIGHT]: Direction.DOWN_LEFT,
      [Direction.DOWN_RIGHT]: Direction.UP_LEFT,
      [Direction.DOWN_LEFT]: Direction.UP_RIGHT
    };
    return oppositeDirections[direction];
  }
  var Direction, NumberOfDirections;
  var init_Direction = __esm({
    "src/Direction/Direction.ts"() {
      init_Vector2();
      (function(Direction4) {
        Direction4["NONE"] = "none";
        Direction4["LEFT"] = "left";
        Direction4["UP_LEFT"] = "up-left";
        Direction4["UP"] = "up";
        Direction4["UP_RIGHT"] = "up-right";
        Direction4["RIGHT"] = "right";
        Direction4["DOWN_RIGHT"] = "down-right";
        Direction4["DOWN"] = "down";
        Direction4["DOWN_LEFT"] = "down-left";
      })(Direction || (Direction = {}));
      (function(NumberOfDirections2) {
        NumberOfDirections2[NumberOfDirections2["FOUR"] = 4] = "FOUR";
        NumberOfDirections2[NumberOfDirections2["EIGHT"] = 8] = "EIGHT";
      })(NumberOfDirections || (NumberOfDirections = {}));
    }
  });

  // src/Utils/VectorUtils.ts
  var VectorUtils;
  var init_VectorUtils = __esm({
    "src/Utils/VectorUtils.ts"() {
      init_Vector2();
      VectorUtils = class {
        static vec2str(vec) {
          return `${vec.x}#${vec.y}`;
        }
        static equal(vec1, vec2) {
          return VectorUtils.vec2str(vec1) == VectorUtils.vec2str(vec2);
        }
        static manhattanDistance(pos1, pos2) {
          const xDist = Math.abs(pos1.x - pos2.x);
          const yDist = Math.abs(pos1.y - pos2.y);
          return xDist + yDist;
        }
        static chebyshevDistance(pos1, pos2) {
          const xDist = Math.abs(pos1.x - pos2.x);
          const yDist = Math.abs(pos1.y - pos2.y);
          return Math.max(xDist, yDist);
        }
        static scalarMult(vec, scalar) {
          return vec.clone().multiply(new Vector2(scalar, scalar));
        }
      };
    }
  });

  // src/GridCharacter/CharacterAnimation/CharacterAnimation.ts
  var _CharacterAnimation, CharacterAnimation;
  var init_CharacterAnimation = __esm({
    "src/GridCharacter/CharacterAnimation/CharacterAnimation.ts"() {
      init_Direction();
      _CharacterAnimation = class {
        constructor(sprite, walkingAnimationMapping, characterIndex) {
          this.sprite = sprite;
          this.walkingAnimationMapping = walkingAnimationMapping;
          this.characterIndex = characterIndex;
          this.lastFootLeft = false;
          this.directionToFrameRow = {
            [Direction.DOWN]: 0,
            [Direction.DOWN_LEFT]: 1,
            [Direction.DOWN_RIGHT]: 2,
            [Direction.LEFT]: 1,
            [Direction.RIGHT]: 2,
            [Direction.UP]: 3,
            [Direction.UP_LEFT]: 1,
            [Direction.UP_RIGHT]: 2
          };
          this._isEnabled = true;
        }
        setIsEnabled(isEnabled) {
          this._isEnabled = isEnabled;
        }
        isEnabled() {
          return this._isEnabled;
        }
        updateCharacterFrame(movementDirection, hasWalkedHalfATile) {
          if (this._isEnabled) {
            if (hasWalkedHalfATile) {
              this.setStandingFrameDuringWalk(movementDirection);
            } else {
              this.setWalkingFrame(movementDirection);
            }
          }
        }
        setStandingFrame(direction) {
          if (this._isEnabled) {
            this._setStandingFrame(direction);
          }
        }
        setWalkingAnimationMapping(walkingAnimationMapping) {
          this.walkingAnimationMapping = walkingAnimationMapping;
        }
        setStandingFrameDuringWalk(direction) {
          if (!this.isCurrentFrameStanding(direction)) {
            this.lastFootLeft = !this.lastFootLeft;
          }
          this._setStandingFrame(direction);
        }
        setWalkingFrame(direction) {
          const frameRow = this.framesOfDirection(direction);
          this.sprite.setFrame(this.lastFootLeft ? frameRow.rightFoot : frameRow.leftFoot);
        }
        _setStandingFrame(direction) {
          this.sprite.setFrame(this.framesOfDirection(direction).standing);
        }
        isCurrentFrameStanding(direction) {
          return Number(this.sprite.frame.name) == this.framesOfDirection(direction).standing;
        }
        framesOfDirection(direction) {
          if (this.walkingAnimationMapping) {
            return this.getFramesForAnimationMapping(direction);
          }
          return this.getFramesForCharIndex(direction);
        }
        getFramesForAnimationMapping(direction) {
          return this.walkingAnimationMapping[direction] || this.walkingAnimationMapping[this.fallbackDirection(direction)];
        }
        fallbackDirection(direction) {
          switch (direction) {
            case Direction.DOWN_LEFT:
              return Direction.LEFT;
            case Direction.DOWN_RIGHT:
              return Direction.RIGHT;
            case Direction.UP_LEFT:
              return Direction.LEFT;
            case Direction.UP_RIGHT:
              return Direction.RIGHT;
          }
          return direction;
        }
        getFramesForCharIndex(direction) {
          const charsInRow = this.sprite.texture.source[0].width / this.sprite.width / _CharacterAnimation.FRAMES_CHAR_ROW;
          const playerCharRow = Math.floor(this.characterIndex / charsInRow);
          const playerCharCol = this.characterIndex % charsInRow;
          const framesInRow = charsInRow * _CharacterAnimation.FRAMES_CHAR_ROW;
          const framesInSameRowBefore = _CharacterAnimation.FRAMES_CHAR_ROW * playerCharCol;
          const rows = this.directionToFrameRow[direction] + playerCharRow * _CharacterAnimation.FRAMES_CHAR_COL;
          const startFrame = framesInSameRowBefore + rows * framesInRow;
          return {
            rightFoot: startFrame,
            standing: startFrame + 1,
            leftFoot: startFrame + 2
          };
        }
      };
      CharacterAnimation = _CharacterAnimation;
      CharacterAnimation.FRAMES_CHAR_ROW = 3;
      CharacterAnimation.FRAMES_CHAR_COL = 4;
    }
  });

  // src/GridTilemap/CharBlockCache/CharBlockCache.ts
  var CharBlockCache;
  var init_CharBlockCache = __esm({
    "src/GridTilemap/CharBlockCache/CharBlockCache.ts"() {
      CharBlockCache = class {
        constructor() {
          this.tilePosToCharacters = new Map();
          this.positionChangedSubs = new Map();
          this.positionChangeFinishedSubs = new Map();
        }
        isCharBlockingAt(pos) {
          const posStr = this.posToString(pos);
          return this.tilePosToCharacters.has(posStr) && this.tilePosToCharacters.get(posStr).size > 0;
        }
        addCharacter(character) {
          if (!this.tilePosToCharacters.has(this.posToString(character.getTilePos()))) {
            this.tilePosToCharacters.set(this.posToString(character.getTilePos()), new Set());
          }
          this.tilePosToCharacters.get(this.posToString(character.getTilePos())).add(character);
          if (!this.tilePosToCharacters.has(this.posToString(character.getNextTilePos()))) {
            this.tilePosToCharacters.set(this.posToString(character.getNextTilePos()), new Set());
          }
          this.tilePosToCharacters.get(this.posToString(character.getNextTilePos())).add(character);
          const sub = character.positionChanged().subscribe((positionChange) => {
            if (!this.tilePosToCharacters.has(this.posToString(positionChange.enterTile))) {
              this.tilePosToCharacters.set(this.posToString(positionChange.enterTile), new Set());
            }
            this.tilePosToCharacters.get(this.posToString(positionChange.enterTile)).add(character);
          });
          const sub2 = character.positionChangeFinished().subscribe((positionChange) => {
            this.tilePosToCharacters.get(this.posToString(positionChange.exitTile)).delete(character);
          });
          this.positionChangedSubs.set(character.getId(), sub);
          this.positionChangeFinishedSubs.set(character.getId(), sub2);
        }
        removeCharacter(character) {
          const charId = character.getId();
          this.positionChangedSubs.get(charId).unsubscribe();
          this.positionChangeFinishedSubs.get(charId).unsubscribe();
          this.tilePosToCharacters.get(this.posToString(character.getTilePos())).delete(character);
          this.tilePosToCharacters.get(this.posToString(character.getNextTilePos())).delete(character);
        }
        posToString(pos) {
          return `${pos.x}#${pos.y}`;
        }
      };
    }
  });

  // src/GridTilemap/GridTilemap.ts
  var _GridTilemap, GridTilemap;
  var init_GridTilemap = __esm({
    "src/GridTilemap/GridTilemap.ts"() {
      init_CharBlockCache();
      _GridTilemap = class {
        constructor(tilemap, firstLayerAboveChar) {
          this.tilemap = tilemap;
          this.firstLayerAboveChar = firstLayerAboveChar;
          this.characters = new Map();
          this.collisionTilePropertyName = "ge_collide";
          this.charBlockCache = new CharBlockCache();
          this.setLayerDepths();
        }
        addCharacter(character) {
          this.characters.set(character.getId(), character);
          this.charBlockCache.addCharacter(character);
        }
        removeCharacter(charId) {
          this.charBlockCache.removeCharacter(this.characters.get(charId));
          this.characters.delete(charId);
        }
        getCharacters() {
          return [...this.characters.values()];
        }
        isBlocking(pos, direction) {
          return this.hasNoTile(pos) || this.hasBlockingTile(pos, direction) || this.hasBlockingChar(pos);
        }
        hasBlockingTile(pos, direction) {
          if (this.hasNoTile(pos))
            return true;
          const collidesPropName = _GridTilemap.ONE_WAY_COLLIDE_PROP_PREFIX + direction;
          return this.tilemap.layers.some((layer) => {
            const tile = this.tilemap.getTileAt(pos.x, pos.y, false, layer.name);
            return (tile == null ? void 0 : tile.properties) && (tile.properties[this.collisionTilePropertyName] || tile.properties[collidesPropName]);
          });
        }
        hasNoTile(pos) {
          return !this.tilemap.layers.some((layer) => this.tilemap.hasTileAt(pos.x, pos.y, layer.name));
        }
        hasBlockingChar(pos) {
          return this.charBlockCache.isCharBlockingAt(pos);
        }
        setCollisionTilePropertyName(name) {
          this.collisionTilePropertyName = name;
        }
        getTileWidth() {
          const tilemapScale = this.tilemap.layers[0].tilemapLayer.scale;
          return this.tilemap.tileWidth * tilemapScale;
        }
        getTileHeight() {
          const tilemapScale = this.tilemap.layers[0].tilemapLayer.scale;
          return this.tilemap.tileHeight * tilemapScale;
        }
        getLayerProp(layer, name) {
          const layerProps = layer.properties;
          const prop = layerProps.find((el) => el.name == name);
          return prop == null ? void 0 : prop.value;
        }
        hasLayerProp(layer, name) {
          return this.getLayerProp(layer, name) != void 0;
        }
        isLayerAlwaysOnTop(layerData, layerIndex) {
          return layerIndex >= this.firstLayerAboveChar || this.hasLayerProp(layerData, _GridTilemap.ALWAYS_TOP_PROP_NAME);
        }
        setLayerDepths() {
          const layersToDelete = [];
          this.tilemap.layers.forEach((layerData, layerIndex) => {
            if (this.isLayerAlwaysOnTop(layerData, layerIndex)) {
              layerData.tilemapLayer.setDepth(_GridTilemap.FIRST_PLAYER_LAYER + _GridTilemap.MAX_PLAYER_LAYERS + layerIndex);
            } else if (this.hasLayerProp(layerData, _GridTilemap.HEIGHT_SHIFT_PROP_NAME)) {
              this.createLayerForEachRow(layerData, layerIndex);
              layersToDelete.push(layerData.tilemapLayer);
            } else {
              layerData.tilemapLayer.setDepth(layerIndex);
            }
          });
          layersToDelete.forEach((layer) => layer.destroy());
        }
        createLayerForEachRow(layer, layerIndex) {
          const heightShift = this.getLayerProp(layer, _GridTilemap.HEIGHT_SHIFT_PROP_NAME);
          for (let row = 0; row < layer.height; row++) {
            const newLayer = this.tilemap.createBlankLayer(`${layerIndex}#${row}`, layer.tilemapLayer.tileset);
            for (let col = 0; col < layer.width; col++) {
              newLayer.putTileAt(layer.data[row][col], col, row);
            }
            newLayer.scale = layer.tilemapLayer.scale;
            const makeHigherThanPlayerWhenOnSameLevel = 0.5;
            newLayer.setDepth(_GridTilemap.FIRST_PLAYER_LAYER + row + heightShift - 1 + makeHigherThanPlayerWhenOnSameLevel);
          }
        }
      };
      GridTilemap = _GridTilemap;
      GridTilemap.MAX_PLAYER_LAYERS = 1e3;
      GridTilemap.FIRST_PLAYER_LAYER = 1e3;
      GridTilemap.ALWAYS_TOP_PROP_NAME = "ge_alwaysTop";
      GridTilemap.HEIGHT_SHIFT_PROP_NAME = "ge_heightShift";
      GridTilemap.ONE_WAY_COLLIDE_PROP_PREFIX = "ge_collide_";
    }
  });

  // node_modules/rxjs/node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "node_modules/rxjs/node_modules/tslib/tslib.js"(exports, module) {
      var __extends2;
      var __assign2;
      var __rest2;
      var __decorate2;
      var __param2;
      var __metadata2;
      var __awaiter2;
      var __generator2;
      var __exportStar2;
      var __values2;
      var __read2;
      var __spread2;
      var __spreadArrays2;
      var __spreadArray2;
      var __await2;
      var __asyncGenerator2;
      var __asyncDelegator2;
      var __asyncValues2;
      var __makeTemplateObject2;
      var __importStar2;
      var __importDefault2;
      var __classPrivateFieldGet2;
      var __classPrivateFieldSet2;
      var __createBinding2;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p))
              d[p] = b[p];
        };
        __extends2 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign2 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest2 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate2 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param2 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata2 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter2 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator2 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar2 = function(m, o) {
          for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding2(o, m, p);
        };
        __createBinding2 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values2 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read2 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread2 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read2(arguments[i]));
          return ar;
        };
        __spreadArrays2 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray2 = function(to, from) {
          for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
          return to;
        };
        __await2 = function(v) {
          return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
        };
        __asyncGenerator2 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator2 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues2 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject2 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar2 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding2(result, mod, k);
          }
          __setModuleDefault(result, mod);
          return result;
        };
        __importDefault2 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet2 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet2 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends2);
        exporter("__assign", __assign2);
        exporter("__rest", __rest2);
        exporter("__decorate", __decorate2);
        exporter("__param", __param2);
        exporter("__metadata", __metadata2);
        exporter("__awaiter", __awaiter2);
        exporter("__generator", __generator2);
        exporter("__exportStar", __exportStar2);
        exporter("__createBinding", __createBinding2);
        exporter("__values", __values2);
        exporter("__read", __read2);
        exporter("__spread", __spread2);
        exporter("__spreadArrays", __spreadArrays2);
        exporter("__spreadArray", __spreadArray2);
        exporter("__await", __await2);
        exporter("__asyncGenerator", __asyncGenerator2);
        exporter("__asyncDelegator", __asyncDelegator2);
        exporter("__asyncValues", __asyncValues2);
        exporter("__makeTemplateObject", __makeTemplateObject2);
        exporter("__importStar", __importStar2);
        exporter("__importDefault", __importDefault2);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      });
    }
  });

  // node_modules/rxjs/node_modules/tslib/modules/index.js
  var import_tslib, __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __createBinding, __values, __read, __spread, __spreadArrays, __spreadArray, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet;
  var init_modules = __esm({
    "node_modules/rxjs/node_modules/tslib/modules/index.js"() {
      import_tslib = __toModule(require_tslib());
      ({
        __extends,
        __assign,
        __rest,
        __decorate,
        __param,
        __metadata,
        __awaiter,
        __generator,
        __exportStar,
        __createBinding,
        __values,
        __read,
        __spread,
        __spreadArrays,
        __spreadArray,
        __await,
        __asyncGenerator,
        __asyncDelegator,
        __asyncValues,
        __makeTemplateObject,
        __importStar,
        __importDefault,
        __classPrivateFieldGet,
        __classPrivateFieldSet
      } = import_tslib.default);
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/isFunction.js
  function isFunction(value) {
    return typeof value === "function";
  }
  var init_isFunction = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/isFunction.js"() {
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }
  var init_createErrorClass = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js"() {
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
  var UnsubscriptionError;
  var init_UnsubscriptionError = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js"() {
      init_createErrorClass();
      UnsubscriptionError = createErrorClass(function(_super) {
        return function UnsubscriptionErrorImpl(errors) {
          _super(this);
          this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
            return i + 1 + ") " + err.toString();
          }).join("\n  ") : "";
          this.name = "UnsubscriptionError";
          this.errors = errors;
        };
      });
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }
  var init_arrRemove = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/arrRemove.js"() {
    }
  });

  // node_modules/rxjs/dist/esm5/internal/Subscription.js
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
  }
  function execTeardown(teardown) {
    if (isFunction(teardown)) {
      teardown();
    } else {
      teardown.unsubscribe();
    }
  }
  var Subscription, EMPTY_SUBSCRIPTION;
  var init_Subscription = __esm({
    "node_modules/rxjs/dist/esm5/internal/Subscription.js"() {
      init_modules();
      init_isFunction();
      init_UnsubscriptionError();
      init_arrRemove();
      Subscription = function() {
        function Subscription2(initialTeardown) {
          this.initialTeardown = initialTeardown;
          this.closed = false;
          this._parentage = null;
          this._teardowns = null;
        }
        Subscription2.prototype.unsubscribe = function() {
          var e_1, _a, e_2, _b;
          var errors;
          if (!this.closed) {
            this.closed = true;
            var _parentage = this._parentage;
            if (_parentage) {
              this._parentage = null;
              if (Array.isArray(_parentage)) {
                try {
                  for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                    var parent_1 = _parentage_1_1.value;
                    parent_1.remove(this);
                  }
                } catch (e_1_1) {
                  e_1 = { error: e_1_1 };
                } finally {
                  try {
                    if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                      _a.call(_parentage_1);
                  } finally {
                    if (e_1)
                      throw e_1.error;
                  }
                }
              } else {
                _parentage.remove(this);
              }
            }
            var initialTeardown = this.initialTeardown;
            if (isFunction(initialTeardown)) {
              try {
                initialTeardown();
              } catch (e) {
                errors = e instanceof UnsubscriptionError ? e.errors : [e];
              }
            }
            var _teardowns = this._teardowns;
            if (_teardowns) {
              this._teardowns = null;
              try {
                for (var _teardowns_1 = __values(_teardowns), _teardowns_1_1 = _teardowns_1.next(); !_teardowns_1_1.done; _teardowns_1_1 = _teardowns_1.next()) {
                  var teardown_1 = _teardowns_1_1.value;
                  try {
                    execTeardown(teardown_1);
                  } catch (err) {
                    errors = errors !== null && errors !== void 0 ? errors : [];
                    if (err instanceof UnsubscriptionError) {
                      errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                    } else {
                      errors.push(err);
                    }
                  }
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (_teardowns_1_1 && !_teardowns_1_1.done && (_b = _teardowns_1.return))
                    _b.call(_teardowns_1);
                } finally {
                  if (e_2)
                    throw e_2.error;
                }
              }
            }
            if (errors) {
              throw new UnsubscriptionError(errors);
            }
          }
        };
        Subscription2.prototype.add = function(teardown) {
          var _a;
          if (teardown && teardown !== this) {
            if (this.closed) {
              execTeardown(teardown);
            } else {
              if (teardown instanceof Subscription2) {
                if (teardown.closed || teardown._hasParent(this)) {
                  return;
                }
                teardown._addParent(this);
              }
              (this._teardowns = (_a = this._teardowns) !== null && _a !== void 0 ? _a : []).push(teardown);
            }
          }
        };
        Subscription2.prototype._hasParent = function(parent) {
          var _parentage = this._parentage;
          return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
        };
        Subscription2.prototype._addParent = function(parent) {
          var _parentage = this._parentage;
          this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
        };
        Subscription2.prototype._removeParent = function(parent) {
          var _parentage = this._parentage;
          if (_parentage === parent) {
            this._parentage = null;
          } else if (Array.isArray(_parentage)) {
            arrRemove(_parentage, parent);
          }
        };
        Subscription2.prototype.remove = function(teardown) {
          var _teardowns = this._teardowns;
          _teardowns && arrRemove(_teardowns, teardown);
          if (teardown instanceof Subscription2) {
            teardown._removeParent(this);
          }
        };
        Subscription2.EMPTY = function() {
          var empty = new Subscription2();
          empty.closed = true;
          return empty;
        }();
        return Subscription2;
      }();
      EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    }
  });

  // node_modules/rxjs/dist/esm5/internal/config.js
  var config;
  var init_config = __esm({
    "node_modules/rxjs/dist/esm5/internal/config.js"() {
      config = {
        onUnhandledError: null,
        onStoppedNotification: null,
        Promise: void 0,
        useDeprecatedSynchronousErrorHandling: false,
        useDeprecatedNextContext: false
      };
    }
  });

  // node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
  var timeoutProvider;
  var init_timeoutProvider = __esm({
    "node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js"() {
      init_modules();
      timeoutProvider = {
        setTimeout: function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var delegate = timeoutProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) || setTimeout).apply(void 0, __spreadArray([], __read(args)));
        },
        clearTimeout: function(handle) {
          var delegate = timeoutProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
        },
        delegate: void 0
      };
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function() {
      var onUnhandledError = config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  }
  var init_reportUnhandledError = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js"() {
      init_config();
      init_timeoutProvider();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/noop.js
  function noop() {
  }
  var init_noop = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/noop.js"() {
    }
  });

  // node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
  function errorNotification(error) {
    return createNotification("E", void 0, error);
  }
  function nextNotification(value) {
    return createNotification("N", value, void 0);
  }
  function createNotification(kind, value, error) {
    return {
      kind,
      value,
      error
    };
  }
  var COMPLETE_NOTIFICATION;
  var init_NotificationFactories = __esm({
    "node_modules/rxjs/dist/esm5/internal/NotificationFactories.js"() {
      COMPLETE_NOTIFICATION = function() {
        return createNotification("C", void 0, void 0);
      }();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/Subscriber.js
  function wrapForErrorHandling(handler, instance) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      try {
        handler.apply(void 0, __spreadArray([], __read(args)));
      } catch (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
          if (instance._syncErrorHack_isSubscribing) {
            instance.__syncError = err;
          } else {
            throw err;
          }
        } else {
          reportUnhandledError(err);
        }
      }
    };
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config.onStoppedNotification;
    onStoppedNotification && timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  var Subscriber, SafeSubscriber, EMPTY_OBSERVER;
  var init_Subscriber = __esm({
    "node_modules/rxjs/dist/esm5/internal/Subscriber.js"() {
      init_modules();
      init_isFunction();
      init_Subscription();
      init_config();
      init_reportUnhandledError();
      init_noop();
      init_NotificationFactories();
      init_timeoutProvider();
      Subscriber = function(_super) {
        __extends(Subscriber2, _super);
        function Subscriber2(destination) {
          var _this = _super.call(this) || this;
          _this.isStopped = false;
          if (destination) {
            _this.destination = destination;
            if (isSubscription(destination)) {
              destination.add(_this);
            }
          } else {
            _this.destination = EMPTY_OBSERVER;
          }
          return _this;
        }
        Subscriber2.create = function(next, error, complete) {
          return new SafeSubscriber(next, error, complete);
        };
        Subscriber2.prototype.next = function(value) {
          if (this.isStopped) {
            handleStoppedNotification(nextNotification(value), this);
          } else {
            this._next(value);
          }
        };
        Subscriber2.prototype.error = function(err) {
          if (this.isStopped) {
            handleStoppedNotification(errorNotification(err), this);
          } else {
            this.isStopped = true;
            this._error(err);
          }
        };
        Subscriber2.prototype.complete = function() {
          if (this.isStopped) {
            handleStoppedNotification(COMPLETE_NOTIFICATION, this);
          } else {
            this.isStopped = true;
            this._complete();
          }
        };
        Subscriber2.prototype.unsubscribe = function() {
          if (!this.closed) {
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
            this.destination = null;
          }
        };
        Subscriber2.prototype._next = function(value) {
          this.destination.next(value);
        };
        Subscriber2.prototype._error = function(err) {
          try {
            this.destination.error(err);
          } finally {
            this.unsubscribe();
          }
        };
        Subscriber2.prototype._complete = function() {
          try {
            this.destination.complete();
          } finally {
            this.unsubscribe();
          }
        };
        return Subscriber2;
      }(Subscription);
      SafeSubscriber = function(_super) {
        __extends(SafeSubscriber2, _super);
        function SafeSubscriber2(observerOrNext, error, complete) {
          var _this = _super.call(this) || this;
          var next;
          if (isFunction(observerOrNext)) {
            next = observerOrNext;
          } else if (observerOrNext) {
            next = observerOrNext.next, error = observerOrNext.error, complete = observerOrNext.complete;
            var context_1;
            if (_this && config.useDeprecatedNextContext) {
              context_1 = Object.create(observerOrNext);
              context_1.unsubscribe = function() {
                return _this.unsubscribe();
              };
            } else {
              context_1 = observerOrNext;
            }
            next = next === null || next === void 0 ? void 0 : next.bind(context_1);
            error = error === null || error === void 0 ? void 0 : error.bind(context_1);
            complete = complete === null || complete === void 0 ? void 0 : complete.bind(context_1);
          }
          _this.destination = {
            next: next ? wrapForErrorHandling(next, _this) : noop,
            error: wrapForErrorHandling(error !== null && error !== void 0 ? error : defaultErrorHandler, _this),
            complete: complete ? wrapForErrorHandling(complete, _this) : noop
          };
          return _this;
        }
        return SafeSubscriber2;
      }(Subscriber);
      EMPTY_OBSERVER = {
        closed: true,
        next: noop,
        error: defaultErrorHandler,
        complete: noop
      };
    }
  });

  // node_modules/rxjs/dist/esm5/internal/symbol/observable.js
  var observable;
  var init_observable = __esm({
    "node_modules/rxjs/dist/esm5/internal/symbol/observable.js"() {
      observable = function() {
        return typeof Symbol === "function" && Symbol.observable || "@@observable";
      }();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/identity.js
  function identity(x) {
    return x;
  }
  var init_identity = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/identity.js"() {
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/pipe.js
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }
  var init_pipe = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/pipe.js"() {
      init_identity();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/Observable.js
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }
  var Observable;
  var init_Observable = __esm({
    "node_modules/rxjs/dist/esm5/internal/Observable.js"() {
      init_Subscriber();
      init_Subscription();
      init_observable();
      init_pipe();
      init_config();
      init_isFunction();
      Observable = function() {
        function Observable3(subscribe) {
          if (subscribe) {
            this._subscribe = subscribe;
          }
        }
        Observable3.prototype.lift = function(operator) {
          var observable2 = new Observable3();
          observable2.source = this;
          observable2.operator = operator;
          return observable2;
        };
        Observable3.prototype.subscribe = function(observerOrNext, error, complete) {
          var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
          if (config.useDeprecatedSynchronousErrorHandling) {
            this._deprecatedSyncErrorSubscribe(subscriber);
          } else {
            var _a = this, operator = _a.operator, source = _a.source;
            subscriber.add(operator ? operator.call(subscriber, source) : source ? this._subscribe(subscriber) : this._trySubscribe(subscriber));
          }
          return subscriber;
        };
        Observable3.prototype._deprecatedSyncErrorSubscribe = function(subscriber) {
          var localSubscriber = subscriber;
          localSubscriber._syncErrorHack_isSubscribing = true;
          var operator = this.operator;
          if (operator) {
            subscriber.add(operator.call(subscriber, this.source));
          } else {
            try {
              subscriber.add(this._subscribe(subscriber));
            } catch (err) {
              localSubscriber.__syncError = err;
            }
          }
          var dest = localSubscriber;
          while (dest) {
            if ("__syncError" in dest) {
              try {
                throw dest.__syncError;
              } finally {
                subscriber.unsubscribe();
              }
            }
            dest = dest.destination;
          }
          localSubscriber._syncErrorHack_isSubscribing = false;
        };
        Observable3.prototype._trySubscribe = function(sink) {
          try {
            return this._subscribe(sink);
          } catch (err) {
            sink.error(err);
          }
        };
        Observable3.prototype.forEach = function(next, promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function(resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function(value) {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
              }
            }, reject, resolve);
          });
        };
        Observable3.prototype._subscribe = function(subscriber) {
          var _a;
          return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
        };
        Observable3.prototype[observable] = function() {
          return this;
        };
        Observable3.prototype.pipe = function() {
          var operations = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
          }
          return operations.length ? pipeFromArray(operations)(this) : this;
        };
        Observable3.prototype.toPromise = function(promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function(resolve, reject) {
            var value;
            _this.subscribe(function(x) {
              return value = x;
            }, function(err) {
              return reject(err);
            }, function() {
              return resolve(value);
            });
          });
        };
        Observable3.create = function(subscribe) {
          return new Observable3(subscribe);
        };
        return Observable3;
      }();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/lift.js
  function hasLift(source) {
    return isFunction(source === null || source === void 0 ? void 0 : source.lift);
  }
  function operate(init) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  var init_lift = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/lift.js"() {
      init_isFunction();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
  var OperatorSubscriber;
  var init_OperatorSubscriber = __esm({
    "node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js"() {
      init_modules();
      init_Subscriber();
      OperatorSubscriber = function(_super) {
        __extends(OperatorSubscriber2, _super);
        function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize) {
          var _this = _super.call(this, destination) || this;
          _this.onFinalize = onFinalize;
          _this._next = onNext ? function(value) {
            try {
              onNext(value);
            } catch (err) {
              destination.error(err);
            }
          } : _super.prototype._next;
          _this._error = onError ? function(err) {
            try {
              onError(err);
            } catch (err2) {
              destination.error(err2);
            } finally {
              this.unsubscribe();
            }
          } : _super.prototype._error;
          _this._complete = onComplete ? function() {
            try {
              onComplete();
            } catch (err) {
              destination.error(err);
            } finally {
              this.unsubscribe();
            }
          } : _super.prototype._complete;
          return _this;
        }
        OperatorSubscriber2.prototype.unsubscribe = function() {
          var _a;
          var closed = this.closed;
          _super.prototype.unsubscribe.call(this);
          !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        };
        return OperatorSubscriber2;
      }(Subscriber);
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
  var ObjectUnsubscribedError;
  var init_ObjectUnsubscribedError = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js"() {
      init_createErrorClass();
      ObjectUnsubscribedError = createErrorClass(function(_super) {
        return function ObjectUnsubscribedErrorImpl() {
          _super(this);
          this.name = "ObjectUnsubscribedError";
          this.message = "object unsubscribed";
        };
      });
    }
  });

  // node_modules/rxjs/dist/esm5/internal/Subject.js
  var Subject, AnonymousSubject;
  var init_Subject = __esm({
    "node_modules/rxjs/dist/esm5/internal/Subject.js"() {
      init_modules();
      init_Observable();
      init_Subscription();
      init_ObjectUnsubscribedError();
      init_arrRemove();
      Subject = function(_super) {
        __extends(Subject2, _super);
        function Subject2() {
          var _this = _super.call(this) || this;
          _this.closed = false;
          _this.observers = [];
          _this.isStopped = false;
          _this.hasError = false;
          _this.thrownError = null;
          return _this;
        }
        Subject2.prototype.lift = function(operator) {
          var subject = new AnonymousSubject(this, this);
          subject.operator = operator;
          return subject;
        };
        Subject2.prototype._throwIfClosed = function() {
          if (this.closed) {
            throw new ObjectUnsubscribedError();
          }
        };
        Subject2.prototype.next = function(value) {
          var e_1, _a;
          this._throwIfClosed();
          if (!this.isStopped) {
            var copy = this.observers.slice();
            try {
              for (var copy_1 = __values(copy), copy_1_1 = copy_1.next(); !copy_1_1.done; copy_1_1 = copy_1.next()) {
                var observer = copy_1_1.value;
                observer.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (copy_1_1 && !copy_1_1.done && (_a = copy_1.return))
                  _a.call(copy_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
        };
        Subject2.prototype.error = function(err) {
          this._throwIfClosed();
          if (!this.isStopped) {
            this.hasError = this.isStopped = true;
            this.thrownError = err;
            var observers = this.observers;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        };
        Subject2.prototype.complete = function() {
          this._throwIfClosed();
          if (!this.isStopped) {
            this.isStopped = true;
            var observers = this.observers;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        };
        Subject2.prototype.unsubscribe = function() {
          this.isStopped = this.closed = true;
          this.observers = null;
        };
        Object.defineProperty(Subject2.prototype, "observed", {
          get: function() {
            var _a;
            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
          },
          enumerable: false,
          configurable: true
        });
        Subject2.prototype._trySubscribe = function(subscriber) {
          this._throwIfClosed();
          return _super.prototype._trySubscribe.call(this, subscriber);
        };
        Subject2.prototype._subscribe = function(subscriber) {
          this._throwIfClosed();
          this._checkFinalizedStatuses(subscriber);
          return this._innerSubscribe(subscriber);
        };
        Subject2.prototype._innerSubscribe = function(subscriber) {
          var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
          return hasError || isStopped ? EMPTY_SUBSCRIPTION : (observers.push(subscriber), new Subscription(function() {
            return arrRemove(observers, subscriber);
          }));
        };
        Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
          var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
          if (hasError) {
            subscriber.error(thrownError);
          } else if (isStopped) {
            subscriber.complete();
          }
        };
        Subject2.prototype.asObservable = function() {
          var observable2 = new Observable();
          observable2.source = this;
          return observable2;
        };
        Subject2.create = function(destination, source) {
          return new AnonymousSubject(destination, source);
        };
        return Subject2;
      }(Observable);
      AnonymousSubject = function(_super) {
        __extends(AnonymousSubject2, _super);
        function AnonymousSubject2(destination, source) {
          var _this = _super.call(this) || this;
          _this.destination = destination;
          _this.source = source;
          return _this;
        }
        AnonymousSubject2.prototype.next = function(value) {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        };
        AnonymousSubject2.prototype.error = function(err) {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
        };
        AnonymousSubject2.prototype.complete = function() {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        AnonymousSubject2.prototype._subscribe = function(subscriber) {
          var _a, _b;
          return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
        };
        return AnonymousSubject2;
      }(Subject);
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
  var isArrayLike;
  var init_isArrayLike = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js"() {
      isArrayLike = function(x) {
        return x && typeof x.length === "number" && typeof x !== "function";
      };
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/isPromise.js
  function isPromise(value) {
    return isFunction(value === null || value === void 0 ? void 0 : value.then);
  }
  var init_isPromise = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/isPromise.js"() {
      init_isFunction();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  var iterator;
  var init_iterator = __esm({
    "node_modules/rxjs/dist/esm5/internal/symbol/iterator.js"() {
      iterator = getSymbolIterator();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
  function isInteropObservable(input) {
    return isFunction(input[observable]);
  }
  var init_isInteropObservable = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js"() {
      init_observable();
      init_isFunction();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/isIterable.js
  function isIterable(input) {
    return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
  }
  var init_isIterable = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/isIterable.js"() {
      init_iterator();
      init_isFunction();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }
  var init_isAsyncIterable = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js"() {
      init_isFunction();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  var init_throwUnobservableError = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js"() {
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            if (false)
              return [3, 8];
            return [4, __await(reader.read())];
          case 3:
            _a = _b.sent(), value = _a.value, done = _a.done;
            if (!done)
              return [3, 5];
            return [4, __await(void 0)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  function isReadableStreamLike(obj) {
    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }
  var init_isReadableStreamLike = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js"() {
      init_modules();
      init_isFunction();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/observable/from.js
  function innerFrom(input) {
    if (input instanceof Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function fromInteropObservable(obj) {
    return new Observable(function(subscriber) {
      var obs = obj[observable]();
      if (isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  function fromArrayLike(array) {
    return new Observable(function(subscriber) {
      for (var i = 0; i < array.length && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    });
  }
  function fromPromise(promise) {
    return new Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError);
    });
  }
  function fromIterable(iterable) {
    return new Observable(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
            _a.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  function fromAsyncIterable(asyncIterable) {
    return new Observable(function(subscriber) {
      process(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
  }
  function process(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function() {
      var value, e_2_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }
  var init_from = __esm({
    "node_modules/rxjs/dist/esm5/internal/observable/from.js"() {
      init_modules();
      init_isArrayLike();
      init_isPromise();
      init_observable();
      init_Observable();
      init_isFunction();
      init_reportUnhandledError();
      init_isInteropObservable();
      init_isAsyncIterable();
      init_throwUnobservableError();
      init_isIterable();
      init_isReadableStreamLike();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/operators/filter.js
  function filter(predicate, thisArg) {
    return operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(new OperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }
  var init_filter = __esm({
    "node_modules/rxjs/dist/esm5/internal/operators/filter.js"() {
      init_lift();
      init_OperatorSubscriber();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/types.js
  var init_types = __esm({
    "node_modules/rxjs/dist/esm5/internal/types.js"() {
    }
  });

  // node_modules/rxjs/dist/esm5/index.js
  var init_esm5 = __esm({
    "node_modules/rxjs/dist/esm5/index.js"() {
      init_Subject();
      init_types();
    }
  });

  // src/GridCharacter/GridCharacter.ts
  var GridCharacter;
  var init_GridCharacter = __esm({
    "src/GridCharacter/GridCharacter.ts"() {
      init_CharacterAnimation();
      init_VectorUtils();
      init_Direction();
      init_Direction();
      init_GridTilemap();
      init_esm5();
      init_Vector2();
      GridCharacter = class {
        constructor(id, config2) {
          this.id = id;
          this.movementDirection = Direction.NONE;
          this.tileSizePixelsWalked = Vector2.ZERO.clone();
          this._nextTilePos = new Vector2(0, 0);
          this._tilePos = new Vector2(0, 0);
          this.movementStarted$ = new Subject();
          this.movementStopped$ = new Subject();
          this.directionChanged$ = new Subject();
          this.positionChanged$ = new Subject();
          this.positionChangeFinished$ = new Subject();
          this.autoMovementSet$ = new Subject();
          this.lastMovementImpulse = Direction.NONE;
          this.facingDirection = Direction.DOWN;
          let characterIndex = 0;
          let walkingAnimationMapping;
          if (typeof config2.walkingAnimationMapping == "number") {
            characterIndex = config2.walkingAnimationMapping;
          } else {
            walkingAnimationMapping = config2.walkingAnimationMapping;
          }
          this.sprite = config2.sprite;
          this.sprite.setOrigin(0, 0);
          this.container = config2.container;
          this.tilemap = config2.tilemap;
          this.speed = config2.speed;
          this.customOffset = new Vector2(config2.offsetX || 0, config2.offsetY || 0);
          this.tileSize = config2.tileSize.clone();
          this.animation = new CharacterAnimation(this.sprite, walkingAnimationMapping, characterIndex);
          this.animation.setIsEnabled(config2.walkingAnimationMapping !== void 0);
          this.animation.setStandingFrame(Direction.DOWN);
          this.updateZindex();
        }
        getId() {
          return this.id;
        }
        getSpeed() {
          return this.speed;
        }
        setSpeed(speed) {
          this.speed = speed;
        }
        setMovement(movement) {
          var _a;
          this.autoMovementSet$.next();
          this.movement = movement;
          (_a = this.movement) == null ? void 0 : _a.setCharacter(this);
        }
        getMovement() {
          return this.movement;
        }
        setWalkingAnimationMapping(walkingAnimationMapping) {
          this.animation.setWalkingAnimationMapping(walkingAnimationMapping);
        }
        setTilePosition(tilePosition) {
          if (this.isMoving()) {
            this.movementStopped$.next(this.movementDirection);
          }
          this.positionChanged$.next({
            exitTile: this.tilePos,
            enterTile: tilePosition
          });
          this.positionChangeFinished$.next({
            exitTile: this.tilePos,
            enterTile: tilePosition
          });
          this.movementDirection = Direction.NONE;
          this.nextTilePos = tilePosition;
          this.tilePos = tilePosition;
          this.updateZindex();
          this.setPosition(this.tilePosToPixelPos(tilePosition).add(this.getOffset()).add(this.customOffset));
        }
        getTilePos() {
          return this.tilePos;
        }
        getNextTilePos() {
          return this.nextTilePos;
        }
        move(direction) {
          this.lastMovementImpulse = direction;
          if (direction == Direction.NONE)
            return;
          if (this.isMoving())
            return;
          if (this.isBlockingDirection(direction)) {
            this.facingDirection = direction;
            this.animation.setStandingFrame(direction);
            this.directionChanged$.next(direction);
          } else {
            this.startMoving(direction);
          }
        }
        update(delta) {
          var _a;
          (_a = this.movement) == null ? void 0 : _a.update(delta);
          if (this.isMoving()) {
            this.updateCharacterPosition(delta);
            this.updateZindex();
          }
          this.lastMovementImpulse = Direction.NONE;
        }
        getMovementDirection() {
          return this.movementDirection;
        }
        isBlockingTile(tilePos) {
          return this.nextTilePos.equals(tilePos) || this.tilePos.equals(tilePos);
        }
        isBlockingDirection(direction) {
          if (direction == Direction.NONE)
            return false;
          return this.tilemap.hasBlockingTile(this.tilePosInDirection(direction), oppositeDirection(this.toMapDirection(direction))) || this.tilemap.hasBlockingChar(this.tilePosInDirection(direction));
        }
        isMoving() {
          return this.movementDirection != Direction.NONE;
        }
        turnTowards(direction) {
          if (this.isMoving())
            return;
          if (direction == Direction.NONE)
            return;
          this.facingDirection = direction;
          this.animation.setStandingFrame(direction);
        }
        getFacingDirection() {
          return this.facingDirection;
        }
        movementStarted() {
          return this.movementStarted$;
        }
        movementStopped() {
          return this.movementStopped$;
        }
        directionChanged() {
          return this.directionChanged$;
        }
        positionChanged() {
          return this.positionChanged$;
        }
        positionChangeFinished() {
          return this.positionChangeFinished$;
        }
        autoMovementSet() {
          return this.autoMovementSet$;
        }
        tilePosToPixelPos(tilePosition) {
          return tilePosition.clone().multiply(this.tileSize);
        }
        getTileDistance(direction) {
          if (direction === Direction.NONE)
            return Vector2.ZERO.clone();
          return this.tileSize.clone();
        }
        toMapDirection(direction) {
          return direction;
        }
        getOffset() {
          const offsetX = this.tileSize.x / 2 - Math.floor(this.sprite.width * this.sprite.scale / 2);
          const offsetY = -(this.sprite.height * this.sprite.scale) + this.tileSize.y;
          return new Vector2(offsetX, offsetY);
        }
        createSpeedPixelsPerSecond() {
          const speedPixelsPerSecond = {
            [Direction.LEFT]: new Vector2(this.tileSize.x, 0),
            [Direction.RIGHT]: new Vector2(this.tileSize.x, 0),
            [Direction.UP]: new Vector2(0, this.tileSize.y),
            [Direction.DOWN]: new Vector2(0, this.tileSize.y),
            [Direction.UP_LEFT]: this.getTileDistance(Direction.UP_LEFT),
            [Direction.UP_RIGHT]: this.getTileDistance(Direction.UP_RIGHT),
            [Direction.DOWN_LEFT]: this.getTileDistance(Direction.DOWN_LEFT),
            [Direction.DOWN_RIGHT]: this.getTileDistance(Direction.DOWN_RIGHT),
            [Direction.NONE]: Vector2.ZERO.clone()
          };
          Object.entries(speedPixelsPerSecond).forEach(([key, val]) => {
            speedPixelsPerSecond[key] = VectorUtils.scalarMult(val, this.speed);
          });
          return speedPixelsPerSecond;
        }
        get nextTilePos() {
          return this._nextTilePos.clone();
        }
        set nextTilePos(newTilePos) {
          this._nextTilePos.x = newTilePos.x;
          this._nextTilePos.y = newTilePos.y;
        }
        get tilePos() {
          return this._tilePos.clone();
        }
        set tilePos(newTilePos) {
          this._tilePos.x = newTilePos.x;
          this._tilePos.y = newTilePos.y;
        }
        updateZindex() {
          const gameObject = this.container || this.sprite;
          gameObject.setDepth(GridTilemap.FIRST_PLAYER_LAYER + this.mapDepth(this.nextTilePos));
        }
        mapDepth(nextTilePos) {
          return nextTilePos.y;
        }
        setPosition(position) {
          const gameObject = this.container || this.sprite;
          gameObject.x = position.x;
          gameObject.y = position.y;
        }
        getPosition() {
          const gameObject = this.container || this.sprite;
          return new Vector2(gameObject.x, gameObject.y);
        }
        startMoving(direction) {
          this.movementStarted$.next(direction);
          this.movementDirection = direction;
          this.facingDirection = direction;
          this.updateTilePos();
        }
        updateTilePos() {
          this.tilePos = this.nextTilePos;
          const newTilePos = this.nextTilePos.add(directionVector(this.toMapDirection(this.movementDirection)));
          this.nextTilePos = newTilePos;
          this.positionChanged$.next({
            exitTile: this.tilePos,
            enterTile: newTilePos
          });
        }
        tilePosInDirection(direction) {
          return this.nextTilePos.add(directionVector(this.toMapDirection(direction)));
        }
        updateCharacterPosition(delta) {
          const pixelsToWalkThisUpdate = this.getSpeedPerDelta(delta);
          if (!this.willCrossTileBorderThisUpdate(pixelsToWalkThisUpdate)) {
            this.moveCharacterSprite(pixelsToWalkThisUpdate);
          } else if (this.shouldContinueMoving()) {
            this.moveCharacterSprite(pixelsToWalkThisUpdate);
            this.positionChangeFinished$.next({
              exitTile: this.tilePos,
              enterTile: this.nextTilePos
            });
            this.updateTilePos();
          } else {
            this.moveCharacterSpriteRestOfTile();
            this.stopMoving();
          }
        }
        shouldContinueMoving() {
          return this.movementDirection == this.lastMovementImpulse && !this.isBlockingDirection(this.lastMovementImpulse);
        }
        getSpeedPerDelta(delta) {
          const deltaInSeconds = delta / 1e3;
          return this.createSpeedPixelsPerSecond()[this.movementDirection].clone().multiply(new Vector2(deltaInSeconds, deltaInSeconds)).multiply(directionVector(this.movementDirection));
        }
        willCrossTileBorderThisUpdate(pixelsToWalkThisUpdate) {
          return this.tileSizePixelsWalked.x + Math.abs(pixelsToWalkThisUpdate.x) >= this.getTileDistance(this.movementDirection).x || this.tileSizePixelsWalked.y + Math.abs(pixelsToWalkThisUpdate.y) >= this.getTileDistance(this.movementDirection).y;
        }
        moveCharacterSpriteRestOfTile() {
          this.moveCharacterSprite(this.getTileDistance(this.movementDirection).clone().subtract(this.tileSizePixelsWalked).multiply(directionVector(this.movementDirection)));
        }
        moveCharacterSprite(speed) {
          const newPlayerPos = this.getPosition().add(speed);
          this.setPosition(newPlayerPos);
          this.tileSizePixelsWalked.x += Math.abs(speed.x);
          this.tileSizePixelsWalked.y += Math.abs(speed.y);
          this.animation.updateCharacterFrame(this.movementDirection, this.hasWalkedHalfATile());
          this.tileSizePixelsWalked.x %= this.getTileDistance(this.movementDirection).x;
          this.tileSizePixelsWalked.y %= this.getTileDistance(this.movementDirection).y;
        }
        stopMoving() {
          this.movementStopped$.next(this.movementDirection);
          this.positionChangeFinished$.next({
            exitTile: this.tilePos,
            enterTile: this.nextTilePos
          });
          this.movementDirection = Direction.NONE;
          this.tilePos = this.nextTilePos;
        }
        hasWalkedHalfATile() {
          return this.tileSizePixelsWalked.x > this.getTileDistance(this.movementDirection).x / 2 || this.tileSizePixelsWalked.y > this.getTileDistance(this.movementDirection).y / 2;
        }
      };
    }
  });

  // src/GridCharacter/IsometricGridCharacter/IsometricGridCharacter.ts
  var IsometricGridCharacter;
  var init_IsometricGridCharacter = __esm({
    "src/GridCharacter/IsometricGridCharacter/IsometricGridCharacter.ts"() {
      init_Direction();
      init_Vector2();
      init_VectorUtils();
      init_GridCharacter();
      IsometricGridCharacter = class extends GridCharacter {
        tilePosToPixelPos(tilePosition) {
          return this.getTileDistance(Direction.UP_LEFT).multiply(new Vector2(tilePosition.x - tilePosition.y, tilePosition.x + tilePosition.y));
        }
        getTileDistance(direction) {
          switch (direction) {
            case Direction.DOWN_LEFT:
            case Direction.DOWN_RIGHT:
            case Direction.UP_LEFT:
            case Direction.UP_RIGHT:
              return VectorUtils.scalarMult(this.tileSize, 0.5);
            default:
              return super.getTileDistance(direction);
          }
        }
        toMapDirection(direction) {
          return turnCounterClockwise(direction);
        }
        mapDepth(nextTilePos) {
          return nextTilePos.x + nextTilePos.y;
        }
      };
    }
  });

  // node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
  function takeUntil(notifier) {
    return operate(function(source, subscriber) {
      innerFrom(notifier).subscribe(new OperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop));
      !subscriber.closed && source.subscribe(subscriber);
    });
  }
  var init_takeUntil = __esm({
    "node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js"() {
      init_lift();
      init_OperatorSubscriber();
      init_from();
      init_noop();
    }
  });

  // node_modules/rxjs/dist/esm5/operators/index.js
  var init_operators = __esm({
    "node_modules/rxjs/dist/esm5/operators/index.js"() {
      init_filter();
      init_takeUntil();
    }
  });

  // src/Algorithms/ShortestPath/NoPathFoundStrategy.ts
  var NoPathFoundStrategy;
  var init_NoPathFoundStrategy = __esm({
    "src/Algorithms/ShortestPath/NoPathFoundStrategy.ts"() {
      (function(NoPathFoundStrategy2) {
        NoPathFoundStrategy2["STOP"] = "STOP";
        NoPathFoundStrategy2["CLOSEST_REACHABLE"] = "CLOSEST_REACHABLE";
        NoPathFoundStrategy2["RETRY"] = "RETRY";
      })(NoPathFoundStrategy || (NoPathFoundStrategy = {}));
    }
  });

  // src/Algorithms/ShortestPath/Bfs/Bfs.ts
  var Bfs;
  var init_Bfs = __esm({
    "src/Algorithms/ShortestPath/Bfs/Bfs.ts"() {
      init_VectorUtils();
      Bfs = class {
        getShortestPath(startPos, targetPos, getNeighbours) {
          const shortestPath = this.shortestPathBfs(startPos, targetPos, getNeighbours);
          return {
            path: this.returnPath(shortestPath.previous, startPos, targetPos),
            closestToTarget: shortestPath.closestToTarget
          };
        }
        shortestPathBfs(startNode, stopNode, getNeighbours) {
          const previous = new Map();
          const visited = new Set();
          const queue = [];
          let closestToTarget = startNode;
          let smallestDistToTarget = VectorUtils.manhattanDistance(startNode, stopNode);
          queue.push({ node: startNode, dist: 0 });
          visited.add(VectorUtils.vec2str(startNode));
          while (queue.length > 0) {
            const { node, dist } = queue.shift();
            const distToTarget = VectorUtils.manhattanDistance(node, stopNode);
            if (distToTarget < smallestDistToTarget) {
              smallestDistToTarget = distToTarget;
              closestToTarget = node;
            }
            if (VectorUtils.equal(node, stopNode)) {
              return { shortestDistance: dist, previous, closestToTarget };
            }
            for (const neighbour of getNeighbours(node)) {
              if (!visited.has(VectorUtils.vec2str(neighbour))) {
                previous.set(VectorUtils.vec2str(neighbour), node);
                queue.push({ node: neighbour, dist: dist + 1 });
                visited.add(VectorUtils.vec2str(neighbour));
              }
            }
          }
          return { shortestDistance: -1, previous, closestToTarget };
        }
        returnPath(previous, startNode, stopNode) {
          const ret = [];
          let currentNode = stopNode;
          ret.push(currentNode);
          while (!VectorUtils.equal(currentNode, startNode)) {
            currentNode = previous.get(VectorUtils.vec2str(currentNode));
            if (!currentNode)
              return [];
            ret.push(currentNode);
          }
          return ret.reverse();
        }
      };
    }
  });

  // src/Movement/TargetMovement/Retryable/Retryable.ts
  var Retryable;
  var init_Retryable = __esm({
    "src/Movement/TargetMovement/Retryable/Retryable.ts"() {
      Retryable = class {
        constructor(backoffMs, maxRetries, onFinished) {
          this.backoffMs = backoffMs;
          this.maxRetries = maxRetries;
          this.onFinished = onFinished;
          this.retries = 0;
          this.elapsed = 0;
        }
        retry(elapsed, fn) {
          if (this.shouldRetry()) {
            this.elapsed += elapsed;
            if (this.elapsed >= this.backoffMs) {
              this.elapsed = 0;
              this.retries++;
              fn();
            }
          } else {
            this.onFinished();
          }
        }
        shouldRetry() {
          return this.maxRetries === -1 || this.retries < this.maxRetries;
        }
        reset() {
          this.retries = 0;
          this.elapsed = 0;
        }
      };
    }
  });

  // src/Utils/DistanceUtils8/DistanceUtils8.ts
  var DistanceUtils8;
  var init_DistanceUtils8 = __esm({
    "src/Utils/DistanceUtils8/DistanceUtils8.ts"() {
      init_VectorUtils();
      init_Direction();
      init_Vector2();
      DistanceUtils8 = class {
        distance(pos1, pos2) {
          return VectorUtils.chebyshevDistance(pos1, pos2);
        }
        neighbours(pos) {
          const orthogonalNeighbours = [
            new Vector2(pos.x, pos.y + 1),
            new Vector2(pos.x + 1, pos.y),
            new Vector2(pos.x - 1, pos.y),
            new Vector2(pos.x, pos.y - 1)
          ];
          const diagonalNeighbours = [
            new Vector2(pos.x + 1, pos.y + 1),
            new Vector2(pos.x + 1, pos.y - 1),
            new Vector2(pos.x - 1, pos.y + 1),
            new Vector2(pos.x - 1, pos.y - 1)
          ];
          return [...orthogonalNeighbours, ...diagonalNeighbours];
        }
        direction(from, to) {
          if (to.x > from.x) {
            if (to.y > from.y) {
              return Direction.DOWN_RIGHT;
            } else if (to.y < from.y) {
              return Direction.UP_RIGHT;
            } else {
              return Direction.RIGHT;
            }
          } else if (to.x < from.x) {
            if (to.y > from.y) {
              return Direction.DOWN_LEFT;
            } else if (to.y < from.y) {
              return Direction.UP_LEFT;
            } else {
              return Direction.LEFT;
            }
          } else if (to.y < from.y) {
            return Direction.UP;
          } else if (to.y > from.y) {
            return Direction.DOWN;
          }
          return Direction.NONE;
        }
      };
    }
  });

  // src/Utils/DistanceUtils4/DistanceUtils4.ts
  var DistanceUtils4;
  var init_DistanceUtils4 = __esm({
    "src/Utils/DistanceUtils4/DistanceUtils4.ts"() {
      init_VectorUtils();
      init_Direction();
      init_Vector2();
      DistanceUtils4 = class {
        distance(pos1, pos2) {
          return VectorUtils.manhattanDistance(pos1, pos2);
        }
        direction(from, to) {
          if (VectorUtils.equal(from, to))
            return Direction.NONE;
          const diff = from.clone().subtract(to);
          if (Math.abs(diff.x) > Math.abs(diff.y)) {
            if (diff.x > 0) {
              return Direction.LEFT;
            } else {
              return Direction.RIGHT;
            }
          } else {
            if (diff.y > 0) {
              return Direction.UP;
            } else {
              return Direction.DOWN;
            }
          }
        }
        neighbours(pos) {
          return [
            new Vector2(pos.x, pos.y + 1),
            new Vector2(pos.x + 1, pos.y),
            new Vector2(pos.x - 1, pos.y),
            new Vector2(pos.x, pos.y - 1)
          ];
        }
      };
    }
  });

  // src/Movement/TargetMovement/TargetMovement.ts
  var TargetMovement;
  var init_TargetMovement = __esm({
    "src/Movement/TargetMovement/TargetMovement.ts"() {
      init_NoPathFoundStrategy();
      init_PathBlockedStrategy();
      init_Direction();
      init_Bfs();
      init_Retryable();
      init_DistanceUtils8();
      init_DistanceUtils4();
      TargetMovement = class {
        constructor(tilemap, targetPos, distance = 0, config2) {
          this.tilemap = tilemap;
          this.targetPos = targetPos;
          this.distance = distance;
          this.posOnPath = 0;
          this.stopped = false;
          this.distanceUtils = new DistanceUtils4();
          this.getNeighbours = (pos) => {
            const neighbours = this.distanceUtils.neighbours(pos);
            return neighbours.filter((pos2) => !this.isBlocking(pos2));
          };
          this.isBlocking = (pos) => {
            return !pos || this.tilemap.isBlocking(pos);
          };
          this.noPathFoundStrategy = (config2 == null ? void 0 : config2.noPathFoundStrategy) || NoPathFoundStrategy.STOP;
          this.pathBlockedStrategy = (config2 == null ? void 0 : config2.pathBlockedStrategy) || PathBlockedStrategy.WAIT;
          this.noPathFoundRetryable = new Retryable((config2 == null ? void 0 : config2.noPathFoundRetryBackoffMs) || 200, (config2 == null ? void 0 : config2.noPathFoundMaxRetries) || -1, () => this.stop());
          this.pathBlockedRetryable = new Retryable((config2 == null ? void 0 : config2.pathBlockedRetryBackoffMs) || 200, (config2 == null ? void 0 : config2.pathBlockedMaxRetries) || -1, () => this.stop());
          this.pathBlockedWaitTimeoutMs = (config2 == null ? void 0 : config2.pathBlockedWaitTimeoutMs) || -1;
        }
        setPathBlockedStrategy(pathBlockedStrategy) {
          this.pathBlockedStrategy = pathBlockedStrategy;
        }
        getPathBlockedStrategy() {
          return this.pathBlockedStrategy;
        }
        setNumberOfDirections(numberOfDirections) {
          if (numberOfDirections === NumberOfDirections.EIGHT) {
            this.distanceUtils = new DistanceUtils8();
          } else {
            this.distanceUtils = new DistanceUtils4();
          }
        }
        setCharacter(character) {
          this.character = character;
          this.noPathFoundRetryable.reset();
          this.pathBlockedRetryable.reset();
          this.pathBlockedWaitElapsed = 0;
          this.calcShortestPath();
        }
        update(delta) {
          if (this.stopped)
            return;
          if (this.noPathFound()) {
            if (this.noPathFoundStrategy === NoPathFoundStrategy.RETRY) {
              this.noPathFoundRetryable.retry(delta, () => this.calcShortestPath());
            }
          }
          if (this.isBlocking(this.nextTileOnPath())) {
            this.applyPathBlockedStrategy(delta);
          } else {
            this.pathBlockedWaitElapsed = 0;
          }
          this.updatePosOnPath();
          if (this.hasArrived()) {
            if (this.existsDistToTarget()) {
              this.turnTowardsTarget();
            }
          } else if (!this.isBlocking(this.nextTileOnPath())) {
            this.moveCharOnPath();
          }
        }
        applyPathBlockedStrategy(delta) {
          if (this.pathBlockedStrategy === PathBlockedStrategy.RETRY) {
            this.pathBlockedRetryable.retry(delta, () => this.calcShortestPath());
          } else if (this.pathBlockedStrategy === PathBlockedStrategy.STOP) {
            this.stop();
          } else if (this.pathBlockedStrategy === PathBlockedStrategy.WAIT) {
            if (this.pathBlockedWaitTimeoutMs > -1) {
              this.pathBlockedWaitElapsed += delta;
              if (this.pathBlockedWaitElapsed >= this.pathBlockedWaitTimeoutMs) {
                this.stop();
              }
            }
          }
        }
        moveCharOnPath() {
          const dir = this.getDir(this.character.getNextTilePos(), this.nextTileOnPath());
          this.character.move(dir);
        }
        nextTileOnPath() {
          return this.shortestPath[this.posOnPath + 1];
        }
        stop() {
          this.stopped = true;
        }
        turnTowardsTarget() {
          const nextTile = this.shortestPath[this.posOnPath + 1];
          const dir = this.getDir(this.character.getNextTilePos(), nextTile);
          this.character.turnTowards(dir);
        }
        existsDistToTarget() {
          return this.posOnPath < this.shortestPath.length - 1;
        }
        hasArrived() {
          return this.posOnPath + Math.max(0, this.distance - this.distOffset) >= this.shortestPath.length - 1;
        }
        updatePosOnPath() {
          let currentTile = this.shortestPath[this.posOnPath];
          while (this.posOnPath < this.shortestPath.length - 1 && (this.character.getNextTilePos().x != currentTile.x || this.character.getNextTilePos().y != currentTile.y)) {
            this.posOnPath++;
            currentTile = this.shortestPath[this.posOnPath];
          }
        }
        noPathFound() {
          return this.shortestPath.length === 0;
        }
        calcShortestPath() {
          const shortestPath = this.getShortestPath();
          this.posOnPath = 0;
          this.shortestPath = shortestPath.path;
          this.distOffset = shortestPath.distOffset;
        }
        getShortestPath() {
          const shortestPathAlgo = new Bfs();
          const {
            path: shortestPath,
            closestToTarget
          } = shortestPathAlgo.getShortestPath(this.character.getNextTilePos(), this.targetPos, this.getNeighbours);
          const noPathFound = shortestPath.length == 0;
          if (noPathFound && this.noPathFoundStrategy === NoPathFoundStrategy.CLOSEST_REACHABLE) {
            const shortestPathToClosestPoint = shortestPathAlgo.getShortestPath(this.character.getNextTilePos(), closestToTarget, this.getNeighbours).path;
            const distOffset = this.distanceUtils.distance(closestToTarget, this.targetPos);
            return { path: shortestPathToClosestPoint, distOffset };
          }
          return { path: shortestPath, distOffset: 0 };
        }
        getDir(from, to) {
          return this.distanceUtils.direction(from, to);
        }
      };
    }
  });

  // src/Movement/FollowMovement/FollowMovement.ts
  var FollowMovement;
  var init_FollowMovement = __esm({
    "src/Movement/FollowMovement/FollowMovement.ts"() {
      init_operators();
      init_Direction();
      init_TargetMovement();
      init_NoPathFoundStrategy();
      init_Vector2();
      FollowMovement = class {
        constructor(gridTilemap, charToFollow, distance = 0, noPathFoundStrategy = NoPathFoundStrategy.STOP) {
          this.gridTilemap = gridTilemap;
          this.charToFollow = charToFollow;
          this.distance = distance;
          this.noPathFoundStrategy = noPathFoundStrategy;
          this.numberOfDirections = NumberOfDirections.FOUR;
        }
        setNumberOfDirections(numberOfDirections) {
          this.numberOfDirections = numberOfDirections;
        }
        setCharacter(character) {
          this.character = character;
          this.updateTarget(this.charToFollow.getTilePos());
          this.charToFollow.positionChanged().pipe(takeUntil(this.character.autoMovementSet())).subscribe(({ enterTile }) => {
            this.updateTarget(enterTile);
          });
        }
        update(delta) {
          var _a;
          (_a = this.targetMovement) == null ? void 0 : _a.update(delta);
        }
        updateTarget(targetPos) {
          this.targetMovement = new TargetMovement(this.gridTilemap, new Vector2(targetPos), this.distance + 1, { noPathFoundStrategy: this.noPathFoundStrategy });
          this.targetMovement.setNumberOfDirections(this.numberOfDirections);
          this.targetMovement.setCharacter(this.character);
        }
      };
    }
  });

  // src/Movement/RandomMovement/RandomMovement.ts
  var RandomMovement;
  var init_RandomMovement = __esm({
    "src/Movement/RandomMovement/RandomMovement.ts"() {
      init_Direction();
      init_Direction();
      init_operators();
      init_Vector2();
      init_DistanceUtils8();
      init_DistanceUtils4();
      RandomMovement = class {
        constructor(delay = 0, radius = -1) {
          this.delay = delay;
          this.radius = radius;
          this.numberOfDirections = NumberOfDirections.FOUR;
          this.distanceUtils = new DistanceUtils4();
        }
        setNumberOfDirections(numberOfDirections) {
          this.numberOfDirections = numberOfDirections;
          if (numberOfDirections === NumberOfDirections.EIGHT) {
            this.distanceUtils = new DistanceUtils8();
          } else {
            this.distanceUtils = new DistanceUtils4();
          }
        }
        setCharacter(character) {
          this.character = character;
          this.delayLeft = this.delay;
          this.initialRow = character.getNextTilePos().y;
          this.initialCol = character.getNextTilePos().x;
          this.stepSize = this.getRandomInt(this.radius) + 1;
          this.stepsWalked = 0;
          this.currentMovementDirection = Direction.NONE;
          this.character.positionChanged().pipe(takeUntil(this.character.autoMovementSet())).subscribe(() => {
            this.stepsWalked++;
          });
        }
        update(delta) {
          if (this.shouldContinueWalkingCurrentDirection()) {
            this.character.move(this.currentMovementDirection);
          } else {
            this.delayLeft -= delta;
            if (this.delayLeft <= 0) {
              this.delayLeft = this.delay;
              const dir = this.getFreeRandomDirection();
              this.stepsWalked = 0;
              this.character.move(dir);
              this.currentMovementDirection = dir;
              this.stepSize = this.getRandomInt(this.radius) + 1;
            }
          }
        }
        shouldContinueWalkingCurrentDirection() {
          return this.stepsWalked < this.stepSize && this.currentMovementDirection !== Direction.NONE && !this.character.isBlockingDirection(this.currentMovementDirection) && this.isWithinRadius(this.currentMovementDirection);
        }
        getFreeDirections() {
          const unblocked = getDirections(this.numberOfDirections).filter((dir) => !this.character.isBlockingDirection(dir));
          return unblocked.filter((dir) => this.isWithinRadius(dir));
        }
        isWithinRadius(dir) {
          if (this.radius == -1)
            return true;
          return this.getDist(dir) <= this.radius;
        }
        getDist(dir) {
          return this.distanceUtils.distance(this.character.getNextTilePos().add(directionVector(dir)), new Vector2(this.initialCol, this.initialRow));
        }
        getFreeRandomDirection() {
          const freeDirections = this.getFreeDirections();
          if (freeDirections.length == 0)
            return Direction.NONE;
          return freeDirections[this.getRandomInt(freeDirections.length)];
        }
        getRandomInt(max) {
          return Math.floor(Math.random() * Math.floor(max));
        }
      };
    }
  });

  // src/GridEngine.ts
  var GridEngine;
  var init_GridEngine = __esm({
    "src/GridEngine.ts"() {
      init_PathBlockedStrategy();
      init_IsometricGridCharacter();
      init_FollowMovement();
      init_TargetMovement();
      init_GridCharacter();
      init_Direction();
      init_GridTilemap();
      init_RandomMovement();
      init_esm5();
      init_operators();
      init_NoPathFoundStrategy();
      init_Vector2();
      GridEngine = class {
        constructor(scene) {
          this.scene = scene;
          this.isCreated = false;
          this.numberOfDirections = NumberOfDirections.FOUR;
          this.scene.sys.events.once("boot", this.boot, this);
        }
        boot() {
          this.scene.sys.events.on("update", this.update, this);
          this.scene.sys.events.on("destroy", this.destroy, this);
        }
        destroy() {
          this.scene = void 0;
          this.tilemap = void 0;
          this.gridCharacters = void 0;
          this.gridTilemap = void 0;
          this.movementStarted$ = void 0;
          this.movementStopped$ = void 0;
          this.directionChanged$ = void 0;
          this.positionChangeStarted$ = void 0;
          this.positionChangeFinished$ = void 0;
          this.charRemoved$ = void 0;
        }
        create(tilemap, config2) {
          this.isCreated = true;
          this.gridCharacters = new Map();
          this.tilemap = tilemap;
          this.movementStopped$ = new Subject();
          this.movementStarted$ = new Subject();
          this.directionChanged$ = new Subject();
          this.positionChangeStarted$ = new Subject();
          this.positionChangeFinished$ = new Subject();
          this.charRemoved$ = new Subject();
          this.gridTilemap = new GridTilemap(tilemap);
          if (config2.collisionTilePropertyName) {
            this.gridTilemap.setCollisionTilePropertyName(config2.collisionTilePropertyName);
          }
          this.numberOfDirections = config2.numberOfDirections || this.numberOfDirections;
          this.addCharacters(config2);
        }
        getPosition(charId) {
          this.initGuard();
          this.unknownCharGuard(charId);
          return this.gridCharacters.get(charId).getTilePos();
        }
        move(charId, direction) {
          this.moveChar(charId, direction);
        }
        moveRandomly(charId, delay = 0, radius = -1) {
          this.initGuard();
          this.unknownCharGuard(charId);
          const randomMovement = new RandomMovement(delay, radius);
          randomMovement.setNumberOfDirections(this.numberOfDirections);
          this.gridCharacters.get(charId).setMovement(randomMovement);
        }
        moveTo(charId, targetPos, config2) {
          const moveToConfig = this.assembleMoveToConfig(config2);
          this.initGuard();
          this.unknownCharGuard(charId);
          const targetMovement = new TargetMovement(this.gridTilemap, new Vector2(targetPos), 0, moveToConfig);
          targetMovement.setNumberOfDirections(this.numberOfDirections);
          this.gridCharacters.get(charId).setMovement(targetMovement);
        }
        stopMovement(charId) {
          this._stopMovement(charId);
        }
        setSpeed(charId, speed) {
          this.initGuard();
          this.unknownCharGuard(charId);
          this.gridCharacters.get(charId).setSpeed(speed);
        }
        setWalkingAnimationMapping(charId, walkingAnimationMapping) {
          this.initGuard();
          this.unknownCharGuard(charId);
          this.gridCharacters.get(charId).setWalkingAnimationMapping(walkingAnimationMapping);
        }
        update(_time, delta) {
          if (this.isCreated) {
            if (this.gridCharacters) {
              for (const [_key, val] of this.gridCharacters) {
                val.update(delta);
              }
            }
          }
        }
        addCharacter(charData) {
          this.initGuard();
          const charConfig = {
            sprite: charData.sprite,
            speed: charData.speed || 4,
            tilemap: this.gridTilemap,
            tileSize: new Vector2(this.gridTilemap.getTileWidth(), this.gridTilemap.getTileHeight()),
            walkingAnimationMapping: charData.walkingAnimationMapping,
            container: charData.container,
            offsetX: charData.offsetX,
            offsetY: charData.offsetY
          };
          const gridChar = this.createCharacter(charData.id, charConfig);
          if (charData.facingDirection) {
            gridChar.turnTowards(charData.facingDirection);
          }
          this.gridCharacters.set(charData.id, gridChar);
          const startPos = charData.startPosition ? new Vector2(charData.startPosition) : new Vector2(0, 0);
          gridChar.setTilePosition(startPos);
          this.gridTilemap.addCharacter(gridChar);
          gridChar.movementStopped().pipe(this.takeUntilCharRemoved(gridChar.getId())).subscribe((direction) => {
            this.movementStopped$.next({ charId: gridChar.getId(), direction });
          });
          gridChar.movementStarted().pipe(this.takeUntilCharRemoved(gridChar.getId())).subscribe((direction) => {
            this.movementStarted$.next({ charId: gridChar.getId(), direction });
          });
          gridChar.directionChanged().pipe(this.takeUntilCharRemoved(gridChar.getId())).subscribe((direction) => {
            this.directionChanged$.next({ charId: gridChar.getId(), direction });
          });
          gridChar.positionChanged().pipe(this.takeUntilCharRemoved(gridChar.getId())).subscribe(({ exitTile, enterTile }) => {
            this.positionChangeStarted$.next({
              charId: gridChar.getId(),
              exitTile,
              enterTile
            });
          });
          gridChar.positionChangeFinished().pipe(this.takeUntilCharRemoved(gridChar.getId())).subscribe(({ exitTile, enterTile }) => {
            this.positionChangeFinished$.next({
              charId: gridChar.getId(),
              exitTile,
              enterTile
            });
          });
        }
        hasCharacter(charId) {
          this.initGuard();
          return this.gridCharacters.has(charId);
        }
        removeCharacter(charId) {
          this.initGuard();
          this.unknownCharGuard(charId);
          this.gridTilemap.removeCharacter(charId);
          this.gridCharacters.delete(charId);
          this.charRemoved$.next(charId);
        }
        removeAllCharacters() {
          this.initGuard();
          for (const charId of this.gridCharacters.keys()) {
            this.removeCharacter(charId);
          }
        }
        getAllCharacters() {
          this.initGuard();
          return [...this.gridCharacters.keys()];
        }
        follow(charId, charIdToFollow, distance = 0, closestPointIfBlocked = false) {
          this.initGuard();
          this.unknownCharGuard(charId);
          this.unknownCharGuard(charIdToFollow);
          const followMovement = new FollowMovement(this.gridTilemap, this.gridCharacters.get(charIdToFollow), distance, closestPointIfBlocked ? NoPathFoundStrategy.CLOSEST_REACHABLE : NoPathFoundStrategy.STOP);
          followMovement.setNumberOfDirections(this.numberOfDirections);
          this.gridCharacters.get(charId).setMovement(followMovement);
        }
        isMoving(charId) {
          this.initGuard();
          this.unknownCharGuard(charId);
          return this.gridCharacters.get(charId).isMoving();
        }
        getFacingDirection(charId) {
          this.initGuard();
          this.unknownCharGuard(charId);
          return this.gridCharacters.get(charId).getFacingDirection();
        }
        turnTowards(charId, direction) {
          this.initGuard();
          this.unknownCharGuard(charId);
          return this.gridCharacters.get(charId).turnTowards(direction);
        }
        setPosition(charId, pos) {
          this.initGuard();
          this.unknownCharGuard(charId);
          this.gridCharacters.get(charId).setTilePosition(new Vector2(pos));
        }
        movementStarted() {
          return this.movementStarted$;
        }
        movementStopped() {
          return this.movementStopped$;
        }
        directionChanged() {
          return this.directionChanged$;
        }
        positionChangeStarted() {
          return this.positionChangeStarted$;
        }
        positionChangeFinished() {
          return this.positionChangeFinished$;
        }
        takeUntilCharRemoved(charId) {
          return takeUntil(this.charRemoved$.pipe(filter((cId) => cId == charId)));
        }
        initGuard() {
          if (!this.isCreated) {
            throw new Error("Plugin not initialized. You need to call create() first.");
          }
        }
        unknownCharGuard(charId) {
          if (!this.gridCharacters.has(charId)) {
            throw new Error(`Character unknown: ${charId}`);
          }
        }
        createCharacter(id, config2) {
          if (this._isIsometric()) {
            return new IsometricGridCharacter(id, config2);
          } else {
            return new GridCharacter(id, config2);
          }
        }
        addCharacters(config2) {
          config2.characters.forEach((charData) => this.addCharacter(charData));
        }
        moveChar(charId, direction) {
          this.initGuard();
          this.unknownCharGuard(charId);
          if (this.numberOfDirections === NumberOfDirections.FOUR) {
            if (!this._isIsometric() && isDiagonal(direction)) {
              console.warn(`GridEngine: Character '${charId}' can't be moved '${direction}' in 4 direction mode.`);
              return;
            } else if (this._isIsometric() && !isDiagonal(direction)) {
              console.warn(`GridEngine: Character '${charId}' can't be moved '${direction}' in 4 direction isometric mode.`);
              return;
            }
          }
          this.gridCharacters.get(charId).move(direction);
        }
        _stopMovement(charId) {
          this.initGuard();
          this.unknownCharGuard(charId);
          this.gridCharacters.get(charId).setMovement(void 0);
        }
        _isIsometric() {
          return this.tilemap.orientation == `${Phaser.Tilemaps.Orientation.ISOMETRIC}`;
        }
        assembleMoveToConfig(config2) {
          const moveToConfig = __spreadProps(__spreadValues({}, config2), {
            noPathFoundStrategy: NoPathFoundStrategy.STOP,
            pathBlockedStrategy: PathBlockedStrategy.WAIT
          });
          if (config2 == null ? void 0 : config2.noPathFoundStrategy) {
            if (Object.values(NoPathFoundStrategy).includes(config2.noPathFoundStrategy)) {
              moveToConfig.noPathFoundStrategy = config2.noPathFoundStrategy;
            } else {
              console.warn(`GridEngine: Unknown NoPathFoundStrategy '${config2.noPathFoundStrategy}'. Falling back to '${NoPathFoundStrategy.STOP}'`);
            }
          }
          if (config2 == null ? void 0 : config2.pathBlockedStrategy) {
            if (Object.values(PathBlockedStrategy).includes(config2.pathBlockedStrategy)) {
              moveToConfig.pathBlockedStrategy = config2.pathBlockedStrategy;
            } else {
              console.warn(`GridEngine: Unknown PathBlockedStrategy '${config2.pathBlockedStrategy}'. Falling back to '${PathBlockedStrategy.WAIT}'`);
            }
          }
          return moveToConfig;
        }
      };
    }
  });

  // src/main-iife.ts
  var require_main_iife = __commonJS({
    "src/main-iife.ts"(exports, module) {
      init_GridEngine();
      module.exports = GridEngine;
    }
  });
  return require_main_iife();
})();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
